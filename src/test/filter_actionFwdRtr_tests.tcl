proc DTS161231_FilterParamsEntry_test { dut2 args } {

    global testdir testResultFlag
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl

    set opt(filter_id)       1
    set opt(entry_id)        100
    set opt(filter_ipv6_id)       1
    set opt(entry_ipv6_id)        200

    getopt opt $args

    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"
    set testId "coverityDTS161231_FilterParamsEntry_test"

    # start memory leak checks
    filter_subinsert_memLeakChecks $dut2 start

    log_msg INFO "Creating IPv4 and IPv6 filter with one entry in each" 

    Dut-$dut2 setTIPFilterRowStatus $opt(filter_id) "createAndGo"
    Dut-$dut2 setTIPFilterParamsRowStatus $opt(filter_id) $opt(entry_id) "createAndGo"
    Dut-$dut2 setTIPv6FilterRowStatus $opt(filter_ipv6_id) "createAndGo"
    Dut-$dut2 setTIPv6FilterParamsRowStatus $opt(filter_ipv6_id) $opt(entry_ipv6_id) "createAndGo"

    log_msg INFO "--------------------------------------"
    log_msg INFO "1. Creating IPv4 action forward Next Hop"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action drop -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output noError -expected_dest "1.2.3.4"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNHIndirect"
    createIpFilterParams $dut2 -action forward -forward ForwardNHIndirect -dest true -verify true -reverse false -expected_create_output noError -expected_dest "true"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Create test interface
    cliCne Dut-$dut2 "/configure port 1/1/1 ethernet mode network"
    cliCne Dut-$dut2 "/configure port 1/1/1 no shutdown"
    cliCne Dut-$dut2 "/configure router interface test address 1.1.1.1/24"
    cliCne Dut-$dut2 "/configure router interface test port 1/1/1"
    
    
    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    cliCne Dut-$dut2 "/configure router interface test shutdown"
    cliCne Dut-$dut2 "/configure router no interface test"
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy

    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    
    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest 1/1/1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest 0
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1

    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "00:00:00:00:00:00:00:00"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    log_msg INFO " -> FwdRtrId"
    
    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Configure VPRN
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure service vprn 1 customer 1 service-name VPRN"
    regexp {vRtrRowStatus.(\d+)} [Dut-$dut2 getnext vRtrRowStatus.1] match vRtrId

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest $vRtrId -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure VPRN
    cliCne Dut-$dut2 "/configure service no vprn VPRN"


    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPFilterParamsAction $opt(filter_id) $opt(entry_id) $action
        if { $action == "gtpLclBrkout" } {
            set testResultFlag [wccpCompareOutputString "0.0.0.0" [Dut-$dut2 getTIPFilterParamsForwardNH $opt(filter_id) $opt(entry_id)]]           
        } else {
            set testResultFlag [wccpCompareOutputString "1.2.3.4" [Dut-$dut2 getTIPFilterParamsForwardNH $opt(filter_id) $opt(entry_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv4 action forward Next Hop - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action drop -forward ForwardNH -dest 1.2.3.4 -verify true -reverse true -expected_create_output noError -expected_dest "1.2.3.4"
    createIpFilterParams $dut2 -action drop -forward ForwardNH -dest 1.2.3.5 -verify true -reverse true -expected_create_output noError -expected_dest "1.2.3.5"
    # Clear the destination
    createIpFilterParams $dut2 -action drop -forward ForwardNH -dest 0.0.0.0 -verify true -reverse true -expected_create_output noError -expected_dest "0.0.0.0"

    
    log_msg INFO "--------------------------------------"
    log_msg INFO "2. Creating IPv4 action forward Next Hop Interface"
    log_msg INFO "--------------------------------------"

    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output noError -expected_dest "test"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNH"
    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0.0.0.0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy

    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest 1/1/1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest 0
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"

    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "00:00:00:00:00:00:00:00"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    log_msg INFO " -> FwdRtrId"

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Configure VPRN
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure service vprn 1 customer 1 service-name VPRN"
    regexp {vRtrRowStatus.(\d+)} [Dut-$dut2 getnext vRtrRowStatus.1] match vRtrId

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest $vRtrId -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure VPRN
    cliCne Dut-$dut2 "/configure service no vprn VPRN"


    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPFilterParamsAction $opt(filter_id) $opt(entry_id) $action
        if { $action == "gtpLclBrkout" } {
            set testResultFlag [wccpCompareOutputString "" [Dut-$dut2 getTIPFilterParamsForwardNHInterface $opt(filter_id) $opt(entry_id)]]
        } else {
            set testResultFlag [wccpCompareOutputString "test" [Dut-$dut2 getTIPFilterParamsForwardNHInterface $opt(filter_id) $opt(entry_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv4 action forward Next Hop Interface - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action drop -forward ForwardNHInterface -dest test -verify true -reverse true -expected_create_output noError -expected_dest "test"
    createIpFilterParams $dut2 -action drop -forward ForwardNHInterface -dest test2 -verify true -reverse true -expected_create_output noError -expected_dest "test2"
    createIpFilterParams $dut2 -action drop -forward ForwardNHInterface -dest "" -verify true -reverse true -expected_create_output noError -expected_dest ""

    log_msg INFO "--------------------------------------"
    log_msg INFO "3. Creating IPv4 action forward RP"
    log_msg INFO "--------------------------------------"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]
    
    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNH"
    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0.0.0.0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest 1/1/1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest 0
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1

    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "00:00:00:00:00:00:00:00"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    log_msg INFO " -> FwdRtrId"

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Configure VPRN
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure service vprn 1 customer 1 service-name VPRN"
    regexp {vRtrRowStatus.(\d+)} [Dut-$dut2 getnext vRtrRowStatus.1] match vRtrId

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest $vRtrId -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure VPRN
    cliCne Dut-$dut2 "/configure service no vprn VPRN"


    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPFilterParamsAction $opt(filter_id) $opt(entry_id) $action
        if { $action == "gtpLclBrkout" } {
            set testResultFlag [wccpCompareOutputString "" [Dut-$dut2 getTIPFilterParamsForwardRedPlcy $opt(filter_id) $opt(entry_id)]]
        } else {
            set testResultFlag [wccpCompareOutputString "wccp" [Dut-$dut2 getTIPFilterParamsForwardRedPlcy $opt(filter_id) $opt(entry_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv4 action forward RP - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action drop -forward ForwardRedPlcy -dest wccp -verify true -reverse true -expected_create_output noError -expected_dest "wccp"
    createIpFilterParams $dut2 -action drop -forward ForwardRedPlcy -dest "" -verify true -reverse true -expected_create_output noError -expected_dest ""

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy
    
    log_msg INFO "--------------------------------------"
    log_msg INFO "4. Creating IPv4 action forward SAP"
    log_msg INFO "--------------------------------------"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNH"
    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output noError -expected_dest "1.2.3.4"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 0.0.0.0 -verify true -reverse false -expected_create_output noError -expected_dest "0.0.0.0"
    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]

    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output noError -expected_dest "test"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""    
    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""
    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy


    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]

    log_msg INFO " -> FwdRtrId"

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output noError -expected_dest "1"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 0 -verify true -reverse false -expected_create_output noError -expected_dest "0"
    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]

    # Configure VPRN
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure service vprn 2 customer 1 service-name VPRN"
    regexp {vRtrRowStatus.(\d+)} [Dut-$dut2 getnext vRtrRowStatus.1] match vRtrId

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest $vRtrId -verify true -reverse false -expected_create_output noError -expected_dest "$vRtrId"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure VPRN

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 0 -verify true -reverse false -expected_create_output noError -expected_dest "0"
    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]

    cliCne Dut-$dut2 "/configure service no vprn VPRN"

    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPFilterParamsAction $opt(filter_id) $opt(entry_id) $action
        if { $action == "gtpLclBrkout" } {
            set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getTIPFilterParamsFwdSapPortId $opt(filter_id) $opt(entry_id)]]
        } else {
            set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getTIPFilterParamsFwdSapPortId $opt(filter_id) $opt(entry_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv4 action forward RP - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action drop -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse true -expected_create_output noError -expected_dest "0"
    createIpFilterParams $dut2 -action drop -forward FwdSapPortId -dest "0" -verify true -reverse true -expected_create_output noError -expected_dest "0"

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1
    
    log_msg INFO "--------------------------------------"
    log_msg INFO "5. Creating IPv4 action forward SDP"
    log_msg INFO "--------------------------------------"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNH"
    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output noError -expected_dest "1.2.3.4"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 0.0.0.0 -verify true -reverse false -expected_create_output noError -expected_dest "0.0.0.0"
    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"

    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output noError -expected_dest "test"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""
    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""
    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy
    
    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port 1/1/1]
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest 0 -verify true -reverse false -expected_create_output noError -expected_dest 0

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1

    log_msg INFO " -> FwdRtrId"

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output noError -expected_dest "1"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 0 -verify true -reverse false -expected_create_output noError -expected_dest "0"
    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"

    # Configure VPRN
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure service vprn 1 customer 1 service-name VPRN"
    regexp {vRtrRowStatus.(\d+)} [Dut-$dut2 getnext vRtrRowStatus.1] match vRtrId

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest $vRtrId -verify true -reverse false -expected_create_output noError -expected_dest "$vRtrId"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure VPRN

    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 0 -verify true -reverse false -expected_create_output noError -expected_dest "0"
    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"

    cliCne Dut-$dut2 "/configure service no vprn VPRN"

    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPFilterParamsAction $opt(filter_id) $opt(entry_id) $action
        if { $action == "gtpLclBrkout" } {
            set testResultFlag [wccpCompareOutputString "00:00:00:00:00:00:00:00" [Dut-$dut2 getTIPFilterParamsFwdSdpBind $opt(filter_id) $opt(entry_id)]]
        } else {
            set testResultFlag [wccpCompareOutputString "00:00:00:00:00:00:00:00" [Dut-$dut2 getTIPFilterParamsFwdSdpBind $opt(filter_id) $opt(entry_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv4 action forward RP - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action drop -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse true -expected_create_output noError -expected_dest "00:00:00:00:00:00:00:00"

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre


    log_msg INFO "--------------------------------------"
    log_msg INFO "6. Creating IPv4 action forward router - Base"
    log_msg INFO "--------------------------------------"
 
    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output noError -expected_dest "1"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNH"
    createIpFilterParams $dut2 -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0.0.0.0"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy

    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -action forward -forward FwdSapPortId -dest 1/1/1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest 0
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1

    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "00:00:00:00:00:00:00:00"
    puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPFilterParamsAction $opt(filter_id) $opt(entry_id) $action
        if { $action == "forward" } {
            set testResultFlag [wccpCompareOutputString "1" [Dut-$dut2 getTIPFilterParamsFwdRtrId $opt(filter_id) $opt(entry_id)]]
        } else {
            set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getTIPFilterParamsFwdRtrId $opt(filter_id) $opt(entry_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv4 action forward router Base - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 1 -verify true -reverse true -expected_create_output noError -expected_dest "1"
    createIpFilterParams $dut2 -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"


## IPv6

    log_msg INFO "--------------------------------------"
    log_msg INFO "1. Creating IPv6 action forward Next Hop"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -ipv6 true -action drop -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse false -expected_create_output noError -expected_dest "2002:0000:0000:0000:0000:0000:0102:0304"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNHIndirect"
    createIpFilterParams $dut2 -ipv6 true -action forward -forward ForwardNHIndirect -dest true -verify true -reverse false -expected_create_output noError -expected_dest "true"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Create test interface
    cliCne Dut-$dut2 "/configure port 1/1/1 ethernet mode network"
    cliCne Dut-$dut2 "/configure port 1/1/1 no shutdown"
    cliCne Dut-$dut2 "/configure router interface test address 1.1.1.1/24"
    cliCne Dut-$dut2 "/configure router interface test port 1/1/1"
    
    
    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -ipv6 true -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    cliCne Dut-$dut2 "/configure router interface test shutdown"
    cliCne Dut-$dut2 "/configure router no interface test"
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -ipv6 true -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy

    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    
    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdSapPortId -dest 1/1/1 -verify true -reverse false -expected_create_output noAccess -expected_dest "ERROR"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1

    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noAccess -expected_dest "ERROR"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    log_msg INFO " -> FwdRtrId"
    
    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Configure VPRN
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure service vprn 1 customer 1 service-name VPRN"
    regexp {vRtrRowStatus.(\d+)} [Dut-$dut2 getnext vRtrRowStatus.1] match vRtrId

    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdRtrId -dest $vRtrId -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Deconfigure VPRN
    cliCne Dut-$dut2 "/configure service no vprn VPRN"


    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_ipv6_id) $opt(entry_ipv6_id) $action
        if { $action == "gtpLclBrkout" } {
            set testResultFlag [wccpCompareOutputString "2002:0000:0000:0000:0000:0000:0102:0304" [Dut-$dut2 getTIPv6FilterParamsForwardNH $opt(filter_ipv6_id) $opt(entry_ipv6_id)]]           
        } else {
            set testResultFlag [wccpCompareOutputString "2002:0000:0000:0000:0000:0000:0102:0304" [Dut-$dut2 getTIPv6FilterParamsForwardNH $opt(filter_ipv6_id) $opt(entry_ipv6_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv6 action forward Next Hop - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -ipv6 true -action drop -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse true -expected_create_output noError -expected_dest "2002:0000:0000:0000:0000:0000:0102:0304"
    createIpFilterParams $dut2 -ipv6 true -action drop -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:05 -verify true -reverse true -expected_create_output noError -expected_dest "2002:0000:0000:0000:0000:0000:0102:0305"
    # Clear the destination
    createIpFilterParams $dut2 -ipv6 true -action drop -forward ForwardNH -dest 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 -verify true -reverse true -expected_create_output noError -expected_dest "0000:0000:0000:0000:0000:0000:0000:0000"

    
    log_msg INFO "--------------------------------------"
    log_msg INFO "2. Creating IPv6 action forward Next Hop Interface"
    log_msg INFO "--------------------------------------"

    createIpFilterParams $dut2 -ipv6 true -action drop -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]


    log_msg INFO "--------------------------------------"
    log_msg INFO "3. Creating IPv6 action forward RP"
    log_msg INFO "--------------------------------------"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -ipv6 true -action drop -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]
    
    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy
    
    log_msg INFO "--------------------------------------"
    log_msg INFO "4. Creating IPv6 action forward SAP"
    log_msg INFO "--------------------------------------"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -ipv6 true -action drop -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port 1/1/1] -verify true -reverse false -expected_create_output noAccess -expected_dest "ERROR"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1
    
    log_msg INFO "--------------------------------------"
    log_msg INFO "5. Creating IPv6 action forward SDP"
    log_msg INFO "--------------------------------------"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -ipv6 true -action drop -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noAccess -expected_dest "ERROR"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]


    log_msg INFO "--------------------------------------"
    log_msg INFO "6. Creating IPv6 action forward router - Base"
    log_msg INFO "--------------------------------------"
 
    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdRtrId -dest 1 -verify true -reverse false -expected_create_output noError -expected_dest "1"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "Trying to reset NH destination with another"
    log_msg INFO "--------------------------------------"

    log_msg INFO " -> ForwardNH"
    createIpFilterParams $dut2 -ipv6 true -action forward -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0000:0000:0000:0000:0000:0000:0000:0000"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    log_msg INFO " -> ForwardNHInterface"
    createIpFilterParams $dut2 -ipv6 true -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    log_msg INFO " -> ForwardRedPlcy"

    # Create Redirect Policy
    Dut-$dut2 setTFilterRPRowStatus wccp 4
    Dut-$dut2 setTFilterRPAdminState wccp inService

    createIpFilterParams $dut2 -ipv6 true -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Destroy RP
    Dut-$dut2 setTFilterRPRowStatus wccp destroy

    log_msg INFO " -> FwdSapPortId"

    # Configure SAP
    Dut-$dut2 configurePort 1/1/1 -Mode access
    Dut-$dut2 createTls 1 1
    Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdSapPortId -dest 1/1/1 -verify true -reverse false -expected_create_output noAccess -expected_dest "ERROR"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Deconfigure SAP
    Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
    Dut-$dut2 deleteTls 1 1
    cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
    Dut-$dut2 deconfigurePort 1/1/1

    log_msg INFO " -> FwdSdpBind"

    # Configure SDP
    Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noAccess -expected_dest "ERROR"
    puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

    # Deconfigure SDP
    Dut-$dut2 deleteSdp 1 gre

    foreach action { forward default nat reassemble gtpLclBrkout } {
        log_msg DEBUG "Resetting action to $action"
        Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_ipv6_id) $opt(entry_ipv6_id) $action
        if { $action == "forward" } {
            set testResultFlag [wccpCompareOutputString "1" [Dut-$dut2 getTIPv6FilterParamsFwdRtrId $opt(filter_ipv6_id) $opt(entry_ipv6_id)]]
        } else {
            set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getTIPv6FilterParamsFwdRtrId $opt(filter_ipv6_id) $opt(entry_ipv6_id)]]
        }
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "Creating IPv6 action forward router Base - reverse snmp command items"
    log_msg INFO "--------------------------------------"
    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdRtrId -dest 1 -verify true -reverse true -expected_create_output noError -expected_dest "1"
    createIpFilterParams $dut2 -ipv6 true -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

    log_msg INFO "Removing IPv4 and IPv6 filter"

    Dut-$dut2 setTIPFilterRowStatus $opt(filter_id) "destroy"
    Dut-$dut2 setTIPv6FilterRowStatus $opt(filter_ipv6_id) "destroy"

    # check for memory leaks
    set check [filter_subinsert_memLeakChecks $dut2 check]
    if {$check != "PASSED"} {
        log_msg ERROR "Memory leak detected after cleanup, found $check"
        set testResultFlag "FAILED"
    }


    if { ($testResultFlag == "PASSED") && ($setupErrorFlag == "NOERROR") } {
        log_result PASSED "Test Case $testId PASSED"
    } else {
        log_result FAILED "Test Case $testId FAILED"
    }

}

proc filterActionFwdRtrSnmpChecks { args  } {

    global setupErrorFlag testResultFlag ixia_port logdir testdir
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl
    source $testdir/testsuites/filter/params_file_filter_tcam.tcl

    set opt(filter_ip_id)       1
    set opt(entry_ip_id)        100
    set opt(filter_ipv6_id)       2
    set opt(entry_ipv6_id)        200
    set opt(vprn_id)        500
    set opt(vprn2_id)        600
    set opt(dut)        C

    getopt opt $args

    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"
    set testId "filterActionFwdRtr_snmp"
    set description [boxifyText \
        "This test should verify set/get functions for action forward router snmp objects:
    tIPFilterParamsFwdRtrId and tIPv6FilterParamsFwdRtrId. Verify attributes value range
    (positive/negative cases). Verify overwriting of default-action with entry specific 
    action policy (forward router). Verify overwriting of action forward router with 
    another action policies. Check the output of mibwalk and getnext (TIPFilterParamsEntry, 
    TIPv6FilterParamsEntry tables)
            "]
    log_msg INFO "$description"

    # Dut-C (dut2) is the dut under test
    set dut2 $opt(dut)
    if { [getGlobalVar ipv6Support] == "true" } { set filterList "IP IPv6" } else { set filterList "IP" }

    catch {exec date} timestamp

    log_msg INFO "START: $testId  --  $timestamp"
    log_msg INFO "Beginning $testId Test Cases............"
    log_msg NULL ""

    # create IPv4 and IPv6 filter with one entry in each
    log_msg INFO "Creating IPv4 and IPv6 filter with one entry in each"

    Dut-$dut2 setTIPFilterRowStatus $opt(filter_ip_id) "createAndGo"
    Dut-$dut2 setTIPFilterParamsRowStatus $opt(filter_ip_id) $opt(entry_ip_id) "createAndGo"
    Dut-$dut2 setTIPv6FilterRowStatus $opt(filter_ipv6_id) "createAndGo"
    Dut-$dut2 setTIPv6FilterParamsRowStatus $opt(filter_ipv6_id) $opt(entry_ipv6_id) "createAndGo"

    # configure VPRN services
    set r [Dut-$dut2 createVprn $opt(vprn_id) 1]
    if { $r != "OK" } { log_msg ERROR "Creation of VPRN service with ID: $opt(vprn_id) was not successful"; set testResultFlag "FAILED" }
    set r [Dut-$dut2 createVprn $opt(vprn2_id) 1]
    if { $r != "OK" } { log_msg ERROR "Creation of VPRN service with ID: $opt(vprn2_id) was not successful"; set testResultFlag "FAILED" }

  foreach {filterType} $filterList {

    print_console_msg "$testId.$filterType"

    # start memory leak checks
    filter_subinsert_memLeakChecks $dut2 start

    if {[Dut-$dut2 cget -redundantSystem] != "false"} {
        # start memory leak checks on standby CPM
        filterScale_memLeakChecks $dut2 start -card [Dut-$dut2 findInactiveCpm] -mPools {"Services" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}
    }


    #verify set/get functions on new snmp objects (tIPFilterParamsFwdRtrId, tIPv6FilterParamsFwdRtrId) in TIPFilterParamsEntry and TIPv6FilterParamsEntry tables
    log_msg INFO "--------------------------------------"
    log_msg INFO "1. Verify set/get functions on new snmp objects (t[getVar3 $filterType]FilterParamsFwdRtrId)"
    log_msg INFO "--------------------------------------"
    
    # verify, that default value for objects FilterParamsFwdRtrId is 0
    log_msg INFO "=> Verify default value for object t[getVar3 $filterType]FilterParamsFwdRtrId (expect 0)"
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "0" $r]

    # set action to forward
    set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ]]]
    set testResultFlag [wccpCompareOutputString "noError" [lindex $r 0]]

    log_msg INFO "=> Set action forward router - Base"
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) 1]
    set testResultFlag [wccpCompareOutputString "noError" $r]

    # verify, that action for filter is set to forward router Base via SNMP and CLI as well
    log_msg INFO "=> Verify action forward router - Base"
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "1" $r]
    # CLI
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
        if { $name != "Base" } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]

    # set action forward router - router-instance
    log_msg INFO "=> Set action forward router - router-instance ($opt(vprn_id))"
    set VRtrId [Dut-$dut2 getVRtrInstanceId $opt(vprn_id)]
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $VRtrId]
    set testResultFlag [wccpCompareOutputString "noError" $r]

    # verify, that action for filter is set to forward router router-instance via SNMP and CLI as well
    log_msg INFO "=> Verify action forward router - router-instance ($opt(vprn_id))"
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString $VRtrId $r]
    # CLI
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
        if { $id != $opt(vprn_id) } { log_msg ERROR "Wrong router id: $id"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse digit for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    
    # set action forward router - router-instance 2
    log_msg INFO "=> Set action forward router - router-instance ($opt(vprn2_id))"
    set VRtrId [Dut-$dut2 getVRtrInstanceId $opt(vprn2_id)]
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $VRtrId]
    set testResultFlag [wccpCompareOutputString "noError" $r]

    # verify, that action for filter is set to forward router router-instance 2 via SNMP and CLI as well
    log_msg INFO "=> Verify action forward router - router-instance ($opt(vprn2_id))"
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString $VRtrId $r]
    # CLI
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
        if { $id != $opt(vprn2_id) } { log_msg ERROR "Wrong router id: $id"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse digit for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    
    # set action forward router back to Base
    log_msg INFO "=> Set action forward router back to Base"
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) 1]
    set testResultFlag [wccpCompareOutputString "noError" $r]

    # verify, that action for filter is set to forward router Base via SNMP and CLI as well
    log_msg INFO "=> Verify action forward router - Base"
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "1" $r]
    # CLI
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
        if { $name != "Base" } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]

    # set default value for objects FilterParamsFwdRtrId - 0
    log_msg INFO "=> Set default value for object t[getVar3 $filterType]FilterParamsFwdRtrId (expect 0)"
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) 0]
    set testResultFlag [wccpCompareOutputString "noError" $r]

    # verify, that action for filter is set to forward router Base via SNMP and CLI as well
    log_msg INFO "=> Verify default value for object t[getVar3 $filterType]FilterParamsFwdRtrId (expect 0)"
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "0" $r]
    # CLI
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
    if { [regexp {Next Hop     : (Not Specified)} $r1 match name] == "0" } { 
        log_msg ERROR "Default next hop is not correct"; set testResultFlag "FAILED" 
    }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]


    log_msg INFO "--------------------------------------"
    log_msg INFO "2. Verify attributes value range {TmnxVRtrIDOrZero}"
    log_msg INFO "--------------------------------------"

    # trying to set invalid values
    ### DTS176380 add check that there is no possible to set action forward router to default vprn instances: vpls-management (4094) and management (4095)
    log_msg INFO "Trying to set valid as well as invalid values (-100, -1, 0, 1, 60, 61, $opt(vprn_id), $VRtrId, $opt(vprn2_id), 1000, 999999999, 4094, 4095, 1, 0)"
    set res ""
    foreach value "-100 -1 0 1 60 61 $opt(vprn_id) $VRtrId $opt(vprn2_id) 1000 999999999 4094 4095 1 0" {
       lappend res [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $value]
    }
    set exp "wrongValue wrongValue noError noError inconsistentValue inconsistentValue inconsistentValue noError inconsistentValue inconsistentValue wrongValue inconsistentValue inconsistentValue noError noError"
    set testResultFlag [wccpCompareOutputString $exp $res]


    log_msg INFO "--------------------------------------"
    log_msg INFO "3. Verify overwriting of 'action forward router' with another action policies"
    log_msg INFO "--------------------------------------"

    set buildVersion [lindex [split [lindex [split [cookCliData [Dut-$dut2 sendCliCommand "show version"]] .] 0] "-"] 2 ]

    set routerList "1 $VRtrId"
   foreach {routerInstance} $routerList {
    
    if { $routerInstance == "1" } {
        log_msg INFO "=> Set action forward router - Base"
        set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) 1]
        set testResultFlag [wccpCompareOutputString "noError" $r]
    } else {
        log_msg INFO "=> Set action forward router - $VRtrId"
        set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $routerInstance]
        set testResultFlag [wccpCompareOutputString "noError" $r]
    }

    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]

if {($buildVersion != 0) && ($buildVersion < 13)} {    

    if { $filterType == "IP" } {
        log_msg INFO "Trying to reset 'action forward router $routerInstance' with another next hops (expect fail for all cases)"

        log_msg INFO " -> ForwardNH"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0.0.0.0"
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardNHInterface"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardRedPlcy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output inconsistentValue -expected_dest ""
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy

        log_msg INFO " -> FwdSapPortId"

        # Configure SAP
        Dut-$dut2 configurePort [set topoMap(Dut-$dut2,1/1/1)] -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] -verify true -reverse false -expected_create_output inconsistentValue -expected_dest 0
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0
        Dut-$dut2 deleteTls 1 1
        cliCne Dut-$dut2 "/configure port [set topoMap(Dut-$dut2,1/1/1)] shutdown"
        Dut-$dut2 deconfigurePort [set topoMap(Dut-$dut2,1/1/1)]

        log_msg INFO " -> FwdSdpBind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "00:00:00:00:00:00:00:00"
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre

        log_msg INFO " -> FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"
        
        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"

        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }


        if { ([getGlobalVar subTopology] == "sparrow") || ([getGlobalVar subTopology] == "sicily") || ([getGlobalVar mixedMode] == "true") } {
            set actionList "forward default nat reassemble httpRedirect drop"
        } elseif { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList "forward default httpRedirect drop"
        } else {
            set actionList "forward default nat reassemble gtpLclBrkout httpRedirect drop"
        }

        foreach action $actionList {
            createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output noError -expected_dest $routerInstance

            log_msg DEBUG "Resetting action to $action"
            
            if { $action != "httpRedirect" } {
                Dut-$dut2 setTIPFilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            } else {
                Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $action ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsRedirectURL $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] http://1.2.3.4/ ] ]
            }
            if { ($action == "forward") || ($action == "default")} {
                set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            } else {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            }
        }

        log_msg INFO " => Try to set action forward router while action is not forward"

        if { ([getGlobalVar subTopology] == "sparrow") || ([getGlobalVar subTopology] == "sicily") || ([getGlobalVar mixedMode] == "true") } {
            set actionList "nat reassemble drop"
        } elseif { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList "drop"
        } else {
            set actionList "nat reassemble gtpLclBrkout drop"
        }

        foreach action $actionList {

            log_msg DEBUG "Set action to $action - try to set router as a destination (ignore of action is expected)"

            Dut-$dut2 setTIPFilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack tIPFilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ]]]
            set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0] ]
            if { $action == "gtpLclBrkout" } {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            } else {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            }
            set testResultFlag [wccpCompareOutputString $action [Dut-$dut2 getT[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            # CLI
            set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Match action\""]
            if { [regexp {Match action : (\S+)} $r1 match name] == "0" } {
                log_msg ERROR "Action is not possible to parse"; set testResultFlag "FAILED"
            } else {
                if { $name == "GTP-Local-Breakout" } { set name "gtpLclBrkout" }
                if { [string tolower $name] != [string tolower $action] } {
                    log_msg ERROR "Action is not correct: $name and it sould be $action"; set testResultFlag "FAILED"
                }
             
            }

        }
        

        log_msg INFO " => Creating IPv4 action forward router $routerInstance - reverse snmp command items"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

        log_msg INFO " => Set destination router $routerInstance with different action combinations (different order of set commands)"


      foreach action $actionList {
        log_msg INFO "set FwdRtr -> set action: $action"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest "0"
        log_msg INFO "Reverse order - set action: $action -> set FwdRtr"
        if { $action == "gtpLclBrkout" } {
            createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
        } else {
            createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
        }
      }
    Dut-$dut2 setTIPFilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) forward
    createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"


      log_msg INFO " => Try to set action forward router $routerInstance and next-hop together (expect fail)"
      set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsForwardNH $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1.2.3.4 ] ]]
      set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0]]

    } else {

        log_msg INFO "Trying to reset 'action forward router $routerInstance' with another next hops (expect fail for all cases)"

        log_msg INFO " -> ForwardNH"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0000:0000:0000:0000:0000:0000:0000:0000"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardNHInterface"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardRedPlcy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy

        log_msg INFO " -> FwdSapPortId"

        # Configure SAP
        Dut-$dut2 configurePort [set topoMap(Dut-$dut2,1/1/1)] -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0
        Dut-$dut2 deleteTls 1 1
        Dut-$dut2 deconfigurePort [set topoMap(Dut-$dut2,1/1/1)]
#        cliCne Dut-$dut2 "/configure port [set topoMap(Dut-$dut2,1/1/1)] shutdown"

        log_msg INFO " -> FwdSdpBind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "00:00:00:00:00:00:00:00"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre

        log_msg INFO " -> FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"

        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

        if { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionListIPv6 "forward default httpRedirect drop"
        } else {
            set actionListIPv6 "forward nat default httpRedirect drop"
        }

        foreach action  $actionListIPv6 {
            createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output noError -expected_dest $routerInstance

            log_msg DEBUG "Resetting action to $action"
            
            if { $action != "httpRedirect" } {
                Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            } else {
                Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $action ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsRedirectURL $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] http://1.2.3.4/ ] ]
            }
            if { ($action == "forward") || ($action == "default") } {
                set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            } else {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            }
        }

        log_msg INFO " => Try to set action forward router while action is not forward"

        if { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList2IPv6 "drop"
        } else {
            set actionList2IPv6 "nat drop"
        }

        foreach action $actionList2IPv6 {

            log_msg DEBUG "Set action to $action - try to set router as a destination (ignore of action is expected)"

            Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack tIPv6FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ]]]
            set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0] ]
            set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            set testResultFlag [wccpCompareOutputString $action [Dut-$dut2 getT[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            # CLI
            set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Match action\""]
            if { [regexp {Match action : (\S+)} $r1 match name] == "0" } {
                log_msg ERROR "Action is not possible to parse"; set testResultFlag "FAILED"
            } else {
                if { [string tolower $name] != [string tolower $action] } {
                    log_msg ERROR "Action is not correct: $name and it sould be $action"; set testResultFlag "FAILED"
                }

            }

        }


        log_msg INFO " => Creating IPv6 action forward router Base - reverse snmp command items"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

        log_msg INFO " => Set destination router $routerInstance with different action combinations (different order of set commands)"

      foreach action $actionList2IPv6 {
        log_msg INFO "set FwdRtr -> set action: $action"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest "0"
        log_msg INFO "Reverse order - set action: $action -> set FwdRtr"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output inconsistentValue -expected_dest "0"
      }

    Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) forward
    createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

      log_msg INFO " => Try to set action forward router $routerInstance and next-hop together (expect fail)"
      set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsForwardNH $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 ] ]]
      set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0]]

    }
} else {
    if { $filterType == "IP" } {
        log_msg INFO "Trying to reset 'action forward router $routerInstance' with another next hops (expect pass for all cases)"

        log_msg INFO " -> ForwardNH"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output noError -expected_dest "1.2.3.4"
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardNHInterface"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output noError -expected_dest "test"
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardRedPlcy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy

        log_msg INFO " -> FwdSapPortId"

        # Configure SAP
        Dut-$dut2 configurePort [set topoMap(Dut-$dut2,1/1/1)] -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0
        Dut-$dut2 deleteTls 1 1
        cliCne Dut-$dut2 "/configure port [set topoMap(Dut-$dut2,1/1/1)] shutdown"
        Dut-$dut2 deconfigurePort [set topoMap(Dut-$dut2,1/1/1)]

        log_msg INFO " -> FwdSdpBind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre

        log_msg INFO " -> FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $LspId ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1 ]]

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output noError -expected_dest "$LspId"

        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }


        if { ([getGlobalVar subTopology] == "sparrow") || ([getGlobalVar subTopology] == "sicily") || ([getGlobalVar mixedMode] == "true") } {
            set actionList "forward default nat reassemble httpRedirect drop"
        } elseif { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList "forward default httpRedirect drop"
        } else {
            set actionList "forward default nat reassemble gtpLclBrkout httpRedirect drop"
        }

        foreach action $actionList {
            createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output noError -expected_dest $routerInstance

            log_msg DEBUG "Resetting action to $action"

            if { $action != "httpRedirect" } {
                Dut-$dut2 setTIPFilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            } else {
                Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $action ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsRedirectURL $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] http://1.2.3.4/ ] ]
            }
            if { ($action == "forward") || ($action == "default")} {
                set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            } else {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            }
        }

        log_msg INFO " => Try to set action forward router while action is not forward"

        if { ([getGlobalVar subTopology] == "sparrow") || ([getGlobalVar subTopology] == "sicily") || ([getGlobalVar mixedMode] == "true") } {
            set actionList "nat reassemble drop"
        } elseif { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList "drop"
        } else {
            set actionList "nat reassemble gtpLclBrkout drop"
        }

        foreach action $actionList {

            log_msg DEBUG "Set action to $action - try to set router as a destination (ignore of action is expected)"

            Dut-$dut2 setTIPFilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack tIPFilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ]]]
            set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0] ]
            if { $action == "gtpLclBrkout" } {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            } else {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            }
            set testResultFlag [wccpCompareOutputString $action [Dut-$dut2 getT[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            # CLI
            set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Match action\""]
            if { [regexp {Match action : (\S+)} $r1 match name] == "0" } {
                log_msg ERROR "Action is not possible to parse"; set testResultFlag "FAILED"
            } else {
                if { $name == "GTP-Local-Breakout" } { set name "gtpLclBrkout" }
                if { [string tolower $name] != [string tolower $action] } {
                    log_msg ERROR "Action is not correct: $name and it sould be $action"; set testResultFlag "FAILED"
                }

            }

        }


        log_msg INFO " => Creating IPv4 action forward router $routerInstance - reverse snmp command items"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

        log_msg INFO " => Set destination router $routerInstance with different action combinations (different order of set commands)"


      foreach action $actionList {
        log_msg INFO "set FwdRtr -> set action: $action"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify false -reverse true -expected_create_output inconsistentValue -expected_dest "0"
        log_msg INFO "Reverse order - set action: $action -> set FwdRtr"
        if { $action == "gtpLclBrkout" } {
            createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify false -reverse false -expected_create_output inconsistentValue -expected_dest "0"
        } else {
            createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify false -reverse false -expected_create_output inconsistentValue -expected_dest "0"
        }
      }
    Dut-$dut2 setTIPFilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) forward
    createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

      log_msg INFO " => Try to set action forward router $routerInstance and next-hop together (expect fail)"
      set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsForwardNH $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1.2.3.4 ] ]]
      set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0]]


    } else {

        log_msg INFO "Trying to reset 'action forward router $routerInstance' with another next hops (expect pass for all cases)"

        log_msg INFO " -> ForwardNH"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse false -expected_create_output noError -expected_dest "2002:0000:0000:0000:0000:0000:0102:0304"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardNHInterface"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output wrongValue -expected_dest ""
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        log_msg INFO " -> ForwardRedPlcy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService


        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy

        log_msg INFO " -> FwdSapPortId"

        # Configure SAP
        Dut-$dut2 configurePort [set topoMap(Dut-$dut2,1/1/1)] -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]]
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0
        Dut-$dut2 deleteTls 1 1
        Dut-$dut2 deconfigurePort [set topoMap(Dut-$dut2,1/1/1)]
#        cliCne Dut-$dut2 "/configure port [set topoMap(Dut-$dut2,1/1/1)] shutdown"

        log_msg INFO " -> FwdSdpBind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre

        log_msg INFO " -> FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $LspId ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1 ]]

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output noError -expected_dest "$LspId"

        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

        if { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionListIPv6 "forward default httpRedirect drop"
        } else {
            set actionListIPv6 "forward nat default httpRedirect drop"
        }

        foreach action  $actionListIPv6 {
            createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse false -expected_create_output noError -expected_dest $routerInstance

            log_msg DEBUG "Resetting action to $action"

            if { $action != "httpRedirect" } {
                Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            } else {
                Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $action ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsRedirectURL $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] http://1.2.3.4/ ] ]
            }
            if { ($action == "forward") || ($action == "default") } {
                set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            } else {
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            }
        }

        log_msg INFO " => Try to set action forward router while action is not forward"

        if { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList2IPv6 "drop"
        } else {
            set actionList2IPv6 "nat drop"
        }

        foreach action $actionList2IPv6 {

            log_msg DEBUG "Set action to $action - try to set router as a destination (ignore of action is expected)"

            Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $action
            set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack tIPv6FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ]]]
            set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0] ]
            set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            set testResultFlag [wccpCompareOutputString $action [Dut-$dut2 getT[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
            # CLI
            set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Match action\""]
            if { [regexp {Match action : (\S+)} $r1 match name] == "0" } {
                log_msg ERROR "Action is not possible to parse"; set testResultFlag "FAILED"
            } else {
                if { [string tolower $name] != [string tolower $action] } {
                    log_msg ERROR "Action is not correct: $name and it sould be $action"; set testResultFlag "FAILED"
                }

            }

        }


        log_msg INFO " => Creating IPv6 action forward router Base - reverse snmp command items"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

        log_msg INFO " => Set destination router $routerInstance with different action combinations (different order of set commands)"

      foreach action $actionList2IPv6 {
        log_msg INFO "set FwdRtr -> set action: $action"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify false -reverse true -expected_create_output inconsistentValue -expected_dest "0"
        log_msg INFO "Reverse order - set action: $action -> set FwdRtr"
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action $action -forward FwdRtrId -dest $routerInstance -verify false -reverse false -expected_create_output inconsistentValue -expected_dest "0"
      }

    Dut-$dut2 setTIPv6FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) forward
    createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

      log_msg INFO " => Try to set action forward router $routerInstance and next-hop together (expect fail)"
      set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsForwardNH $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 ] ]]
      set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0]]

    }
}
   } 

    log_msg INFO "--------------------------------------"
    log_msg INFO "4. Verify overwriting of different action policies by 'action forward router'"
    log_msg INFO "--------------------------------------"

    set routerList "1 $VRtrId"
   foreach {routerInstance} $routerList {

    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]

if {($buildVersion != 0) && ($buildVersion < 13)} {

    if { $filterType == "IP" } {
        log_msg INFO "Trying to reset different action policies by 'action forward router $routerInstance' (expect fail for all cases)"

        log_msg INFO " -> reset ForwardNH"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output noError -expected_dest "1.2.3.4"
        # trying to reset ForwardNH with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output inconsistentValue -expected_dest 0
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 0.0.0.0 -verify true -reverse false -expected_create_output noError -expected_dest "0.0.0.0"

        log_msg INFO " -> reset ForwardNHInterface"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output noError -expected_dest "test"
        # trying to reset ForwardNHInterface with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output inconsistentValue -expected_dest 0
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""

        log_msg INFO " -> reset ForwardRedPlcy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
        # trying to reset ForwardRedPlcy with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output inconsistentValue -expected_dest 0
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy

        log_msg INFO " -> reset FwdSapPortId"

        # Configure SAP
        Dut-$dut2 configurePort [set topoMap(Dut-$dut2,1/1/1)] -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]]
        # trying to reset FwdSapPortIdd with action forward router - expect pass
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"


        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0
        Dut-$dut2 deleteTls 1 1
        cliCne Dut-$dut2 "/configure port [set topoMap(Dut-$dut2,1/1/1)] shutdown"
        Dut-$dut2 deconfigurePort [set topoMap(Dut-$dut2,1/1/1)]

        log_msg INFO " -> reset FwdSdpBind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"
        # trying to reset FwdSdpBind with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre

        log_msg INFO " -> reset FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $LspId ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1 ]]
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output noError -expected_dest $LspId
        # trying to reset FwdLsp with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output inconsistentValue -expected_dest 0
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ]]        


        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    } else {

        log_msg INFO "Trying to reset different action policies by 'action forward router $routerInstance' (expect fail for all cases)" 

        log_msg INFO " -> reset ForwardNH"

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse false -expected_create_output noError -expected_dest "2002:0000:0000:0000:0000:0000:0102:0304"
       # trying to reset ForwardNH with action forward router
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output inconsistentValue -expected_dest "0"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 -verify true -reverse false -expected_create_output noError -expected_dest "0000:0000:0000:0000:0000:0000:0000:0000"


        log_msg INFO " -> reset FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $LspId ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1 ]]
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output noError -expected_dest $LspId
       # trying to reset ForwardNHInterface with action forward router
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output inconsistentValue -expected_dest "0"
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ]]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    }
} else {
    if { $filterType == "IP" } {
        log_msg INFO "Trying to reset different action policies by 'action forward router $routerInstance' (expect pass for all cases)"

        log_msg INFO " -> reset ForwardNH"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 1.2.3.4 -verify true -reverse false -expected_create_output noError -expected_dest "1.2.3.4"
        # trying to reset ForwardNH with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 0.0.0.0 -verify true -reverse false -expected_create_output noError -expected_dest "0.0.0.0"

        log_msg INFO " -> reset ForwardNHInterface"
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest test -verify true -reverse false -expected_create_output noError -expected_dest "test"
        # trying to reset ForwardNHInterface with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNHInterface -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""

        log_msg INFO " -> reset ForwardRedPlcy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest wccp -verify true -reverse false -expected_create_output noError -expected_dest "wccp"
        # trying to reset ForwardRedPlcy with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardRedPlcy -dest "" -verify true -reverse false -expected_create_output noError -expected_dest ""

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy

        log_msg INFO " -> reset FwdSapPortId"

        # Configure SAP
        Dut-$dut2 configurePort [set topoMap(Dut-$dut2,1/1/1)] -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSapPortId -dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] -verify true -reverse false -expected_create_output noError -expected_dest [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]]
        # trying to reset FwdSapPortIdd with action forward router - expect pass
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"


        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port [set topoMap(Dut-$dut2,1/1/1)]] 0
        Dut-$dut2 deleteTls 1 1
        cliCne Dut-$dut2 "/configure port [set topoMap(Dut-$dut2,1/1/1)] shutdown"
        Dut-$dut2 deconfigurePort [set topoMap(Dut-$dut2,1/1/1)]

        log_msg INFO " -> reset FwdSdpBind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdSdpBind -dest 00:00:00:01:00:00:00:01 -verify true -reverse false -expected_create_output noError -expected_dest "00:00:00:01:00:00:00:01"
        # trying to reset FwdSdpBind with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest 0 -verify true -reverse true -expected_create_output noError -expected_dest "0"

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre

        log_msg INFO " -> reset FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $LspId ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1 ]]
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output noError -expected_dest $LspId
        # trying to reset FwdLsp with action forward router
        createIpFilterParams $dut2 -filter_id $opt(filter_[getVar4 $filterType]_id) -entry_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ]]


        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    } else {

        log_msg INFO "Trying to reset different action policies by 'action forward router $routerInstance' (expect pass for all cases)"

        log_msg INFO " -> reset ForwardNH"

        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 20:02:00:00:00:00:00:00:00:00:00:00:01:02:03:04 -verify true -reverse false -expected_create_output noError -expected_dest "2002:0000:0000:0000:0000:0000:0102:0304"
       # trying to reset ForwardNH with action forward router
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward ForwardNH -dest 00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00 -verify true -reverse false -expected_create_output noError -expected_dest "0000:0000:0000:0000:0000:0000:0000:0000"


        log_msg INFO " -> reset FwdLsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $LspId ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 1 ]]
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdLsp -dest $LspId -verify true -reverse false -expected_create_output noError -expected_dest $LspId
       # trying to reset ForwardNHInterface with action forward router
        createIpFilterParams $dut2 -ipv6 true -filter_ipv6_id $opt(filter_[getVar4 $filterType]_id) -entry_ipv6_id $opt(entry_[getVar4 $filterType]_id) -action forward -forward FwdRtrId -dest $routerInstance -verify true -reverse true -expected_create_output noError -expected_dest $routerInstance
        puts [Dut-$dut2 sendCliCommand "/show filter ipv6 $opt(filter_[getVar4 $filterType]_id)"]
        # set NH to default value
        Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLsp $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdLspRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ]]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    }
}
   }

    # check for memory leaks
    log_msg INFO "Check for memory leaks"
    set check [filter_subinsert_memLeakChecks $dut2 check]
    if {$check != "PASSED"} {
        log_msg ERROR "Memory leak detected after cleanup, found $check"
        set testResultFlag "FAILED"
    }
    if {[Dut-$dut2 cget -redundantSystem] != "false"} {
        set check_stb [filterScale_memLeakChecks $dut2 check -card [Dut-$dut2 findInactiveCpm] -mPools {"Services" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}]
        if {$check_stb != "OK"} {
            log_msg ERROR "Memory leak detected after cleanup on standby CPM, found $check_stb"
            set testResultFlag "FAILED"
        }
    }


    log_msg INFO "--------------------------------------"
    log_msg INFO "5. Verify output of mibwalk and getnext"
    log_msg INFO "--------------------------------------"

    set num_entries 500

  foreach {routerInstance} $routerList {
    for {set i 0} {$i < $num_entries} {incr i} {
        Dut-$dut2 setT[getVar3 $filterType]FilterRowStatus $opt(filter_[getVar4 $filterType]_id) "createAndGo"
        Dut-$dut2 setT[getVar3 $filterType]FilterParamsRowStatus $opt(filter_[getVar4 $filterType]_id) [expr $opt(entry_[getVar4 $filterType]_id) + $i] "createAndGo"
        set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) [expr $opt(entry_[getVar4 $filterType]_id) + $i]] forward ]]]
        set testResultFlag [wccpCompareOutputString "noError" [lindex $r 0]]
        set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) [expr $opt(entry_[getVar4 $filterType]_id) + $i] $routerInstance]
        set testResultFlag [wccpCompareOutputString "noError" $r]
     }

    log_msg INFO "Verify correct number of entries with mib walk of t[getVar3 $filterType]FilterParamsRowStatus and t[getVar3 $filterType]FilterParamsEntry.52 - $num_entries"
    wccpMibWalk $dut2 t[getVar3 $filterType]FilterParamsRowStatus $num_entries
    after 2000
    wccpMibWalk $dut2 t[getVar3 $filterType]FilterParamsEntry.52 $num_entries

    log_msg INFO "Verify correct number of entries with getnext"
    wccpMibGetNext $dut2 t[getVar3 $filterType]FilterParamsRowStatus $num_entries

    log_msg INFO "Verify, if each entry has action set to forward router - $routerInstance"
    for {set i 0} {$i < $num_entries} {incr i} {
        set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) [expr $opt(entry_[getVar4 $filterType]_id) + $i]]]
    }
  }


    log_msg INFO "--------------------------------------"
    log_msg INFO "6. Verify cleanup of child objects when parent is removed"
    log_msg INFO "--------------------------------------"

    log_msg INFO "Destroy the filter"
    Dut-$dut2 setT[getVar3 $filterType]FilterRowStatus $opt(filter_[getVar4 $filterType]_id) "destroy"
    log_msg INFO "Verify cleanup of child objects"
    set testResultFlag [wccpCompareOutputString "ERROR" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO "Create filter again"
    Dut-$dut2 setT[getVar3 $filterType]FilterRowStatus $opt(filter_[getVar4 $filterType]_id) "createAndGo"
    Dut-$dut2 setT[getVar3 $filterType]FilterParamsRowStatus $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) "createAndGo"
    log_msg INFO "Verify, that child objects have default value"
    set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO "Verify, that child objects have default value after changing action to forward"
    Dut-$dut2 setT[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) forward
    set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    
    log_msg INFO "--------------------------------------"
    log_msg INFO "7. Verify that action can not be set when the filter is blocked due to li-source"
    log_msg INFO "--------------------------------------"

    log_msg INFO "Check if an ip-filter's action can be modified when used as an li-source and the lock state is locked"

    log_msg INFO "Create liadmin and configure li-source"
    # Among the password criteria we can set now there is one of them preventing to reuse the username in the password, that's why we disable this check
    Dut-$dut2 sendCliCommand "/configure system security password complexity-rules allow-user-name"
    liUserSetup Dut-$dut2
    Dut-$dut2 sendCliCommand "/configure mirror mirror-dest 1 create"
    switchUser Dut-$dut2 liadmin liadmin
    Dut-$dut2 sendCliCommand "/configure li li-source 1 [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id)"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 no shutdown"
    
  foreach {routerInstance} $routerList {
    log_msg INFO " => Trying to change action to forward router - $routerInstance (expect fail)"
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $routerInstance]
    set testResultFlag [wccpCompareOutputString "inconsistentValue" $r]

    set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ] ]]
    set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0]]
    set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO " => Deconfigure li-source"
    Dut-$dut2 sendCliCommand "/configure li no li-source 1"
    log_msg INFO " => Trying to change action to forward router - $routerInstance (expect pass)"
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) $routerInstance]
    set testResultFlag [wccpCompareOutputString "noError" $r]
    
    log_msg INFO " => Configure li-source again"
    Dut-$dut2 sendCliCommand "/configure mirror mirror-dest 1 create"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id)"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 no shutdown"
    
    log_msg INFO " => Trying to set same action to forward router - $routerInstance (expect pass)"
    set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] $routerInstance ] ]]
    set testResultFlag [wccpCompareOutputString "noError" [lindex $r 0]]
    set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
    
    log_msg INFO " => Trying to change action to forward only (expect fail)"
    set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] ]]
    set testResultFlag [wccpCompareOutputString "inconsistentValue" [lindex $r 0]]
    set testResultFlag [wccpCompareOutputString $routerInstance [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO " => Trying to change action to drop (expect fail)"
    set r [Dut-$dut2 setT[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) drop]
    set testResultFlag [wccpCompareOutputString "inconsistentValue" $r]

    log_msg INFO " => Deconfigure li-source in order to set action to default value"
    Dut-$dut2 sendCliCommand "/configure li no li-source 1"
    Dut-$dut2 sendCliCommand "/configure mirror no mirror-dest 1"

    set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] ]]

    log_msg INFO " => Configure li-source again"
    Dut-$dut2 sendCliCommand "/configure mirror mirror-dest 1 create"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id)"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 no shutdown"

  }
  
    log_msg INFO " => Deconfigure li-source"
    Dut-$dut2 sendCliCommand "/configure li no li-source 1"
    Dut-$dut2 sendCliCommand "/configure mirror no mirror-dest 1"
    
    set r [Dut-$dut2 set_ [ list [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsAction $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] forward ] [ list [ Tnm::mib pack t[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)] 0 ] ]]
    
    switchUser Dut-$dut2 admin admin
    liUserCleanup Dut-$dut2
  }

    Dut-$dut2 sendCliCommand "/configure system security password complexity-rules no allow-user-name"

    set r [Dut-$dut2 deleteVprn $opt(vprn_id)]
    if { $r != "OK" } { log_msg ERROR "Deletion of VPRN service with ID: $opt(vprn_id) was not successful"; set testResultFlag "FAILED" }
    set r [Dut-$dut2 deleteVprn $opt(vprn2_id)]
    if { $r != "OK" } { log_msg ERROR "Deletion of VPRN service with ID: $opt(vprn2_id) was not successful"; set testResultFlag "FAILED" }

    Dut-$dut2 setTIPFilterRowStatus $opt(filter_ip_id) "destroy"
    Dut-$dut2 setTIPv6FilterRowStatus $opt(filter_ipv6_id) "destroy"

    if { ($testResultFlag == "PASSED") && ($setupErrorFlag == "NOERROR") } {
        log_result PASSED "Test Case $testId PASSED"
    } else {
        log_result FAILED "Test Case $testId FAILED"
    }

}


proc filterActionFwdRtrCliChecks { args  } {

    global setupErrorFlag testResultFlag ixia_port logdir testdir
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl
    source $testdir/testsuites/filter/params_file_filter_tcam.tcl

    set opt(filter_ip_id)       1
    set opt(entry_ip_id)        100
    set opt(filter_ipv6_id)       2
    set opt(entry_ipv6_id)        200
    set opt(vprn_id)        500
    set opt(vprn2_id)        600
    set opt(dut)        C

    getopt opt $args

    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"
    set testId "filterActionFwdRtr_cli"
    set description [boxifyText \
        "This test should verify config/show commands for action forward router. 
    Verify attributes value range (positive/negative cases). Verify overwriting of 
    default-action with entry specific action policy (forward router). Verify 
    overwriting of action forward router with another action policies. Check the 
    defualt values are restored after 'no' command ...
             "]
    log_msg INFO "$description"

    # Dut-C (dut2) is the dut under test
    set dut2 $opt(dut)
    if { [getGlobalVar ipv6Support] == "true" } { set filterList "IP IPv6" } else { set filterList "IP" }

    catch {exec date} timestamp

    log_msg INFO "START: $testId  --  $timestamp"
    log_msg INFO "Beginning $testId Test Cases............"
    log_msg NULL ""

    # create IPv4 and IPv6 filter with one entry in each
    log_msg INFO "Creating IPv4 and IPv6 filter with one entry in each"

    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure filter ip-filter $opt(filter_ip_id) create entry $opt(entry_ip_id) create"
    cliCne Dut-$dut2 "/configure filter ipv6-filter $opt(filter_ipv6_id) create entry $opt(entry_ipv6_id) create"
    cliCne Dut-$dut2 "exit all"

    # configure VPRN services
    set r [Dut-$dut2 createVprn $opt(vprn_id) 1]
    if { $r != "OK" } { log_msg ERROR "Creation of VPRN service with ID: $opt(vprn_id) was not successful"; set testResultFlag "FAILED" }
    set r [Dut-$dut2 createVprn $opt(vprn2_id) 1]
    if { $r != "OK" } { log_msg ERROR "Creation of VPRN service with ID: $opt(vprn2_id) was not successful"; set testResultFlag "FAILED" }

  foreach {filterType} $filterList {

    print_console_msg "$testId.$filterType"

    # start memory leak checks
    filter_subinsert_memLeakChecks $dut2 start

    if {[Dut-$dut2 cget -redundantSystem] != "false"} {
        # start memory leak checks on standby CPM
        filterScale_memLeakChecks $dut2 start -card [Dut-$dut2 findInactiveCpm] -mPools {"Services" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}
    }

    log_msg INFO "--------------------------------------"
    log_msg INFO "1. Verify config/show CLI commands"
    log_msg INFO "--------------------------------------"

    log_msg INFO "=> Set action forward router - Base"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router Base"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Verify action forward router - Base"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
        if { $name != "Base" } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "1" $r]
    
    log_msg INFO "=> Set action forward router - router-instance ($opt(vprn_id))"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $opt(vprn_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
    
    log_msg INFO "=> Verify action forward router - router-instance ($opt(vprn_id))"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
        if { $id != $opt(vprn_id) } { log_msg ERROR "Wrong router id: $id"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse digit for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set VRtrId [Dut-$dut2 getVRtrInstanceId $opt(vprn_id)]
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString $VRtrId $r]

    # set action forward router - router-instance 2
    log_msg INFO "=> Set action forward router - router-instance ($opt(vprn2_id))"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $opt(vprn2_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    # verify, that action for filter is set to forward router router-instance 2 via SNMP and CLI as well
    log_msg INFO "=> Verify action forward router - router-instance ($opt(vprn2_id))"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
        if { $id != $opt(vprn2_id) } { log_msg ERROR "Wrong router id: $id"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse digit for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set VRtrId [Dut-$dut2 getVRtrInstanceId $opt(vprn2_id)]
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString $VRtrId $r]

    # set action forward router back to Base
    log_msg INFO "=> Set action forward router back to Base"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router Base"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Verify action forward router - Base"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
        if { $name != "Base" } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "1" $r]

    log_msg INFO "=> Set action forward - reset the next hop value"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Verify action forward"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
    if { [regexp {Next Hop     : (Not Specified)} $r1 match name] == "0" } {
        log_msg ERROR "Default next hop is not correct"; set testResultFlag "FAILED"
    }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "0" $r]

    log_msg INFO "=> Set action forward router - service-name for router-instance $opt(vprn_id)"

    set vprn_name [Dut-$dut2 getSvcName $opt(vprn_id)]
    set vprn2_name [Dut-$dut2 getSvcName $opt(vprn2_id)]

    set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name \"$vprn_name\""]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
    
    log_msg INFO "=> Verify action forward router - service-name for router-instance $opt(vprn_id)"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
        if { $id != $opt(vprn_id) } { log_msg ERROR "Wrong router id: $id"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse digit for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set VRtrId [Dut-$dut2 getVRtrInstanceId $opt(vprn_id)]
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString $VRtrId $r]
    
#    log_msg INFO "=> Verify service-name via info command"
#    set r1 [ Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
#    set r1 [ Dut-$dut2 sendCliCommand "info | match action"]
#    if { [regexp " action forward router service-name (\"$vprn_name\")" $r1 match name] == 0 } {
#        log_msg ERROR "Wrong router name"; set testResultFlag "FAILED"
#    }
    
    log_msg INFO "=> Set no action - reset the next hop value"
    Dut-$dut2 sendCliCommand "exit all"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) no action"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Verify action drop"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Match action\""]
    if { [regexp {Match action : (Drop)} $r1 match name] == "0" } {
        log_msg ERROR "Default match action is not correct"; set testResultFlag "FAILED"
    }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString "0" $r]

    log_msg INFO "=> Set action forward router - service-name for router-instance $opt(vprn2_id)"

    set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name \"$vprn2_name\""]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Verify action forward router - service-name for router-instance $opt(vprn2_id)"
    set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
    if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
        if { $id != $opt(vprn2_id) } { log_msg ERROR "Wrong router id: $id"; set testResultFlag "FAILED" }
    } else { log_msg ERROR "Not possible to parse digit for routerId"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    # SNMP
    set VRtrId [Dut-$dut2 getVRtrInstanceId $opt(vprn2_id)]
    set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
    set testResultFlag [wccpCompareOutputString $VRtrId $r]

#    log_msg INFO "=> Verify service-name via info command"
#    set r1 [ Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
#    set r1 [ Dut-$dut2 sendCliCommand "info | match action"]
#    if { [regexp " action forward router service-name (\"$vprn2_name\")" $r1 match name] == 0 } {
#        log_msg ERROR "Wrong router name"; set testResultFlag "FAILED"
#    }

    log_msg INFO "=> Set action forward router - service-name using serviceID $opt(vprn_id) (expect fail) - DTS163777"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name $opt(vprn_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
    
    log_msg INFO "=> Set action forward router - service-name using serviceID $opt(vprn2_id) (expect fail) - DTS163777"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name $opt(vprn2_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Set action forward router - router-instance using service-name \"$vprn_name\" (expect fail)"
    set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router \"$vprn_name\"" -expectError true]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Set action forward router - router-instance using service-name \"$vprn2_name\" (expect fail)"
    set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router \"$vprn2_name\"" -expectError true]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Set action forward router - service-name 'Base' (expect fail)"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name Base"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }




    log_msg INFO " => Set action to forward"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }


    log_msg INFO "--------------------------------------"
    log_msg INFO "2. Verify if command 'action forward router' doesn't offer service ID from another service pool"
    log_msg INFO "--------------------------------------"

    set j 1
  foreach service {apipe cpipe epipe fpipe ies ipipe vpls} {
    log_msg INFO "=> Create service: $service with service ID: $j and service-name: [string toupper $service]"
    cliCne Dut-$dut2 "/environment no create"
    set r1 [cliCne Dut-$dut2 "/configure service $service $j customer 1 service-name [string toupper $service]"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Set action forward router - router-instance: $j (expect fail)"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $j"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Set action forward router - service-name: [string toupper $service]  (expect fail)"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name [string toupper $service]"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
    log_msg INFO "=> Deconfigure service: $service with service ID: $j and service-name: [string toupper $service]"
    set r1 [cliCne Dut-$dut2 "/configure service no $service $j"]
    incr j
  }
  

    log_msg INFO "--------------------------------------"
    log_msg INFO "3. Try to define nonexistant VPRN"
    log_msg INFO "--------------------------------------"

    foreach value "-100000 -1 0 256 300 DUMMY * management vpls-management" {
        log_msg INFO "=> Trying to configure 'action forward router $value' (expect fail)"
        set cmd "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $value"
        set r1 [cliConfigError Dut-$dut2 $cmd]
        if {$r1 == "ERROR"} { log_msg ERROR "unexpected CLI output for command: $cmd"; set testResultFlag "FAILED" }
        ### check also error output in case of management and vpls-management 
        if {($value == "management") || ($value == "vpls-management")} {
            set r2 [ cookCliData [ Dut-$dut2 sendCliCommand $cmd]]
            if {[regexp "MINOR: FILTER #1360 The indicated Virtual Router cannot be found in the system" $r2] == 0} {
                log_msg ERROR "There was possible to set action forward router $value and it shouldn't be (DTS176380)"; set testResultFlag "FAILED"
            }
        }
        
        log_msg INFO "=> Trying to configure 'action forward router service-name $value' (expect fail)"
        set cmd "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router service-name $value"
        set r1 [cliConfigError Dut-$dut2 $cmd]
        if {$r1 == "ERROR"} { log_msg ERROR "unexpected CLI output for command: $cmd"; set testResultFlag "FAILED" }        
    }


    log_msg INFO "--------------------------------------"
    log_msg INFO "4. Verify overwriting of 'action forward router' with another action policies and vice versa"
    log_msg INFO "--------------------------------------"

    set routerList "Base $opt(vprn_id) $opt(vprn2_id)"
  foreach {routerInstance} $routerList {

    if {$routerInstance == "Base"} {
        set routerInstance_snmp 1
    } elseif {$routerInstance == $opt(vprn_id)} {
        set routerInstance_snmp [Dut-$dut2 getVRtrInstanceId $opt(vprn_id)]
    } elseif {$routerInstance == $opt(vprn2_id)} {
        set routerInstance_snmp [Dut-$dut2 getVRtrInstanceId $opt(vprn2_id)]
    } else {
        log_msg ERROR "Wrong router ID"; set testResultFlag "FAILED"
    }
    
    log_msg INFO "=> Set action forward router - $routerInstance"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
    puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
    
    if { $filterType == "IP" } {
        log_msg INFO "Trying to reset 'action forward router $routerInstance' with another next hops (expect pass for all cases)"

        log_msg INFO " -> forward next-hop"

        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward next-hop 1.2.3.4"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward next-hop 1.2.3.4"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
        if { [regexp "1.2.3.4" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward next-hop' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

        
        log_msg INFO " -> Forward Next Hop Interface"
    
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward next-hop interface test"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward next-hop interface"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
        if { [regexp "test" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward next-hop interface' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]


        log_msg INFO " -> Forward Redirect Policy"

        # Create Redirect Policy
        Dut-$dut2 setTFilterRPRowStatus wccp 4
        Dut-$dut2 setTFilterRPAdminState wccp inService

        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward redirect-policy wccp"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward redirect-policy"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Redirect\""]
        if { [regexp "wccp" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward redirect-policy' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

        # Destroy RP
        Dut-$dut2 setTFilterRPRowStatus wccp destroy


        log_msg INFO " -> Forward Sap Port Id"

        # Configure SAP
        Dut-$dut2 configurePort 1/1/1 -Mode access
        Dut-$dut2 createTls 1 1
        Dut-$dut2 createSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0

        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward sap 1/1/1"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward SAP 1/1/1"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
        if { [regexp "1/1/1" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward SAP' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]
        
        # Deconfigure SAP
        Dut-$dut2 deleteSap 1 [Dut-$dut2 convert_port_ifIndex port 1/1/1] 0
        Dut-$dut2 deleteTls 1 1
        cliCne Dut-$dut2 "/configure port 1/1/1 shutdown"
        Dut-$dut2 deconfigurePort 1/1/1


        log_msg INFO " -> Forward Sdp Bind"

        # Configure SDP
        Dut-$dut2 createSdp 10.20.1.2 gre none -Id 1 -signaling 2 -AdminPathMtu 1500

        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward sdp 1:1"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward SDP 1:1"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
        if { [regexp "1:1" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward SDP' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

        # Deconfigure SDP
        Dut-$dut2 deleteSdp 1 gre


        log_msg INFO " -> Forward Lsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward lsp"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Fwd Lsp\""]
        if { [regexp "LSP test name" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward LSP' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

        if { ([getGlobalVar subTopology] == "sparrow") || ([getGlobalVar subTopology] == "sicily") || ([getGlobalVar mixedMode] == "true") } {
            set actionList "forward nat reassemble http-redirect drop"
        } elseif { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionList "forward http-redirect drop"
        } else {
            set actionList "forward nat reassemble gtp-local-breakout http-redirect drop"
        }
        
        foreach action $actionList {

            log_msg INFO "Set action to forward router $routerInstance"
            set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
            # Verify
            log_msg INFO "=> Verify action forward router $routerInstance"
            # CLI
            set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
                if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
            } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
            puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
            # SNMP
            set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
            set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

            log_msg DEBUG "Resetting action to $action"

            if { $action != "http-redirect" } {
                cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action $action"
            } else {
                cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) match protocol tcp"
                cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action $action http://1.2.3.4/"
            }
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
        }



    } else {

        log_msg INFO "Trying to reset 'action forward router $routerInstance' with another next hops (expect pass for all cases)"

        log_msg INFO " -> forward next-hop"

        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward next-hop 2002:0000:0000:0000:0000:0000:0102:0304"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward next-hop 2002:0000:0000:0000:0000:0000:0102:0304"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Next Hop\""]
        if { [regexp "2002::102:304" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward next-hop' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

        log_msg INFO " -> Forward Lsp"

        # Configure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router mpls lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        Dut-$dut2 sendCliCommand "exit all"

        set LspId [Dut-$dut2 getLspIdFromName "LSP test name"]

        set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward lsp \"LSP test name\""]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
        # Verify
        log_msg INFO "=> Verify action forward lsp"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match \"Fwd Lsp\""]
        if { [regexp "LSP test name" $r1] == 0 } { log_msg ERROR "Wrong next hop"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter ip $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString "0" $r]

        log_msg INFO " -> reset 'forward LSP' with 'action forward router $routerInstance'"
        set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
        # Verify
        log_msg INFO "=> Verify action forward router $routerInstance"
        # CLI
        set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
            if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
        } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
        puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
        # SNMP
        set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
        set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]

        # Deconfigure lsp-name
        set r1 [ Dut-$dut2 sendCliCommand "/configure router no mpls"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

        if { [getGlobalVar platform] == "7950" || [Dut-$dut2 isHsa] } {
            set actionListIPv6 "forward http-redirect drop"
        } else {
            set actionListIPv6 "forward nat http-redirect drop"
        }

        foreach action $actionListIPv6 {

            log_msg INFO "Set action to forward router $routerInstance"
            set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
            # Verify
            log_msg INFO "=> Verify action forward router $routerInstance"
            # CLI
            set r1 [ Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id) | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
                if { $name != $routerInstance } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
            } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
            puts [Dut-$dut2 sendCliCommand "/show filter [getVar4 $filterType] $opt(filter_[getVar4 $filterType]_id)"]
            # SNMP
            set r [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id) ]
            set testResultFlag [wccpCompareOutputString $routerInstance_snmp $r]


            log_msg DEBUG "Resetting action to $action"

            if { $action != "http-redirect" } {
                if { $action == "nat" } {
                    cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action nat nat-type nat64"
                } else {
                    cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action $action"
                }
            } else {
                cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) match next-header tcp"
                cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action $action http://1.2.3.4/"
            }
                set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]
        }
    }
  }


    # check for memory leaks
    log_msg INFO "Check for memory leaks"
    set check [filter_subinsert_memLeakChecks $dut2 check]
    if {$check != "PASSED"} {
        log_msg ERROR "Memory leak detected after cleanup, found $check"
        set testResultFlag "FAILED"
    }
    if {[Dut-$dut2 cget -redundantSystem] != "false"} {
        set check_stb [filterScale_memLeakChecks $dut2 check -card [Dut-$dut2 findInactiveCpm] -mPools {"Services" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}]
        if {$check_stb != "OK"} {
            log_msg ERROR "Memory leak detected after cleanup on standby CPM, found $check_stb"
            set testResultFlag "FAILED"
        }
    }

    
    log_msg INFO "--------------------------------------"
    log_msg INFO "5. Verify cleanup of child objects when parent is removed"
    log_msg INFO "--------------------------------------"

    log_msg INFO "Delete the filter via CLI"
    set r1 [ Dut-$dut2 sendCliCommand "/configure filter no [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "Verify cleanup of child objects via SNMP"
    set testResultFlag [wccpCompareOutputString "ERROR" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO "Create filter again"
    cliCne Dut-$dut2 "/environment no create"
    cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) create entry $opt(entry_[getVar4 $filterType]_id) create"
    cliCne Dut-$dut2 "exit all"

    log_msg INFO "Verify, that child objects have default value"
    set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO "Verify, that child objects have default value after changing action to forward"
    cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"
    set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]


    log_msg INFO "--------------------------------------"
    log_msg INFO "6. Verify that referenced VPRN is not possible to delete"
    log_msg INFO "--------------------------------------"

    log_msg INFO "Set action to forward router $opt(vprn_id)"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $opt(vprn_id)"]

    log_msg INFO "Try to delete VPRN: $opt(vprn_id) via CLI (expect fail)"
    set r1 [ cliConfigError Dut-$dut2 "/configure service no vprn $opt(vprn_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "Deletion of VPRN via CLI was successful and it shouldn't be"; set testResultFlag "FAILED" }

    log_msg INFO "Try to delete VPRN: $opt(vprn_id) via SNMP (expect fail)"
    set r [Dut-$dut2 deleteVprn $opt(vprn_id)]
    if {$r1 == "OK"} { log_msg ERROR "Deletion of VPRN via SNMP was successful and it shouldn't be"; set testResultFlag "FAILED" }
    
    log_msg INFO "Delete VPRN's service-name and check the info/info detail output"

    log_msg INFO "=> Verify service-name via info command before delete"
    set r1 [ Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
    set r1 [ Dut-$dut2 sendCliCommand "info | match action"]
#    if { [regexp " action forward router service-name (\"$vprn_name\")" $r1 match name] == 0 } {
#        log_msg ERROR "Wrong router name in info command output"; set testResultFlag "FAILED"
#    }
    if { [regexp " action forward router ($opt(vprn_id))" $r1 match name] == 0 } {
        log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
    }
    puts [Dut-$dut2 sendCliCommand "info"]

    log_msg INFO "Delete VPRN's service-name"
    set r1 [ cliCne Dut-$dut2 "/configure service vprn $opt(vprn_id) no service-name"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO "=> Verify service-name via info command after delete (there should be router-instance in output)"
    set r1 [ Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
    set r1 [ Dut-$dut2 sendCliCommand "info | match action"]
    if { [regexp " action forward router ($opt(vprn_id))" $r1 match name] == 0 } {
        log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
    }
    puts [Dut-$dut2 sendCliCommand "info"]

    set r1 [ Dut-$dut2 sendCliCommand "/configure service vprn $opt(vprn_id) service-name \"$vprn_name\""]
    Dut-$dut2 sendCliCommand "exit all"

    log_msg INFO "=> Configure long service-name"
    set r1 [ Dut-$dut2 sendCliCommand "/configure service vprn $opt(vprn_id) service-name abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\~\!\@\%\^\&\*\(\)" ]; puts $r1

    log_msg INFO "=> Verify service-name via info command"
    set r1 [ Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
    set r1 [ Dut-$dut2 sendCliCommand "info | match action"]
#    if { [regexp " action forward router service-name (\\\"abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\\\~\\\!\\\@\\\%\\\^\\\&\\\*\\\(\\\)\\\")" $r1 match name] == 0 } {
#        log_msg ERROR "Wrong router name in info command output. Expected service name in info output is: abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\~\!\@\%\^\&\*\(\)"; set testResultFlag "FAILED"
#    }
    if { [regexp " action forward router ($opt(vprn_id))" $r1 match name] == 0 } {
        log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
    }

    puts [Dut-$dut2 sendCliCommand "info"]

    set r1 [ Dut-$dut2 sendCliCommand "/configure service vprn $opt(vprn_id) service-name \"$vprn_name\""]
    Dut-$dut2 sendCliCommand "exit all"


    log_msg INFO "Set action to forward"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"]

    log_msg INFO "--------------------------------------"
    log_msg INFO "7. Verify that action can not be set when the filter is blocked due to li-source"
    log_msg INFO "--------------------------------------"

    log_msg INFO "Check if an ip-filter's action can be modified when used as an li-source and the lock state is locked"

    # Among the password criteria we can set now there is one of them preventing to reuse the username in the password, that's why we disable this check
    Dut-$dut2 sendCliCommand "/configure system security password complexity-rules allow-user-name"

    log_msg INFO "Create liadmin and configure li-source"
    liUserSetup Dut-$dut2
    Dut-$dut2 sendCliCommand "/configure mirror mirror-dest 1 create"
    switchUser Dut-$dut2 liadmin liadmin
    Dut-$dut2 sendCliCommand "/configure li li-source 1 [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id)"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 no shutdown"

  foreach {routerInstance} $routerList {
    log_msg INFO " => Trying to change action to forward router - $routerInstance (expect fail)"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    set testResultFlag [wccpCompareOutputString "0" [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterType]_id) $opt(entry_[getVar4 $filterType]_id)]]

    log_msg INFO " => Deconfigure li-source"
    Dut-$dut2 sendCliCommand "/configure li no li-source 1"
    log_msg INFO " => Trying to change action to forward router - $routerInstance (expect pass)"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO " => Configure li-source again"
    Dut-$dut2 sendCliCommand "/configure mirror mirror-dest 1 create"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id)"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 no shutdown"

    log_msg INFO " => Trying to set same action to forward router - $routerInstance (expect pass)"
    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward router $routerInstance"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO " => Trying to change action to forward only (expect fail)"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO " => Trying to change action to drop (expect fail)"
    set r1 [cliConfigError Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action drop"]

    log_msg INFO " => Deconfigure li-source in order to set action to forward"
    Dut-$dut2 sendCliCommand "/configure li no li-source 1"
    Dut-$dut2 sendCliCommand "/configure mirror no mirror-dest 1"

    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO " => Configure li-source again"
    Dut-$dut2 sendCliCommand "/configure mirror mirror-dest 1 create"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id)"
    Dut-$dut2 sendCliCommand "/configure li li-source 1 no shutdown"
  }
    log_msg INFO " => Deconfigure li-source"
    Dut-$dut2 sendCliCommand "/configure li no li-source 1"
    Dut-$dut2 sendCliCommand "/configure mirror no mirror-dest 1"

    set r1 [cliCne Dut-$dut2 "/configure filter [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id) entry $opt(entry_[getVar4 $filterType]_id) action forward"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    switchUser Dut-$dut2 admin admin
    liUserCleanup Dut-$dut2
    
    Dut-$dut2 sendCliCommand "/configure system security password complexity-rules no allow-user-name"

    log_msg INFO "--------------------------------------"
    log_msg INFO "8. Verify creating of filter entry with 'action forward router' using CLI commands with ranges"
    log_msg INFO "--------------------------------------"

    set num_entries 500

  foreach {routerInstance} $routerList {

    if {$routerInstance == "Base"} {
        set routerInstance_snmp 1
    } elseif {$routerInstance == $opt(vprn_id)} {
        set routerInstance_snmp [Dut-$dut2 getVRtrInstanceId $opt(vprn_id)]
    } elseif {$routerInstance == $opt(vprn2_id)} {
        set routerInstance_snmp [Dut-$dut2 getVRtrInstanceId $opt(vprn2_id)]
    } else {
        log_msg ERROR "Wrong router ID"; set testResultFlag "FAILED"
    }

    set r1 [ Dut-$dut2 sendCliCommand "/configure filter no [getVar4 $filterType]-filter $opt(filter_[getVar4 $filterType]_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    log_msg INFO " => Configure filter entries using CLI command with ranges - 'action forward router $routerInstance'"
    cliCne Dut-$dut2 "/environment no create"
    set r1 [Dut-$dut2 sendCliCommand "/configure filter [getVar4 $filterType]-filter \[11..15\] entry \[1001..1100\] action forward router $routerInstance"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
    log_msg INFO "Verify correct number of entries with mib walk - $num_entries"

    wccpMibWalk $dut2 t[getVar3 $filterType]FilterParamsRowStatus $num_entries
    after 2000
    wccpMibWalk $dut2 t[getVar3 $filterType]FilterParamsEntry.52 $num_entries

    log_msg INFO "Verify correct number of entries with getnext"
    wccpMibGetNext $dut2 t[getVar3 $filterType]FilterParamsRowStatus $num_entries

    log_msg INFO "Verify, if each entry has action set to forward router - $routerInstance"
    for {set i 11} {$i <= 15} {incr i} {
        for {set j 1001} {$j <= 1100} {incr j} {
            set testResultFlag [wccpCompareOutputString $routerInstance_snmp [Dut-$dut2 getT[getVar3 $filterType]FilterParamsFwdRtrId $i $j ]]
        }
    }
    
    log_msg INFO " => Deconfigure filter entries using CLI command with ranges"
    set r1 [Dut-$dut2 sendCliCommand "/configure filter no [getVar4 $filterType]-filter \[11..15\]"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }
 

  }

  }

    cliCne Dut-$dut2 "/configure service vprn $opt(vprn_id) shutdown"
    cliCne Dut-$dut2 "/configure service vprn $opt(vprn2_id) shutdown"
    set r1 [ cliCne Dut-$dut2 "/configure service no vprn $opt(vprn_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "Deletion of VPRN $opt(vprn_id) via CLI was not successful"; set testResultFlag "FAILED" }
    set r1 [ cliCne Dut-$dut2 "/configure service no vprn $opt(vprn2_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "Deletion of VPRN $opt(vprn2_id) via CLI was not successful"; set testResultFlag "FAILED" }


    set r1 [ Dut-$dut2 sendCliCommand "/configure filter no ip-filter $opt(filter_ip_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    set r1 [ Dut-$dut2 sendCliCommand "/configure filter no ipv6-filter $opt(filter_ipv6_id)"]
    if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set testResultFlag "FAILED" }

    if { ($testResultFlag == "PASSED") && ($setupErrorFlag == "NOERROR") } {
        log_result PASSED "Test Case $testId PASSED"
    } else {
        log_result FAILED "Test Case $testId FAILED"
    }

}

proc filterActionFwdRtrBasicTrafficTest { args } {

    global testdir logdir ixia_port
    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl


    set opt(debug)      true
    set opt(debugPrint) false
    set opt(mode)       regular
    set opt(snmp)       true
    set opt(setupType)  ""
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(issu)       "false"
    set opt(iteration)  1
    set opt(systemFilter) "false"
    getopt opt $args

    set testID $::TestDB::currentTestCase
    set result PASSED
    set dut3 C

    # start memory leak checks
    set CliTim [ Dut-$dut3 cget -cli_timeout ]
    set Tim [ Dut-$dut3 cget -timeout ]
    Dut-$dut3 configure -cli_timeout 200
    Dut-$dut3 configure -timeout 200
#    fullDebug -action init -dut Dut-$dut3 -minLeak 2

    if {$opt(mode) == "regular"} {
        filterScale_memLeakChecks $dut3 start -card [Dut-$dut3 findActiveCpm] -mPools {"Services" "FltrLOG" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}

        if {[Dut-$dut3 cget -redundantSystem] != "false"} {
            # start memory leak checks on standby CPM
            filterScale_memLeakChecks $dut3 start -card [Dut-$dut3 findInactiveCpm] -mPools {"Services" "FltrLOG" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}
        }
    }

    handlePacket -action reset -portList all

for { set it 0 } { $it < $opt(iteration) } { incr it } {
#    if {$opt(issu) == "true"} {
    # save initial configuration
#    saveOrRestore save -name deleteConfig -replaceDeleteWith true
#    log_msg INFO "Save the first rollback restore point - initial config"
    # save the first rollback restore point
#      log_msg INFO "Creating rollback restore point-1"
#      set username $::TestDB::thisTestBed ; set hostIp $::TestDB::thisHostIpAddr
#      set logDir "ftp://${username}:tigris@${hostIp}/$logdir/device_logs"
#      set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
#      Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
#      Dut-$dut3 sendCliCommand "exit all"
#      Dut-$dut3 sendCliCommand "shell rollbackBlackListDisable"
#      Dut-$dut3 sendCliCommand "configure system rollback rollback-location $logDir/wccpInitRollback"
#      Dut-$dut3 sendCliCommand "admin rollback save"
#      after 10000
#      log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
#      log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
#      set rollbackSaveResult [filter_getRollbackResult $dut3 save]
#      if {$rollbackSaveResult != "Successful"} {
#          log_msg ERROR "error with creating rollback restore point-1 - $rollbackSaveResult" ; set result "FAILED"
#      }
#      Dut-$dut3 configure -cli_timeout $extCliTim ; Dut-$dut3 configure -timeout $extTim
#    }
    # randomly choose setupType
    if {$opt(setupType) == ""} {
        if { $opt(svcType) == "vprn" } {
            set setupType [fwdRtrVrfToVrf_getSetupType $opt(filterType)]
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "L2 service is used for filter testing - verify, that traffic will be just forwarded and PBR is not taken into account"
            set setupType [fwdRtrL2Service_getSetupType $opt(filterType)]
        } elseif { $opt(svcType) == "rvpls" } {
            log_msg INFO "Routed VPLS is used for filter testing - verify, that PBR is taken into account"
            set setupType [fwdRtrRVPLS_getSetupType $opt(filterType)]
        } else {
            set setupType [fwdRtrGrtToVrf_getSetupType $opt(filterType)]
        }
    } else {
        set setupType $opt(setupType)
        log_msg NOTICE "User defined setupType: $setupType"
    }
    if {[filterTCAM_getGlobals $setupType] != "OK"} {
        log_msg ERROR "Unable to find correct parameters for $setupType"
        set result FAILED
    }
    # configuration
    if {($filterType == "IPv6") && ($itfBind == "subsap")} {
        set r [filter_radOverride_runTest $filterType -select [string trimleft $setupType IPv6_ ] -hostType dhcp6_IANA -cleanup false -dual false]
    } else {
        filterTCAM_config $setupType
    }
    filterTCAM_ixInit $setupType

    ### find out, if card is IOM3 and higher or not (in case of older IOMs, PBR is not taken into account)
    if { $itfType == "lag" } {
        set iom3 ""
        foreach {port} $port_3_2 {
            if {[Dut-$dut3 isIom3Equipped [lindex [split $port "/"] 0]] != "TRUE"} {
                if {$iom3 == "true"} {set iom3 "none"} else {set iom3 "false"}
            } else {
                if {$iom3 == "false"} {set iom3 "none"} else {set iom3 "true"}
            }
        }
        log_msg NOTICE "iom3 $iom3"
        if {$iom3 == "none"} { log_msg ERROR "testing on lag with mixture of iom3 and non-iom3 ports, results for action forward router tests could be unpredictable" }
    } else {
        set iom3 [ string tolower [Dut-$dut3 isIom3Equipped [lindex [split $port_3_2 "/"] 0]]]
        if { $iom3 == "false" } {
            log_msg INFO "Used line card is NOT IOM3 and higher - verify, that traffic will be just forwarded and PBR is not taken into account"
        }
    }
    # configure ixia streams, first without IP options
    # redirectToVRF action will not work for pkts with options because they are sent from CPM - PBR should be ignored than
    # streams 2-5 with ip-options will be just forwarded (not redirected)
    set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions false]
    set streamIdList ""
    for {set i 1} {$i <= $numStreams} {incr i} { lappend streamIdList $i }
    filterTCAM_ixTestTraffic $streamIdList

    log_msg INFO ""
    log_msg INFO "=> Setup vprns to be used in filter action redirectToVFR"
    set vprnId1 10
    set vprnId2 2147483647
    set vprnId3 5000
    set vprnId4 123456
    set serviceName1 "testvprn $vprnId1"
    set serviceName2 "abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\~\!\@\%\^\&\*\(\)"
    set serviceName3 "testvprn $vprnId3"
    set serviceName4 "testvprn $vprnId4"
    set customer 0
    set i 1

    foreach {vprnId} "$vprnId1 $vprnId2 $vprnId3 $vprnId4" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service customer $i create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    configure service vprn $vprnId customer [expr $customer + $i] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        route-distinguisher 10.20.1.3:[expr $i + 1]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        service-name \"[ set serviceName$i]\""]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface vprn${vprnId}ToIxia3 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.0.1/24"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.0.1]/[maskConvert Ipv6 24]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:[expr $i + 1] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    ### in case svcType is vprn, modify action in entry 40 to forward router Base - in such case, we need to create ies service with sap to IXIA port
    if { $opt(svcType) == "vprn" } {
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId4 interface vprn${vprnId4}ToIxia3 sap ${port_3_3}:5 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId4}ToIxia3 no sap ${port_3_3}:5"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service ies 300 customer 1 vpn 1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia300 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.3.1/14"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:03"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.3.1]/[maskConvert Ipv6 14]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:5 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    }

    # create filter logs
    set r1 [Dut-$dut3 setTFilterLogRowStatus 110 createAndGo ]
    set r2 [Dut-$dut3 setTFilterLogRowStatus 120 createAndGo ]
    set r3 [Dut-$dut3 setTFilterLogRowStatus 130 createAndGo ]
    set r4 [Dut-$dut3 setTFilterLogRowStatus 140 createAndGo ]
    set r5 [Dut-$dut3 setTFilterLogRowStatus 150 createAndGo ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "failed to create filterlogs in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
    }

    ### PART 1 : test FwdRtr action on INGRESS
    print_console_msg "STEP 1"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 1: check FwdRtr action on ingress $svcType $itfBind"
    log_msg INFO "----------------------------------------------------"
    # configure IP filter to forward matching traffic in testDut dut3
    if {$opt(systemFilter)} {
        set r1 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 800]
        log_msg DEBUG "Configure and activate $filterType system filter 8"
        set r3 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 8 ]
        set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterScope 8 "system"]
        set r5 [Dut-$dut3 setTFilterSystemFilterRowStatus fltrtypesel[getVar1 $filterType] 8 createAndGo]
        set r6 [Dut-$dut3 setT[getVar3 $filterType]FilterChainToSystemFilter 800 true]
        if {($r1 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError") || ($r6 != "noError")} {
            log_msg ERROR "failed to create $filterType chaining filter 800 or system filter 8 in Dut-$dut3, found $r1, $r3, $r4, $r5, $r6"
            set result FAILED
        }
    } else {
        set r1 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 8]
    }
    # apply filter to ingress interface under test
    set direction "Ingress Egress"
    if {$opt(systemFilter)} { set filterID  800 } else { set filterID  8 }
    foreach direct $direction {
        switch $itfBind {
            "sap" {
                set r2 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
            }
            "subsap" {
                set r2 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
                if {$filterType == "IPv6"} {
                    # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla1 now ...
                    filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla1 -hostType dhcp6_IANA
                }
            }
            "spoke" - "mesh" {
                set r2 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
            }
            "net" {
                set r2 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
            }
            default {
                # destination type inconsistency
                log_msg ERROR "itfBind type $itfBind not yet supported"
                set r2 ERROR
            }
        }
    }
    if {($r1 != "noError") || ($r2 != "noError")} {
        log_msg ERROR "failed to create $filterType filter $filterID and assign to $direction $itfBind in Dut-$dut3, found $r1, $r2"
        set result FAILED
    }

    set vprnNameOrId [ expr round( rand() ) ]
    if { $vprnNameOrId == 1 } {set vprnNameOrId "router service-name"; set vprn1 $serviceName1; set vprn2 $serviceName2; set vprn3 $serviceName3; set vprn4 $serviceName4} else {set vprnNameOrId "router"; set vprn1 $vprnId1; set vprn2 $vprnId2; set vprn3 $vprnId3; set vprn4 $vprnId4}

    if {$filterType == "IP"} {set matchProtocol "protocol"} else {set matchProtocol "next-header"}
    if {$filterType == "IP"} { set fltrMask 16 } else { set fltrMask [maskConvert $family 16] }
    set fltrSrcAddr [ipv62MibVal [ipConvert $family 3.3.0.0]]
    set fltrDstAddr [ipv62MibVal [ipConvert $family 1.1.0.0]]
    set fltrSrcAddrCLI [ipConvert $family 3.3.0.0]
    set fltrDstAddrCLI [ipConvert $family 1.1.0.0]

    set testList ""
    set testList2 ""
    if { $filterType == "IP" } {
        set stream_egr "1 2 3 4"
        lappend testList 1 "match $matchProtocol tcp tcp syn true"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
        lappend testList 2 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
        lappend testList 3 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
        if { $opt(svcType) == "vprn" } {
            lappend testList 4 "match $matchProtocol icmp"              40 "action forward router Base" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
        } else {
            lappend testList 4 "match $matchProtocol icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150 
        }
    } else {
        set stream_egr "1 2 4 5"
        lappend testList 7 "match $matchProtocol sctp"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
        lappend testList 4 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
        lappend testList 5 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
        if { $opt(svcType) == "vprn" } {
            lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward router Base" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
        } else {
            lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
        }
        # create stream [expr $numStreams + 1] - IPv6 packet with next-header sctp
        if {[getGlobalVar physTopology] == "scaleBed"} { set ing_port 5; set eg_port 1 } else { set ing_port 1; set eg_port 3 }
        set portList [list $ixport1 ]
        scan $ixport1 "%d %d %d" chassis card port
        port get $chassis $card $port
        stream get $chassis $card $port 1
        set da_mac [join [split [stream cget -da] " "] ":"]
        handlePacket -port $ing_port -dot1q 1 -dst 3FFE::303:2:0:0:0:0 -numDest 1 -src 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -stream [expr $numStreams + 1] -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        after 1000
        stream get $chassis $card $port [expr $numStreams + 1]
        stream config  -enable  false
        stream set $chassis $card $port [expr $numStreams + 1]
        stream write $chassis $card $port [expr $numStreams + 1]

        set portList [list $ixport3 ]
        scan $ixport3 "%d %d %d" chassis card port
        port get $chassis $card $port
        stream get $chassis $card $port 1
        set da_mac [join [split [stream cget -da] " "] ":"]
        handlePacket -port $eg_port -dot1q 1 -src 3FFE::303:2:0:0:0:0 -numDest 1 -dst 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -stream [expr $numStreams + 1] -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        after 1000
        stream get $chassis $card $port [expr $numStreams + 1]
        stream config  -enable  false
        stream set $chassis $card $port [expr $numStreams + 1]
        stream write $chassis $card $port [expr $numStreams + 1]
    }

    # create entries and set action forward router
    set configType [ expr round( rand() ) ]
    if {$opt(systemFilter)} {set configType 1}
    # if $configType=0, configuration will be performed via CLI, otherwise via SNMP
    if { $configType == 1 } {
        if {$filterType == "IP"} {set matchProtocolSNMP "-Protocol"} else {set matchProtocolSNMP "-NextHeader"}
        if {$filterType == "IP"} {
            set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 10 $matchProtocolSNMP 6 -TcpSyn true -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId1] ]
            set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId2] ]
            set r3 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 30 $matchProtocolSNMP 17 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId3] ]
            if { $opt(svcType) == "vprn" } {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 1 -Action forward -FwdRtrId 1 ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId 1] ]
            } else {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 1 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId4] ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId 1 ]
            }
            set r6 "noError"; set r7 "noError"; set r8 "noError"; set r9 "noError"; set r10 "noError"
            if {$opt(systemFilter)} {
                set r6 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 10 $matchProtocolSNMP 6 -TcpSyn true -Action forward ]
                set r7 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward ]
                set r8 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 30 $matchProtocolSNMP 17 -Action forward ]
                if { $opt(svcType) == "vprn" } {
                    set r9 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 40 $matchProtocolSNMP 1 -Action forward ]
                    set r10 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward ]
                } else {
                    set r9 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 40 $matchProtocolSNMP 1 -Action forward ]
                    set r10 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward ]
                }
            }
        } else {
            set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 10 $matchProtocolSNMP 132 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId1] ]
            set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId2] ]
            set r3 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 30 $matchProtocolSNMP 17 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId3] ]
            if { $opt(svcType) == "vprn" } {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 58 -Action forward -FwdRtrId 1 ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId 1] ]
            } else {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 58 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId4] ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId 1 ]
            }
            set r6 "noError"; set r7 "noError"; set r8 "noError"; set r9 "noError"; set r10 "noError"
            if {$opt(systemFilter)} {
                set r6 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 10 $matchProtocolSNMP 132 -Action forward ]
                set r7 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward ]
                set r8 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 30 $matchProtocolSNMP 17 -Action forward ]
                if { $opt(svcType) == "vprn" } {
                    set r9 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 40 $matchProtocolSNMP 58 -Action forward ]
                    set r10 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward ]
                } else {
                    set r9 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 40 $matchProtocolSNMP 58 -Action forward ]
                    set r10 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 800 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward ]
                }
            }
        }
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError") || ($r6 != "noError") || ($r7 != "noError") || ($r8 != "noError") || ($r9 != "noError") || ($r10 != "noError")} {
            log_msg ERROR "failed to create $filterType filter entries with different actions in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5, $r6, $r7, $r8, $r9, $r10"
            set result FAILED
        }
    } else {
        Dut-C sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList2 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
    }
    ### add second match criterium for entry 1 - in order to eliminate hits by control traffic
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 create"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"
    if {$opt(systemFilter)} {
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 800 entry 1 create"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"
        set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 800 10 110 ]
        set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 800 20 120 ]
        set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 800 30 130 ]
        set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 800 40 140 ]
        set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 800 1 150 ]
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
            log_msg ERROR "failed to assign filterlogs to $filterType chaining filter 800 entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
            set result FAILED
         }
    }
    # add filter logs to the different entries
    set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 10 110 ]
    set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 20 120 ]
    set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 30 130 ]
    set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 40 140 ]
    set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 1 150 ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "failed to assign filterlogs to $filterType filter entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
     }

    # bind same filter on egress of each configured VPRN - in order to verify hit counters
    log_msg INFO "Bind same filter on ingress of each configured VPRN in order to verify hit counters"
    for {set i 1} {$i <= 4} {incr i} {
        if { ($opt(svcType) == "vprn") && ($i == 4) } {
#            set r1 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            set r2 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
        } else {
#            set r1 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            set r2 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
        }
        if {($r2 != "noError")} {
            log_msg ERROR "Failed to assign filter: $filterID to ingress of VPRN: [set vprnId${i}] ,found $r2"
            set result FAILED
         }
    }


    # check the redirected traffic
    ### configure additional match criteria for entry 40 - in order to block unwanted hits of ICMP packets
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 40"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "match src-ip $fltrDstAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"

    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
    } elseif { $opt(svcType) == "L2Service" } {
        log_msg INFO "Check that traffic is forwarded and not redirected"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
    }
    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
    } else {
        if {$opt(systemFilter)} {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
        }
    }
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

    print_console_msg "STEP 2"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 2: check router id in info after delete service-name and verify traffic"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "=> Verify service-name via info command before delete"

    set testList3 ""
    lappend testList3 10 $vprnId1 $serviceName1
    lappend testList3 20 $vprnId2 $serviceName2
    lappend testList3 30 $vprnId3 $serviceName3
    if { $opt(svcType) != "vprn" } {
        lappend testList3 40 $vprnId4 $serviceName4
    }
    foreach { entryId vprnId serviceName } $testList3 {
        set r1 [ Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry $entryId"]
        set r1 [ Dut-$dut3 sendCliCommand "info | match action"]; log_msg INFO $r1
#        if { $vprnId == $vprnId2 } {
#            if { [regexp " action forward router service-name (\\\"abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\\\~\\\!\\\@\\\%\\\^\\\&\\\*\\\(\\\)\\\")" $r1 match name] == 0 } {
#                log_msg ERROR "Wrong router name in info command output"; set result FAILED
#            }
#        } else {
#            if { [regexp " action forward router service-name (\"$serviceName\")" $r1 match name] == 0 } {
#                log_msg ERROR "Wrong router name in info command output"; set result FAILED
#            }
#        }
        if { [regexp " action forward router ($vprnId)" $r1 match name] == 0 } {
            log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
        }
        set r1 [ Dut-$dut3 sendCliCommand "exit all"]

        log_msg INFO "=> Delete the service name: $serviceName for VPRN: $vprnId"
        set r1 [ cliCne Dut-$dut3 "/configure service vprn $vprnId no service-name"]
        if {$r1 == "ERROR"} { log_msg ERROR "CLI command was not successful"; set result FAILED }
        log_msg INFO "=> Verify service-name via info command after delete (there should be router-instance in output: $vprnId)"
        set r1 [ Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry $entryId"]
        set r1 [ Dut-$dut3 sendCliCommand "info | match action"]; log_msg INFO $r1
        if { [regexp " action forward router ($vprnId)" $r1 match name] == 0 } {
            log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
        }
        set r1 [ Dut-$dut3 sendCliCommand "exit all"]
    }
    ### test traffic
    log_msg INFO "Test traffic"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
    }
    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        log_msg INFO "Skip this step - no redirection in case of non-routed traffic"
        set r "PASSED"
    } else {
        if {$opt(systemFilter)} {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
        }
    }
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }
    ### configure service-name for VPRNs again
    foreach { entryId vprnId serviceName } $testList3 {
        log_msg INFO "=> Create the service name again: $serviceName for VPRN: $vprnId"
        set r1 [ cliCne Dut-$dut3 "/configure service vprn $vprnId service-name \\\"[ set serviceName]\\\""]
        log_msg INFO "=> Verify service-name via info command"
        set r1 [ Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry $entryId"]
        set r1 [ Dut-$dut3 sendCliCommand "info | match action"]; log_msg INFO $r1
#        if { $vprnId == $vprnId2 } {
#            if { [regexp " action forward router service-name (\\\"abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\\\~\\\!\\\@\\\%\\\^\\\&\\\*\\\(\\\)\\\")" $r1 match name] == 0 } {
#                log_msg ERROR "Wrong router name in info command output"; set result FAILED
#            }            
#        } else {
#            if { [regexp " action forward router service-name (\"$serviceName\")" $r1 match name] == 0 } {
#                log_msg ERROR "Wrong router name in info command output"; set result FAILED
#            }
#        }
        if { [regexp " action forward router ($vprnId)" $r1 match name] == 0 } {
            log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
        }
        set r1 [ Dut-$dut3 sendCliCommand "exit all"]
    }

    print_console_msg "STEP 3"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 3: shut/no shut target VPRN and verify traffic"
    log_msg INFO "----------------------------------------------------"
    foreach { entryId vprnId serviceName } $testList3 {
        log_msg INFO "=> Shutdown and no shutdown again VPRN: $vprnId"
        set r1 [ cliCne Dut-$dut3 "/configure service vprn $vprnId shutdown"]
        after 1000
        set r1 [ cliCne Dut-$dut3 "/configure service vprn $vprnId no shutdown"]
    }    
    ### test traffic
    log_msg INFO "Test traffic"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
    }
    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        log_msg INFO "Skip this step - no redirection in case of non-routed traffic"
        set r "PASSED"
    } else {
        if {$opt(systemFilter)} {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
        }
    }
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

    print_console_msg "STEP 4"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 4: check redirect action behaves as regular forward action for packets with ip-options"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Test traffic"
    log_msg INFO "Check traffic for each entry and streams with ip-options: Direction from Dut-$dut1 to Dut-$dut3 - no redirect"
    
    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        log_msg INFO "Skip this step - there is no point to test this in case of non-routed traffic"
    } else {
        if { $filterType == "IP" } {
            set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions true]
            if {$opt(systemFilter)} {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions true -chainedFilterId 800]
            } else {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions true]
            }
            if {$r != "PASSED"} {
                if {$opt(debugPrint) == "true"} {
                    filterTCAM_debug $setupType
                    set opt(debugPrint) false
                }
                set result FAILED
            }
            set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions false]
        } else {
            set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions true]
            ### in case IPv6 - start stream 3 - Hop-by-hop option header
            set testList4 ""
            set testList5 ""
            lappend testList4 3 "match $matchProtocol tcp tcp syn true" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList5 3 "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
            cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 8 entry 20 match $matchProtocol tcp tcp-syn true"
            if {$opt(systemFilter)} {
                cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 800 entry 20 match $matchProtocol tcp tcp-syn true"
            }
            cliCne Dut-$dut3 "exit all"
            ### test traffic
            if {$opt(systemFilter)} {
                set r [fwdRtr_checkTraffic $setupType $testList4 $testList5 -withOptions true -chainedFilterId 800]
            } else {
                set r [fwdRtr_checkTraffic $setupType $testList4 $testList5 -withOptions true]
            }
            if {$r != "PASSED"} {
                if {$opt(debugPrint) == "true"} {
                    filterTCAM_debug $setupType
                    set opt(debugPrint) false
                }
                set result FAILED
            }
            set testList4 ""
            set testList5 ""
            lappend testList4 3 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList5 3 "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
            cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 8 entry 20 match $matchProtocol tcp tcp-syn false"
            if {$opt(systemFilter)} {
                cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 800 entry 20 match $matchProtocol tcp tcp-syn false"
            }
            cliCne Dut-$dut3 "exit all"
            set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions false]
        }
    }

    print_console_msg "STEP 5"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 5: Verify that multicast traffic is not subject to PBR action"
    log_msg INFO "----------------------------------------------------"
if {$opt(systemFilter) == "false"} {
    set dst_ip [ipConvert $family 224.0.0.[random 255]]
    set src_ip_ing [ipConvert $family 1.1.0.2]
    set src_ip_egr [ipConvert $family 3.3.0.2]

    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        log_msg INFO "Skip this step - there is no point to test this in case of non-routed traffic"
    } else {
        ### multicast is non routed - packets reached $dut3 only when svcType is IES ???
        if { $svcType == "ies" } {
            log_msg INFO "=> create stream with multicast IP and verify that traffic is not redirected"

            ### ingress stream
            set portList [list $ixport1 ]
            scan $ixport1 "%d %d %d" chassis card port
            port get $chassis $card $port
            stream get $chassis $card $port 1
            set da_mac [join [split [stream cget -da] " "] ":"]

            ### add second match criterium for entry 1 - in order to eliminate hits by control traffic - change dst-ip to multicast
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 create"
            Dut-$dut3 sendCliCommand "match dst-ip $dst_ip/$fltrMask"
            Dut-$dut3 sendCliCommand "exit all"

            if { $filterType == "IP" } { set str_id [expr $numStreams + 1] } else { set str_id [expr $numStreams + 2] }
            if {[getGlobalVar physTopology] == "scaleBed"} { set ing_port 5; set eg_port 1 } else { set ing_port 1; set eg_port 3 } 

            handlePacket -port $ing_port -dot1q 1 -dst $dst_ip -numDest 1 -src $src_ip_ing -numSource 1 -damac $da_mac -stream $str_id -framesize 900 -rawProtocol 17 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
            after 2000
            stream get $chassis $card $port $str_id
            stream config  -enable  false
            stream set $chassis $card $port $str_id
            stream write $chassis $card $port $str_id

            ### egress stream
            set portList [list $ixport3 ]
            scan $ixport3 "%d %d %d" chassis card port
            port get $chassis $card $port
            stream get $chassis $card $port 1
            set da_mac [join [split [stream cget -da] " "] ":"]

            handlePacket -port $eg_port -dot1q 5 -dst $dst_ip -numDest 1 -src $src_ip_egr -numSource 1 -damac $da_mac -stream $str_id -framesize 900 -rawProtocol 17 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
            after 2000
            stream get $chassis $card $port $str_id
            stream config  -enable  false
            stream set $chassis $card $port $str_id
            stream write $chassis $card $port $str_id
        
            set testList6 ""
            set testList7 ""
            lappend testList6 $str_id "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
            lappend testList7 $str_id "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
            ### test traffic
            set r [fwdRtr_checkTraffic $setupType $testList6 $testList7 -withOptions true]
            if {$r != "PASSED"} {
                if {$opt(debugPrint) == "true"} {
                    filterTCAM_debug $setupType
                    set opt(debugPrint) false
                }
                set result FAILED
            }
        ### change dst-ip back to unicast
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 create"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"
        }
    }
  
#    log_msg INFO "=> create stream with control traffic and verify that traffic is not redirected"

#    if { $filterType == "IP" } {
#        if { $svcType == "ies" } {
#            set str_id 10
#        } else {
#            set str_id 9
#        }
#    } else {
#        if { $svcType == "ies" } {
#            set str_id 9
#        } else {
#            set str_id 8 
#        }
#    }
    ### ingress stream
#    set portList [list $ixport1 ]
#    scan $ixport1 "%d %d %d" chassis card port
#    port get $chassis $card $port
#    stream get $chassis $card $port 1
#    set da_mac [join [split [stream cget -da] " "] ":"]

#    handlePacket -port 1 -dot1q 1 -dst $src_ip_egr -numDest 1 -src $src_ip_ing -numSource 1 -damac $da_mac -stream $str_id -framesize 600 -rawProtocol 89 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
#    after 2000
#    stream get $chassis $card $port $str_id
#    stream config  -enable  false
#    stream set $chassis $card $port $str_id
#    stream write $chassis $card $port $str_id
#    
#    ### egress stream
#    set portList [list $ixport3 ]
#    scan $ixport3 "%d %d %d" chassis card port
#    port get $chassis $card $port
#    stream get $chassis $card $port 1
#    set da_mac [join [split [stream cget -da] " "] ":"]

#    handlePacket -port 3 -dot1q 5 -dst $src_ip_ing -numDest 1 -src $src_ip_egr -numSource 1 -damac $da_mac -stream $str_id -framesize 600 -rawProtocol 89 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
#    after 2000
#    stream get $chassis $card $port $str_id
#    stream config  -enable  false
#    stream set $chassis $card $port $str_id
#    stream write $chassis $card $port $str_id

#    set testList6 ""
#    set testList7 ""
#    lappend testList6 $str_id "match $matchProtocol ospf-igp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
#    lappend testList7 $str_id "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
#    foreach {strId strMatch entryId strAction logId} $testList6 {
#        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
#        Dut-$dut3 sendCliCommand $strMatch
#        Dut-$dut3 sendCliCommand "exit all"
#    }
    ### test traffic
#    set r [fwdRtr_checkTraffic $setupType $testList6 $testList7 -withOptions true]
#    if {$r != "PASSED"} {
#        if {$opt(debugPrint) == "true"} {
#            filterTCAM_debug $setupType
#            set opt(debugPrint) false
#        }
#        set result FAILED
#    }

    print_console_msg "STEP 6"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 6: Verify that PBR is not taken into account on egress"
    log_msg INFO "----------------------------------------------------"

    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        log_msg INFO "Skip this step - there is no point to test this in case of non-routed traffic"
    } else {
        ### deactivate entry 1, because all packets will be hitting this entry - unwanted
        log_msg INFO "Deactivate entry 1, because all packets will be hitting this entry - this is unwanted"
        cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 8 entry 1 no action"
        ### configure additional match criteria for entry 40 - in order to block unwanted hits of ICMP packets
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 40 create"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "match src-ip $fltrSrcAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"
       
        ### test traffic
        log_msg INFO "Test traffic"
        log_msg INFO "Verify that traffic hitting the egress filter with PBR is forwarded using standard routing path and not redirected"
        set r [fwdRtr_checkTraffic_egress $setupType $testList -withOptions false]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        ### activate entry 1 back again
        log_msg INFO "Activate entry 1 back again"
        if { $opt(svcType) == "vprn" } {
            cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 8 entry 1 action forward router 1"
        } else {
            cliCne Dut-$dut3 "configure filter [getVar4 $filterType]-filter 8 entry 1 action forward router Base"
        }
        ### unconfigure additional match criteria for entry 40
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 40"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "match no src-ip"
        Dut-$dut3 sendCliCommand "exit all"
    }

    print_console_msg "STEP 7"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 7: Verify that an entry in the filter with \"action forward router\" can be used as mirror source"
    log_msg INFO "----------------------------------------------------"

    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        log_msg INFO "Skip this step - there is no point to test this in case of non-routed traffic"
    } else {
        if {([getGlobalVar physTopology] == "scaleBed") && (([getGlobalVar subTopology] == "default") || ([getGlobalVar subTopology] == "newZealandLavaIom"))} { 
            set mirrorPort "8/2/2" 
        } elseif  {([getGlobalVar physTopology] == "scaleBed") && (([getGlobalVar subTopology] == "lavaIom") || ([getGlobalVar subTopology] == "lavaMagmaIom") || ([getGlobalVar subTopology] == "lavaPlasmaIom")) } {
            set mirrorPort "8/1/5"
        } else {
            set mirrorPort $topoMap(Dut-C,1/1/4) 
        }
        # configure mirror source and destination
        log_msg INFO "Configure mirror-dest (Ixia port 2) and mirror-source (filter entries with action forward router)"
        cliCne Dut-$dut3 "/configure port $mirrorPort ethernet mode hybrid"
        cliCne Dut-$dut3 "/configure port $mirrorPort ethernet encap-type dot1q"    
        cliCne Dut-$dut3 "/configure port $mirrorPort no shutdown"
        cliCne Dut-$dut3 "/configure mirror mirror-dest 200 create"
        cliCne Dut-$dut3 "  sap ${mirrorPort}:1 create"
        cliCne Dut-$dut3 "  exit"
        cliCne Dut-$dut3 "no shutdown"
        cliCne Dut-$dut3 "exit all"

        cliCne Dut-$dut3 "debug mirror-source 200"
        cliCne Dut-$dut3 "        [getVar4 $filterType]-filter 8 entry 10"
        cliCne Dut-$dut3 "        [getVar4 $filterType]-filter 8 entry 20"
        cliCne Dut-$dut3 "        [getVar4 $filterType]-filter 8 entry 30"
        cliCne Dut-$dut3 "        [getVar4 $filterType]-filter 8 entry 40"
        cliCne Dut-$dut3 "        no shutdown"
        cliCne Dut-$dut3 "        exit"

        # check the redirected traffic
        log_msg INFO "Check redirected traffic for each entry and streams and verify that all traffic is mirrored"
        set r [fwdRtr_checkTraffic_mirror $setupType $testList -withOptions false]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        # deconfigure mirror source and destination
        cliCne Dut-$dut3 "debug no mirror-source 200"
        cliCne Dut-$dut3 "/configure mirror mirror-dest 200 shutdown"
        cliCne Dut-$dut3 "/configure mirror no mirror-dest 200"
        cliCne Dut-$dut3 "/configure port $mirrorPort shutdown"
        cliCne Dut-$dut3 "/configure port $mirrorPort ethernet no mode"
    }
}
    if { $opt(mode) == "extensive" } {
        print_console_msg "STEP 8"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP 8: Remove and insert mda(s)"
        log_msg INFO "----------------------------------------------------"
        set port $port_3_2
        set slot [lindex [ split $port "/" ] 0]
        set mda  [lindex [ split $port "/" ] 1]
        log_msg INFO "=> Remove and insert mda ${slot}/${mda}"
        Dut-$dut3 sendCliCommand "shell cardcmd $slot remove_mda n:$mda"
        after 5000
        Dut-$dut3 sendCliCommand "shell cardcmd $slot insert_mda n:$mda"
        after 15000
        # wait for sdps to converge before continuing
        foreach { dut remoteIp sdpId } $sdpList {
            set r [check_converge $dut $sdpId ]
            set r [Dut-$dut getSdpOperStatus $sdpId]
            if { ($r != "up") } {
                log_msg DEBUG "converge for Dut-$dut sdp $sdpId not ok - $r"
                if {$opt(debug) != "false"} { return $result    }
            }
        }
        Dut-$dut3 CnWMdaStatus
        ### verify traffic
        log_msg INFO "Test traffic"
        log_msg INFO "Check redirected traffic for each entry and streams after removal and insertion of mda(s)"
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
        } else {
            if {$opt(systemFilter)} {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
            } else {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
            }
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        
        print_console_msg "STEP 9"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP 9: Clear IOM card(s)"
        log_msg INFO "----------------------------------------------------"
        set port $port_3_2
        set card [lindex [ split $port "/" ] 0]
        log_msg INFO "Clear IOM card $card"
        catch {Dut-$dut3 getTmnxCardEquippedType 1 $card} card_type
        Dut-$dut3 sendCliCommand "exit all"
        Dut-$dut3 sendCliCommand "clear card $card"
        after 15000
        set i 1
        set card_reboot "Fail"
        while {$i < 20} {
            catch {Dut-$dut3 getTmnxCardEquippedType 1 $card} card_type_new
            if {$card_type == $card_type_new} {
                set card_reboot "Ok"
                break
            }
            incr i
            after 5000
        }
        log_msg DEBUG "Card reboot returned $card_reboot"
        Dut-$dut3 CnWCardStatus
        after 20000
        # wait for sdps to converge before continuing
        foreach { dut remoteIp sdpId } $sdpList {
            set r [check_converge $dut $sdpId ]
            set r [Dut-$dut getSdpOperStatus $sdpId]
            if { ($r != "up") } {
                log_msg DEBUG "converge for Dut-$dut sdp $sdpId not ok - $r"
            }
        }
        ### verify traffic
        log_msg INFO "Test traffic"
        log_msg INFO "Check redirected traffic for each entry and streams after IOM restart"
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
        } else {
            if {$opt(systemFilter)} {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
            } else {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
            }
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP 10"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP 10: Double CPM SWO"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "Perform CPM SWO"
        Dut-$dut3 activitySwitch
        ### verify traffic
        log_msg INFO "Test traffic"
        log_msg INFO "Check redirected traffic for each entry and streams after CPM SWO"
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
        } else {
            if {$opt(systemFilter)} {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
            } else {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
            }
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        log_msg INFO "Perform second CPM SWO"
        Dut-$dut3 activitySwitch
        ### verify traffic
        log_msg INFO "Test traffic"
        log_msg INFO "Check redirected traffic for each entry and streams after second CPM SWO"
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
        } else {
            if {$opt(systemFilter)} {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
            } else {
                set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
            }
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP 11"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP 11: Admin save/exec of saved config file"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "Save the config - admin save"
        ### randomly choose admin save or admin save detail
        if {[random 2] == "1"} {
            set detail "detail"
            set fileName "actionFwdRtr_Dut${dut3}_detail.cfg"
        } else  {
            set detail ""
            set fileName "actionFwdRtr_Dut${dut3}.cfg"
        }
        set username $::TestDB::thisTestBed
        set hostIp $::TestDB::thisHostIpAddr
        set dir "ftp://${username}:tigris@${hostIp}/$logdir/device_logs"
#        set CliTim [ Dut-$dut3 cget -cli_timeout ]
#        set Tim [ Dut-$dut3 cget -timeout ]
#        Dut-$dut3 configure -cli_timeout 200
#        Dut-$dut3 configure -timeout 25

        Dut-$dut3 sendCliCommand "exit all"
        Dut-$dut3 getSysName
        log_msg INFO "=> Saving config file $fileName"
        set CLI [ cookCliData [ Dut-$dut3 sendCliCommand "admin save $detail $dir/$fileName" ]]
        set SC [ string first "Completed" $CLI ]
        if { $SC < 1 } {
            log_msg DEBUG "$CLI"
            log_msg ERROR "Save of $fileName FAILED - Was $SC And Should Be >= 1"
            set result FAILED
            if {$opt(debug) != "false"} { return $result    }
        }
        Dut-$dut3 sendCliCommand "exit all"

        
        if {$SC >= 1} {
            # only cleanup and execute the file if save was successfull
            log_msg INFO "=> Cleanup configuration in Dut-$dut3 before executing saved config file"
            # cleanup test configuration in Dut-$dut3 only
            set direction "Ingress Egress"
            set filterID  0
            foreach direct $direction {
                switch $itfBind {
                    "sap" {
                        set r1 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
                    }
                    "subsap" {
                        if {$filterType == "IPv6"} {
                            # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla2 again
                            #filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla2 -hostType dhcp6_IANA
                        }
                        set r1 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
                    }
                    "spoke" - "mesh" {
                        set r1 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
                    }
                    "net" {
                        set r1 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
                    }
                    default {
                        # destination type inconsistency
                        log_msg ERROR "itfBind type $itfBind not yet supported"
                        set r1 ERROR
                    }
                }
            }
            ### unbind the filter from VPRNs
            for {set i 1} {$i <= 4} {incr i} {
                if { ($opt(svcType) == "vprn") && ($i == 4) } {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
                    set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
                } else {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
                    set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
                }
                if {($r12 != "noError")} {
                    log_msg ERROR "Failed to deassign filter: $filterID from ingress in VPRN: [set vprnId${i}] ,found $r12"
                    set result FAILED
                 }
            }

            if {$opt(systemFilter)} {
                set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 800 destroy]
                set r3 [Dut-$dut3 setTFilterSystemFilterRowStatus fltrtypesel[getVar1 $filterType] 8 destroy]
                set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 8 destroy]
                if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError")} {
                    log_msg ERROR "failed to cleanup filter in Dut-$dut3, found $r1, $r2, $r3, $r4"
                    set result FAILED
                }
            } else {
                set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 8 destroy]
            }
            if {($r1 != "noError") || ($r2 != "noError")} {
                log_msg ERROR "failed to cleanup $filterType filter 8 in Dut-$dut3, found $r1, $r2"
                set result FAILED
                if {$opt(debug) != "false"} { return $result    }
            }
            set r1 [Dut-$dut3 setTFilterLogRowStatus 110 destroy ]
            set r2 [Dut-$dut3 setTFilterLogRowStatus 120 destroy ]
            set r3 [Dut-$dut3 setTFilterLogRowStatus 130 destroy ]
            set r4 [Dut-$dut3 setTFilterLogRowStatus 140 destroy ]
            set r5 [Dut-$dut3 setTFilterLogRowStatus 150 destroy ]
            if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
                log_msg ERROR "Failed to cleanup filter logs in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
                set result FAILED
                if {$opt(debug) != "false"} { return $result    }
            }
            set i 1
            foreach {vprnId} "$vprnId1 $vprnId2 $vprnId3 $vprnId4" {
                set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
                if { ($opt(svcType) == "vprn") && ($i == "4") } {
                    # do nothing
                } else {
                    set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 sap ${port_3_3}:[expr $i + 1] shutdown"]; log_msg INFO $rCli
                    set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 no sap ${port_3_3}:[expr $i + 1]"]; log_msg INFO $rCli
                }
                set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 shutdown"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no interface vprn${vprnId}ToIxia3 "]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId shutdown"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service no vprn $vprnId"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
                incr i
            }
            if { $opt(svcType) == "vprn" } {
                set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure router no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure router no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 sap ${port_3_3}:5 shutdown"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 no sap ${port_3_3}:5"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 shutdown"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 no interface itfToIxia300"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "/configure service no ies 300"]; log_msg INFO $rCli
                set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
            }
            log_msg INFO "=> Executing saved config file $fileName after cleaning up and retest filter"
            set CLI [ cookCliData [ Dut-$dut3 sendCliCommand "exec $dir/$fileName" ]]
            set SC [ string first "Executed" $CLI ]
            if { $SC < 1 } {
                log_msg DEBUG "$CLI"
                log_msg ERROR "Exec of $fileName FAILED - Was $SC And Should Be >= 1"
                set result FAILED
                if {$opt(debug) != "false"} { return $result    }
            }
            Dut-$dut3 sendCliCommand "exit all"
            ### verify traffic
            log_msg INFO "Test traffic"
            log_msg INFO "Check redirected traffic for each entry and streams after admin save/exec"
            if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
                set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
            } else {
                if {$opt(systemFilter)} {
                    set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -chainedFilterId 800]
                } else {
                    set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
                }
            }
            if {$r != "PASSED"} {
                if {$opt(debugPrint) == "true"} {
                    filterTCAM_debug $setupType
                    set opt(debugPrint) false
                }
                set result FAILED
            }

        }
        # restore timeout values
#        Dut-$dut3 configure -cli_timeout $CliTim
#        Dut-$dut3 configure -timeout $Tim
    }

    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Admin tech-support"
    log_msg INFO "----------------------------------------------------"

    set rCli [Dut-$dut3 sendCliCommand "admin tech-support ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs/admin_tech_support_$dut3"] ; log_msg INFO "$rCli"

    # cleanup
    print_console_msg "cleanup test config"
    ### unbind filter from VPRNs
    for {set i 1} {$i <= 4} {incr i} {
        if { ($opt(svcType) == "vprn") && ($i == 4) } {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 0 ]
        } else {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] 0 ]
        }
        if {($r12 != "noError")} {
            log_msg ERROR "Failed to deassign filter: $filterID from ingress in VPRN: [set vprnId${i}] ,found $r12"
            set result FAILED
         }
    }
    ### unbind filter from test interface
    set direction "Ingress Egress"
    set filterID  0
    foreach direct $direction {
        switch $itfBind {
            "sap" {
                set r1 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
            }
            "subsap" {
                if {$filterType == "IPv6"} {
                    # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla2 again
                    #filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla2 -hostType dhcp6_IANA
                }
                set r1 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
            }
            "spoke" - "mesh" {
                set r1 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
            }
            "net" {
                set r1 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
            }
            default {
                # destination type inconsistency
                log_msg ERROR "itfBind type $itfBind not yet supported"
                set r1 ERROR
            }
        }
    }
    ### delete filter
    if {$opt(systemFilter)} {
        set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 800 destroy]
        set r3 [Dut-$dut3 setTFilterSystemFilterRowStatus fltrtypesel[getVar1 $filterType] 8 destroy]
        set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 8 destroy]
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError")} {
            log_msg ERROR "failed to cleanup filter in Dut-$dut3, found $r1, $r2, $r3, $r4"
            set result FAILED
        }
    } else {
        set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 8 destroy]
    }
    if {($r1 != "noError") || ($r2 != "noError")} {
        log_msg ERROR "failed to cleanup $filterType filter 8 in Dut-$dut3, found $r1, $r2"
        set result FAILED
        if {$opt(debug) != "false"} { return $result    }
    }
    ### delete filter logs
    set r1 [Dut-$dut3 setTFilterLogRowStatus 110 destroy ]
    set r2 [Dut-$dut3 setTFilterLogRowStatus 120 destroy ]
    set r3 [Dut-$dut3 setTFilterLogRowStatus 130 destroy ]
    set r4 [Dut-$dut3 setTFilterLogRowStatus 140 destroy ]
    set r5 [Dut-$dut3 setTFilterLogRowStatus 150 destroy ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "Failed to cleanup filter logs in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
        if {$opt(debug) != "false"} { return $result    }
    }
    ### delete VPRNs
    set i 1; set customer 0
    foreach {vprnId} "$vprnId1 $vprnId2 $vprnId3 $vprnId4" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        if { ($opt(svcType) == "vprn") && ($i == "4") } {
            # do nothing
        } else {
            set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 sap ${port_3_3}:[expr $i + 1] shutdown"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 no sap ${port_3_3}:[expr $i + 1]"]; log_msg INFO $rCli
        }
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no interface vprn${vprnId}ToIxia3 "]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no vprn $vprnId"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no customer [expr $customer + $i]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    if { $opt(svcType) == "vprn" } {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 sap ${port_3_3}:5 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 no sap ${port_3_3}:5"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 no interface itfToIxia300"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no ies 300"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    }
    ### delete configured customers
    set rCli [Dut-$dut3 sendCliCommand "/configure service no customer 2"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure service no customer 3"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure service no customer 4"]; log_msg INFO $rCli

    filterTCAM_cleanup $setupType -testResult $result
    filterTCAM_ixCleanup $setupType
    if {[isIpv6Run]} {saveOrRestore delete}

}; #end of iterations

    if {$opt(mode) == "regular"} {
        # check for memory leaks
        log_msg INFO "Check for memory leaks"
        set check [filterScale_memLeakChecks $dut3 check -card [Dut-$dut3 findActiveCpm] -mPools {"Services" "FltrLOG" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}]
        if {$check != "OK"} {
            log_msg ERROR "Memory leak detected after cleanup, found $check"
            set result "FAILED"
        }
        if {[Dut-$dut3 cget -redundantSystem] != "false"} {
            set check_stb [filterScale_memLeakChecks $dut3 check -card [Dut-$dut3 findInactiveCpm] -mPools {"Services" "FltrLOG" "TLS MFIB" "DHCPS" "PIP" "MFIB" "BGP" "Management"}]
            if {$check_stb != "OK"} {
                log_msg ERROR "Memory leak detected after cleanup on standby CPM, found $check_stb"
                set result "FAILED"
            }
        }
    }

#    set result [ fullDebug -action check -dut Dut-$dut3 -memPoolList "allPools" -minLeak 2]
    # restore timeout values
    Dut-$dut3 configure -cli_timeout $CliTim
    Dut-$dut3 configure -timeout $Tim

    if { $result == "PASSED" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

#    if {$opt(deconfig)} {
#       saveOrRestore delete
#       saveOrRestore restore -name deleteConfig
#    }
}

proc filterActionFwdRtrCopyRenumEmbed { args } {

    global testdir logdir ixia_port
    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl


    set opt(debug)      true
    set opt(debugPrint) false
    set opt(mode)       regular
    set opt(snmp)       true
    set opt(setupType)  "random"
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(copyFilter) "false"
    set opt(embedFilter) "false"
    getopt opt $args

    set testID $::TestDB::currentTestCase
    set result PASSED

    handlePacket -action reset -portList all
    # save initial configuration
#    saveOrRestore save -name deleteConfig -replaceDeleteWith true

    # randomly choose setupType
    if {$opt(setupType) == "random"} {
        if {[random 2] == "0"} {set opt(svcType) "vprn"} else {set opt(svcType) ""}
        if { $opt(svcType) == "vprn" } {
            set setupType [fwdRtrVrfToVrf_getSetupType $opt(filterType)]
        } else {
            set setupType [fwdRtrGrtToVrf_getSetupType $opt(filterType)]
        }
    } else {
        set setupType $opt(setupType)
        log_msg NOTICE "User defined setupType: $setupType"
    }
    if {[filterTCAM_getGlobals $setupType] != "OK"} {
        log_msg ERROR "Unable to find correct parameters for $setupType"
        set result FAILED
    }
    if { [regexp {vprn} $svcType] } { set opt(svcType) "vprn" }
    # configuration
    if {($filterType == "IPv6") && ($itfBind == "subsap")} {
        set r [filter_radOverride_runTest $filterType -select [string trimleft $setupType IPv6_ ] -hostType dhcp6_IANA -cleanup false -dual false]
    } else {
        filterTCAM_config $setupType
    }
    filterTCAM_ixInit $setupType

    ### find out, if card is IOM3 and higher or not (in case of older IOMs, PBR is not taken into account)
    if { $itfType == "lag" } {
        set iom3 ""
        foreach {port} $port_3_2 {
            if {[Dut-$dut3 isIom3Equipped [lindex [split $port "/"] 0]] != "TRUE"} {
                if {$iom3 == "true"} {set iom3 "none"} else {set iom3 "false"}
            } else {
                if {$iom3 == "false"} {set iom3 "none"} else {set iom3 "true"}
            }
        }
        log_msg NOTICE "iom3 $iom3"
        if {$iom3 == "none"} { log_msg ERROR "testing on lag with mixture of iom3 and non-iom3 ports, results for action forward router tests could be unpredictable" }
    } else {
        set iom3 [ string tolower [Dut-$dut3 isIom3Equipped [lindex [split $port_3_2 "/"] 0]]]
        if { $iom3 == "false" } {
            log_msg INFO "Used line card is NOT IOM3 and higher - verify, that traffic will be just forwarded and PBR is not taken into account"
        }
    }
    set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions false]
    set streamIdList ""
    for {set i 1} {$i <= $numStreams} {incr i} { lappend streamIdList $i }
    filterTCAM_ixTestTraffic $streamIdList

    log_msg INFO ""
    log_msg INFO "=> Setup vprns to be used in filter action redirectToVFR"
    set vprnId1 10
    set vprnId2 2147483647
    set vprnId3 5000
    set vprnId4 123456
    set serviceName1 "testvprn $vprnId1"
    set serviceName2 "abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\~\!\@\%\^\&\*\(\)"
    set serviceName3 "testvprn $vprnId3"
    set serviceName4 "testvprn $vprnId4"
    set customer 0
    set i 1

    foreach {vprnId} "$vprnId1 $vprnId2 $vprnId3 $vprnId4" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service customer $i create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    configure service vprn $vprnId customer [expr $customer + $i] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        route-distinguisher 10.20.1.3:[expr $i + 1]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        service-name \"[ set serviceName$i]\""]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface vprn${vprnId}ToIxia3 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.0.1/24"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.0.1]/[maskConvert Ipv6 24]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:[expr $i + 1] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    ### in case svcType is vprn, modify action in entry 40 to forward router Base - in such case, we need to create ies service with sap to IXIA port
    if { $opt(svcType) == "vprn" } {
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId4 interface vprn${vprnId4}ToIxia3 sap ${port_3_3}:5 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId4}ToIxia3 no sap ${port_3_3}:5"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service ies 300 customer 1 vpn 1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia300 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.3.1/14"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:03"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.3.1]/[maskConvert Ipv6 14]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:5 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    }

    # create filter logs
    set r1 [Dut-$dut3 setTFilterLogRowStatus 110 createAndGo ]
    set r2 [Dut-$dut3 setTFilterLogRowStatus 120 createAndGo ]
    set r3 [Dut-$dut3 setTFilterLogRowStatus 130 createAndGo ]
    set r4 [Dut-$dut3 setTFilterLogRowStatus 140 createAndGo ]
    set r5 [Dut-$dut3 setTFilterLogRowStatus 150 createAndGo ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "failed to create filterlogs in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
    }

    # configure IP filter to forward matching traffic in testDut dut3
    set r1 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 8]
    # apply filter to ingress interface under test
    set direction "Ingress Egress"
    set filterID  8
    foreach direct $direction {
        switch $itfBind {
            "sap" {
                set r2 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
            }
            "subsap" {
                set r2 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
                if {$filterType == "IPv6"} {
                    # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla1 now ...
                    filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla1 -hostType dhcp6_IANA
                }
            }
            "spoke" - "mesh" {
                set r2 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
            }
            "net" {
                set r2 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
            }
            default {
                # destination type inconsistency
                log_msg ERROR "itfBind type $itfBind not yet supported"
                set r2 ERROR
            }
        }
    }
    if {($r1 != "noError") || ($r2 != "noError")} {
        log_msg ERROR "failed to create $filterType filter $filterID and assign to $direction $itfBind in Dut-$dut3, found $r1, $r2"
        set result FAILED
    }
    set vprnNameOrId [ expr round( rand() ) ]
    if { $vprnNameOrId == 1 } {set vprnNameOrId "router service-name"; set vprn1 $serviceName1; set vprn2 $serviceName2; set vprn3 $serviceName3; set vprn4 $serviceName4} else {set vprnNameOrId "router"; set vprn1 $vprnId1; set vprn2 $vprnId2; set vprn3 $vprnId3; set vprn4 $vprnId4}

    if {$filterType == "IP"} {set matchProtocol "protocol"} else {set matchProtocol "next-header"}
    if {$filterType == "IP"} { set fltrMask 16 } else { set fltrMask [maskConvert $family 16] }
    set fltrSrcAddr [ipv62MibVal [ipConvert $family 3.3.0.0]]
    set fltrDstAddr [ipv62MibVal [ipConvert $family 1.1.0.0]]
    set fltrSrcAddrCLI [ipConvert $family 3.3.0.0]
    set fltrDstAddrCLI [ipConvert $family 1.1.0.0]

    set testList ""
    set testList2 ""
    if { $filterType == "IP" } {
        set stream_egr "1 2 3 4"
        lappend testList 1 "match $matchProtocol tcp tcp syn true"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
        lappend testList 2 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
        lappend testList 3 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
        if { $opt(svcType) == "vprn" } {
            lappend testList 4 "match $matchProtocol icmp"              40 "action forward router Base" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
        } else {
            lappend testList 4 "match $matchProtocol icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
        }
    } else {
        set stream_egr "1 2 4 5"
        lappend testList 7 "match $matchProtocol sctp"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
        lappend testList 4 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
        lappend testList 5 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
        if { $opt(svcType) == "vprn" } {
            lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward router Base" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
        } else {
            lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
        }
        # create stream 7 - IPv6 packet with next-header sctp
        if {[getGlobalVar physTopology] == "scaleBed"} { set ing_port 5; set eg_port 1 } else { set ing_port 1; set eg_port 3 }
        set portList [list $ixport1 ]
        scan $ixport1 "%d %d %d" chassis card port
        port get $chassis $card $port
        stream get $chassis $card $port 1
        set da_mac [join [split [stream cget -da] " "] ":"]
        handlePacket -port $ing_port -dot1q 1 -dst 3FFE::303:2:0:0:0:0 -numDest 1 -src 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -stream 7 -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        after 1000
        stream get $chassis $card $port 7
        stream config  -enable  false
        stream set $chassis $card $port 7
        stream write $chassis $card $port 7

        set portList [list $ixport3 ]
        scan $ixport3 "%d %d %d" chassis card port
        port get $chassis $card $port
        stream get $chassis $card $port 1
        set da_mac [join [split [stream cget -da] " "] ":"]
        handlePacket -port $eg_port -dot1q 1 -src 3FFE::303:2:0:0:0:0 -numDest 1 -dst 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -stream 7 -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        after 1000
        stream get $chassis $card $port 7
        stream config  -enable  false
        stream set $chassis $card $port 7
        stream write $chassis $card $port 7
    }

    # create entries and set action forward router
    set configType [ expr round( rand() ) ]
    # if $configType=0, configuration will be performed via CLI, otherwise via SNMP
    if { $configType == 1 } {
        if {$filterType == "IP"} {set matchProtocolSNMP "-Protocol"} else {set matchProtocolSNMP "-NextHeader"}
        if {$filterType == "IP"} {
            set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 10 $matchProtocolSNMP 6 -TcpSyn true -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId1] ]
            set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId2] ]
            set r3 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 30 $matchProtocolSNMP 17 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId3] ]
            if { $opt(svcType) == "vprn" } {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 1 -Action forward -FwdRtrId 1 ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId 1] ]
            } else {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 1 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId4] ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId 1 ]
            }
        } else {
            set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 10 $matchProtocolSNMP 132 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId1] ]
            set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId2] ]
            set r3 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 30 $matchProtocolSNMP 17 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId3] ]
            if { $opt(svcType) == "vprn" } {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 58 -Action forward -FwdRtrId 1 ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId 1] ]
            } else {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 58 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId4] ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId 1 ]
            }
        }
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
            log_msg ERROR "failed to create $filterType filter entries with different actions in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
            set result FAILED
        }
    } else {
        Dut-$dut3 sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList2 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
    }
    ### add second match criterium for entry 1 - in order to eliminate hits by control traffic
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 create"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"
    # add filter logs to the different entries
    set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 10 110 ]
    set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 20 120 ]
    set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 30 130 ]
    set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 40 140 ]
    set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 1 150 ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "failed to assign filterlogs to $filterType filter entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
     }

    # bind same filter on egress of each configured VPRN - in order to verify hit counters
    log_msg INFO "Bind same filter on ingress of each configured VPRN in order to verify hit counters"
    for {set i 1} {$i <= 4} {incr i} {
        if { ($opt(svcType) == "vprn") && ($i == 4) } {
#            set r1 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            set r2 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
        } else {
#            set r1 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            set r2 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
        }
        if {($r2 != "noError")} {
            log_msg ERROR "Failed to assign filter: $filterID to ingress of VPRN: [set vprnId${i}] ,found $r2"
            set result FAILED
         }
    }

    # check the redirected traffic
    ### configure additional match criteria for entry 40 - in order to block unwanted hits of ICMP packets
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 40"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"

    set step 1
    # create new VPRN
    set vprnId5 600
    set serviceName5 "testvprn $vprnId5"
    set customer 1

    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "    configure service vprn $vprnId5 customer $customer create"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "        route-distinguisher 10.20.1.3:6"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "        service-name \"[ set serviceName5]\""]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "        interface vprn${vprnId5}ToIxia3 create"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            address 3.3.0.1/24"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:05"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.0.1]/[maskConvert Ipv6 24]"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:05"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:6 create"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "     static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "     static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    
#interpreter

    if { $opt(copyFilter) == "true" } {
        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: renum filter entries"
        log_msg INFO "----------------------------------------------------"
        incr step

        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 1 100"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 10 500"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 20 400"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 30 300"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 40 200"]; log_msg INFO $rCli

        set testList3 ""
        set testList4 ""
        if { $filterType == "IP" } {
            set stream_egr "1 2 3 4"
            lappend testList3 1 "match $matchProtocol tcp tcp syn true"  500 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList3 2 "match $matchProtocol tcp tcp syn false" 400 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList3 3 "match $matchProtocol udp"               300 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList3 4 "match $matchProtocol icmp"              200 "action forward router Base" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router 1" 150
            } else {
                lappend testList3 4 "match $matchProtocol icmp"              200 "action forward $vprnNameOrId \"$vprn4\"" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router Base" 150
            }
        } else {
            set stream_egr "1 2 4 5"
            lappend testList3 7 "match $matchProtocol sctp"  500 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList3 4 "match $matchProtocol tcp tcp syn false" 400 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList3 5 "match $matchProtocol udp"               300 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList3 2 "match $matchProtocol ipv6-icmp"              200 "action forward router Base" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router 1" 150
            } else {
                lappend testList3 2 "match $matchProtocol ipv6-icmp"              200 "action forward $vprnNameOrId \"$vprn4\"" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router Base" 150
            }
        }
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList3 $testList4 -withOptions false -renum true]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList3 $testList4 -withOptions false -renum true]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: copy filter 8 to non-existant filter 80 and verify traffic"
        log_msg INFO "----------------------------------------------------"
        incr step

        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 8 to 80"]; log_msg INFO $rCli
        
        log_msg INFO "Unbind filter 8 and try to bind copied filter 80"
        
        set filterID  80
        filterTCAM_applyFilter $setupType Ingress $filterID -type $filterType -mode snmp
        filterTCAM_applyFilter $setupType Egress $filterID -type $filterType -mode snmp
        for {set i 1} {$i <= 4} {incr i} {
            if { ($opt(svcType) == "vprn") && ($i == 4) } {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
                set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            } else {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
                set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            }
            if {($r12 != "noError")} {
                log_msg ERROR "Failed to deassign filter: $filterID from ingress in VPRN: [set vprnId${i}] ,found $r12"
                set result FAILED
             }
        }
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList3 $testList4 -withOptions false -renum true -filterId 80]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList3 $testList4 -withOptions false -renum true -filterId 80]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        log_msg INFO "Bind back filter 8"
        set filterID  8
        filterTCAM_applyFilter $setupType Ingress $filterID -type $filterType -mode snmp
        filterTCAM_applyFilter $setupType Egress $filterID -type $filterType -mode snmp
        for {set i 1} {$i <= 4} {incr i} {
            if { ($opt(svcType) == "vprn") && ($i == 4) } {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
                set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            } else {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
                set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            }
            if {($r12 != "noError")} {
                log_msg ERROR "Failed to deassign filter: $filterID from ingress in VPRN: [set vprnId${i}] ,found $r12"
                set result FAILED
             }
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: create another VPRN, set action forward to this new VPRN in filter 80, overwrite filter 8 with filter 80"
        log_msg INFO "----------------------------------------------------"
        incr step

        # configure action forward router 600 to entries in filter 80
        log_msg INFO "Configure action forward router 600 to entries in filter 80"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 100 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 200 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 300 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 400 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 500 action forward router $vprnId5"

        log_msg INFO "Overwrite filter 8 with filter 80 and verify that traffic is redirected to new VPRN: $vprnId5"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 overwrite"]; log_msg INFO $rCli

        set testList5 ""
        set testList6 ""
        if { $filterType == "IP" } {
            lappend testList5 1 "match $matchProtocol tcp tcp syn true"  500 "action forward $vprnNameOrId \"$vprnId5\"" 110
            lappend testList5 2 "match $matchProtocol tcp tcp syn false" 400 "action forward $vprnNameOrId \"$vprnId5\"" 120
            lappend testList5 3 "match $matchProtocol udp"               300 "action forward $vprnNameOrId \"$vprnId5\"" 130
            lappend testList5 4 "match $matchProtocol icmp"              200 "action forward $vprnNameOrId \"$vprnId5\"" 140
        } else {
            lappend testList5 7 "match $matchProtocol sctp"  500 "action forward $vprnNameOrId \"$vprnId5\"" 110
            lappend testList5 4 "match $matchProtocol tcp tcp syn false" 400 "action forward $vprnNameOrId \"$vprnId5\"" 120
            lappend testList5 5 "match $matchProtocol udp"               300 "action forward $vprnNameOrId \"$vprnId5\"" 130
            lappend testList5 2 "match $matchProtocol ipv6-icmp"              200 "action forward $vprnNameOrId \"$vprnId5\"" 140
        }
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList5 $testList6 -withOptions false -renum true -newVPRN $vprnId5]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList5 $testList6 -withOptions false -renum true -newVPRN $vprnId5]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: in filter 80 set action forward router for entries with lower ID than in 8, copy/overwrite filter entries from 80 to 8"
        log_msg INFO "----------------------------------------------------"
        incr step

        set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 80 destroy]
        if {($r1 != "noError")} {
            log_msg ERROR "failed to cleanup $filterType filter 80 in Dut-$dut3, found $r1"
            set result FAILED
            if {$opt(debug) != "false"} { return $result    }
        }
        set r2 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 80]
        if {($r2 != "noError")} {
            log_msg ERROR "failed to create again $filterType filter 80 in Dut-$dut3, found $r2"
            set result FAILED
            if {$opt(debug) != "false"} { return $result    }
        }

        Dut-$dut3 sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 80"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList2 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 80"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        ### add second match criterium for entry 1 - in order to eliminate hits by control traffic
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 1 create"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"
        ### add filter log
        set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 10 110 ]
        set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 20 120 ]
        set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 30 130 ]
        set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 40 140 ]
        set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 1 150 ]
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
            log_msg ERROR "failed to assign filterlogs to $filterType filter entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
            set result FAILED
         }

        log_msg INFO "Copy/overwrite filter entries from 80 to 8"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 1 dst-entry 2 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 10 dst-entry 3"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 20 dst-entry 100 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 30 dst-entry 10"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 40 dst-entry 200 overwrite"]; log_msg INFO $rCli

        set testList7 ""
        set testList8 ""
        if { $filterType == "IP" } {
            set stream_egr "1 2 3 4"
            lappend testList7 1 "match $matchProtocol tcp tcp syn true"  3 "action forward $vprnNameOrId \"$vprnId1\"" 110
            lappend testList7 2 "match $matchProtocol tcp tcp syn false" 100 "action forward $vprnNameOrId \"$vprnId2\"" 120
            lappend testList7 3 "match $matchProtocol udp"               10 "action forward $vprnNameOrId \"$vprnId3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList7 4 "match $matchProtocol icmp"              200 "action forward router Base" 140
                lappend testList8 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  2 "action forward router 1" 150
            } else {
                lappend testList7 4 "match $matchProtocol icmp"              200 "action forward $vprnNameOrId \"$vprnId4\"" 140
                lappend testList8 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  2 "action forward router Base" 150
            }
        } else {
            set stream_egr "1 2 4 5"
            lappend testList7 7 "match $matchProtocol sctp"  3 "action forward $vprnNameOrId \"$vprnId1\"" 110
            lappend testList7 4 "match $matchProtocol tcp tcp syn false" 100 "action forward $vprnNameOrId \"$vprnId2\"" 120
            lappend testList7 5 "match $matchProtocol udp"               10 "action forward $vprnNameOrId \"$vprnId3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList7 2 "match $matchProtocol ipv6-icmp"              200 "action forward router Base" 140
                lappend testList8 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  2 "action forward router 1" 150
            } else {
                lappend testList7 2 "match $matchProtocol ipv6-icmp"              200 "action forward $vprnNameOrId \"$vprnId4\"" 140
                lappend testList8 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  2 "action forward router Base" 150
            }
        }
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList7 $testList8 -withOptions false -renum true -renum2 true]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList7 $testList8 -withOptions false -renum true -renum2 true]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: set action forward for entries in filter 8"
        log_msg INFO "----------------------------------------------------"
        incr step
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 200 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 3 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 100 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 10 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 2 action forward"]; log_msg INFO $rCli

        log_msg INFO "Check that traffic is forwarded and not redirected"
        set r [fwdRtr_checkTraffic_nonRouted $setupType $testList7 $testList8 -withOptions false -action "forward" -renum2 true]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: overwrite entries from filter 80 to 8"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Overwrite filter entries from 80 to 8"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 1 dst-entry 2 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 10 dst-entry 3 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 20 dst-entry 100 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 30 dst-entry 10 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 40 dst-entry 200 overwrite"]; log_msg INFO $rCli
                
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList7 $testList8 -withOptions false -renum true -renum2 true]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList7 $testList8 -withOptions false -renum true -renum2 true]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: set action forward for entries in filter 80 and overwrite entries in filter 8"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Set action forward for entries in filter 80"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 1 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 10 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 20 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 30 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 40 action forward"]; log_msg INFO $rCli

        log_msg INFO "Overwrite filter entries from 80 to 8"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 1 dst-entry 2 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 10 dst-entry 3 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 20 dst-entry 100 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 30 dst-entry 10 overwrite"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 src-entry 40 dst-entry 200 overwrite"]; log_msg INFO $rCli

        log_msg INFO "Check that traffic is forwarded and not redirected"
        set r [fwdRtr_checkTraffic_nonRouted $setupType $testList7 $testList8 -withOptions false -action "forward" -renum2 true]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: set action forward router for entries in filter 8"
        log_msg INFO "----------------------------------------------------"
        incr step
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        if { $opt(svcType) == "vprn" } {
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 2 action forward router 1"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 200 action forward router Base"]; log_msg INFO $rCli
        } else {
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 2 action forward router Base"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 200 action forward router $vprnId4"]; log_msg INFO $rCli
        }
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 3 action forward router $vprnId1"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 100 action forward router $vprnId2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 10 action forward router $vprnId3"]; log_msg INFO $rCli

        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList7 $testList8 -withOptions false -renum true -renum2 true]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList7 $testList8 -withOptions false -renum true -renum2 true]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: set action forward for entries in filter 80 and overwrite whole filter 8"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Set action forward for entries in filter 80"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 1 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 10 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 20 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 30 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 40 action forward"]; log_msg INFO $rCli

        log_msg INFO "Overwrite whole filter from 80 to 8"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter copy [getVar4 $filterType]-filter 80 to 8 overwrite"]; log_msg INFO $rCli

        log_msg INFO "Check that traffic is forwarded and not redirected"
        set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false -action "forward"]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        if { $opt(svcType) == "vprn" } {
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 1 action forward router 1"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 40 action forward router Base"]; log_msg INFO $rCli
        } else {
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 1 action forward router Base"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 40 action forward router $vprnId4"]; log_msg INFO $rCli
        }
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 10 action forward router $vprnId1"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 20 action forward router $vprnId2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 30 action forward router $vprnId3"]; log_msg INFO $rCli

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: verify filter default action in case of no match"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Modify filter entries in order to achieve no match"
        set newIP [ipConvert $family 99.99.0.0]
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 10 match src-ip ${newIP}/${fltrMask}"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 20 match src-ip ${newIP}/${fltrMask}"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 30 match src-ip ${newIP}/${fltrMask}"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 40 match src-ip ${newIP}/${fltrMask}"]; log_msg INFO $rCli

        log_msg INFO "Check that traffic is forwarded and not redirected based on filter default action"
        set r [fwdRtr_checkTraffic_noMatch $setupType $testList $testList2 -withOptions false]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        # delete filter 80
        set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterRowStatus 80 destroy]
        if {($r1 != "noError")} {
            log_msg ERROR "failed to cleanup $filterType filter 80 in Dut-$dut3, found $r1"
            set result FAILED
            if {$opt(debug) != "false"} { return $result    }
        }

    }
    if { $opt(embedFilter) == "true" } {

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: create embedded filter 80 with entries with action forward router and embed it to filter 8, verify traffic"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Remove entries from filter 8"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 1"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 10"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 20"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 30"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 40"]; log_msg INFO $rCli

        log_msg INFO "Create embedded filter 80 with entries with action forward router and embed it to filter 8, verify traffic"
        set r2 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 80]
        if {($r2 != "noError")} {
            log_msg ERROR "failed to create again $filterType filter 80 in Dut-$dut3, found $r2"
            set result FAILED
            if {$opt(debug) != "false"} { return $result    }
        }
        # change scope to embed
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 scope embedded"]; log_msg INFO $rCli

        Dut-$dut3 sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 80"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList2 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 80"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        ### add second match criterium for entry 1 - in order to eliminate hits by control traffic
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 1 create"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"

        ### configure additional match criteria for entry 40 - in order to block unwanted hits of ICMP packets
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 40"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "match src-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"

        ### add filter log
        set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 10 110 ]
        set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 20 120 ]
        set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 30 130 ]
        set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 40 140 ]
        set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 80 1 150 ]
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
            log_msg ERROR "failed to assign filterlogs to $filterType filter entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
            set result FAILED
         }

        log_msg INFO "Embed filter 80 into filter 8"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 embed-filter 80 active"]; log_msg INFO $rCli

        log_msg INFO "Verify traffic"
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        
        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: embed embedded filter entries with action forward to another router instance"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Remove embedding"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no embed-filter 80"]; log_msg INFO $rCli
        log_msg INFO "Create entries in filter 8"

        set testList3 ""
        set testList4 ""
        if { $filterType == "IP" } {
            set stream_egr "1 2 3 4"
            lappend testList3 1 "match $matchProtocol tcp tcp syn true"  500 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList3 2 "match $matchProtocol tcp tcp syn false" 400 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList3 3 "match $matchProtocol udp"               300 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList3 4 "match $matchProtocol icmp"              200 "action forward router Base" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router 1" 150
            } else {
                lappend testList3 4 "match $matchProtocol icmp"              200 "action forward $vprnNameOrId \"$vprn4\"" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router Base" 150
            }
        } else {
            set stream_egr "1 2 4 5"
            lappend testList3 7 "match $matchProtocol sctp"  500 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList3 4 "match $matchProtocol tcp tcp syn false" 400 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList3 5 "match $matchProtocol udp"               300 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList3 2 "match $matchProtocol ipv6-icmp"              200 "action forward router Base" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router 1" 150
            } else {
                lappend testList3 2 "match $matchProtocol ipv6-icmp"              200 "action forward $vprnNameOrId \"$vprn4\"" 140
                lappend testList4 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  100 "action forward router Base" 150
            }
        }

        Dut-$dut3 sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList3 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList4 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        ### add second match criterium for entry 1 - in order to eliminate hits by control traffic
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 100 create"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"

        ### configure additional match criteria for entry 200 - in order to block unwanted hits of ICMP packets
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 200"
        Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "match src-ip $fltrDstAddrCLI/$fltrMask"
        Dut-$dut3 sendCliCommand "exit all"

        ### add filter log
        set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 500 110 ]
        set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 400 120 ]
        set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 300 130 ]
        set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 200 140 ]
        set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 100 150 ]
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
            log_msg ERROR "failed to assign filterlogs to $filterType filter entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
            set result FAILED
         }

        log_msg INFO "Embed filter 80 into filter 8"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 embed-filter 80 active"]; log_msg INFO $rCli
    
        log_msg INFO "Change action for embed filter entries to forward router 600"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 1 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 10 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 20 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 30 action forward router $vprnId5"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry 40 action forward router $vprnId5"

        log_msg INFO "Verify traffic"
        set testList5 ""
        set testList6 ""
        if { $filterType == "IP" } {
            lappend testList5 1 "match $matchProtocol tcp tcp syn true"  10 "action forward $vprnNameOrId \"$vprnId5\"" 110
            lappend testList5 2 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprnId5\"" 120
            lappend testList5 3 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprnId5\"" 130
            lappend testList5 4 "match $matchProtocol icmp"              40 "action forward $vprnNameOrId \"$vprnId5\"" 140
        } else {
            lappend testList5 7 "match $matchProtocol sctp"  10 "action forward $vprnNameOrId \"$vprnId5\"" 110
            lappend testList5 4 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprnId5\"" 120
            lappend testList5 5 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprnId5\"" 130
            lappend testList5 2 "match $matchProtocol ipv6-icmp"              40 "action forward $vprnNameOrId \"$vprnId5\"" 140
        }
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList5 $testList6 -withOptions false -renum true -newVPRN2 $vprnId5]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList5 $testList6 -withOptions false -renum true -newVPRN2 $vprnId5]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: modify entries in embedded filter to action forward"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Set action forward for entries in embedded filter 80"
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 1 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 10 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 20 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 30 action forward"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 80 entry 40 action forward"]; log_msg INFO $rCli

        log_msg INFO "Check that traffic is forwarded and not redirected"
        set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false -action "forward"]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: overrule the embedded entry by renum of entry in filter 8"
        log_msg INFO "----------------------------------------------------"
        incr step
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 100 1"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 500 10"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 400 20"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 300 30"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 renum 200 40"]; log_msg INFO $rCli
        
        log_msg INFO "Verify traffic"
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }

        print_console_msg "STEP $step"
        log_msg INFO "----------------------------------------------------"
        log_msg INFO "STEP $step: remove embedding, remove entries in filter 8 and embed again embedded filter with offset"
        log_msg INFO "----------------------------------------------------"
        incr step
        log_msg INFO "Remove embedding"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no embed-filter 80"]; log_msg INFO $rCli
        log_msg INFO "Remove entries from filter 8"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 1"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 10"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 20"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 30"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 40"]; log_msg INFO $rCli

        Dut-$dut3 sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 80"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList2 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 80"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 80 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }

        log_msg INFO "Embed filter 80 into filter 8 with offset"
        set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 embed-filter 80 active offset 100"]; log_msg INFO $rCli

        set testList10 ""
        set testList11 ""
        if { $filterType == "IP" } {
            set stream_egr "1 2 3 4"
            lappend testList10 1 "match $matchProtocol tcp tcp syn true"  110 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList10 2 "match $matchProtocol tcp tcp syn false" 120 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList10 3 "match $matchProtocol udp"               130 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList10 4 "match $matchProtocol icmp"              140 "action forward router Base" 140
                lappend testList11 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  101 "action forward router 1" 150
            } else {
                lappend testList10 4 "match $matchProtocol icmp"              140 "action forward $vprnNameOrId \"$vprn4\"" 140
                lappend testList11 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  101 "action forward router Base" 150
            }
        } else {
            set stream_egr "1 2 4 5"
            lappend testList10 7 "match $matchProtocol sctp"  110 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList10 4 "match $matchProtocol tcp tcp syn false" 120 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList10 5 "match $matchProtocol udp"               130 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList10 2 "match $matchProtocol ipv6-icmp"              140 "action forward router Base" 140
                lappend testList11 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  101 "action forward router 1" 150
            } else {
                lappend testList10 2 "match $matchProtocol ipv6-icmp"              140 "action forward $vprnNameOrId \"$vprn4\"" 140
                lappend testList11 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  101 "action forward router Base" 150
            }
        }
        log_msg INFO "Verify traffic"
        # verify traffic
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
        } elseif { $opt(svcType) == "L2Service" } {
            log_msg INFO "Check that traffic is forwarded and not redirected"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
        }
        if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
            set r [fwdRtr_checkTraffic_nonRouted $setupType $testList10 $testList11 -withOptions false -embedOffset true]
        } else {
            set r [fwdRtr_checkTraffic $setupType $testList10 $testList11 -withOptions false -embedOffset true]
        }
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
        

    }

    if { $result == "PASSED" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

    if {$opt(deconfig)} {
      saveOrRestore delete
    # restore initial configuration
#    saveOrRestore restore -name deleteConfig

    }

}

proc filterActionFwdRtrRollback { args } {

    global testdir logdir ixia_port setupErrorFlag testResultFlag
    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl


    set opt(debug)      true
    set opt(debugPrint) false
    set opt(mode)       regular
    set opt(snmp)       true
    set opt(setupType)  "random"
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(copyFilter) "false"
    set opt(embedFilter) "false"
    getopt opt $args

    set testID $::TestDB::currentTestCase
    set result PASSED
    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"

    # randomly choose setupType
    if {$opt(setupType) == "random"} {
        if {[random 2] == "0"} {set opt(svcType) "vprn"} else {set opt(svcType) ""}
        if { $opt(svcType) == "vprn" } {
            set setupType [fwdRtrVrfToVrf_getSetupType $opt(filterType)]
        } else {
            set setupType [fwdRtrGrtToVrf_getSetupType $opt(filterType)]
        }
    } else {
        set setupType $opt(setupType)
        log_msg NOTICE "User defined setupType: $setupType"
    }
    if {[filterTCAM_getGlobals $setupType] != "OK"} {
        log_msg ERROR "Unable to find correct parameters for $setupType"
        set result FAILED
    }
    if { [regexp {vprn} $svcType] } { set opt(svcType) "vprn" }
    # configuration
    if {($filterType == "IPv6") && ($itfBind == "subsap")} {
        set r [filter_radOverride_runTest $filterType -select [string trimleft $setupType IPv6_ ] -hostType dhcp6_IANA -cleanup false -dual false]
    } else {
        filterTCAM_config $setupType
    }

    # configure IP filter to forward matching traffic in testDut dut3
    set r1 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 8]
    # apply filter to ingress interface under test
    set direction "Ingress Egress"
    set filterID  8
    foreach direct $direction {
        switch $itfBind {
            "sap" {
                set r2 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
            }
            "subsap" {
                set r2 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
                if {$filterType == "IPv6"} {
                    # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla1 now ...
                    filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla1 -hostType dhcp6_IANA
                }
            }
            "spoke" - "mesh" {
                set r2 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
            }
            "net" {
                set r2 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
            }
            default {
                # destination type inconsistency
                log_msg ERROR "itfBind type $itfBind not yet supported"
                set r2 ERROR
            }
        }
    }
    if {($r1 != "noError") || ($r2 != "noError")} {
        log_msg ERROR "failed to create $filterType filter $filterID and assign to $direction $itfBind in Dut-$dut3, found $r1, $r2"
        set result FAILED
    }
    # create entry with action forward - save first restore point
    print_console_msg "STEP 1"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 1: Create entry with action forward and save first restore point"
    log_msg INFO "----------------------------------------------------"
    set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -Action forward]
    if {($r1 != "noError")} {
        log_msg ERROR "failed to create $filterType filter entry with action forward in Dut-$dut3, found $r1"
        set result FAILED
    }
    log_msg INFO "Save the first rollback restore point - entry with action forward"
    log_msg INFO "Creating rollback restore point-1"
    set username $::TestDB::thisTestBed ; set hostIp $::TestDB::thisHostIpAddr
    set logDir "ftp://${username}:tigris@${hostIp}/$logdir/device_logs"
    set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
    Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
    Dut-$dut3 sendCliCommand "exit all"
    Dut-$dut3 sendCliCommand "shell rollbackBlackListDisable"
    Dut-$dut3 sendCliCommand "configure system rollback rollback-location $logDir/fwdRtrRollback"
    Dut-$dut3 sendCliCommand "admin rollback save"
    after 3000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackSaveResult [filter_getRollbackResult $dut3 save]
    if {$rollbackSaveResult != "Successful"} {
        log_msg ERROR "error with creating rollback restore point-1 - $rollbackSaveResult" ; set result "FAILED"
    }
    Dut-$dut3 configure -cli_timeout $extCliTim ; Dut-$dut3 configure -timeout $extTim


    print_console_msg "STEP 2"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 2: Create 1. VPRN and modify action to forward router 1.VPRN - create second restore point"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO ""
    log_msg INFO "=> Setup 1.VPRN in order to be used in filter action forward router"
    set vprnId1 10
    set vprnId2 2147483647
    set serviceName1 "testvprn $vprnId1"
    set serviceName2 "abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\~\!\@\%\^\&\*\(\)"
    set customer 0
    set i 1

    foreach {vprnId} "$vprnId1" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service customer $i create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    configure service vprn $vprnId customer [expr $customer + $i] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        route-distinguisher 10.20.1.3:[expr $i + 1]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        service-name \"[ set serviceName$i]\""]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface vprn${vprnId}ToIxia3 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.0.1/24"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.0.1]/[maskConvert Ipv6 24]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:[expr $i + 1] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    log_msg INFO "Configure action to action forward router $vprnId1"
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 action forward router $vprnId1"

    log_msg INFO "Create a second restore point - entry with action forward router $vprnId1"
    log_msg INFO "Creating rollback restore point-2"
    set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
    Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
    Dut-$dut3 sendCliCommand "exit all"
    Dut-$dut3 sendCliCommand "admin rollback save" -match_max 200000
    after 3000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackSaveResult [filter_getRollbackResult $dut3 save]
    if {$rollbackSaveResult != "Successful"} {
      log_msg ERROR "error with creating rollback restore point-2 - $rollbackSaveResult" ; set result "FAILED"
    }
    after 2000


    print_console_msg "STEP 3"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 3: Create 2. VPRN and modify action to forward router 2.VPRN, delete 1.VPRN - create third restore point"
    log_msg INFO "----------------------------------------------------"
    foreach {vprnId} "$vprnId2" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service customer $i create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    configure service vprn $vprnId customer [expr $customer + $i] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        route-distinguisher 10.20.1.3:[expr $i + 1]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        service-name \"[ set serviceName$i]\""]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface vprn${vprnId}ToIxia3 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.0.1/24"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.0.1]/[maskConvert Ipv6 24]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:[expr $i + 1] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    log_msg INFO "Configure action to action forward router $vprnId2"
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 action forward router $vprnId2"

    log_msg INFO "Delete 1.VPRN"
    set i 1
    foreach {vprnId} "$vprnId1" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        if { ($opt(svcType) == "vprn") && ($i == "4") } {
            # do nothing
        } else {
            set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 sap ${port_3_3}:[expr $i + 1] shutdown"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 no sap ${port_3_3}:[expr $i + 1]"]; log_msg INFO $rCli
        }
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no interface vprn${vprnId}ToIxia3 "]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no vprn $vprnId"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }

    log_msg INFO "Create a third restore point - entry with action forward router $vprnId2"
    log_msg INFO "Creating rollback restore point-3"
    set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
    Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
    Dut-$dut3 sendCliCommand "exit all"
    Dut-$dut3 sendCliCommand "admin rollback save" -match_max 200000
    after 3000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackSaveResult [filter_getRollbackResult $dut3 save]
    if {$rollbackSaveResult != "Successful"} {
      log_msg ERROR "error with creating rollback restore point-3 - $rollbackSaveResult" ; set result "FAILED"
    }
    after 2000


    print_console_msg "STEP 4"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 4: Delete service-name for 2.VPRN - create fourth restore point"
    log_msg INFO "----------------------------------------------------"
    set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId2 no service-name"]; log_msg INFO $rCli

    log_msg INFO "Create a fourth restore point - entry with action forward router $vprnId2 without service-name"
    log_msg INFO "Creating rollback restore point-4"
    set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
    Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
    Dut-$dut3 sendCliCommand "exit all"
    Dut-$dut3 sendCliCommand "admin rollback save" -match_max 200000
    after 3000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackSaveResult [filter_getRollbackResult $dut3 save]
    if {$rollbackSaveResult != "Successful"} {
      log_msg ERROR "error with creating rollback restore point-4 - $rollbackSaveResult" ; set result "FAILED"
    }
    after 2000


    print_console_msg "STEP 5"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 5: Perform rollback to third restore point and verify action"
    log_msg INFO "----------------------------------------------------"
    # rollback to the third restore point
    log_msg INFO "Rollback to restore point-3 - entry with action forward router $vprnId2 (with service-name configured)"
    Dut-$dut3 sendCliCommand "exit all"
    set errMsg [cookCliData [Dut-$dut3 sendCliCommand "admin rollback revert 1 now" -match_max 200000]]
    after 5000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackRevertResult [filter_getRollbackResult $dut3 revert]
    if {$rollbackRevertResult != "Successful" || [regexp "CLI Rollback revert failed" $errMsg]} {
      log_msg ERROR "error with reverting to rollback restore point-3 - $rollbackRevertResult - $errMsg" ; set result "FAILED"
    }
    log_msg INFO "Verify entry action"
    log_msg INFO "=> Verify service-name via info command"
    set r1 [ Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 1"]
    set r1 [ Dut-$dut3 sendCliCommand "info | match action"]; log_msg INFO $r1
#    if { [regexp " action forward router service-name (\\\"abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\\\~\\\!\\\@\\\%\\\^\\\&\\\*\\\(\\\)\\\")" $r1 match name] == 0 } {
#            log_msg ERROR "Wrong router name in info command output"; set result FAILED
#    } else {
#        log_msg INFO "Entry action is correct: action forward router service-name $name"
#    }
#    set r1 [ Dut-$dut3 sendCliCommand "exit all"]
    if { [regexp " action forward router ($vprnId2)" $r1 match name] == 0 } {
        log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
    }
    set r1 [ Dut-$dut3 sendCliCommand "exit all"]

    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8"]

    print_console_msg "STEP 6"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 6: Perform rollback to second restore point and verify action"
    log_msg INFO "----------------------------------------------------"
    # rollback to the second restore point
    log_msg INFO "Rollback to restore point-2 - entry with action forward router $vprnId1"
    Dut-$dut3 sendCliCommand "exit all"
    set errMsg [cookCliData [Dut-$dut3 sendCliCommand "admin rollback revert 2 now" -match_max 200000]]
    after 5000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackRevertResult [filter_getRollbackResult $dut3 revert]
    if {$rollbackRevertResult != "Successful" || [regexp "CLI Rollback revert failed" $errMsg]} {
      log_msg ERROR "error with reverting to rollback restore point-2 - $rollbackRevertResult - $errMsg" ; set result "FAILED"
    }
    log_msg INFO "Verify entry action"
    log_msg INFO "=> Verify service-name via info command"
    set r1 [ Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 1"]
    set r1 [ Dut-$dut3 sendCliCommand "info | match action"]; log_msg INFO $r1
#    if { [regexp " action forward router service-name (\"$serviceName1\")" $r1 match name] == 0 } {
#        log_msg ERROR "Wrong router name in info command output"; set result FAILED
#    } else {
#        log_msg INFO "Entry action is correct: action forward router service-name $name"
#    }
#    set r1 [ Dut-$dut3 sendCliCommand "exit all"]
    if { [regexp " action forward router ($vprnId1)" $r1 match name] == 0 } {
        log_msg ERROR "Wrong router id in info command output"; set testResultFlag "FAILED"
    }
    set r1 [ Dut-$dut3 sendCliCommand "exit all"]

    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8"]

    print_console_msg "STEP 7"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 7: Perform rollback to first restore point and verify action"
    log_msg INFO "----------------------------------------------------"
    # rollback to the first restore point
    log_msg INFO "Rollback to restore point-1 - entry with action forward"
    Dut-$dut3 sendCliCommand "exit all"
    set errMsg [cookCliData [Dut-$dut3 sendCliCommand "admin rollback revert 3 now" -match_max 200000]]
    after 5000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackRevertResult [filter_getRollbackResult $dut3 revert]
    if {$rollbackRevertResult != "Successful" || [regexp "CLI Rollback revert failed" $errMsg]} {
      log_msg ERROR "error with reverting to rollback restore point-1 - $rollbackRevertResult - $errMsg" ; set result "FAILED"
    }
    log_msg INFO "Verify entry action"
    log_msg INFO "=> Verify action forward"
    set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8 | match \"Next Hop\""]
    if { [regexp {Next Hop     : (Not Specified)} $r1 match name] == "0" } {
        log_msg ERROR "Default next hop is not correct"; set result "FAILED"
    } else {
        log_msg INFO "Entry action is correct: action forward"
    }
    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8"]
    # SNMP
    set r [Dut-$dut3 getT[getVar3 $filterType]FilterParamsFwdRtrId 8 1 ]
    set result [wccpCompareOutputString "0" $r]

    print_console_msg "STEP 8"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 8: Perform rollback to fourth restore point and verify action"
    log_msg INFO "----------------------------------------------------"
    # rollback to the fourth restore point
    log_msg INFO "Rollback to restore point-4 - entry with action forward router $vprnId2 without service-name"
    Dut-$dut3 sendCliCommand "exit all"
    set errMsg [cookCliData [Dut-$dut3 sendCliCommand "admin rollback revert latest-rb now" -match_max 200000]]
    after 5000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackRevertResult [filter_getRollbackResult $dut3 revert]
    if {$rollbackRevertResult != "Successful" || [regexp "CLI Rollback revert failed" $errMsg]} {
      log_msg ERROR "error with reverting to rollback restore point-4 - $rollbackRevertResult - $errMsg" ; set result "FAILED"
    }
    log_msg INFO "Verify entry action"
    log_msg INFO "=> Verify deleted service-name via info command (there should be router-instance in output: $vprnId2)"
    set r1 [ Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 1"]
    set r1 [ Dut-$dut3 sendCliCommand "info | match action"]; log_msg INFO $r1
    if { [regexp " action forward router ($vprnId2)" $r1 match name] == 0 } {
        log_msg ERROR "Wrong router id in info command output"; set result "FAILED"
    } else {
        log_msg INFO "Entry action is correct: action forward router $name"
    }
    set r1 [ Dut-$dut3 sendCliCommand "exit all"]
    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8"]

    # delete rollback restore points and rollback location
    set rCli [Dut-$dut3 sendCliCommand "admin rollback delete 3"] ; log_msg INFO "$rCli"
    set rCli [Dut-$dut3 sendCliCommand "admin rollback delete 2"] ; log_msg INFO "$rCli"
    set rCli [Dut-$dut3 sendCliCommand "admin rollback delete 1"] ; log_msg INFO "$rCli"
    set rCli [Dut-$dut3 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
    set rCli [Dut-$dut3 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"

    if { $result == "PASSED" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

    if {$opt(deconfig)} {
      saveOrRestore delete
    }
}

proc actionFwdRtr_radOverride_runTest {fltrType args} {

    global testdir logdir ixia_port

    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl

    set opt(debug)       false
    set opt(mode)        regular
    set opt(testOptions) "" ; # not used in this proc at this point in time
    set opt(hostType)    ""
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(debugPrint) true

    getopt opt $args

    set testID $::TestDB::currentTestCase
    set result PASSED
    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"

    ### randomly choose hostType and setupType for ESM test cases
    if {([getGlobalVar physTopology] == "scaleBed")} {
        set hostTypeIPv4 [lindex "dhcp4 arpHost" [random 2]]
        set hostTypeIPv6 [lindex "dhcp6_IAPD dhcp6_IANA" [random 2]]
    } else {
        set hostTypeIPv4 [lindex "dhcp4 arpHost pppoe_4 pppoe_46" [random 4]]
        set hostTypeIPv6 [lindex "dhcp6_IAPD dhcp6_IANA pppoe_6 pppoe_46" [random 4]]
    }
    if { $hostTypeIPv4 == "arpHost" } {
        set setupTypeIPv4 "ethernet_vprnRCO_subsap_CreditCntrl"
        set setupTypeIPv6 [lindex "nullEncap_iesRCO_subsap ethernet_iesRCO_subsap qinq_iesRCO_subsap lag_iesRCO_subsap nullEncap_vprnRCO_subsap ethernet_vprnRCO_subsap qinq_vprnRCO_subsap lag_vprnRCO_subsap" [random 8]]
    } else {
        set setupTypeIPv4 [lindex "nullEncap_iesRCO_subsap ethernet_iesRCO_subsap qinq_iesRCO_subsap lag_iesRCO_subsap nullEncap_vprnRCO_subsap ethernet_vprnRCO_subsap qinq_vprnRCO_subsap lag_vprnRCO_subsap" [random 8]]
        set setupTypeIPv6 [lindex "nullEncap_iesRCO_subsap ethernet_iesRCO_subsap qinq_iesRCO_subsap lag_iesRCO_subsap nullEncap_vprnRCO_subsap ethernet_vprnRCO_subsap qinq_vprnRCO_subsap lag_vprnRCO_subsap" [random 8]]
    }

    log_msg DEBUG "####################################################"
    if { $fltrType == "IP" } {
        log_msg DEBUG "Randomly choosed hostType: $hostTypeIPv4"
        log_msg DEBUG "Randomly choosed setupType: $setupTypeIPv4"
    } else {
        log_msg DEBUG "Randomly choosed hostType: $hostTypeIPv6"
        log_msg DEBUG "Randomly choosed setupType: $setupTypeIPv6"
    }
    log_msg DEBUG "####################################################"

    if {$fltrType == "IP"} {
        filter_radOverride_runTest $fltrType -hostType $hostTypeIPv4 -select $setupTypeIPv4 -testProc actionFwdRtr -mode $opt(mode)
    } else {
        filter_radOverride_runTest $fltrType -hostType $hostTypeIPv6 -select $setupTypeIPv6 -testProc actionFwdRtr -mode $opt(mode)
    }

    if { $result == "PASSED" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

}

proc filter_radOverride_actionFwdRtr {setupType args} {

    global testdir logdir ixia_port

    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl

    set opt(debug)       false
    set opt(mode)        regular
    set opt(testOptions) "" ; # not used in this proc at this point in time
    set opt(hostType)    ""
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(debugPrint) true

    getopt opt $args


    log_msg INFO "TEST CASE filterActionFwdRtr_radOverride for $setupType started - [exec date]"
    if {[filterTCAM_getGlobals $setupType ] != "OK"} {
        log_msg ERROR "unable to find correct parameters for $setupType"
        return FAILED
    }

    set testID $::TestDB::currentTestCase
    set result PASSED
    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"

    filterTCAM_ixInit $setupType

    ### find out, if card is IOM3 and higher or not (in case of older IOMs, PBR is not taken into account)
    if { $itfType == "lag" } {
        set iom3 ""
        foreach {port} $port_3_2 {
            if {[Dut-$dut3 isIom3Equipped [lindex [split $port "/"] 0]] != "TRUE"} {
                if {$iom3 == "true"} {set iom3 "none"} else {set iom3 "false"}
            } else {
                if {$iom3 == "false"} {set iom3 "none"} else {set iom3 "true"}
            }
        }
        log_msg NOTICE "iom3 $iom3"
        if {$iom3 == "none"} { log_msg ERROR "testing on lag with mixture of iom3 and non-iom3 ports, results for action forward router tests could be unpredictable" }
    } else {
        set iom3 [ string tolower [Dut-$dut3 isIom3Equipped [lindex [split $port_3_2 "/"] 0]]]
        if { $iom3 == "false" } {
            log_msg INFO "Used line card is NOT IOM3 and higher - verify, that traffic will be just forwarded and PBR is not taken into account"
        }
    }
    if { [regexp {vprn} $svcType] } { set opt(svcType) "vprn" }


    log_msg INFO ""
    log_msg INFO "=> Setup vprns to be used in filter action redirectToVFR"
    set vprnId1 10
    set vprnId2 2147483647
    set vprnId3 5000
    set vprnId4 123456
    set serviceName1 "testvprn $vprnId1"
    set serviceName2 "abcdefghijklmnopqrstuvxyz12345abcdefghijklmnopqrstuvxyz\~\!\@\%\^\&\*\(\)"
    set serviceName3 "testvprn $vprnId3"
    set serviceName4 "testvprn $vprnId4"
    set customer 0
    set i 1

    foreach {vprnId} "$vprnId1 $vprnId2 $vprnId3 $vprnId4" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service customer $i create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    configure service vprn $vprnId customer [expr $customer + $i] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        route-distinguisher 10.20.1.3:[expr $i + 1]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        service-name \"[ set serviceName$i]\""]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface vprn${vprnId}ToIxia3 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.0.1/24"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.0.1]/[maskConvert Ipv6 24]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:[expr $i + 1] create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "     static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    ### in case svcType is vprn, modify action in entry 40 to forward router Base - in such case, we need to create ies service with sap to IXIA port
    if { $opt(svcType) == "vprn" } {
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId4 interface vprn${vprnId4}ToIxia3 sap ${port_3_3}:5 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId4}ToIxia3 no sap ${port_3_3}:5"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "configure service ies 300 customer 1 vpn 1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia300 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            address 3.3.3.1/14"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            static-arp 3.3.0.2 00:00:01:00:03:03"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            ipv6"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                address [ipConvert Ipv6 3.3.3.1]/[maskConvert Ipv6 14]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "                neighbor [ipConvert Ipv6 3.3.0.2] 00:00:01:00:03:0$i"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            sap ${port_3_3}:5 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    }

    # create filter logs
    set r1 [Dut-$dut3 setTFilterLogRowStatus 110 createAndGo ]
    set r2 [Dut-$dut3 setTFilterLogRowStatus 120 createAndGo ]
    set r3 [Dut-$dut3 setTFilterLogRowStatus 130 createAndGo ]
    set r4 [Dut-$dut3 setTFilterLogRowStatus 140 createAndGo ]
    set r5 [Dut-$dut3 setTFilterLogRowStatus 150 createAndGo ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "failed to create filterlogs in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
    }

    # use shell commands to set radius-cache timeout to smaller value (check with "word sbmRadiusCacheTimeout" in kernel)
    Dut-$dut3 sendCliCommand "shell sbmRadiusCacheSetTimeout 1"
    Dut-$dut3 sendCliCommand "shell cardcmd [Dut-$dut3 findInactiveCpm] sbmRadiusCacheSetTimeout 1"
    # for arp-host also disable min-auth-interval of 1 minute via shellcmd
    Dut-$dut3 sendCliCommand "shell setVar8 arpHostAlwaysReauth 1"
    Dut-$dut3 sendCliCommand "shell cardcmd [Dut-$dut3 findInactiveCpm] setVar8 arpHostAlwaysReauth 1"
    set waitHostSetup    3000
    set waitRadiusCache  3000

    ### make this test run on dhcp4, dhcp6_IANA, pppoe_4, pppoe_6, pppoe_46

    set hostType $opt(hostType)
    if {[regexp {arpHost} $hostType]} { set ixHost  1 } else { set ixHost  0 } ; # second host to remote ixPort in case of arpHost Setup
    if {[regexp {pppoe_46} $hostType]} { set numHost 2 } else { set numHost 1 } ; # 2 hosts in case of pppoe_46

    set dualRsc46 false ; # resource difference should always be there - fixed with dts128203

    # set debug logging with filters
    Dut-$dut3 sendCliCommand "configure log log-id 10 from main"
    Dut-$dut3 sendCliCommand "configure log log-id 10 to memory"

    if {$filterType == "IP"} { set fTypeList "IP 4"} else { set fTypeList "IPv6 6"}
    if {[regexp {46} $hostType]} {
      if {$filterType == "IP"} {
        set fTypeList "IP 4 IPv6 6"
        set filterType2 IPv6
      } else {
        set fTypeList "IPv6 6 IP 4"
        set filterType2 IP
      }
    }

    # use subhostIp1,2,3 and subhostMac1,2,3 corresponding with ixia subscriber streams
    set subhostIp [ipConvert $filterType $subhostIp1]
    set sapName $sapName_3_2$encapName
    set slaName sla1

    # configure ixia streams, first without IP options
    # redirectToVRF action will not work for pkts with options because they are sent from CPM - PBR should be ignored than
    # streams 2-5 with ip-options will be just forwarded (not redirected)
    # switch ixia streams to filterTCAM streams for subHost1
    handlePacket -portList [list $ixport1 $ixport3] -action reset -scheduler sequential
    if {[regexp {pppoe} $opt(hostType)]} { set opt(pppoe) true } else { set opt(pppoe) false }
    set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions false -pppoe $opt(pppoe)]
    set streamIdList ""
    for {set i 1} {$i <= $numStreams} {incr i} { lappend streamIdList $i }
    filterTCAM_ixTestTraffic $streamIdList

    # use all 6 traffic streams to test entry action 
    # pppoe stream4 will hit high-priority entry5 in ip-filter (need to check how to specify icmp-type for pppoe stream4 in filterTCAM_ixConfigStreams)
#    if {([regexp {pppoe} $opt(hostType)]) && ($filterType == "IP")} { set numStreams 3 }

    # configure IP filter to forward matching traffic in Dut dut3
    log_msg INFO "Create $filterType filter 8"
    set r1 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 8]
    set r2 [Dut-$dut3 setFilterInsert Radius [getVar3 $filterType] 8 1000 100]
    set r3 [Dut-$dut3 setFilterInsert HostShared [getVar3 $filterType] 8 1100 100]

    if {([regexp {pppoe_46} $hostType])} {
        # create also filterType2 filter
        log_msg INFO "Create $filterType2 filter 8"
        set r1 [Dut-$dut3 create[getVar1 $filterType2]FilterPolicy 8]
        set r2 [Dut-$dut3 setFilterInsert Radius [getVar3 $filterType2] 8 1000 100]
        set r3 [Dut-$dut3 setFilterInsert HostShared [getVar3 $filterType2] 8 1100 100]
    }

    # clear host in order to be able assign filter to sla-profile - otherwise you get snmp error: SLA profile is in use by one or more active subscribers
    filter_subinsert_radius_clearHost $subhostIp -hostType $hostType

    # assign filter to sla-profile
    log_msg INFO "Assign filter to sla-profile"
    set direction "Ingress Egress"
    set filterID  8
    foreach {fType fvers} $fTypeList {
        foreach {dirStr dir} "Ing ingress Egr egress" {
            ### SNMP
            log_msg INFO "Trying to associate $dir $fType filter $filterID with sla-profile $slaName"
            set r [Dut-$dut3 setTmnxSLAProf[set dirStr][getVar3 $fType]FilterId $slaName $filterID]
            if {$r != "noError"} {
                log_msg ERROR "failed to associate $dir $fType filter 8 with sla-profile $slaName - returned $r" ; set result FAILED
            }
        }
    }

    log_msg INFO "Create entries for $filterType filter 8"
    set vprnNameOrId [ expr round( rand() ) ]
    if { $vprnNameOrId == 1 } {set vprnNameOrId "router service-name"; set vprn1 $serviceName1; set vprn2 $serviceName2; set vprn3 $serviceName3; set vprn4 $serviceName4} else {set vprnNameOrId "router"; set vprn1 $vprnId1; set vprn2 $vprnId2; set vprn3 $vprnId3; set vprn4 $vprnId4}

    if {$filterType == "IP"} {set matchProtocol "protocol"} else {set matchProtocol "next-header"}
    if {$filterType == "IP"} { set fltrMask 16 } else { set fltrMask [maskConvert $family 16] }
    set fltrSrcAddr [ipv62MibVal [ipConvert $family 3.3.0.0]]
    set fltrDstAddr [ipv62MibVal [ipConvert $family 1.1.0.0]]
    set fltrSrcAddrCLI [ipConvert $family 3.3.0.0]
    set fltrDstAddrCLI [ipConvert $family 1.1.0.0]

    set testList ""
    set testList2 ""
#    if {$opt(pppoe) == "false"} {set streamID 8} else {set streamID 7}
    set streamID 7
    if { $filterType == "IP" } {
        set stream_egr "1 2 3 4"
        lappend testList 1 "match $matchProtocol tcp tcp syn true"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
        lappend testList 2 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
        lappend testList 3 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
        if { $opt(svcType) == "vprn" } {
            lappend testList 4 "match $matchProtocol icmp"              40 "action forward router Base" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
        } else {
            lappend testList 4 "match $matchProtocol icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
        }
    } else {
        set stream_egr "1 2 4 5"
        lappend testList $streamID "match $matchProtocol sctp"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
        lappend testList 4 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
        lappend testList 5 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
        if { $opt(svcType) == "vprn" } {
            lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward router Base" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
        } else {
            lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
            lappend testList2 [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
        }
        # create new stream - IPv6 packet with next-header sctp
        if {[getGlobalVar physTopology] == "scaleBed"} { set ing_port 5; set eg_port 1 } else { set ing_port 1; set eg_port 3 }
        set portList [list $ixport1 ]
        scan $ixport1 "%d %d %d" chassis card port
        port get $chassis $card $port
        stream get $chassis $card $port 1
        set da_mac [join [split [stream cget -da] " "] ":"]
        set sa_mac [join [split [stream cget -sa] " "] ":"]
        if {$opt(pppoe) == "false"} {
            handlePacket -port $ing_port -dot1q 1 -dst 3FFE::303:2:0:0:0:0 -numDest 1 -src 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -samac $sa_mac -stream $streamID -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        } else {
            handlePacket -port $ing_port -dot1q 1 -dst 3FFE::303:2:0:0:0:0 -numDest 1 -src 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -samac $sa_mac -stream 7 -PPPoESessionId 1 -iplen 1400 -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        }
        after 1000
        stream get $chassis $card $port $streamID
        stream config  -enable  false
        stream set $chassis $card $port $streamID
        stream write $chassis $card $port $streamID

        set portList [list $ixport3 ]
        scan $ixport3 "%d %d %d" chassis card port
        port get $chassis $card $port
        stream get $chassis $card $port 1
        set da_mac [join [split [stream cget -da] " "] ":"]
        set sa_mac [join [split [stream cget -sa] " "] ":"]
        if {$opt(pppoe) == "false"} {
            handlePacket -port $eg_port -dot1q 1 -src 3FFE::303:2:0:0:0:0 -numDest 1 -dst 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -samac $sa_mac -stream 7 -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        } else {
            handlePacket -port $eg_port -dot1q 1 -src 3FFE::303:2:0:0:0:0 -numDest 1 -dst 3FFE::101:2:0:0:0:0 -numSource 1 -damac $da_mac -samac $sa_mac -stream 7 -PPPoESessionId 1 -iplen 1400 -framesize 100 -rawProtocol 132 -packetsPerBurst 20 -rate 20 -loop 1 -action createdownloadstart
        }
        after 1000
        stream get $chassis $card $port 7
        stream config  -enable  false
        stream set $chassis $card $port 7
        stream write $chassis $card $port 7
    }
    # create entries and set action forward router
    set configType [ expr round( rand() ) ]
    # if $configType=0, configuration will be performed via CLI, otherwise via SNMP
    if { $configType == 1 } {
        if {$filterType == "IP"} {set matchProtocolSNMP "-Protocol"} else {set matchProtocolSNMP "-NextHeader"}
        if {$filterType == "IP"} {
            set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 10 $matchProtocolSNMP 6 -TcpSyn true -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId1] ]
            set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId2] ]
            set r3 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 30 $matchProtocolSNMP 17 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId3] ]
            if { $opt(svcType) == "vprn" } {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 1 -Action forward -FwdRtrId 1 ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId 1] ]
            } else {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 1 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId4] ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId 1 ]
            }
        } else {
            set r1 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 10 $matchProtocolSNMP 132 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId1] ]
            set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 20 $matchProtocolSNMP 6 -TcpSyn false -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId2] ]
            set r3 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 30 $matchProtocolSNMP 17 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId3] ]
            if { $opt(svcType) == "vprn" } {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 58 -Action forward -FwdRtrId 1 ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId 1] ]
            } else {
                set r4 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 40 $matchProtocolSNMP 58 -Action forward -FwdRtrId [Dut-$dut3 getVRtrInstanceId $vprnId4] ]
                set r5 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 8 1 -SourceIpAddr $fltrSrcAddr -SourceIpMask $fltrMask -Action forward -FwdRtrId 1 ]
            }
        }
        if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
            log_msg ERROR "failed to create $filterType filter entries with different actions in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
            set result FAILED
        }
    } else {
        Dut-C sendCliCommand "exit all"
        foreach {strId strMatch entryId strAction logId} $testList {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
        foreach {strId strMatch entryId strAction logId} $testList2 {
            log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
            Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
            Dut-$dut3 sendCliCommand $strAction
            Dut-$dut3 sendCliCommand $strMatch
            Dut-$dut3 sendCliCommand "exit all"
        }
    }
    ### add second match criterium for entry 1 - in order to eliminate hits by control traffic
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 1 create"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrDstAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"
    # add filter logs to the different entries
    set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 10 110 ]
    set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 20 120 ]
    set r3 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 30 130 ]
    set r4 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 40 140 ]
    set r5 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsLogId 8 1 150 ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "failed to assign filterlogs to $filterType filter entries in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
     }

    # bind same filter on egress of each configured VPRN - in order to verify hit counters
    log_msg INFO "Bind same filter on ingress of each configured VPRN in order to verify hit counters"
    for {set i 1} {$i <= 4} {incr i} {
        if { ($opt(svcType) == "vprn") && ($i == 4) } {
#            set r1 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            set r2 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
        } else {
#            set r1 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            set r2 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
        }
        if {($r2 != "noError")} {
            log_msg ERROR "Failed to assign filter: $filterID to ingress of VPRN: [set vprnId${i}] ,found $r2"
            set result FAILED
         }
    }

    ### configure additional match criteria for entry 40 - in order to block unwanted hits of ICMP packets
    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry 40"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "match src-ip $fltrDstAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"

#interpreter

    log_msg INFO "----------------------------------------------------"
    log_msg INFO " Host creation with sla filter"
    log_msg INFO "----------------------------------------------------"

#    print_console_msg "Clear host before starting test"
#    filter_subinsert_radius_clearHost $subhostIp -hostType $hostType
    after 3000
    print_console_msg "Host setup with sla filter"
    set SubscrFilterString "ingr-v4:-2, egr-v4:-2, ingr-v6:-2, egr-v6:-2"
    foreach {dir} "ingress egress" { set testFltr($dir) 8; set hostFltr($dir) 0 }

    if {$filterType == "IP"} {set ixStreamNbr 8} else {set ixStreamNbr 7}
    
    filter_radOverride_changeHost $sapName $subhostIp $subhostMac1 $slaName $hostType "initial authentication" true $ixStreamNbr -filterAttr $SubscrFilterString
    filter_subinsert_checkNumHosts $dut3 [expr $numHost + $ixHost]
    filter_radOverride_checkCliSnmp $hostType $subhostIp $subhostMac1 $slaName $hostFltr(ingress) $hostFltr(egress) 8

    set testList_bck $testList; set testList2_bck $testList2
    if {[regexp {pppoe} $opt(hostType)]} {
        set testList ""
        set testList2 ""
        if { $filterType == "IP" } {
#            set stream_egr "1 2 3 4"
            lappend testList 1 "match $matchProtocol tcp tcp syn true"  20 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList 2 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList 3 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList 4 "match $matchProtocol icmp"              40 "action forward router Base" 140
#                lappend testList2_ppp [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
            } else {
                lappend testList 4 "match $matchProtocol icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
#                lappend testList2_ppp [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
            }
        } else {
#            set stream_egr "1 2 4 5"
#            lappend testList 7 "match $matchProtocol sctp"  10 "action forward $vprnNameOrId \"$vprn1\"" 110
            lappend testList 4 "match $matchProtocol tcp tcp syn false" 20 "action forward $vprnNameOrId \"$vprn2\"" 120
            lappend testList 5 "match $matchProtocol udp"               30 "action forward $vprnNameOrId \"$vprn3\"" 130
            if { $opt(svcType) == "vprn" } {
                lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward router Base" 140
#                lappend testList2_ppp [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router 1" 150
            } else {
                lappend testList 2 "match $matchProtocol ipv6-icmp"              40 "action forward $vprnNameOrId \"$vprn4\"" 140
#                lappend testList2_ppp [lindex $stream_egr [random 4]] "match src-ip $fltrSrcAddrCLI/$fltrMask"  1 "action forward router Base" 150
            }
        }
    }

    log_msg INFO "Check ingress and egress subscriber host traffic is hitting $filterType filter 8"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
    }
    set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -pppoe $opt(pppoe)]
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

    log_msg INFO "verifying resources on CPM and IOM are matching for Dut-$dut3"
    set r [ resMgr_verify_resources OK -dut Dut-$dut3 -maxTries 1 ]
    if {$r != "OK"} { log_msg ERROR "resource mismatch between CPM and IOM for Dut-$dut3, found $r" ; set result FAILED }

    # Create copy of shared sla filter by subinserting shared radius
    log_msg INFO "----------------------------------------------------"
    log_msg INFO " Create copy of shared sla filter by subinserting shared radius"
    log_msg INFO "----------------------------------------------------"

    set msgList [list "radius COA" "initial authentication"]
    set nasRuleList ""
    set nasRule(ingress) "permit in ip from any to any"
    set nasRule(egress)  "permit out ip from any to any"
    lappend nasRuleList $nasRule(ingress) $nasRule(egress)
    set attrTestList "" ; lappend attrTestList Alc-NAS-Filter-Rule-Shared ; lappend attrTestList $nasRuleList
    filter_radius_changeHost $sapName $subhostIp $subhostMac1 $slaName $hostType "initial authentication" -ruleList $attrTestList \
        -hostSucceed true -filterList $SubscrFilterString -numStreams $ixStreamNbr
    filter_subinsert_checkNumHosts $dut3 [expr $numHost + $ixHost]
    set numSharedFilters [Dut-$dut3 getT[getVar3 $filterType]FilterNbrHostSharedFltrs 8]
    if {$numSharedFilters != 2} {
        log_msg ERROR "Unexpected shared filter number - $numSharedFilters" ; set result FAILED
    }

    # find out the shared filters
    set sharedFilterId_ingress "" ; set sharedFilterId_egress ""
    foreach {dir} "ingress egress" {
        foreach {lagPort} $port_3_2 {
            set dldList [filterScaleGetDownloadedFilters $dut3 [filterScale_getIom $dut3 $lagPort] $filterType -direction $dir]
            foreach {dldFilter} $dldList {
                if {$dldFilter > $maxFilterId} {
                    # this is a shared filter
                    if {[lsearch -exact [set sharedFilterId_[set dir]] $dldFilter] == -1} {
                        lappend sharedFilterId_[set dir] $dldFilter
                    }
                }
            }
        }
    }
    if {[llength $sharedFilterId_ingress] != 1 || [llength $sharedFilterId_egress] != 1} {
        log_msg ERROR "Expected to find 1 shared $filterType filter in each direction but found - $sharedFilterId_ingress, $sharedFilterId_egress" ; set result FAILED
    }
    
    log_msg INFO "Verify, that after receiving shared filter subinsert rule from radius, shared filter copy based on the user-defined filter is created and all entries with action forward router are successfully copied as well - verify with traffic"
    # find the sequence number of shared filter copy (ingress filter)
    foreach {baseFilter seqNbr} [filter_getSharedFilterBaseSeq $sharedFilterId_ingress] {}
    foreach {baseFilterEg seqNbrEg} [filter_getSharedFilterBaseSeq $sharedFilterId_egress] {}
    log_msg INFO "Sequence number of shared filter copy (ingress filter) is $seqNbr"
    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType]"]
    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr}"]
    
    set testList_shared ""
    lappend testList_shared 10 $vprnId1 $serviceName1
    lappend testList_shared 20 $vprnId2 $serviceName2
    lappend testList_shared 30 $vprnId3 $serviceName3
    if { $opt(svcType) != "vprn" } {
        lappend testList_shared 40 $vprnId4 $serviceName4
    }
    foreach { entryId vprnId serviceName } $testList_shared {
        set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
        set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr} entry $entryId | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
            if { $id != $vprnId } { 
                log_msg ERROR "Wrong router id ($id) set in action of entry: $entryId"; set result FAILED 
            } else {log_msg INFO "Entry: $entryId with action forward router service-name \"$serviceName\" is successfully copied into $filterType filter 8:$seqNbr "
            }
        } else { log_msg ERROR "Not possible to parse digit for routerId"; set result FAILED }
    }

    log_msg INFO "Check ingress subscriber host traffic is hitting $filterType filter 8:${seqNbr}"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF)"
    }
    set r [fwdRtr_checkTraffic_radOverride $setupType $testList $testList2 -withOptions false -pppoe $opt(pppoe) -filterCopySeqNumber $seqNbr -filterCopySeqNumberEgress $seqNbrEg -filterCopyId $sharedFilterId_ingress -filterCopyIdEgress $sharedFilterId_egress]
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

    log_msg INFO "----------------------------------------------------"
    log_msg INFO " Verify that changes in user-defined filter will be applied in shared filter copy"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Change action in $filterType filter for all entries to forward"
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 1 action forward"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 10 action forward"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 20 action forward"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 30 action forward"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 40 action forward"]; log_msg INFO $rCli

    log_msg INFO "Verify action forward in all entries"
    foreach { seqID } "$seqNbr $seqNbrEg" {
        foreach { entryId vprnId serviceName } $testList_shared {
            set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
            set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqID} entry $entryId | match \"Next Hop\""]
            if { [regexp {Next Hop     : (Not Specified)} $r1 match] } {
                log_msg INFO "Action is successfully changed to \"forward\" in shared filter copy $filterType 8:${seqID}"
            } else { 
                log_msg ERROR "Action is not successfully changed to \"forward\" in shared filter copy $filterType 8:${seqID}" 
                set result FAILED 
                puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqID}"]
            }
        }
    }
    log_msg INFO "Create another entry in user-defined filter and verify, that it will be copied into shared filter copy"
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 entry 123 create action forward router $vprnId2"]; log_msg INFO $rCli
    log_msg INFO "Verify new entry"
    foreach { seqID } "$seqNbr $seqNbrEg" {
        foreach { entryId vprnId serviceName } "123 $vprnId2 abc" {
            set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
            set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqID} entry $entryId | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
                if { $id != $vprnId } {
                    log_msg ERROR "Wrong router id ($id) set in action of entry: $entryId"; set result FAILED
                } else {log_msg INFO "Entry: $entryId with action forward router $vprnId is successfully copied into $filterType filter 8:$seqID "
                }
            } else { log_msg ERROR "Not possible to parse digit for routerId"; set result FAILED }
        }
    }


    log_msg INFO "Delete new entry and configure back action forward router in all entries"
    set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 8 no entry 123"]; log_msg INFO $rCli
    foreach {strId strMatch entryId strAction logId} $testList_bck {
        log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
        Dut-$dut3 sendCliCommand $strAction
        Dut-$dut3 sendCliCommand $strMatch
        Dut-$dut3 sendCliCommand "exit all"
    }
    foreach {strId strMatch entryId strAction logId} $testList2_bck {
        log_msg DEBUG "Adding entry $entryId with $strMatch and $strAction in [getVar4 $filterType]-filter 8"
        Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 8 entry $entryId create"
        Dut-$dut3 sendCliCommand $strAction
        Dut-$dut3 sendCliCommand $strMatch
        Dut-$dut3 sendCliCommand "exit all"
    }
    foreach { entryId vprnId serviceName } $testList_shared {
        set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
        set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr} entry $entryId | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
            if { $id != $vprnId } {
                log_msg ERROR "Wrong router id ($id) set in action of entry: $entryId"; set result FAILED
            } else {log_msg INFO "Entry: $entryId with action forward router service-name \"$serviceName\" is successfully copied into $filterType filter 8:$seqNbr "
            }
        } else { log_msg ERROR "Not possible to parse digit for routerId"; set result FAILED }
    }

    log_msg INFO "Check ingress subscriber host traffic is hitting $filterType filter 8:${seqNbr}"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF)"
    }
    set r [fwdRtr_checkTraffic_radOverride $setupType $testList $testList2 -withOptions false -pppoe $opt(pppoe) -filterCopySeqNumber $seqNbr -filterCopySeqNumberEgress $seqNbrEg -filterCopyId $sharedFilterId_ingress -filterCopyIdEgress $sharedFilterId_egress]
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

    log_msg INFO "----------------------------------------------------"
    log_msg INFO " Host creation with override filter"
    log_msg INFO "----------------------------------------------------"

    # clear the host
    log_msg INFO "clear the host"
    filter_subinsert_radius_clearHost $subhostIp -hostType $hostType
    # Verify that a host can be setup with embedding override filters
    print_console_msg "Host setup with override filter"
    set SubscrFilterString "ingr-v4:8, egr-v4:8, ingr-v6:8, egr-v6:8"
    foreach {dir} "ingress egress" { set testFltr($dir) 8 ; set hostFltr($dir) 8 }
    filter_radOverride_changeHost $sapName $subhostIp $subhostMac1 $slaName $hostType "initial authentication" true $ixStreamNbr -filterAttr $SubscrFilterString
    filter_subinsert_checkNumHosts $dut3 [expr $numHost + $ixHost]
    filter_radOverride_checkCliSnmp $hostType $subhostIp $subhostMac1 $slaName $hostFltr(ingress) $hostFltr(egress) 8

    log_msg INFO "Check ingress and egress subscriber host traffic is hitting $filterType filter 8"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF) and also direction from Dut-$dut3 to Dut-$dut1 (redirect from VRF to GRT)"
    }
    if { ($iom3 == "false") || ($opt(svcType) == "L2Service") } {
        set r [fwdRtr_checkTraffic_nonRouted $setupType $testList $testList2 -withOptions false]
    } else {
        set r [fwdRtr_checkTraffic $setupType $testList $testList2 -withOptions false -pppoe $opt(pppoe)]
    }
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

    # Create copy of shared Ov filters by subinserting shared radius
    log_msg INFO "----------------------------------------------------"
    log_msg INFO " Create copy of shared Ov filters by subinserting shared radius"
    log_msg INFO "----------------------------------------------------"
    set nasRuleList ""
    set nasRule(ingress) "permit in ip from any to any"
    set nasRule(egress)  "permit out ip from any to any"
    lappend nasRuleList $nasRule(ingress) $nasRule(egress)
    set attrTestList "" ; lappend attrTestList Alc-NAS-Filter-Rule-Shared ; lappend attrTestList $nasRuleList
    filter_radius_changeHost $sapName $subhostIp $subhostMac1 $slaName $hostType "initial authentication" -ruleList $attrTestList \
        -hostSucceed true -filterList $SubscrFilterString -numStreams $ixStreamNbr
    filter_subinsert_checkNumHosts $dut3 [expr $numHost + $ixHost]
    set numSharedFilters [Dut-$dut3 getT[getVar3 $filterType]FilterNbrHostSharedFltrs 8]
    if {$numSharedFilters != 2} {
        log_msg ERROR "Unexpected shared filter number - $numSharedFilters" ; set result FAILED
    }
    # find out the shared filters
    set sharedFilterId_ingress "" ; set sharedFilterId_egress ""
    foreach {dir} "ingress egress" {
        foreach {lagPort} $port_3_2 {
            set dldList [filterScaleGetDownloadedFilters $dut3 [filterScale_getIom $dut3 $lagPort] $filterType -direction $dir]
            foreach {dldFilter} $dldList {
                if {$dldFilter > $maxFilterId} {
                    # this is a shared filter
                    if {[lsearch -exact [set sharedFilterId_[set dir]] $dldFilter] == -1} {
                        lappend sharedFilterId_[set dir] $dldFilter
                    }
                }
            }
        }
    }
    if {[llength $sharedFilterId_ingress] != 1 || [llength $sharedFilterId_egress] != 1} {
        log_msg ERROR "Expected to find 1 shared $filterType filter in each direction but found - $sharedFilterId_ingress, $sharedFilterId_egress" ; set result FAILED
    }

    log_msg INFO "Verify, that after receiving shared filter subinsert rule from radius, shared filter copy based on the user-defined filter is created and all entries with action forward router are successfully copied as well - verify with traffic"
    # find the sequence number of shared filter copy (ingress filter)
    foreach {baseFilter seqNbr} [filter_getSharedFilterBaseSeq $sharedFilterId_ingress] {}
    foreach {baseFilterEg seqNbrEg} [filter_getSharedFilterBaseSeq $sharedFilterId_egress] {}
    log_msg INFO "Sequence number of shared filter copy (ingress filter) is $seqNbr"
    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType]"]
    puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr}"]

    set testList_shared ""
    lappend testList_shared 10 $vprnId1 $serviceName1
    lappend testList_shared 20 $vprnId2 $serviceName2
    lappend testList_shared 30 $vprnId3 $serviceName3
    if { $opt(svcType) != "vprn" } {
        lappend testList_shared 40 $vprnId4 $serviceName4
    }
    foreach { entryId vprnId serviceName } $testList_shared {
        set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
        set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr} entry $entryId | match Fwd"]
        if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
            if { $id != $vprnId } {
                log_msg ERROR "Wrong router id ($id) set in action of entry: $entryId"; set result FAILED
            } else {log_msg INFO "Entry: $entryId with action forward router service-name \"$serviceName\" is successfully copied into $filterType filter 8:$seqNbr "
            }
        } else { log_msg ERROR "Not possible to parse digit for routerId"; set result FAILED }
    }

    log_msg INFO "Check ingress subscriber host traffic is hitting $filterType filter 8:${seqNbr}"
    if { $opt(svcType) == "vprn" } {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF)"
    } else {
        log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF)"
    }
    set r [fwdRtr_checkTraffic_radOverride $setupType $testList $testList2 -withOptions false -pppoe $opt(pppoe) -filterCopySeqNumber $seqNbr -filterCopySeqNumberEgress $seqNbrEg -filterCopyId $sharedFilterId_ingress -filterCopyIdEgress $sharedFilterId_egress]
    if {$r != "PASSED"} {
        if {$opt(debugPrint) == "true"} {
            filterTCAM_debug $setupType
            set opt(debugPrint) false
        }
        set result FAILED
    }

#interpreter

    # HA tests
    if { $opt(mode) == "extensive" } {
      set haTestList ""
      lappend haTestList "HA Switch-Over"
      lappend haTestList "HA Switch-Over"
      lappend haTestList "clear IOM"
      lappend haTestList "port shutdown"
      lappend haTestList "clear MDA"
      foreach {haTest} $haTestList {
        print_console_msg "$haTest with shared override filters"
        if {$haTest == "HA Switch-Over"} {
          Dut-$dut3 activitySwitch
        } elseif {$haTest == "clear IOM"} {
          foreach {lagPort} $port_3_2 {
              Dut-$dut3 sendCliCommand "exit all" ; Dut-$dut3 sendCliCommand "clear card [lindex [split $lagPort "/"] 0]"
          }
          Dut-$dut3 CnWCardStatus ; after 30000
        } elseif {$haTest == "port shutdown"} {
          foreach {lagPort} $port_3_2 {
              Dut-$dut3 sendCliCommand "exit all" ; Dut-$dut3 sendCliCommand "configure port $lagPort shutdown" ; after 5000
              if {[Dut-$dut3 getTmnxPortOperStatus 1 [Dut-$dut3 convert_port_ifIndex port $lagPort]] != "outOfService"} {
                log_msg ERROR "port $lagPort still not outOfService 5 seconds after shutdown" ; set result FAIL
              }
              Dut-$dut3 sendCliCommand "exit all" ; Dut-$dut3 sendCliCommand "configure port $lagPort no shutdown" ; after 15000
              if {[Dut-$dut3 getTmnxPortOperStatus 1 [Dut-$dut3 convert_port_ifIndex port $lagPort]] != "inService"} {
                log_msg ERROR "port $lagPort still not inService 15 seconds after no shutdown" ; set result FAIL
              }
          }
        } elseif {$haTest == "clear MDA"} {
          foreach {lagPort} $port_3_2 {
              Dut-$dut3 sendCliCommand "exit all"
              Dut-$dut3 sendCliCommand "clear mda [lindex [split $lagPort "/"] 0]/1" ; Dut-$dut3 sendCliCommand "clear mda [lindex [split $lagPort "/"] 0]/2"
          }
          Dut-$dut3 CnWMdaStatus -Time 300
        }
        # find out the shared filters
        set sharedFilterId_ingress "" ; set sharedFilterId_egress ""
        foreach {dir} "ingress egress" {
            foreach {lagPort} $port_3_2 {
                set dldList [filterScaleGetDownloadedFilters $dut3 [filterScale_getIom $dut3 $lagPort] $filterType -direction $dir]
                foreach {dldFilter} $dldList {
                    if {$dldFilter > $maxFilterId} {
                        # this is a shared filter
                        if {[lsearch -exact [set sharedFilterId_[set dir]] $dldFilter] == -1} {
                            lappend sharedFilterId_[set dir] $dldFilter
                        }
                    }
                }
            }
        }
        if {[llength $sharedFilterId_ingress] != 1 || [llength $sharedFilterId_egress] != 1} {
            log_msg ERROR "Expected to find 1 shared $filterType filter in each direction but found - $sharedFilterId_ingress, $sharedFilterId_egress" ; set result FAILED
        }
        foreach {baseFilter seqNbr} [filter_getSharedFilterBaseSeq $sharedFilterId_ingress] {}
        foreach {baseFilterEg seqNbrEg} [filter_getSharedFilterBaseSeq $sharedFilterId_egress] {}
        log_msg INFO "Sequence number of shared filter copy (ingress filter) is $seqNbr"
        puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType]"]
        puts [Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr}"]

        set testList_shared ""
        lappend testList_shared 10 $vprnId1 $serviceName1
        lappend testList_shared 20 $vprnId2 $serviceName2
        lappend testList_shared 30 $vprnId3 $serviceName3
        if { $opt(svcType) != "vprn" } {
            lappend testList_shared 40 $vprnId4 $serviceName4
        }
        foreach { entryId vprnId serviceName } $testList_shared {
            set r1 [ Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $r1
            set r1 [ Dut-$dut3 sendCliCommand "/show filter [getVar4 $filterType] 8:${seqNbr} entry $entryId | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\d+)} $r1 match id] } {
                if { $id != $vprnId } {
                    log_msg ERROR "Wrong router id ($id) set in action of entry: $entryId"; set result FAILED
                } else {log_msg INFO "Entry: $entryId with action forward router service-name \"$serviceName\" is successfully copied into $filterType filter 8:$seqNbr "
                }
            } else { log_msg ERROR "Not possible to parse digit for routerId"; set result FAILED }
        }

        log_msg INFO "Check ingress subscriber host traffic is hitting $filterType filter 8:${seqNbr}"
        if { $opt(svcType) == "vprn" } {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from VRF to VRF)"
        } else {
            log_msg INFO "Check redirected traffic for each entry and streams: Direction from Dut-$dut1 to Dut-$dut3 (redirect from GRT to VRF)"
        }
        set r [fwdRtr_checkTraffic_radOverride $setupType $testList $testList2 -withOptions false -pppoe $opt(pppoe) -filterCopySeqNumber $seqNbr -filterCopySeqNumberEgress $seqNbrEg -filterCopyId $sharedFilterId_ingress -filterCopyIdEgress $sharedFilterId_egress]
        if {$r != "PASSED"} {
            if {$opt(debugPrint) == "true"} {
                filterTCAM_debug $setupType
                set opt(debugPrint) false
            }
            set result FAILED
        }
      # restore shell settings after activityswitches
      Dut-$dut3 sendCliCommand "exit all"
      # use shell commands to set radius-cache timeout to smaller value (check with "word sbmRadiusCacheTimeout" in kernel)
      Dut-$dut3 sendCliCommand "shell sbmRadiusCacheSetTimeout 1"
      Dut-$dut3 sendCliCommand "shell cardcmd [Dut-$dut3 findInactiveCpm] sbmRadiusCacheSetTimeout 1"
      # for arp-host also disable min-auth-interval of 1 minute via shellcmd
      Dut-$dut3 sendCliCommand "shell setVar8 arpHostAlwaysReauth 1"
      Dut-$dut3 sendCliCommand "shell cardcmd [Dut-$dut3 findInactiveCpm] setVar8 arpHostAlwaysReauth 1"
      Dut-$dut3 sendCliCommand "exit all"
      }
    }

    # cleanup
    print_console_msg "cleanup host and test config"
    filter_subinsert_radius_clearHost $subhostIp -hostType $hostType

    Dut-$dut3 sendCliCommand "configure log log-id 10 shutdown"
    Dut-$dut3 sendCliCommand "configure log no log-id 10"

    # reset to default
    Dut-$dut3 sendCliCommand "shell sbmRadiusCacheSetTimeout 10"
    Dut-$dut3 sendCliCommand "shell cardcmd [Dut-$dut3 findInactiveCpm] sbmRadiusCacheSetTimeout 10"
    Dut-$dut3 sendCliCommand "shell setVar8 arpHostAlwaysReauth 0"
    Dut-$dut3 sendCliCommand "shell cardcmd [Dut-$dut3 findInactiveCpm] setVar8 arpHostAlwaysReauth 0"

    ### unbind filter from VPRNs
    for {set i 1} {$i <= 4} {incr i} {
        if { ($opt(svcType) == "vprn") && ($i == 4) } {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 $filterID ]
            set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId 300 [Dut-$dut3 convert_port_ifIndex port $port_3_3] 5 0 ]
        } else {
#                    set r11 [ Dut-$dut3 setSapEgress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] $filterID ]
            set r12 [ Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [set vprnId${i}] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [expr $i + 1] 0 ]
        }
        if {($r12 != "noError")} {
            log_msg ERROR "Failed to deassign filter: $filterID from ingress in VPRN: [set vprnId${i}] ,found $r12"
            set result FAILED
         }
    }

    ### unbind filter from sla-profile, delete filter
    set cliCmdList ""
    lappend cliCmdList "exit all"
    foreach {fType fvers} $fTypeList {
        lappend cliCmdList "configure subscriber-mgmt sla-profile $slaName ingress no [string tolower $fType]-filter"
        lappend cliCmdList "configure subscriber-mgmt sla-profile $slaName  egress no [string tolower $fType]-filter"
    }
    lappend cliCmdList "exit all"
    lappend cliCmdList "configure filter no [string tolower $filterType]-filter 8"
    if {([regexp {pppoe_46} $hostType])} {
        lappend cliCmdList "configure filter no [string tolower $filterType2]-filter 8"
    }
    lappend cliCmdList "exit all"
    foreach {cliCmd}  $cliCmdList {
        set errMsg [cookCliData [Dut-$dut3 sendCliCommand $cliCmd]]
        if {$errMsg != ""} {
            log_msg ERROR "CLI command $cliCmd failed in Dut-$dut3: $errMsg" ; set result FAILED
        }
    }

    ### delete filter logs
    set r1 [Dut-$dut3 setTFilterLogRowStatus 110 destroy ]
    set r2 [Dut-$dut3 setTFilterLogRowStatus 120 destroy ]
    set r3 [Dut-$dut3 setTFilterLogRowStatus 130 destroy ]
    set r4 [Dut-$dut3 setTFilterLogRowStatus 140 destroy ]
    set r5 [Dut-$dut3 setTFilterLogRowStatus 150 destroy ]
    if {($r1 != "noError") || ($r2 != "noError") || ($r3 != "noError") || ($r4 != "noError") || ($r5 != "noError")} {
        log_msg ERROR "Failed to cleanup filter logs in Dut-$dut3, found $r1, $r2, $r3, $r4, $r5"
        set result FAILED
        if {$opt(debug) != "false"} { return $result    }
    }

    ### delete VPRNs
    set i 1; set customer 0
    foreach {vprnId} "$vprnId1 $vprnId2 $vprnId3 $vprnId4" {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        if { ($opt(svcType) == "vprn") && ($i == "4") } {
            # do nothing
        } else {
            set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 sap ${port_3_3}:[expr $i + 1] shutdown"]; log_msg INFO $rCli
            set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 no sap ${port_3_3}:[expr $i + 1]"]; log_msg INFO $rCli
        }
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId interface vprn${vprnId}ToIxia3 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId no interface vprn${vprnId}ToIxia3 "]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service vprn $vprnId shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no vprn $vprnId"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no customer [expr $customer + $i]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        incr i
    }
    if { $opt(svcType) == "vprn" } {
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router no static-route 3.0.0.0/8 next-hop 3.3.0.2"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure router no static-route [ipConvert Ipv6 3.0.0.0]/[maskConvert Ipv6 8] next-hop [ipConvert Ipv6 3.3.0.2]"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 sap ${port_3_3}:5 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 no sap ${port_3_3}:5"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 interface itfToIxia300 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 no interface itfToIxia300"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service ies 300 shutdown"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "/configure service no ies 300"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    }
    
    ### delete configured customers
    set rCli [Dut-$dut3 sendCliCommand "/configure service no customer 2"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure service no customer 3"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure service no customer 4"]; log_msg INFO $rCli

    return $result

}

proc filterActionFwdRtrScale { args } {

    global testdir logdir ixia_port setupErrorFlag testResultFlag
    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/params_file_filter_scale.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl


    set opt(debug)      true
    set opt(debugPrint) false
    set opt(mode)       regular
    set opt(snmp)       true
    set opt(setupType)  "random"
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(maxVPRN)   5000 
    getopt opt $args

    set testID $::TestDB::currentTestCase
    set result PASSED
    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"

    handlePacket -action reset -portList all
    # save initial configuration
#    saveOrRestore save -name deleteConfig -replaceDeleteWith true
    # randomly choose setupType
    if {$opt(setupType) == "random"} {
        set setupType [fwdRtr_getSetupTypeRandom $opt(filterType)]
    } else {
        set setupType $opt(setupType)
        log_msg NOTICE "User defined setupType: $setupType"
    }
    if {[filterTCAM_getGlobals $setupType] != "OK"} {
        log_msg ERROR "Unable to find correct parameters for $setupType"
        set result FAILED
    }

    if { [regexp {vprn} $svcType] } { set opt(svcType) "vprn" }
    # configuration
    if {($filterType == "IPv6") && ($itfBind == "subsap")} {
        set r [filter_radOverride_runTest $filterType -select [string trimleft $setupType IPv6_ ] -hostType dhcp6_IANA -cleanup false -dual false]
    } else {
        filterTCAM_config $setupType
    }
    filterTCAM_ixInit $setupType

    ### find out, if card is IOM3 and higher or not (in case of older IOMs, PBR is not taken into account)
    if { $itfType == "lag" } {
        set iom3 ""
        foreach {port} $port_3_2 {
            if {[Dut-$dut3 isIom3Equipped [lindex [split $port "/"] 0]] != "TRUE"} {
                if {$iom3 == "true"} {set iom3 "none"} else {set iom3 "false"}
            } else {
                if {$iom3 == "false"} {set iom3 "none"} else {set iom3 "true"}
            }
        }
        log_msg NOTICE "iom3 $iom3"
        if {$iom3 == "none"} { log_msg ERROR "testing on lag with mixture of iom3 and non-iom3 ports, results for action forward router tests could be unpredictable" }
    } else {
        set iom3 [ string tolower [Dut-$dut3 isIom3Equipped [lindex [split $port_3_2 "/"] 0]]]
        if { $iom3 == "false" } {
            log_msg INFO "Used line card is NOT IOM3 and higher - verify, that traffic will be just forwarded and PBR is not taken into account"
        }
    }
    set numStreams [filterTCAM_ixConfigStreams $setupType -ipOptions false]
    set streamIdList ""
    for {set i 1} {$i <= $numStreams} {incr i} { lappend streamIdList $i }
    filterTCAM_ixTestTraffic $streamIdList

    log_msg INFO "Save the first rollback restore point - without scale config"
    # save the first rollback restore point - only wccp config
      log_msg INFO "Creating rollback restore point-1"
      set username $::TestDB::thisTestBed ; set hostIp $::TestDB::thisHostIpAddr
      set logDir "ftp://${username}:tigris@${hostIp}/$logdir/device_logs"
      set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
      Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
      Dut-$dut3 sendCliCommand "exit all"
      Dut-$dut3 sendCliCommand "shell rollbackBlackListDisable"
      Dut-$dut3 sendCliCommand "configure system rollback rollback-location $logDir/fwdRtrScaleRollback"
      Dut-$dut3 sendCliCommand "admin rollback save"
      after 10000
      log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
      log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
      set rollbackSaveResult [filter_getRollbackResult $dut3 save]
      if {$rollbackSaveResult != "Successful"} {
          log_msg ERROR "error with creating rollback restore point-1 - $rollbackSaveResult" ; set result "FAILED"
      }
      Dut-$dut3 configure -cli_timeout $extCliTim ; Dut-$dut3 configure -timeout $extTim


    print_console_msg "STEP 1"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 1: create max $opt(maxVPRN) VPRNS, create $filterType filter with max $maxFilterRules entries in it with action forward router"
    log_msg INFO "----------------------------------------------------"

    # reconfigure SAP to IXIA port 3 to encap type qinq - in order to be possible to make 10236 SAPs
    log_msg INFO "Reconfigure SAP to IXIA port 3 to encap type qinq"
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure service"]; log_msg INFO $rCli
    if { $svcType == "WRvprnRCO"} {
        set rCli [Dut-$dut3 sendCliCommand "    vprn 2000"]; log_msg INFO $rCli
    } elseif {$opt(svcType) == "vprn"} {
        set rCli [Dut-$dut3 sendCliCommand "    vprn $svc1"]; log_msg INFO $rCli
    } elseif {$svcType == "rvpls"} {
        set rCli [Dut-$dut3 sendCliCommand "    ies 100"]; log_msg INFO $rCli
    } else {
        set rCli [Dut-$dut3 sendCliCommand "    ies $svc1"]; log_msg INFO $rCli
    }
    set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia3 sap ${port_3_3}:1 shutdown"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia3 no sap ${port_3_3}:1"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure port ${port_3_3} shutdown"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure port ${port_3_3} ethernet encap-type qinq"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure port ${port_3_3} no shutdown"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure service"]; log_msg INFO $rCli
    if { $svcType == "WRvprnRCO" } {
        set rCli [Dut-$dut3 sendCliCommand "    vprn 2000 interface itfToIxia3 sap ${port_3_3}:1.1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
    } elseif {$opt(svcType) == "vprn"} {
        set rCli [Dut-$dut3 sendCliCommand "    vprn $svc1 interface itfToIxia3 sap ${port_3_3}:1.1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
    } elseif {$svcType == "rvpls"} {
        set rCli [Dut-$dut3 sendCliCommand "    ies 100 interface itfToIxia3 sap ${port_3_3}:1.1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
    } else {
        set rCli [Dut-$dut3 sendCliCommand "    ies $svc1 interface itfToIxia3 sap ${port_3_3}:1.1 create"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "    no shutdown"]; log_msg INFO $rCli
    }
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli

    log_msg INFO "Reconfigure filter on ixia port for capturing, in order to be able capture qinq encap packets"
    set portList [list $ixport3 ]
    scan $ixport3 "%d %d %d" chassis card port
    port get $chassis $card $port

    set srcIpPattern ""
    for {set cnt 0} {$cnt < 4} {incr cnt} { lappend srcIpPattern [format %02x [lindex [split $srcIp_13 "."] $cnt]]}
    set srcIpv6Pattern "3F FE 00 00 $srcIpPattern 00 00 00 00 00 00 00 00"


       filter                       setDefault
       filterPallette               setDefault
       filter                       config            -captureTriggerPattern              pattern1
       filter                       config            -captureFilterPattern               pattern1
       if {$filterType == "IP"} {
           filterPallette               config            -pattern1                           $srcIpPattern
           filterPallette               config            -patternMask1                       "00 00 FF FF"
           filterPallette               config            -patternOffset1                     34
       } else  {
           filterPallette               config            -pattern1                           $srcIpv6Pattern
           filterPallette               config            -patternMask1                       "00 00 00 00 00 00 00 00 FF FF FF FF FF FF FF FF"
           filterPallette               config            -patternOffset1                     30
       }
       filter                       set               $chassis $card $port
       filterPallette               set               $chassis $card $port
       if {[ixWritePortsToHardware portList]} {
          set RetVal "ixia_init : ixWritePortsToHardware failed => $portList"
          log_msg DEBUG $RetVal
      }
      ixTransmitPortArpRequest $chassis $card $port
      
    log_msg INFO "#################################"
    log_msg INFO "Create max $opt(maxVPRN) VPRNS"
    log_msg INFO "#################################"
    set serviceOffset 20000
    set r1 [configMaxVprns $setupType $opt(maxVPRN) $serviceOffset]
    if { $r1 != "PASSED" } {
        log_msg ERROR "Failed to create $opt(maxVPRN) VPRNS" ; set result FAILED
    }

    # configure IP filter with max entries with action forward to all VPRNs
    set entryOffset 20000
    set matchList [actionFwdRtr_getMatchList $filterType src-ip [expr $maxFilterRules - 3]]
    log_msg INFO "#################################"
    log_msg INFO "Configure $filterType filter with [expr $maxFilterRules - 3] entries - each entry will have configured action forward to different VPRN"
    log_msg INFO "#################################"
    set r1 [filterScaleAddBatchRules $dut3 "" $filterType $entryOffset [expr $entryOffset + $maxFilterRules - 4] -startFilter 8 -endFilter 8 -matchList $matchList -defaultAction forward -ruleAction "forward"]
    if { $r1 != "OK" } {
        log_msg ERROR "Failed to create $filterType filter" ; set result FAILED
    }
    # change action forward to forward router
    log_msg INFO "#################################"
    log_msg INFO "Configure action forward router for each entry"
    log_msg INFO "#################################"
    set r1 [configActionFwdRtr $setupType $opt(maxVPRN) [expr $maxFilterRules - 3] $serviceOffset $entryOffset]
    if { $r1 != "PASSED" } {
        log_msg ERROR "Failed to create action forward router in $filterType filter" ; set result FAILED
    }

    # apply filter to ingress interface under test
    set direction "Ingress Egress"
    set filterID  8
    foreach direct $direction {
        switch $itfBind {
            "sap" {
                set r2 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
            }
            "subsap" {
                set r2 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
                if {$filterType == "IPv6"} {
                    # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla1 now ...
                    filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla1 -hostType dhcp6_IANA
                }
            }
            "spoke" - "mesh" {
                set r2 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
            }
            "net" {
                set r2 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
            }
            default {
                # destination type inconsistency
                log_msg ERROR "itfBind type $itfBind not yet supported"
                set r2 ERROR
            }
        }
    }
    if {($r2 != "noError")} {
        log_msg ERROR "failed to create $filterType filter $filterID and assign to $direction $itfBind in Dut-$dut3, found $r1, $r2"
        set result FAILED
    }

    log_msg INFO "Verify number of entries via mib walk"
    wccpMibWalk $dut3 t[getVar3 $filterType]FilterParamsRowStatus [expr $maxFilterRules - 3]
    after 2000
#    wccpMibWalk $dut3 t[getVar3 $filterType]FilterParamsEntry.52 [expr $maxFilterRules - 3]
    set buf [Dut-$dut3 sendCliCommand "show filter [getVar4 $filterType] 8 | match \"Fwd Rtr/SvcId\"" -match_max 1000000 -timeout 120]
    set cntFwdRtr  0
    foreach line [split $buf "\n"] {
      if {[regexp "Fwd Rtr/SvcId:" $line]} {incr cntFwdRtr }
    }
    if { $cntFwdRtr == [expr $maxFilterRules - 3] } {
        log_msg INFO "Number of entries with action forward router ($cntFwdRtr) is same as expected ([expr $maxFilterRules - 3])"
    } else {
        log_msg ERROR "Number of entries with action forward router ($cntFwdRtr) is not same as expected ([expr $maxFilterRules - 3])"
        set result FAILED
    }

    log_msg INFO "Verify correct number of entries with getnext"
    wccpMibGetNext $dut3 t[getVar3 $filterType]FilterParamsRowStatus [expr $maxFilterRules - 3]

    log_msg INFO "Verify if resources on CPM and IOM are matching"
    set r [resMgr_verify_resources $result -dut Dut-$dut3]
    if {($r != $result)} {
        log_msg ERROR "resources on CPM and IOM not matching for Dut-$dut3, found $r"
        set result FAILED
    }

    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Admin tech-support"
    log_msg INFO "----------------------------------------------------"

    set rCli [Dut-$dut3 sendCliCommand "admin tech-support ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs/admin_tech_support_scale_$dut3" -timeout 500] ; log_msg INFO "$rCli"

    # it tooks too much time
#    set routerInstance $serviceOffset
#    for {set j $entryOffset} {$j <= [expr $entryOffset + $maxFilterRules]} {incr j} {
#        set result [wccpCompareOutputString [Dut-$dut3 getVRtrInstanceId $routerInstance] [Dut-$dut3 getT[getVar3 $filterType]FilterParamsFwdRtrId 8 $j ]]
#        incr routerInstance
#        if {$routerInstance > [expr $opt(maxVPRN) + $serviceOffset]} {set routerInstance $serviceOffset}        
#    }

    log_msg INFO "Configure second filter (match all) and bind it on SAP to IXIA (sap 2/1/5:1.1), in order to verify, that every packets is redirected to some VPRNs - expected hit counter for that filter is 0"
    set r1 [Dut-$dut3 create[getVar1 $filterType]FilterPolicy 1]
    set r2 [Dut-$dut3 create[getVar1 $filterType]FilterEntries 1 1 -Action forward ]
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure service"]; log_msg INFO $rCli
    if { $svcType == "WRvprnRCO" } {
        set rCli [Dut-$dut3 sendCliCommand "    vprn 2000"]; log_msg INFO $rCli
    } elseif {$opt(svcType) == "vprn"} {
        set rCli [Dut-$dut3 sendCliCommand "    vprn $svc1"]; log_msg INFO $rCli
    } elseif {$svcType == "rvpls"} {
        set rCli [Dut-$dut3 sendCliCommand "    ies 100"]; log_msg INFO $rCli
    } else {
        set rCli [Dut-$dut3 sendCliCommand "    ies $svc1"]; log_msg INFO $rCli
    }
    set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia3 sap ${port_3_3}:1.1 egress filter [getVar4 $filterType] 1"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 1 entry 1 log 101"]; log_msg INFO $rCli

    ### add match criterium for entry 1 - in order to eliminate hits by control traffic
    set fltrSrcAddrCLI [ipConvert $family 3.3.0.0]
    set fltrDstAddrCLI [ipConvert $family 1.1.0.0]
    if {$filterType == "IP"} { set fltrMask 16 } else { set fltrMask [maskConvert $family 16] }

    Dut-$dut3 sendCliCommand "configure filter [getVar4 $filterType]-filter 1 entry 1"
    Dut-$dut3 sendCliCommand "match dst-ip $fltrSrcAddrCLI/$fltrMask"
    Dut-$dut3 sendCliCommand "exit all"

    log_msg INFO "Configure IXIA stream and run the traffic"
    if {[getGlobalVar physTopology] == "scaleBed"} { set ing_port 5; set eg_port 1 } else { set ing_port 1; set eg_port 3 }
    set portList [list $ixport1 ]
    scan $ixport1 "%d %d %d" chassis card port
    port get $chassis $card $port
    stream get $chassis $card $port 1
    set da_mac [join [split [stream cget -da] " "] ":"]

    if { $filterType == "IP" } { set rate 400; set waitTime 50000 } else { set rate 300; set waitTime 70000 }
    # create initial stream 
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000
   
    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"
     
    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime
    stop_capture $ixport3
    after 5000
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13"
        set result FAILED
        foreach iom [getIomList $dut3] {
            log_msg DEBUG [Dut-$dut3 sendCliCommand "shell cardcmd $iom distats"]
            log_msg DEBUG [Dut-$dut3 sendCliCommand "shell cardcmd $iom destats"]
        }
    }

    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }

    log_msg INFO "Create a second restore point - with scale config"
        # save the second rollback restore point
        log_msg INFO "Creating rollback restore point-2"
        set extCliTim [Dut-$dut3 cget -cli_timeout] ; set extTim [Dut-$dut3 cget -timeout]
        Dut-$dut3 configure -cli_timeout 3600 ; Dut-$dut3 configure -timeout 125
        Dut-$dut3 sendCliCommand "exit all"
        Dut-$dut3 sendCliCommand "admin rollback save" -match_max 200000
        after 10000
        log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
        log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
        set rollbackSaveResult [filter_getRollbackResult $dut3 save]
        if {$rollbackSaveResult != "Successful"} {
          log_msg ERROR "error with creating rollback restore point-2 - $rollbackSaveResult" ; set result "FAILED"
        }
    after 5000
    
#interpreter

    print_console_msg "STEP 2"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 2: Remove and insert mda(s)"
    log_msg INFO "----------------------------------------------------"
    set port $port_3_2
    set slot [lindex [ split $port "/" ] 0]
    set mda  [lindex [ split $port "/" ] 1]
    log_msg INFO "=> Remove and insert mda ${slot}/${mda}"
    Dut-$dut3 sendCliCommand "shell cardcmd $slot remove_mda n:$mda"
    after 5000
    Dut-$dut3 sendCliCommand "shell cardcmd $slot insert_mda n:$mda"
    after 25000
    # wait for sdps to converge before continuing
    foreach { dut remoteIp sdpId } $sdpList {
        set r [check_converge $dut $sdpId ]
        set r [Dut-$dut getSdpOperStatus $sdpId]
        if { ($r != "up") } {
            log_msg DEBUG "converge for Dut-$dut sdp $sdpId not ok - $r"
            if {$opt(debug) != "false"} { return $result    }
        }
    }
    Dut-$dut3 CnWMdaStatus
    ### verify traffic
    log_msg INFO "Verify if resources on CPM and IOM are matching"
    set r [resMgr_verify_resources $result -dut Dut-$dut3 -maxTries 60]
    if {($r != $result)} {
        log_msg ERROR "resources on CPM and IOM not matching for Dut-$dut3, found $r"
        set result FAILED
    }
    # create initial stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000

    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"

    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"

    log_msg INFO "Test traffic"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime 
    stop_capture $ixport3
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13 (expected: [expr $maxFilterRules - 3]"
        set result FAILED
    }
    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }

    print_console_msg "STEP 3"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 3: Clear IOM card(s)"
    log_msg INFO "----------------------------------------------------"
    set port $port_3_2
    set card [lindex [ split $port "/" ] 0]
    log_msg INFO "Clear IOM card $card"
    catch {Dut-$dut3 getTmnxCardEquippedType 1 $card} card_type
    Dut-$dut3 sendCliCommand "exit all"
    Dut-$dut3 sendCliCommand "clear card $card"
    after 25000
    set i 1
    set card_reboot "Fail"
    while {$i < 20} {
        catch {Dut-$dut3 getTmnxCardEquippedType 1 $card} card_type_new
        if {$card_type == $card_type_new} {
            set card_reboot "Ok"
            break
        }
        incr i
        after 5000
    }
    log_msg DEBUG "Card reboot returned $card_reboot"
    Dut-$dut3 CnWCardStatus
    after 20000
    # wait for sdps to converge before continuing
    foreach { dut remoteIp sdpId } $sdpList {
        set r [check_converge $dut $sdpId ]
        set r [Dut-$dut getSdpOperStatus $sdpId]
        if { ($r != "up") } {
            log_msg DEBUG "converge for Dut-$dut sdp $sdpId not ok - $r"
        }
    }
    log_msg INFO "Verify if resources on CPM and IOM are matching"
    set r [resMgr_verify_resources $result -dut Dut-$dut3 -maxTries 60]
    if {($r != $result)} {
        log_msg ERROR "resources on CPM and IOM not matching for Dut-$dut3, found $r"
        set result FAILED
    }
    ### verify traffic
    # create initial stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000

    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"

    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"

    log_msg INFO "Test traffic"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime 
    stop_capture $ixport3
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13 (expected: [expr $maxFilterRules - 3])"
        set result FAILED
    }
    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }
    
    print_console_msg "STEP 4"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 4: Double CPM SWO"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Perform CPM SWO"
    Dut-$dut3 activitySwitch
    ### verify traffic
    # create initial stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000

    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"

    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"

    log_msg INFO "Test traffic"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime 
    stop_capture $ixport3
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13 (expected: [expr $maxFilterRules - 3])"
        set result FAILED
    }
    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }
    log_msg INFO "Perform second CPM SWO"
    Dut-$dut3 activitySwitch
    log_msg INFO "Verify if resources on CPM and IOM are matching"
    set r [resMgr_verify_resources $result -dut Dut-$dut3 -maxTries 60]
    if {($r != $result)} {
        log_msg ERROR "resources on CPM and IOM not matching for Dut-$dut3, found $r"
        set result FAILED
    }
    ### verify traffic
    # create initial stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000

    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"

    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"

    log_msg INFO "Test traffic"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime 
    stop_capture $ixport3
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13 (expected: [expr $maxFilterRules - 3])"
        set result FAILED
    }
    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }

    print_console_msg "STEP 5"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 5: Admin save/exec of saved config file"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Save the config - admin save"
    set fileName "actionFwdRtr_scale_Dut${dut3}_detail.cfg"
    set username $::TestDB::thisTestBed
    set hostIp $::TestDB::thisHostIpAddr
    set dir "ftp://${username}:tigris@${hostIp}/$logdir/device_logs"
    set CliTim [ Dut-$dut3 cget -cli_timeout ]
    set Tim [ Dut-$dut3 cget -timeout ]
    Dut-$dut3 configure -cli_timeout 1200
    Dut-$dut3 configure -timeout 1200

    Dut-$dut3 sendCliCommand "exit all"
    Dut-$dut3 getSysName
    log_msg INFO "=> Saving config file $fileName"
    set CLI [ cookCliData [ Dut-$dut3 sendCliCommand "admin save detail $dir/$fileName" ]]
    set SC [ string first "Completed" $CLI ]
    if { $SC < 1 } {
        log_msg DEBUG "$CLI"
        log_msg ERROR "Save of $fileName FAILED - Was $SC And Should Be >= 1"
        set result FAILED
        if {$opt(debug) != "false"} { return $result    }
    }
    Dut-$dut3 sendCliCommand "exit all"
    # only cleanup and execute the file if save was successfull
    log_msg INFO "=> Cleanup configuration in Dut-$dut3 before executing saved config file"
    saveOrRestore delete -dut Dut-$dut3 -timeout 900
    # save initial configuration
#    saveOrRestore restore -name deleteConfig
    after 1000
    log_msg INFO "=> Executing saved config file $fileName after cleaning up and retest filter"
    set CLI [ cookCliData [ Dut-$dut3 sendCliCommand "exec $dir/$fileName" ]]
    set SC [ string first "Executed" $CLI ]
    if { $SC < 1 } {
        log_msg DEBUG "$CLI"
        log_msg ERROR "Exec of $fileName FAILED - Was $SC And Should Be >= 1"
        set result FAILED
        if {$opt(debug) != "false"} { return $result    }
    }
    Dut-$dut3 sendCliCommand "exit all"
    log_msg INFO "Verify if resources on CPM and IOM are matching"
    set r [resMgr_verify_resources $result -dut Dut-$dut3 -maxTries 60]
    if {($r != $result)} {
        log_msg ERROR "resources on CPM and IOM not matching for Dut-$dut3, found $r"
        set result FAILED
    }
    ### verify traffic
    # create initial stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000

    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"

    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"

    log_msg INFO "Test traffic"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime 
    stop_capture $ixport3
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13 (expected: [expr $maxFilterRules - 3])"
        set result FAILED
    }
    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }
    log_msg INFO "Exec second time same config saved via admin save/detail"
    log_msg INFO "=> Executing saved config file $fileName after cleaning up and retest filter"
    set CLI [ cookCliData [ Dut-$dut3 sendCliCommand "exec $dir/$fileName" ]]
    set SC [ string first "Executed" $CLI ]
    if { $SC < 1 } {
        log_msg DEBUG "$CLI"
        log_msg ERROR "Exec of $fileName FAILED - Was $SC And Should Be >= 1"
        set result FAILED
    }
    Dut-$dut3 sendCliCommand "exit all"
    
    print_console_msg "STEP 6"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 6: Rollback to point without scale config"
    log_msg INFO "----------------------------------------------------"
    # rollback to the first restore point
    log_msg INFO "Rollback to restore point-1 without scale config"
    Dut-$dut3 sendCliCommand "exit all"
    set errMsg [cookCliData [Dut-$dut3 sendCliCommand "admin rollback revert 1 now" -match_max 200000 -timeout 900]]
    after 10000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackRevertResult [filter_getRollbackResult $dut3 revert]
    if {$rollbackRevertResult != "Successful" || [regexp "CLI Rollback revert failed" $errMsg]} {
      log_msg ERROR "error with reverting to rollback restore point-1 - $rollbackRevertResult - $errMsg" ; set result "FAILED"
    }

    # rollback to the second restore point
    log_msg INFO "Rollback to restore point-2 with scale config"
    Dut-$dut3 sendCliCommand "exit all"
    set errMsg [cookCliData [Dut-$dut3 sendCliCommand "admin rollback revert latest-rb now" -match_max 200000 -timeout 900]]
    after 10000
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    log_msg DEBUG [Dut-$dut3 sendCliCommand "show system rollback"]
    set rollbackRevertResult [filter_getRollbackResult $dut3 revert]
    if {$rollbackRevertResult != "Successful" || [regexp "CLI Rollback revert failed" $errMsg]} {
      log_msg ERROR "error with reverting to rollback restore point-2 - $rollbackRevertResult - $errMsg" ; set result "FAILED"
    }

    log_msg INFO "Verify number of entries via mib walk"
    # there is one more entry, because we configure one more during test
    wccpMibWalk $dut3 t[getVar3 $filterType]FilterParamsRowStatus [expr $maxFilterRules - 2]
    after 2000
#    wccpMibWalk $dut3 t[getVar3 $filterType]FilterParamsEntry.52 [expr $maxFilterRules - 2]
    set buf [Dut-$dut3 sendCliCommand "show filter [getVar4 $filterType] 8 | match \"Fwd Rtr/SvcId\"" -match_max 1000000 -timeout 320]
    set cntFwdRtr  0
    foreach line [split $buf "\n"] {
      if {[regexp "Fwd Rtr/SvcId:" $line]} {incr cntFwdRtr }
    }
    if { $cntFwdRtr == [expr $maxFilterRules - 3] } {
        log_msg INFO "Number of entries with action forward router ($cntFwdRtr) is same as expected ([expr $maxFilterRules - 3])"
    } else {
        log_msg ERROR "Number of entries with action forward router ($cntFwdRtr) is not same as expected ([expr $maxFilterRules - 3])"
        set result FAILED
    }

    log_msg INFO "Verify correct number of entries with getnext"
    wccpMibGetNext $dut3 t[getVar3 $filterType]FilterParamsRowStatus [expr $maxFilterRules - 2]
    log_msg INFO "Verify if resources on CPM and IOM are matching"
    set r [resMgr_verify_resources $result -dut Dut-$dut3 -maxTries 60]
    if {($r != $result)} {
        log_msg ERROR "resources on CPM and IOM not matching for Dut-$dut3, found $r"
        set result FAILED
    }

    ### verify traffic
    # create initial stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource 300 -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst 300 -rate $rate -loop 1 -action createdownloadstart
    after 5000

    # create test stream
    handlePacket -port $ing_port -dot1q 1 -dst [ipConvert $family 3.3.0.2] -numDest 1 -src [ipConvert $family 1.1.0.2] -numSource [expr $maxFilterRules - 3] -damac $da_mac -stream 1 -framesize 68 -rawProtocol 17 -packetsPerBurst [expr $maxFilterRules - 3] -rate $rate -loop 1 -action createdownload
    after 2000

    log_msg DEBUG "Rate: $rate per second"
    log_msg DEBUG "WaitTime: $waitTime"

    stream get $chassis $card $port 1
    stream config  -enable  true
    stream set $chassis $card $port 1
    stream write $chassis $card $port 1

    # clear the filter 1
    Dut-$dut3 sendCliCommand "clear filter [getVar4 $filterType] 1"

    log_msg INFO "Test traffic"
    start_capture_ixia $ixport3
    start_tx $ixport1
    after $waitTime 
    stop_capture $ixport3
    set numRx13  [check_num_packets_captured $ixport3]
    log_msg INFO "Number of captured packets $numRx13 (expected: [expr $maxFilterRules - 3])"
    if {$numRx13 != [expr $maxFilterRules - 3]} {
        log_msg ERROR "Captured packet is not equal to transmitted: $numRx13 (expected: [expr $maxFilterRules - 3])"
        set result FAILED
    }
    log_msg INFO "Verify, that all packets were redirected to VPRNs"
    ### check filter 1 hit counters
    set egr13Cnt [Dut-$dut3 getT[getVar3 $filterType]FilterParamsEgressHitCount  1 1 ]
    if { $egr13Cnt == 0 } {
        log_msg INFO "Filter 1 entry 1 hit counters are equal to 0 - expected"
    } else {
        log_msg ERROR "Filter 1 entry 1 hit counters are not equal to 0 - not expected ($egr13Cnt hits) !!!"
        set rCli [Dut-$dut3 sendCliCommand "environment no more"]; log_msg INFO $rCli
        set rCli [Dut-$dut3 sendCliCommand "show filter log 101"]; log_msg DEBUG $rCli
        set result FAILED
    }
    # delete rollback restore points and rollback location
    set rCli [Dut-$dut3 sendCliCommand "admin rollback delete 1"] ; log_msg INFO "$rCli"
    set rCli [Dut-$dut3 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
    set rCli [Dut-$dut3 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"

    # delete both filters
    log_msg INFO "Delete both filters"

    set direction "Ingress Egress"
    set filterID  0
    foreach direct $direction {
        switch $itfBind {
            "sap" {
                set r2 [ Dut-$dut3 setSap${direct}[getVar1 $filterType]FilterId $svc1 [Dut-$dut3 convert_port_ifIndex $portType_3_2 $portName_3_2] $userTag $filterID ]
            }
            "subsap" {
                set r2 [ Dut-$dut3 createSlaProf[getVar2 $filterType]FilterId sla1 [string tolower $direct] $filterID ]
                if {$filterType == "IPv6"} {
                    # ipv6 filter of sla-profile can not be changed once the sla-profile is in use => update the v6-host to start using sla1 now ...
                    filter_subinsert_radiusCOA "$sapName_3_2$encapName" [ipConvert $filterType 1.1.0.2] {} -slaName sla1 -hostType dhcp6_IANA
                }
            }
            "spoke" - "mesh" {
                set r2 [ Dut-$dut3 setSdpBind${direct}[getVar1 $filterType]FilterId $svc1 [calBindId $svc1 32] $filterID ]
            }
            "net" {
                set r2 [ Dut-$dut3 setVRtrIf[getVar2 $filterType]${direct}FilterId 1 [ Dut-$dut3 interfaceNameToIfIndex "link2" ] $filterID ]
            }
            default {
                # destination type inconsistency
                log_msg ERROR "itfBind type $itfBind not yet supported"
                set r2 ERROR
            }
        }
    }
    if {($r2 != "noError")} {
        log_msg ERROR "failed to create $filterType filter $filterID and assign to $direction $itfBind in Dut-$dut3, found $r1, $r2"
        set result FAILED
    }
    set rCli [Dut-$dut3 sendCliCommand "/configure filter no [getVar4 $filterType]-filter 8"] ; log_msg INFO "$rCli"

    # delete filter 1
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "configure service"]; log_msg INFO $rCli
    if { $svcType == "WRvprnRCO" } {
        set rCli [Dut-$dut3 sendCliCommand "    vprn 2000"]; log_msg INFO $rCli
    } elseif {$opt(svcType) == "vprn"} {
        set rCli [Dut-$dut3 sendCliCommand "    vprn $svc1"]; log_msg INFO $rCli
    } elseif {$svcType == "rvpls"} {
        set rCli [Dut-$dut3 sendCliCommand "    ies 100"]; log_msg INFO $rCli
    } else {
        set rCli [Dut-$dut3 sendCliCommand "    ies $svc1"]; log_msg INFO $rCli
    }
    set rCli [Dut-$dut3 sendCliCommand "        interface itfToIxia3 sap ${port_3_3}:1.1 egress no filter [getVar4 $filterType] 1"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [Dut-$dut3 sendCliCommand "/configure filter no [getVar4 $filterType]-filter 1"] ; log_msg INFO "$rCli"

    print_console_msg "STEP 7"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "STEP 7: Verify if the IOM will be able to install/change all 64k VRF redirect policy entries"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "Configure one embedded filter with one entry with match criteria prefix-list of 32 prefixes"
    set embeddedId1 1; set offset1 0
    set r1 [filterScaleAddBatchRules $dut3 "" $filterType 1 1 -startFilter $embeddedId1 -endFilter $embeddedId1 -defaultAction forward -scope embedded]
    # create prefix list
    set prefixName "myPrefixList"
    if {$filterType == "IP"} {
        if {[filter_isHsa $dut3]} {
            set mask 24 ; set listType ipv4; set maxPL 16
        } else {
            set mask 24 ; set listType ipv4; set maxPL 32
        }
        for {set i 1} {$i<=$maxPL} {incr i} {set prefix_${i} 1.1.${i}.0}
    } else {
        if {[filter_isHsa $dut3]} {
            set mask 120 ; set listType ipv6; set maxPL 6
        } else {
            set mask 120 ; set listType ipv6; set maxPL 14
        }
        for {set i 1} {$i<=$maxPL} {incr i} {set prefix_${i} [ipv4ToIpv6 1.1.${i}.0]}
    }
    set r0 [Dut-$dut3 setTFilterPrefixListRowStatus $listType $prefixName createAndGo]
    for {set i 1} {$i<=$maxPL} {incr i} { set r${i} [Dut-$dut3 setTFilterPrefixListEntryRowStatus $listType $prefixName $listType [ip2HexCStr [set prefix_${i}]] $mask createAndGo]}

    for {set i 1} {$i<=$maxPL} {incr i} {
        if {[set r${i}] != "noError"} {
          log_msg ERROR "failed to create $listType prefix-list $prefixName - prefix [set prefix_${i}] - [set r${i}]" ; set result FAILED
        }
    }
    set r1 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsSrcIpPrefixList $embeddedId1 1 $prefixName]
    set r2 [Dut-$dut3 setT[getVar3 $filterType]FilterParamsRowStatus $embeddedId1 1 active]
    set rc [resMgr_verify_resources OK -dut Dut-$dut3 -maxTries 60]
    if {$r1 != "noError" || $r2 != "noError" || $rc != "OK"} {
      log_msg ERROR "failed to set match criteria of embedded $filterType filter $embeddedId1 to prefix list - $r1 $r2 $rc" ; set result FAILED
    }

    log_msg INFO "Create 2047 embedding filters without any entry and bind it to SAPs in configured VPRNs (in order to download these filters to IOM)"
    set r [filterScaleAddBatchRules $dut3 "" $filterType 1 0 -startFilter 2 -endFilter 2048 -defaultAction forward]
#    for {set i 1} {$i <= 2048} {incr i} {
#        set r1 [Dut-$dut3 sendCliCommand "configure service vprn [expr $serviceOffset + $i] interface vprn[expr $serviceOffset + $i]ToIxia3 sap 2/1/5:1.[expr $i + 2] ingress filter ip $i"]; puts $r1
#    }

    for {set i 2} {$i <= 2048} {incr i} {
        set r1 [Dut-$dut3 setSapIngress[getVar1 $filterType]FilterId [expr $serviceOffset + $i] [Dut-$dut3 convert_port_ifIndex port $port_3_3] [createEncapValue [expr $i+2] 1] $i]
    }


    log_msg INFO "Embed embedded filter to 2k filters on the IOM"
    if {$filterType == "IP"}  { set snmpType fltrtypeselIp } else { set snmpType fltrtypeselIpv6 }
    for {set cnt 2} {$cnt <= 2048} {incr cnt} {
        set r1 [Dut-$dut3 setTFilterEmbeddedRefRowStatus $snmpType $cnt 1 0 createAndGo]
    }
    set rc [resMgr_verify_resources OK -dut Dut-$dut3 -maxTries 60]
    if {$rc != "OK"} {
        log_msg ERROR "Resources on IOM and CPM don't match" ; set result FAILED
    }
    log_msg INFO "Verify number of entries via mib walk"
    wccpMibWalk $dut3 t[getVar3 $filterType]FilterParamsRowStatus 2048
    after 2000

    log_msg INFO "Create/change/delete the action forward router on the embedded entry and verify that all sub-entries on the IOM updated with a single command without any issue"

    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 1 entry 1 action forward router 20000"]; log_msg INFO $rCli
    log_msg INFO "Verify, that all entries changed the action to forward router 20000"
    set routerInstance [Dut-$dut3 getVRtrInstanceId 20000]
    for {set i 2} {$i <= 2048} {incr i} {
        set result [wccpCompareOutputString $routerInstance [Dut-$dut3 getT[getVar3 $filterType]FilterParamsFwdRtrId $i 1]]
    }
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 1 entry 1 action forward router 25000"]; log_msg INFO $rCli
    log_msg INFO "Verify, that all entries changed the action to forward router 25000"
    set routerInstance [Dut-$dut3 getVRtrInstanceId 25000]
    for {set i 2} {$i <= 2048} {incr i} {
        set result [wccpCompareOutputString $routerInstance [Dut-$dut3 getT[getVar3 $filterType]FilterParamsFwdRtrId $i 1]]
    }
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 1 entry 1 action forward"]; log_msg INFO $rCli
    log_msg INFO "Verify, that all entries changed the action to forward"
    for {set i 2} {$i <= 2048} {incr i} {
        set result [wccpCompareOutputString 0 [Dut-$dut3 getT[getVar3 $filterType]FilterParamsFwdRtrId $i 1]]
    }
    set rCli [Dut-$dut3 sendCliCommand "/configure filter [getVar4 $filterType]-filter 1 entry 1 action forward router Base"]; log_msg INFO $rCli
    log_msg INFO "Verify, that all entries changed the action to forward router Base"
    for {set i 2} {$i <= 2048} {incr i} {
        set result [wccpCompareOutputString 1 [Dut-$dut3 getT[getVar3 $filterType]FilterParamsFwdRtrId $i 1]]
    }

    if { $result == "PASSED" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

    if {$opt(deconfig)} {
      saveOrRestore delete
        # restore initial configuration
#        saveOrRestore restore -name deleteConfig

    }

}

proc filterActionFwdRtrISSU { args } {

    global testdir logdir ixia_port
    global dutList sdpList svcListList family
    global itfType svcType itfBind itfMode filterType
    global dut1 dut2 dut3 dut4 dut5 ixport1 ixport3
    global port_1_1 port_1_3 port_2_1 port_2_2 port_3_2 port_3_3 port_3_4 port_4_1 port_5_1 port_5_2
    global portType_2_2 portType_3_2 portName_2_2 portName_3_2 sapName_3_2 itfDot1q userTag encapName

    source $testdir/testsuites/filter/params_file_filter_tcam.tcl
    source $testdir/testsuites/filter/params_file_filter_scale.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl


    set opt(debug)      true
    set opt(debugPrint) false
    set opt(mode)       regular
    set opt(snmp)       true
    set opt(setupType)  "random"
    set opt(filterType) "IP"
    set opt(deconfig)   true
    set opt(svcType)    ""
    set opt(maxVPRN)   5000
    getopt opt $args

    set testID $::TestDB::currentTestCase
    set result PASSED

    set dut3 C
    # save initial configuration
#    saveOrRestore save -name deleteConfig -replaceDeleteWith true


    log_msg INFO "Check version on active and standby CPM"
    set data [Dut-$dut3 sendCliCommand "show redundancy synchronization"] ; log_msg DEBUG $data
    set data [Dut-$dut3 sendCliCommand "show card"] ; log_msg DEBUG $data
    set data [Dut-$dut3 sendCliCommand "show version"] ; log_msg DEBUG $data

    log_msg INFO "########################################################"
    log_msg INFO "Perform activitySwitch in order to continue on new release - trigger ISSU completion"
    log_msg INFO "########################################################"
    log_msg NULL "" ; log_msg INFO "Going to perform activity switch"
    Dut-$dut3 activitySwitch
    set data [Dut-$dut3 sendCliCommand "show version"] ; log_msg DEBUG $data
    

    print_console_msg "TEST 1"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 1: SNMP checks"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrSnmpChecks

    print_console_msg "TEST 2"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 2: CLI checks"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrCliChecks

    print_console_msg "TEST 3"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 3: Basic traffic test grtToVrf IPv4"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrBasicTrafficTest -issu true

    print_console_msg "TEST 4"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 4: Basic traffic test grtToVrf IPv6"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrBasicTrafficTest -filterType IPv6 -issu true

    print_console_msg "TEST 5"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 5: Basic traffic test vrfToVrf IPv4"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrBasicTrafficTest -svcType vprn -issu true

    print_console_msg "TEST 6"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 6: Basic traffic test vrfToVrf IPv6"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrBasicTrafficTest -filterType IPv6 -svcType vprn -issu true

    print_console_msg "TEST 7"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 7: Basic traffic test with non-routed traffic IPv4"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrBasicTrafficTest -svcType L2Service -issu true

    print_console_msg "TEST 8"
    log_msg INFO "----------------------------------------------------"
    log_msg INFO "TEST 8: Basic traffic test with non-routed traffic IPv6"
    log_msg INFO "----------------------------------------------------"
    filterActionFwdRtrBasicTrafficTest -svcType L2Service -filterType IPv6 -issu true

#    print_console_msg "TEST 9"
#    log_msg INFO "----------------------------------------------------"
#    log_msg INFO "TEST 9: Scaling and HA test IPv4"
#    log_msg INFO "----------------------------------------------------"
#    filterActionFwdRtrScale

#    print_console_msg "TEST 10"
#    log_msg INFO "----------------------------------------------------"
#    log_msg INFO "TEST 10: Scaling and HA test IPv6"
#    log_msg INFO "----------------------------------------------------"
#    filterActionFwdRtrScale -filterType IPv6

    if { $result == "PASSED" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

    if {$opt(deconfig)} {
        saveOrRestore delete
        # restore initial configuration
        # saveOrRestore restore -name deleteConfig
    }


}


proc filterActionFwdRtrTms { args } {

  global masterlog testdir logdir ixia_port testResultFlag
  global portA dataip
  source $testdir/library/interop.tcl
  source $testdir/testsuites/tms/tms_procs.tcl
  source $testdir/testsuites/tms/tms_params.tcl
  source $testdir/testsuites/flowspec/flowspec_Procs.tcl
  source $testdir/testsuites/filter/tests/wccp_procs.tcl
  source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl


  set option(filter_ip_id)       1
  set option(entry_ip_id)        100
  set option(filter_ipv6_id)       2
  set option(entry_ipv6_id)        200
  set option(config) true
  set option(test) true
  set option(deconfig) true
  set option(stopAllOngoingMitigationsDuringDeconfig) true
  set option(debug)  false
  set option(logResult) true
  set option(cliExecTimeout) 36000
  set option(cliTimeout) 600
  set option(allTmsItfsOnSameVprn) true
  set option(oneTmsItfsOnMda2) false
  set option(quickEcmp) false
  set option(noEcmp) false
  set option(ecmpActionList) ""
  set option(unresolvedRouteForPrefixUnderAttachWhenMitigationRequestArrives) false
  # offRampItfType: eth | lag
  set option(offRampItfType) eth
  # wait max 5min
  set option(maxRetryCnt) 10
  set option(interRetryTimeSec) 30
  set option(tmsInterfaceCounterCheckIntervalSec) 30
  set option(withRD) true
  set option(stopAfterFirstStep) false
  set option(checkIfOnRampTrafficIsFwdToIxia) true
  set option(captureTrafficFwdToIxia) true
  set option(pktSize) 256
  # 253: Use for experimentation and testing
  set option(rawProtocol) 253

  # there are 4 combinations
  #   autobind - ldp (default)
  #   autobind - gre
  #   sdp - rsvp
  #   sdp - gre
  set option(onRampTunnelMethod) autobind
  set option(onRampTunnelEncap) ldp
  set option(offRampTunnelMethod) autobind
  set option(offRampTunnelEncap) ldp
  set option(offRampViaTunnel) false
  set option(onRampViaTunnel) false
  set option(ixiaInVprn) false
  set option(shutOffRampVprn) false

  # there are 2 combinations
  #   PE-PE (default)
  #   CE-PE (local itf configured under vprn context)
  set option(onRampConnectivity) "PE-PE"
  set option(offRampConnectivity) "PE-PE"

  # there are 2 combinations
  #   CE-PE (default: local itf configured under vprn context)
  #   PE-PE (via extra dut4)
  set option(mgmtVprnConnectivity) "CE-PE"
  set option(mgmtVprnConnectivityMtu) ""

  set option(generateErrorDuningArborTmsSanity) true
  set option(saveMyConfig) false
  set option(getIxiaStatsViaHandlePacket) false

  set option(numSource) 65535
  set option(numMitigations_v4) 1
  set option(numMitigations_v6) 1
  # quick (2min) ; regular (10min) ; long (120min) ; ifFileExists
  set quickTrafficDurationMin 2 ; set regularTrafficDurationMin 10 ; set longTrafficDurationMin 120
  set option(trafficDurationMethod) quick
  set option(fileExistsName) "/tmp/tmsTrafficRunning.txt"
  set swoTestTrafficDurationMin 6 ; set swoTestPerformActionAfterMin 3
  set option(verifySwo) true
  set option(verifySwoWithFilter) false  
  set option(performISSU) false
  set option(tmsHotStandby) false
  set option(stopMitigationActionFwd) true

  # ipv4 | ipv6 | ipv4v6
  set option(family) ipv4
  set option(store2db) true
  set option(nbrRowsInDb) 100

  # 1,2,... <255 (and not 195) or Base
  set option(onRampVprnId) 32
  set option(offRampVprnId) 13
  set option(mgmtVprnId) 9
  set option(baseIesVprnId) 195
  set option(onRampConnectivityEpipeId) 982
  set option(offRampConnectivityEpipeId) 983
  set option(mgmtVprnConnectivityEpipeId) 984

  set option(offRampRedirectToVrf) false
  # sbgp | arborsp
  set option(flowrouteOrigin) sbgp
  set option(flowspecInteraction) false
  # redirectActionBeforeTmsRoute | redirectActionAfterTmsRoute
  set option(offRampRedirectToVrf_order) redirectActionBeforeTmsRoute
  set option(withdrawFlowroute) true

  set option(onRampBaseIesShut) false
  set option(onRampVprnVprnShut) false

  set option(exportFromTmsToOspf3IidList) ""

  getopt option      $args

  set testID $::TestDB::currentTestCase
  set Result OK

  testcaseHeader

  set testResultFlag "PASSED"
  set setupErrorFlag "NOERROR"

  set sdpIdFromDut2ToDut3 723 ; set sdpIdFromDut3ToDut2 732
  set sdpIdFromDut1ToDut3 713 ; set sdpIdFromDut3ToDut1 731

  if {[GGV tmsOnRampVprnId] != "ERROR"} {
    set onRampVprnId [GGV tmsOnRampVprnId]
  } else {
    set onRampVprnId $option(onRampVprnId)
  }

  if {[GGV tmsOffRampVprnId] != "ERROR"} {
    set offRampVprnId [GGV tmsOffRampVprnId]
  } else {
    set offRampVprnId $option(offRampVprnId)
  }
  set firstOffRampVprnId $offRampVprnId

  if {[GGV tmsMgmtVprnId] != "ERROR"} {
    set mgmtVprnId [GGV tmsMgmtVprnId]
  } else {
    set mgmtVprnId $option(mgmtVprnId)
  }

  if {[GGV tmsBaseIesVprnId] != "ERROR"} {
    set baseIesVprnId [GGV tmsBaseIesVprnId]
  } else {
    set baseIesVprnId $option(baseIesVprnId)
  }

  if {[GGV tmsOnRampTunnelMethod] != "ERROR"} {
    set onRampTunnelMethod [GGV tmsOnRampTunnelMethod]
  } else {
    set onRampTunnelMethod $option(onRampTunnelMethod)
  }

  if {[GGV tmsOnRampTunnelEncap] != "ERROR"} {
    set onRampTunnelEncap [GGV tmsOnRampTunnelEncap]
  } else {
    set onRampTunnelEncap $option(onRampTunnelEncap)
  }

  if {[GGV tmsOffRampTunnelMethod] != "ERROR"} {
    set offRampTunnelMethod [GGV tmsOffRampTunnelMethod]
  } else {
    set offRampTunnelMethod $option(offRampTunnelMethod)
  }
  if {[GGV tmsOffRampTunnelEncap] != "ERROR"} {
    set offRampTunnelEncap [GGV tmsOffRampTunnelEncap]
  } else {
    set offRampTunnelEncap $option(offRampTunnelEncap)
  }

  if {[GGV tmsOffRampViaTunnel] != "ERROR"} {
    set offRampViaTunnel [GGV tmsOffRampViaTunnel]
  } else {
    set offRampViaTunnel $option(offRampViaTunnel)
  }

  if {[GGV tmsOnRampViaTunnel] != "ERROR"} {
    set onRampViaTunnel [GGV tmsOnRampViaTunnel]
  } else {
    set onRampViaTunnel $option(onRampViaTunnel)
  }

  if {[GGV tmsSaveMyConfig] != "ERROR"} {
    set saveMyConfig [GGV tmsSaveMyConfig]
  } else {
    set saveMyConfig $option(saveMyConfig)
  }

  if {[GGV tmsMgmtVprnConnectivity] != "ERROR"} {
    set mgmtVprnConnectivity [GGV tmsMgmtVprnConnectivity]
  } else {
    set mgmtVprnConnectivity $option(mgmtVprnConnectivity)
  }

  if {[GGV tmsMgmtVprnConnectivityMtu] != "ERROR"} {
    set mgmtVprnConnectivityMtu [GGV tmsMgmtVprnConnectivityMtu]
  } else {
    set mgmtVprnConnectivityMtu $option(mgmtVprnConnectivityMtu)
  }

  if {[GGV tmsStopAfterFirstStep] != "ERROR"} {
    set stopAfterFirstStep [GGV tmsStopAfterFirstStep]
  } else {
    set stopAfterFirstStep $option(stopAfterFirstStep)
  }
  if {[GGV tmsExportFromTmsToOspf3IidList] != "ERROR"} {
    set exportFromTmsToOspf3IidList [GGV tmsExportFromTmsToOspf3IidList]
  } else {
    set exportFromTmsToOspf3IidList $option(exportFromTmsToOspf3IidList)
  }

  if { $option(family) == "ipv4" } {
     set filterType IP
  } elseif { $option(family) == "ipv6" } {
     set filterType IPv6
  } else {
     set filterType {IP IPv6}
  }

  if {[GGV tmsIxiaInVprn] != "ERROR"} {
    set ixiaInVprn [GGV tmsIxiaInVprn]
  } else {
    set ixiaInVprn $option(ixiaInVprn)
  }

  set pathexec "ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs/"
  set thisArborCP [arbor_getHostIp Dut-J]
  set mirrorId 123

  # dut itfToArborCP portToArborCP pfxMskToArborCP_dut pfxMskToArborCP_ip hostAddrArborCP
  # toArborCpList
  #   itfToArborCpPort itfToArborCpName itfToArborCpPfxMsk_dut itfToArborCpPfxMsk_cp hostAddrArborCp mgmtVprnId
  set toArborCpList_1 [list \
    [set portToArborCP_[set dut3]] itfToArborCP_02 [set itfToArborCpPfxMsk_[set dut3]_dut]  [set itfToArborCpPfxMsk_[set dut3]_cp] $thisArborCP $mgmtVprnId \
    ]
  set patternOffsetDot1q 4
  # dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList
  set isaTmsList [list \
    $dut3 $onRampVprnId $offRampVprnId  [set mda_[set dut3]_11]  [set isaTmsPfxMsk_[set dut3]_11] true $toArborCpList_1 \
    $dut3 $onRampVprnId $offRampVprnId [set mda_[set dut3]_21]  [set isaTmsPfxMsk_[set dut3]_21] false $toArborCpList_1 \
    $dut3 $onRampVprnId $offRampVprnId  [set mda_[set dut3]_22]  [set isaTmsPfxMsk_[set dut3]_22] false $toArborCpList_1 \
    $dut3 $onRampVprnId $offRampVprnId  [set mda_[set dut3]_31]  [set isaTmsPfxMsk_[set dut3]_31] true $toArborCpList_1 \
    ]

  set isaTmsPfxMskList [list [set isaTmsPfxMsk_[set dut3]_11] \
                                        [set isaTmsPfxMsk_[set dut3]_21] \
                                        [set isaTmsPfxMsk_[set dut3]_22] \
                                        [set isaTmsPfxMsk_[set dut3]_31] \
                                        ]

  set onRampVprnIdList ""
  foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
    if {[lsearch $onRampVprnIdList $onRampVprnId] == -1} {
      lappend onRampVprnIdList $onRampVprnId
    }
  }
  set nbrOnRampVprn [llength $onRampVprnIdList]

  set offRampVprnIdList ""
  foreach {dut offRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
    if {[lsearch $offRampVprnIdList $offRampVprnId] == -1} {
      lappend offRampVprnIdList $offRampVprnId
    }
  }
  set nbrOffRampVprn [llength $offRampVprnIdList]

  set mgmtVprnIdList ""
  foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
    foreach {itfToArborCpPort itfToArborCpName itfToArborCpPfxMsk_dut itfToArborCpPfxMsk_cp hostAddrArborCp mgmtVprnId} $toArborCpList {
      if {[lsearch $mgmtVprnIdList $mgmtVprnId] == -1} {
        lappend mgmtVprnIdList $mgmtVprnId
      }
    }
  }
  set nbrMgmtVprn [llength $mgmtVprnIdList]

  set src_fwd_v4 43.43.43.1 ; set src_drop_v4 43.43.43.2
  set src_fwd_v6 [ipv4ToIpv6 $src_fwd_v4] ; set src_drop_v6 [ipv4ToIpv6 $src_drop_v4]

  if {[GGV tmsPktRatePerStream] != "ERROR"} {
    set pktRatePerStream [GGV tmsPktRatePerStream]
  } else {
    if { [GGV physTopology] ==  "isaScaleBed" } {
      set pktRatePerStream "2250000" ; # +/- 5% for 256byte frames
    } else {
      set pktRatePerStream "10"
    }
  }
  if {[GGV tmsPktSize] != "ERROR"} {
    set pktSize [GGV tmsPktSize]
  } else {
    set pktSize $option(pktSize)
  }

  if {[GGV tmsNumSource] != "ERROR"} {
    set numSource [GGV tmsNumSource]
  } else {
    set numSource $option(numSource)
  }

  if {[GGV tmsNumMitigations_v4] != "ERROR"} {
    set numDest_v4 [GGV tmsNumMitigations_v4]
  } else {
    set numDest_v4 $option(numMitigations_v4)
  }

  if {[GGV tmsNumMitigations_v6] != "ERROR"} {
    set numDest_v6 [GGV tmsNumMitigations_v6]
  } else {
    set numDest_v6 $option(numMitigations_v6)
  }

  if {[GGV tmsVerifySwo] != "ERROR"} {
    set verifySwo [GGV tmsVerifySwo]
  } else {
    set verifySwo $option(verifySwo)
  }

  if {[GGV tmsVerifySwoWithFilter] != "ERROR"} {
    set verifySwoWithFilter [GGV tmsVerifySwoWithFilter]
  } else {
    set verifySwoWithFilter $option(verifySwoWithFilter)
  }

  if {[GGV tmsStopMitigationActionFwd] != "ERROR"} {
    set stopMitigationActionFwd [GGV tmsStopMitigationActionFwd]
  } else {
    set stopMitigationActionFwd $option(stopMitigationActionFwd)
  }

  if {[GGV tmsAllTmsItfsOnSameVprn] != "ERROR"} {
    set allTmsItfsOnSameVprn [GGV tmsAllTmsItfsOnSameVprn]
  } else {
    set allTmsItfsOnSameVprn $option(allTmsItfsOnSameVprn)
  }

  if {[GGV tmsPerformISSU] != "ERROR"} {
    set performISSU [GGV tmsPerformISSU]
  } else {
    set performISSU $option(performISSU)
  }

  if {[GGV tmsOnRampConnectivity] != "ERROR"} {
    set onRampConnectivity [GGV tmsOnRampConnectivity]
  } else {
    set onRampConnectivity $option(onRampConnectivity)
  }

  if {[GGV tmsOffRampConnectivity] != "ERROR"} {
    set offRampConnectivity [GGV tmsOffRampConnectivity]
  } else {
    set offRampConnectivity $option(offRampConnectivity)
  }

  if {[GGV tmsOffRampRedirectToVrf] != "ERROR"} {
    set offRampRedirectToVrf [GGV tmsOffRampRedirectToVrf]
  } else {
    set offRampRedirectToVrf $option(offRampRedirectToVrf)
  }

  if {[GGV tmsFlowrouteOrigin] != "ERROR"} {
    set flowrouteOrigin [GGV tmsFlowrouteOrigin]
  } else {
    set flowrouteOrigin $option(flowrouteOrigin)
  }

  if {[GGV tmsOnRampBaseIesShut] != "ERROR"} {
    set onRampBaseIesShut [GGV tmsOnRampBaseIesShut]
  } else {
    set onRampBaseIesShut $option(onRampBaseIesShut)
  }

  if {[GGV tmsOnRampVprnVprnShut] != "ERROR"} {
    set onRampVprnVprnShut [GGV tmsOnRampVprnVprnShut]
  } else {
    set onRampVprnVprnShut $option(onRampVprnVprnShut)
  }

  set expectedTmsRunningList ""
  foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
    lappend expectedTmsRunningList $isaTmsCardMda
  }
  set expectedTmsRunningEcmpList ""
  foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
    if {$hasMitigations} {
      lappend expectedTmsRunningEcmpList $isaTmsCardMda
    }
  }
  set dutList [list $dut1 $dut2 $dut3]
  set nbrIsaTmsToVerify [llength $isaTmsPfxMskList]
  set nbrIsaTmsToVerifyWithMitigations [llength $expectedTmsRunningEcmpList]

  # On isascale (has 12mda's), the mitigation name looks like this:
  #   reg_anisascale1_v4dst_100_1_fwd_12mda_31till82_ecmp
  # On other testbeds (anhwvmda3, anscale4/5, ...), the mitigation name looks like this:
  #   reg_[set ::TestDB::thisTestBed]_v4dst_100_1_fwd_[set mitTxtTail]
  if { [GGV physTopology] ==  "isaScaleBed" } {
    set mitTxtTail "12mda_31till82_ecmp"
  } elseif {$flowrouteOrigin == "arborsp"} {
    set mitTxtTail "1mda_22_ecmp_addFlowroute"
  } else {
    set mitTxtTail "2mda_11_31_ecmp"
  }

  log_msg INFO "########################################################################"
  log_msg INFO "# Test : $testID"
  log_msg INFO "# Descr : Verify isa-tms mitigation behavior on a offramp/onramp/mgmt setup with 3 nodes $dut1 / $dut2 / $dut3"
  log_msg INFO "#"
  log_msg INFO "# Setup:"
  log_msg INFO "# "
  log_msg INFO "#      IXIA----------dut1($dut1)--------------------dut2($dut2)----------IXIA"
  log_msg INFO "#                       |                              |"
  log_msg INFO "#               offramp |                              | onramp"
  log_msg INFO "#                       |                              |"
  log_msg INFO "#                       +----------dut3($dut3)---------+"
  log_msg INFO "#                                     |"
  log_msg INFO "#                                     | mgmt"
  log_msg INFO "#                                     |"
  log_msg INFO "#                              ARBOR CP ($thisArborCP)"
  log_msg INFO "# "
  log_msg INFO "# This testcase options:"
  log_msg INFO "#   pktSize: $pktSize"
  log_msg INFO "#   pktRatePerStream: $pktRatePerStream (max= 100G)"
  log_msg INFO "#   numMitigations_v4: $option(numMitigations_v4) (=> numDest_v4: $numDest_v4)"
  log_msg INFO "#   numMitigations_v6: $option(numMitigations_v6) (=> numDest_v6: $numDest_v6)"
  log_msg INFO "#   nbrIsaTmsToVerify: $nbrIsaTmsToVerify ; nbrIsaTmsToVerifyWithMitigations: $nbrIsaTmsToVerifyWithMitigations"
  log_msg INFO "#   trafficDurationMethod: $option(trafficDurationMethod)"
  log_msg INFO "#   verifySwo: $verifySwo (tmsHotStandby: $option(tmsHotStandby) ; swoTestTrafficDurationMin: $swoTestTrafficDurationMin ; swoTestPerformActionAfterMin: $swoTestPerformActionAfterMin)"
  log_msg INFO "#   performISSU: $performISSU"
  log_msg INFO "#   family: $option(family)"
  log_msg INFO "#   onRampTunnelMethod: $onRampTunnelMethod ; onRampTunnelEncap: $onRampTunnelEncap"
  log_msg INFO "#   offRampTunnelMethod: $offRampTunnelMethod ; offRampTunnelEncap: $offRampTunnelEncap"
  log_msg INFO "#   offRampViaTunnel: $offRampViaTunnel ; onRampViaTunnel: $onRampViaTunnel"
  log_msg INFO "#   allTmsItfsOnSameVprn: $allTmsItfsOnSameVprn"
  log_msg INFO "#   offRampVprnIdList: $offRampVprnIdList (# $nbrOffRampVprn) => onRampVprnIdList: $onRampVprnIdList (# $nbrOnRampVprn ; baseIesVprnId: $baseIesVprnId) ; mgmtVprnIdList: $mgmtVprnIdList (# $nbrMgmtVprn)"
  log_msg INFO "#   onRampConnectivity: $onRampConnectivity ;  offRampConnectivity: $offRampConnectivity"
  log_msg INFO "#     PE-PE (default) connectivity via BGP VPN"
  log_msg INFO "#     CE-PE connectivity: local interface under vprn context"
  log_msg INFO "#  mgmtVprnConnectivity: $mgmtVprnConnectivity"
  log_msg INFO "#     CE-PE (default: local itf configured under vprn context)"
  log_msg INFO "#     PE-PE (via extra $dut4 => ONLY on anscale* !)"
  log_msg INFO "#   offRampRedirectToVrf: $offRampRedirectToVrf ; filterActionOrigin: CLI/SNMP"
  if {$offRampRedirectToVrf} {
  log_msg INFO "#     => traffic from Ixia received in Base instance, but redirectToVrf via CLI/SNMP"
  }
  log_msg INFO "# "
  log_msg INFO "########################################################################"

  set buildVersion [lindex [split [lindex [split [cookCliData [$dut3 sendCliCommand "show version"]] .] 0] "-"] 2 ]

  set cliTimeoutOrig [$dut3 cget -cli_timeout]
  $dut3 configure -cli_timeout $option(cliTimeout)

  if {$option(config)} {
    tms_areThereCleanupIssues $dutList
    # policy/prefixes via good old snmp
    # $dut2 createProtPol fromVprnLeakToBgp vpnLeak bgp

    CLN.reset
    log_msg INFO "configure routing triangle $dut1/$dut2/$dut3"
    CLN "dut $dut1 systemip [set [set dut1]_ifsystem_ip] isisarea $isisAreaId as $AS"
    CLN "dut $dut2 systemip [set [set dut2]_ifsystem_ip] isisarea $isisAreaId as $AS"
    CLN "dut $dut3 systemip [set [set dut3]_ifsystem_ip] isisarea $isisAreaId as $AS"
    if {$mgmtVprnConnectivity == "PE-PE"} {
      CLN "dut $dut4 systemip [set [set dut4]_ifsystem_ip] isisarea $isisAreaId as $AS"
    }

    foreach thisOnRampVprnId $onRampVprnIdList {
      if {$thisOnRampVprnId != "Base"} {
        CLN "dut $dut2 systemip 10.[expr 20 + $thisOnRampVprnId].1.2 as $AS vprnid $thisOnRampVprnId"
        CLN "dut $dut3 systemip 10.[expr 20 + $thisOnRampVprnId].1.3 as $AS vprnid $thisOnRampVprnId"
      }
    }
    foreach thisOffRampVprnId $offRampVprnIdList {
      if {$thisOffRampVprnId != "Base"} {
        CLN "dut $dut1 systemip 10.[expr 30 + $thisOffRampVprnId].1.1 as $AS vprnid $thisOffRampVprnId"
        CLN "dut $dut3 systemip 10.[expr 30 + $thisOffRampVprnId].1.3 as $AS vprnid $thisOffRampVprnId"
      }
    }
    foreach thisMgmtVprnId $mgmtVprnIdList {
      if {$thisMgmtVprnId != "Base"} {
        CLN "dut $dut3 systemip 10.[expr 40 + $thisMgmtVprnId].1.3 as $AS vprnid $thisMgmtVprnId"
        if {$mgmtVprnConnectivity == "PE-PE"} {
          CLN "dut $dut4 systemip 10.[expr 40 + $thisMgmtVprnId].1.4 as $AS vprnid $thisMgmtVprnId"
        }
      }
    }

    CLN "dut $dut1 filter $option(filter_ip_id) entry $option(entry_ip_id) dstip 100.0.0.0/8"
    CLN "dut $dut2 filter $option(filter_ip_id) entry $option(entry_ip_id) dstip 100.0.0.0/8"
    CLN "dut $dut3 filter $option(filter_ip_id) entry $option(entry_ip_id) dstip 100.0.0.0/8"
    CLN "dut $dut1 filterv6 $option(filter_ipv6_id) entry $option(entry_ipv6_id) dstip 100::0/8"
    CLN "dut $dut2 filterv6 $option(filter_ipv6_id) entry $option(entry_ipv6_id) dstip 100::0/8"
    CLN "dut $dut3 filterv6 $option(filter_ipv6_id) entry $option(entry_ipv6_id) dstip 100::0/8"

    CLN "dut $dut2 tonode $dut1 ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
    CLN "dut $dut1 tonode $dut2 ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
    if {[lsearch $offRampVprnIdList Base] != -1} {
      log_msg INFO "offramp via Base instance (default for 90R6)"
      CLN "dut Ixia  tonode $dut1 ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
      CLN "dut $dut1 tonode Ixia  ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
    } elseif {$offRampRedirectToVrf} {
      log_msg INFO "offramp via redirectToVrf (traffic received from Ixia in Base instance)"
      CLN "dut Ixia  tonode $dut1 ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
      CLN "dut $dut1 tonode Ixia  ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
    } else {
      log_msg INFO "offramp via vprn instance"
      foreach thisOffRampVprnId $offRampVprnIdList {
        CLN "dut Ixia tonode $dut1 vprnid $thisOffRampVprnId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
        CLN "dut $dut1 tonode Ixia vprnid $thisOffRampVprnId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id) node 'grt-lookup enable-grt static-route 100.0.0.0/8 grt'"
      }
    }
    CLN "dut $dut3 tonode $dut2 ldp true isisarea $isisAreaId"
    CLN "dut $dut2 tonode $dut3 ldp true isisarea $isisAreaId"

    CLN "dut Ixia  tonode $dut2 isisarea $isisAreaId vprnid $onRampVprnId  inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
    CLN "dut $dut3 tonode $dut1 ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
    CLN "dut $dut1 tonode $dut3 ldp true isisarea $isisAreaId inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"

    if {$mgmtVprnConnectivity == "PE-PE"} {
      CLN "dut $dut3 tonode $dut4 ldp true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut3 ldp true isisarea $isisAreaId"
    }

    CLN "dut $dut2 prefixlist 'all100s prefix 100.0.0.0/8 longer' "
    foreach thisOnRampVprnId $onRampVprnIdList {
      if {$thisOnRampVprnId != "Base"} {
        set ipSubnet [getIpSubnet $thisOnRampVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia) [lenToMask $clnItfMask]]
        CLN "dut $dut2 prefixlist 'allIxias prefix $ipSubnet/$clnItfMask longer' "
      } else {
        set ipSubnet [getIpSubnet $baseIesVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia) [lenToMask $clnItfMask]]
        CLN "dut $dut2 prefixlist 'allIxias prefix $ipSubnet/$clnItfMask longer' "
      }
    }

    foreach thisOnRampVprnId $onRampVprnIdList {
      if {$thisOnRampVprnId != "Base"} {
        CLN "dut $dut2 policy leakFromVprnToGrt entry 1 from 'prefix-list all100s' action accept"
        CLN "dut $dut2 policy leakFromVprnToGrt entry 2 from 'prefix-list allIxias' action accept"
        CLN "dut $dut2 vprnid $thisOnRampVprnId node 'grt-lookup export-grt leakFromVprnToGrt'"
      }
    }

    if {[lsearch $offRampVprnIdList Base] != -1} {
      log_msg INFO "offramp via Base instance (default for 90R6)"
      CLN "dut $dut3 policy exporttmsgrt entry 1 from 'protocol vpn-leak' action accept"
      CLN "dut $dut3 policy exporttmsgrt entry 2 from 'protocol tms' action accept"
    } else {
      log_msg INFO "offramp via vprn instance"
    }

    CLN "dut $dut2 policy fromAll100s entry 1 from 'prefix-list all100s' action accept"
    CLN "dut $dut2 policy fromAllIxias entry 1 from 'prefix-list allIxias' action accept"
    CLN "dut $dut2 policy fromStaticToIsis entry 1 from 'protocol static' action accept"
    CLN "dut $dut2 policy fromStaticToIsis entry 1 to 'protocol isis' action accept"
    CLN "dut $dut2 bgp 'export fromAll100s'"
    CLN "dut $dut2 isis 'export fromAllIxias fromStaticToIsis'"

    foreach thisOnRampVprnId $onRampVprnIdList {
      if {$thisOnRampVprnId != "Base"} {
        CLN "dut $dut2 staticroute '100::0/120 black-hole'"
        CLN "dut $dut2 tonode Ixia vprnid $thisOnRampVprnId dot1q $thisOnRampVprnId staticroute '100.0.0.0/24 next-hop $thisOnRampVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia)' inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
        CLN "dut $dut2 tonode Ixia vprnid $thisOnRampVprnId dot1q $thisOnRampVprnId staticroute '100::0/120 next-hop [ipv4ToIpv6 $thisOnRampVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia)]' inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
      } else {
        CLN "dut $dut2 tonode Ixia dot1q $baseIesVprnId staticroute '100.0.0.0/24 next-hop $baseIesVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia)' inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
        CLN "dut $dut2 tonode Ixia dot1q $baseIesVprnId staticroute '100::0/120 next-hop [ipv4ToIpv6 $baseIesVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia)]' inegfilter $option(filter_ip_id) inegfilterv6 $option(filter_ipv6_id)"
      }
    }

    # bgp
    if {[lsearch $onRampVprnIdList Base] != -1} {
      log_msg INFO "onramp via Base instance"
      CLN "dut $dut3 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6'"
      CLN "dut $dut2 bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6'"
    } else {
      log_msg INFO "onramp via vprn instance (default for 90R6)"
      CLN "dut $dut3 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras $AS bgpfamily 'vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6'"
      CLN "dut $dut2 bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras $AS bgpfamily 'vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6'"
    }

    if {[lsearch $offRampVprnIdList Base] != -1} {
      log_msg INFO "offramp via Base instance (default for 90R6)"
      CLN "dut $dut3 bgpneighbor [set [set dut1]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 flow-ipv4 flow-ipv6' bgp 'export exporttmsgrt'"
      CLN "dut $dut1 bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 flow-ipv4 flow-ipv6'"
      CLN "dut $dut3 bgpneighbor [ipv4ToIpv6 [set [set dut1]_ifsystem_ip]] bgppeeras $AS bgpfamily 'ipv6' bgp 'export exporttmsgrt'"
      CLN "dut $dut1 bgpneighbor [ipv4ToIpv6 [set [set dut3]_ifsystem_ip]] bgppeeras $AS bgpfamily 'ipv6'"

      CLN "dut $dut2 bgpneighbor [set [set dut1]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 flow-ipv4 flow-ipv6'"
      CLN "dut $dut1 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 flow-ipv4 flow-ipv6'"
      CLN "dut $dut2 bgpneighbor [ipv4ToIpv6 [set [set dut1]_ifsystem_ip]] bgppeeras $AS bgpfamily 'ipv6'"
      CLN "dut $dut1 bgpneighbor [ipv4ToIpv6 [set [set dut2]_ifsystem_ip]] bgppeeras $AS bgpfamily 'ipv6'"
    } else {
      log_msg INFO "offramp via vprn instance"
      CLN "dut $dut3 bgpneighbor [set [set dut1]_ifsystem_ip] bgppeeras $AS bgpfamily 'vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6'"
      CLN "dut $dut1 bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras $AS bgpfamily 'vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6'"

      CLN "dut $dut2 bgpneighbor [set [set dut1]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6'"
      CLN "dut $dut1 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras $AS bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6'"
      CLN "dut $dut2 bgpneighbor [ipv4ToIpv6 [set [set dut1]_ifsystem_ip]] bgppeeras $AS bgpfamily 'ipv6'"
      CLN "dut $dut1 bgpneighbor [ipv4ToIpv6 [set [set dut2]_ifsystem_ip]] bgppeeras $AS bgpfamily 'ipv6'"
    }

    if {$offRampRedirectToVrf} {
      switch $flowrouteOrigin {
        "sbgp" {
          CLN "dut $dut3 tonode Linux dot1q $linuxFirstVlanId"
          CLN "dut $dut3 bgpneighbor $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.Linux) bgppeeras $linuxAS bgpfamily 'ipv4 flow-ipv4 flow-ipv6'"
        }
        "arborsp" {
          # done further during configure interfaces to Arbor CP
        }
      }
    }

    if {$mgmtVprnConnectivity == "PE-PE"} {
      CLN "dut $dut3 bgpneighbor [set [set dut4]_ifsystem_ip] bgppeeras $AS bgpfamily 'vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6'"
      CLN "dut $dut4 bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras $AS bgpfamily 'vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6'"
    }

    CLN.exec
    CLN.reset
    
    cliCne $dut1 "environment no create"
    cliCne $dut3 "environment no create"
    #####
    ### offRampConnectivity rework BEGIN
    if {$offRampConnectivity == "CE-PE"} {
      log_msg INFO "Rework $dut1/$dut3 to have offRampConnectivity \"$offRampConnectivity\" setup"
      foreach thisOffRampVprnId $offRampVprnIdList {
        tms_moveItfFromDutToDut $dut1 $dut3 $thisOffRampVprnId $thisOffRampVprnId $portA($dut1.Ixia) $portA($dut3.$dut1) to_Ixia to_[set dut1] \
                                                -shutFromVprn true
        tms_removePortFromItf $dut1 $portA($dut1.$dut3) -newPortMode "access"
        tms_createEpipe $dut1 $option(offRampConnectivityEpipeId) $portA($dut1.Ixia) $portA($dut1.$dut3)
      }
    }
    ### offRampConnectivity rework END
    #####

    #####
    ### onRampConnectivity rework BEGIN
    if {$onRampConnectivity == "CE-PE"} {
      log_msg INFO "Rework $dut3/$dut2 to have onRampConnectivity \"$onRampConnectivity\" setup"
      foreach thisOnRampVprnId $onRampVprnIdList {
        tms_moveItfFromDutToDut $dut2 $dut3 $thisOnRampVprnId $thisOnRampVprnId $portA($dut2.Ixia):[set thisOnRampVprnId] $portA($dut3.$dut2) to_Ixia[set thisOnRampVprnId] to_[set dut2] \
                                                -shutFromVprn true
        tms_removePortFromItf $dut2 $portA($dut2.$dut3) -newPortMode "access"
        tms_createEpipe $dut2 $option(onRampConnectivityEpipeId) $portA($dut2.Ixia):[set thisOnRampVprnId] $portA($dut2.$dut3) \
                                 -fromEncapType dot1q -toEncapType noEncap
        # copy static-routes from dut2 to dut3
        set rCli [$dut3 sendCliCommand "configure service vprn $thisOnRampVprnId static-route 100.0.0.0/24 next-hop $thisOnRampVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia)"] ; log_msg INFO "$rCli"
        set rCli [$dut3 sendCliCommand "configure service vprn $thisOnRampVprnId static-route 100::0/120 next-hop [ipv4ToIpv6 $thisOnRampVprnId.$dataip(id.$dut2).$dataip(id.Ixia).$dataip(id.Ixia)]"] ; log_msg INFO "$rCli"
      }
    }
    ### onRampConnectivity rework END
    #####



    if {$onRampTunnelMethod == "autobind" && $onRampTunnelEncap == "ldp"} {
      log_msg INFO "No rework $dut2/$dut3 needed.  Use default \"$onRampTunnelMethod - $onRampTunnelEncap \" setup"
    }

    if {$offRampTunnelMethod == "autobind" && $offRampTunnelEncap == "ldp"} {
      log_msg INFO "No rework $dut1/$dut3 needed.  Use default \"$offRampTunnelMethod - $offRampTunnelEncap \" setup"
    }

    saveOrRestore resetFile -dut $dutList

    log_msg INFO "configure itfs to Arbor CP"
    set nbrIsaTmsCnt 0
    foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
      foreach {itfToArborCpPort itfToArborCpName itfToArborCpPfxMsk_dut itfToArborCpPfxMsk_cp hostAddrArborCp mgmtVprnId} $toArborCpList {
        set isaTmsItfPfx_cp [lindex [split $itfToArborCpPfxMsk_cp "/"] 0] ; set isaTmsItfMsk_cp [lindex [split $itfToArborCpPfxMsk_cp "/"] 1]
        foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break}
        foreach {thisA thisB thisC thisD} [split $isaTmsPfx "."] {break}
        SORAF $dut "exit all"
        #
        if {$mgmtVprnId == "Base"} {
          SORAF $dut "configure port $itfToArborCpPort no shutdown"
          SORAF $dut "configure router"
          SORAF $dut "        static-route $hostAddrArborCp/32 next-hop $isaTmsItfPfx_cp"
          SORAF $dut "exit all"
        } else {
          if {$mgmtVprnConnectivity == "PE-PE"} {
            if {$mgmtVprnConnectivityMtu != ""} {
              SORAF $dut3 "configure port $portA($dut3.$dut4) shutdown"
              SORAF $dut3 "configure port $portA($dut3.$dut4) ethernet mtu $mgmtVprnConnectivityMtu"
              SORAF $dut3 "configure port $portA($dut3.$dut4) no shutdown"
              SORAF $dut4 "configure port $portA($dut4.$dut3) shutdown"
              SORAF $dut4 "configure port $portA($dut4.$dut3) ethernet mtu $mgmtVprnConnectivityMtu"
              SORAF $dut4 "configure port $portA($dut4.$dut3) no shutdown"
            }
            SORAF $dut4 "configure port $itfToArborCpPort shutdown"
            SORAF $dut4 "configure port $itfToArborCpPort ethernet mode access"
            SORAF $dut4 "configure port $itfToArborCpPort no shutdown"
            SORAF $dut4 "configure service vprn $mgmtVprnId"
            SORAF $dut4 "        static-route $hostAddrArborCp/32 next-hop $isaTmsItfPfx_cp"
            SORAF $dut4 "exit all"
            # There is at least on local itf needed in the vprn.  This ip address is used a src-ip in ping.
            # Use a loopback address in the subnet of the isa-tms's (there is already a static-route on the ArborCP to reach this)
            SORAF $dut "configure service vprn $mgmtVprnId"
            SORAF $dut "        interface thisLoopb create"
            SORAF $dut "        address $thisA.$thisB.$thisC.200/32"
            SORAF $dut "        loopback"
            SORAF $dut "exit all"
          } else {
            SORAF $dut "configure port $itfToArborCpPort shutdown"
            SORAF $dut "configure port $itfToArborCpPort ethernet mode access"
            SORAF $dut "configure port $itfToArborCpPort no shutdown"
            SORAF $dut "configure service vprn $mgmtVprnId"
            SORAF $dut "        static-route $hostAddrArborCp/32 next-hop $isaTmsItfPfx_cp"
            SORAF $dut "exit all"
          }
        }
        #
      }
      incr nbrIsaTmsCnt ; if {$nbrIsaTmsCnt == $nbrIsaTmsMax} {log_msg INFO ">Reached nbrIsaTmsMax ($nbrIsaTmsMax)" ; break}
    }

    log_msg INFO "configure tms-interfaces"
    set nbrIsaTmsCnt 0 ; set isaTmsIpAddrList ""
    foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
      foreach {itfToArborCpPort itfToArborCpName itfToArborCpPfxMsk_dut itfToArborCpPfxMsk_cp hostAddrArborCp mgmtVprnId} $toArborCpList {
        set isaTmsCard [lindex [split $isaTmsCardMda "/"] 0] ; set isaTmsMda [lindex [split $isaTmsCardMda "/"] 1]
        foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break}
        if {$offRampVprnId != "Base"} {
          set offRampTxt "off-ramp-vprn $offRampVprnId"
        } else {
          set offRampTxt ""
        }
        if {$mgmtVprnId != "Base"} {
          set mgmtTxt "mgmt-vprn $mgmtVprnId"
        } else {
          set mgmtTxt ""
        }
        lappend isaTmsIpAddrList $isaTmsPfx
        if {$onRampVprnId == "Base"} {
          SORAF $dut "configure service"
          SORAF $dut "        ies $baseIesVprnId customer 1 create"
          SORAF $dut "            tms-interface mda-$isaTmsCard-$isaTmsMda $offRampTxt create $mgmtTxt"
          SORAF $dut "                description tms-$isaTmsCard-$isaTmsMda"
          SORAF $dut "                address $isaTmsPfxMsk"
          SORAF $dut "                port $isaTmsCardMda"
          SORAF $dut "                password 'password=arbor zone-secret=admin' "
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          SORAF $dut "                ipv6"
          SORAF $dut "                exit"
          }
          SORAF $dut "            exit"
          SORAF $dut "            no shutdown"
          SORAF $dut "        exit"
          SORAF $dut "exit all"
        } else {
          SORAF $dut "configure service"
          SORAF $dut "        vprn $onRampVprnId customer 1 create"
          SORAF $dut "            tms-interface mda-$isaTmsCard-$isaTmsMda create $offRampTxt $mgmtTxt"
          SORAF $dut "                description tms-$isaTmsCard-$isaTmsMda"
          SORAF $dut "                address $isaTmsPfxMsk"
          SORAF $dut "                port $isaTmsCardMda"
          SORAF $dut "                password 'password=arbor zone-secret=admin' "
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          SORAF $dut "                ipv6"
          SORAF $dut "                exit"
          }
          SORAF $dut "            exit"
          SORAF $dut "            no shutdown"
          SORAF $dut "        exit"
          SORAF $dut "exit all"
        }
      }
      incr nbrIsaTmsCnt ; if {$nbrIsaTmsCnt == $nbrIsaTmsMax} {log_msg INFO ">Reached nbrIsaTmsMax ($nbrIsaTmsMax)" ; break}
    }

    log_msg INFO "configure interfaces to Arbor CP"
    set itfToArborCpPfxMskList ""
    set debugMirrorSourcePortList ""
    set nbrIsaTmsCnt 0
    foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
      foreach {itfToArborCpPort itfToArborCpName itfToArborCpPfxMsk_dut itfToArborCpPfxMsk_cp hostAddrArborCp mgmtVprnId} $toArborCpList {
        set isaTmsItfPfx_cp [lindex [split $itfToArborCpPfxMsk_cp "/"] 0] ; set isaTmsItfMsk_cp [lindex [split $itfToArborCpPfxMsk_cp "/"] 1]
        if {[lsearch $itfToArborCpPfxMskList $itfToArborCpPfxMsk_dut] == -1} {
          # this is new itf
          lappend itfToArborCpPfxMskList $itfToArborCpPfxMsk_dut
          lappend debugMirrorSourcePortList $itfToArborCpPort
          set isaTmsCard [lindex [split $isaTmsCardMda "/"] 0] ; set isaTmsMda [lindex [split $isaTmsCardMda "/"] 1]
          if {$mgmtVprnId == "Base"} {
            SORAF $dut "configure router"
            SORAF $dut "interface $itfToArborCpName"
            SORAF $dut "    port $itfToArborCpPort"
            SORAF $dut "    address $itfToArborCpPfxMsk_dut"
            SORAF $dut "exit all"
            if {$flowrouteOrigin == "arborsp"} {
              SORAF $dut "configure router bgp group g neighbor $isaTmsItfPfx_cp local-as $AS"
              SORAF $dut "configure router bgp group g neighbor $isaTmsItfPfx_cp peer-as $linuxAS"
              SORAF $dut "configure router bgp group g neighbor $isaTmsItfPfx_cp family ipv4 flow-ipv4"
            }
          } else {
            if {$mgmtVprnConnectivity == "PE-PE"} {
              SORAF $dut4 "configure service vprn $mgmtVprnId"
              SORAF $dut4 "interface $itfToArborCpName create"
              SORAF $dut4 "    sap $itfToArborCpPort create"
              SORAF $dut4 "    exit"
              SORAF $dut4 "    address $itfToArborCpPfxMsk_dut"
              SORAF $dut4 "exit all"
            } else {
              SORAF $dut "configure service vprn $mgmtVprnId"
              SORAF $dut "interface $itfToArborCpName create"
              SORAF $dut "    sap $itfToArborCpPort create"
              SORAF $dut "    exit"
              SORAF $dut "    address $itfToArborCpPfxMsk_dut"
              SORAF $dut "exit all"
            }
          }
        }
      }
      incr nbrIsaTmsCnt ; if {$nbrIsaTmsCnt == $nbrIsaTmsMax} {log_msg INFO ">Reached nbrIsaTmsMax ($nbrIsaTmsMax)" ; break}
    }

    set resultSaveOrRestore [saveOrRestore execFile -dut $dutList -timeout $option(cliExecTimeout)]
    if {$resultSaveOrRestore != "noError"} {log_msg ERROR "saveOrRestore execFile failed" ; set Result FAIL}

    # enable debug logging to memory
    set rCli [$dut3 sendCliCommand "configure log log-id $isaTmsDebugLogId from debug"] ; log_msg INFO "$rCli"
    set rCli [$dut3 sendCliCommand "configure log log-id $isaTmsDebugLogId to memory"] ; log_msg INFO "$rCli"
  }

  if {$option(test)} {
    foreach {chassisTx cardTx portTx} [split $ixia_port($portA(Ixia.$dut1)) " "] {break}
    foreach {chassisRx cardRx portRx} [split $ixia_port($portA(Ixia.$dut2)) " "] {break}
    log_msg INFO "chassisTx: $chassisTx cardTx: $cardTx portTx: $portTx => chassisRx: $chassisRx cardRx: $cardRx portRx: $portRx"
    set portListIx [list [list $chassisTx $cardTx $portTx] [list $chassisRx $cardRx $portRx]]

    if {! [testFailed] || $Result == "OK"} {
      log_msg INFO "configure traffic streams on Ixia port: $portA(Ixia.$dut1)"
      handlePacket -port $portA(Ixia.$dut1) -action stop
      set thisDA 00:00:00:00:00:[int2Hex1 $dataip(id.$dut1)]
      set startStreamId 1
      set streamId $startStreamId ; set streamFamilyList ""

      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
        if {$option(family) == "ipv4"} {
          # only one stream needed, use default action
          set thisHandlePacketAction ""
        } else {
          # an ipv6 stream is needed also
          set thisHandlePacketAction create
        }
        handlePacket -port $portA(Ixia.$dut1) -dst 100.0.0.1 -numDest $numDest_v4 -src $src_fwd_v4 -numSource $numSource -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $option(rawProtocol) -action $thisHandlePacketAction
        if {$option(family) == "ipv4v6"} {
          # createFilter futher (see => create filter for ipv4 and ipv6 traffic here)
          incr streamId
        } else {
          # ipv4 only filter
          log_msg INFO "configure stats filter (pattern1 $streamData_ISATMS patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v4]) on Ixia port: $portA(Ixia.$dut2)"
          if {$option(getIxiaStatsViaHandlePacket)} {
            handlePacket -action setfilterDownload -port $portA(Ixia.$dut2) -filter "pattern1 \"$streamData_ISATMS\" patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v4]"
          } else {
            ixiaCreateFilter $portA(Ixia.$dut2) -pattern1 $streamData_ISATMS -patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v4]
          }
        }
      }
      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
        handlePacket -port $portA(Ixia.$dut1) -dst 100::1 -numDest $numDest_v6 -src $src_fwd_v6 -numSource $numSource -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $option(rawProtocol)
        switch $streamId {
          "1" {
            # ipv6 only filter
            log_msg INFO "configure stats filter (pattern1 $streamData_ISATMS patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v6]) on Ixia port: $portA(Ixia.$dut2)"
            if {$option(getIxiaStatsViaHandlePacket)} {
              handlePacket -action setfilterDownload -port $portA(Ixia.$dut2) -filter "pattern1 \"$streamData_ISATMS\" patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v6]"
            } else {
              ixiaCreateFilter $portA(Ixia.$dut2) -pattern1 $streamData_ISATMS -patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v6]
            }
          }
          "2" {
            # => create filter for ipv4 and ipv6 traffic here
            log_msg INFO "configure stats filter (pattern1 $streamData_ISATMS patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v4] AND pattern2 $streamData_ISATMS patternOffset2 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v6]) on Ixia port: $portA(Ixia.$dut2)"
            if {$option(getIxiaStatsViaHandlePacket)} {
              handlePacket -action setfilterDownload -port $portA(Ixia.$dut2) -filter "pattern1 \"$streamData_ISATMS\" patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v4] pattern2 \"$streamData_ISATMS\" patternOffset2 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v6]"
            } else {
              ixiaCreateFilter $portA(Ixia.$dut2) -pattern1 $streamData_ISATMS -patternOffset1 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v4] -userDefinedStat1Enable true -pattern2 $streamData_ISATMS -patternOffset2 [expr $patternOffsetDot1q + $streamData_ISATMS_offset_v6] -userDefinedStat2Enable true
            }
          }
        }
      }
      set stopStreamId $streamId

      for {set getStreamId $startStreamId} {$getStreamId <= $stopStreamId} {incr getStreamId} {
        if {[stream get $chassisTx $cardTx $portTx $getStreamId]} {
          log_msg ERROR "stream get failed => $chassisTx $cardTx $portTx $streamId"
        } else {
          set stream_[set getStreamId]_framesize [stream cget -framesize]
          set stream_[set getStreamId]_percentPacketRate [stream cget -percentPacketRate]
          set stream_[set getStreamId]_fpsRate [stream cget -fpsRate]
          set stream_[set getStreamId]_bpsRate [stream cget -bpsRate]
          set stream_[set getStreamId]_gbps [format "%.2f" [expr [set stream_[set getStreamId]_bpsRate] / 1000000000.0]]
          log_msg INFO "stream_[set getStreamId]_framesize: [set stream_[set getStreamId]_framesize] stream_[set getStreamId]_percentPacketRate: [set stream_[set getStreamId]_percentPacketRate] stream_[set getStreamId]_fpsRate: [set stream_[set getStreamId]_fpsRate] stream_[set getStreamId]_bpsRate: [set stream_[set getStreamId]_bpsRate] set stream_[set getStreamId]_gbps: [set stream_[set getStreamId]_gbps]"
        }
      }

    }

    if {! [testFailed] && $Result == "OK"} {
      if {$offRampRedirectToVrf} {
        if {$flowrouteOrigin == "arborsp"} {
          # nop
        } else {
          log_msg INFO "Start bgp peer on Linux $portA(Linux.$dut3)"
          sbgp.init -linuxItf $portA(Linux.$dut3) -id peer$linuxFirstVlanId -linuxIp $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.Linux) \
                                                                                                        -dutIp $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.$dut3) \
                                                                                                        -linuxAs $linuxAS -dutAs $AS \
                                                                                                        -capability [list ipv4 vpn-ipv4 flow-ipv4 flow-ipv6] -linuxDot1q $linuxFirstVlanId
        }
      }
    }
# Verify TMS status
    log_msg INFO "=> Verify ISA TMS status"
    if {! [testFailed] && $Result == "OK"} {
      for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
        log_msg INFO "Waiting $option(interRetryTimeSec) secs" ; after [expr $option(interRetryTimeSec) * 1000]
        set nbrIsaTmsCnt 0 ; set nbrActiveTms 0
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break}
          set tmsStatus [tms_getTmsInterface_tmsHealthInfo $dut $onRampVprnId $isaTmsPfx status]
          log_msg INFO "$dut vprn: $onRampVprnId TMS: $isaTmsCardMda ($isaTmsPfxMsk) => tmsStatus: $tmsStatus"
          if {$tmsStatus != "Up"} {
            log_msg INFO "This TMS is not yet \"Up\" " ; break
          } else {
            incr nbrActiveTms
          }
          incr nbrIsaTmsCnt ; if {$nbrIsaTmsCnt == $nbrIsaTmsToVerify} {log_msg INFO ">Reached nbrIsaTmsToVerify ($nbrIsaTmsToVerify)" ; break}
        }

        if {$nbrActiveTms == $nbrIsaTmsToVerify} {
          log_msg INFO "$nbrActiveTms / $nbrIsaTmsToVerify TMS are \"Up\" "
          break
        } else {
          if {$rCnt == $option(maxRetryCnt)} {
            log_msg ERROR "$nbrActiveTms / $nbrIsaTmsToVerify TMS are \"Up\" .  Max retries ($option(maxRetryCnt) x $option(interRetryTimeSec) secs) reached"
            set Result FAIL
          } else {
            log_msg INFO "$nbrActiveTms / $nbrIsaTmsToVerify TMS are \"Up\"  ... continue till all TMS's are \"Up\" "
          }
        }
      }
    }
# Verify off-ramp and management VPRN
    log_msg INFO "=> Verify off-ramp and management VPRN"
    if {! [testFailed] && $Result == "OK"} {
      foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
        foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break}
        foreach {itfToArborCpPort itfToArborCpName itfToArborCpPfxMsk_dut itfToArborCpPfxMsk_cp hostAddrArborCp mgmtVprnId} $toArborCpList {
          foreach thisMethod [list cli snmp] {
            set tmsOffRampVprnId 0 ; set tmsMgmtVprnId 0
            tms_getTmsInterface_offrampAndMgmtVprn $dut $onRampVprnId $isaTmsPfx tmsOffRampVprnId tmsMgmtVprnId -method $thisMethod
            if {$tmsOffRampVprnId == $offRampVprnId && $tmsMgmtVprnId == $mgmtVprnId} {
              log_msg INFO "$dut (vprn $onRampVprnId ; method: $thisMethod) isa-tms $isaTmsPfx: Successful verified \"Off-Ramp VPRN\" ($tmsOffRampVprnId) and \"Mgmt VPRN\" ($tmsMgmtVprnId)"
            } else {
              log_msg ERROR "$dut (vprn $onRampVprnId ; method: $thisMethod) isa-tms $isaTmsPfx: Not successful verified \"Off-Ramp VPRN\" (found: $tmsOffRampVprnId ; exp: $offRampVprnId) and \"Mgmt VPRN\" (found: $tmsMgmtVprnId ; exp: $mgmtVprnId)"
              break
            }
          }
          if {[testFailed] || $Result != "OK"} {break}
        }
        if {[testFailed] || $Result != "OK"} {break}
      }
    }
    if {! [testFailed] && $Result == "OK"} {
      log_msg INFO "First stop all ongoing mitigations and wait till all mitigated routes are gone"
      arbor_stopAllMitigationTms Dut-J

      foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
        foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break}
        if {[tms_checkTmsInterface_tmsHealthInfo $dut $onRampVprnId $isaTmsPfx nbrMitigations 0]} {
          log_msg INFO "$dut (vprn $onRampVprnId) isa-tms $isaTmsPfx: No mitigations found (expected behavior)"
        } else {
          log_msg ERROR "$dut (vprn $onRampVprnId) isa-tms $isaTmsPfx: Unexpected mitigations found (expected 0)" ; break
        }
        if {$hasMitigations} {
          getFib -match "route 100.0.0.1" -dut $dut3 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
          getFib -match "route 100.0.0.1" -dut $dut1 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
          getFib -match "route 100::1" -dut $dut3 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
          getFib -match "route 100::1" -dut $dut1 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
        }
      }
    }
# Configure prefix lists for IPv6 also into policies - all100s and allIxias - in order to route traffic into Ixia connected to $dut2 in VPRN32 (VPN leak)
#    set rCli [$dut2 sendCliCommand "/configure router no static-route 100::/120 black-hole"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "/configure router policy-options begin"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "/configure router policy-options prefix-list all100s prefix 100::/120 longer"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "/configure router policy-options prefix-list allIxias prefix 3FFE::2002:900/120 longer"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "/configure router policy-options commit"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
    after 30000
    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)"} ; after 10000
      }
      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
        foreach dut $dutList {$dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
      }

      if {$offRampConnectivity == "CE-PE" || $onRampConnectivity == "CE-PE"} {
        log_msg INFO "Skip \"Precondition: Check if traffic goes through path $dut1->$dut2\" for offRampConnectivity: \"$offRampConnectivity\" ; onRampConnectivity: \"$onRampConnectivity\" "
      } else {
        set mySubtest "Precondition: Check if traffic goes through path $dut1->$dut2"
        log_msg INFO "$mySubtest (clear filters, wait 10secs and check if traffic flows like expected)"

        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
        subtest "$mySubtest"
      }
    }

    if {! [testFailed] && $Result == "OK"} {
      foreach isaTmsPfxMsk $isaTmsPfxMskList {
        foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; arbor_pingIsaTms Dut-J $isaTmsPfx -generateError $option(generateErrorDuningArborTmsSanity)
      }
    }
# interpreter
# Set action forward to router on Dut-A filter 1

    if {$option(offRampRedirectToVrf_order) == "redirectActionBeforeTmsRoute"} {
        foreach filterIpType $filterType {
            set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $offRampVprnId"]
            # Verify
            log_msg INFO "=> Verify action forward router $offRampVprnId"
            # CLI
            set r1 [ $dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id) | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
                if { $name != $offRampVprnId } { log_msg ERROR "Wrong router name: $name"; set Result FAIL }
            } else { log_msg ERROR "Not possible to parse string for routerId"; set Result FAIL }
            puts [$dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id)"]
            # SNMP
            set r [$dut1 getT[getVar3 $filterIpType]FilterParamsFwdRtrId $option(filter_[getVar4 $filterIpType]_id) $option(entry_[getVar4 $filterIpType]_id) ]
            set testResultFlag [wccpCompareOutputString [$dut1 getVRtrInstanceId $offRampVprnId] $r]
        }
    }
    if {$option(flowspecInteraction) == "true"} {
        log_msg INFO "Test will be performed with flowspec filter interaction"
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            set rCli [$dut1 sendCliCommand "configure router interface to_Ixia ingress flowspec"] ; log_msg INFO "$rCli"
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            set rCli [$dut1 sendCliCommand "configure router interface to_Ixia ingress flowspec-ipv6"] ; log_msg INFO "$rCli"
        }
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            log_msg INFO "Inject IPv4 flowroute"
            for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
              # start from 100.0.0.1/32
              set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
              # starts from firstOffRampVprnId
              set thisRT "target:1:[expr $firstOffRampVprnId + $thisDestCnt_v4 - 1]"
              set flow1 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix]
              set comm1 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT]
              sbgp.add -id peer$linuxFirstVlanId -mpReachRaw $flow1 -community $comm1 -nlriAs "$linuxAS 65001 65002" -mpAfi ipv4 -mpSafi flow-base
              log_msg INFO "Linux: Add flowroute for \"$flow1\" with extCommunityAttr \"$comm1\""
            }
            sbgp.run -id peer$linuxFirstVlanId
            log_msg INFO "Linux: Send $numDest_v4 flowroute(s)"
            set gridDepth 2 ; set tBgpPeerGroupMinRouteAdvertisementSecs [expr ($tBgpPeerGroupMinRouteAdvertisement + 5) * $gridDepth]
            log_msg INFO "Waiting $tBgpPeerGroupMinRouteAdvertisementSecs secs" ; after [expr $tBgpPeerGroupMinRouteAdvertisementSecs * 1000]
            set rCli [$dut1 sendCliCommand "show router bgp routes flow-ipv4"] ; log_msg INFO "$rCli"
            set thisFlowIpv4ActRtsResultList [flowspec_getFlowIpv4ActRts [list flowIpv4ActRts_[set dut1_N]_ngbr[set dut3_N]]]
            if {$thisFlowIpv4ActRtsResultList != 0} {
              foreach {flowIpv4ActRts_dut1_ngbrdut3} $thisFlowIpv4ActRtsResultList {break}
              if {$flowIpv4ActRts_dut1_ngbrdut3 == $numDest_v4} {
                log_msg INFO "$dut1: Found expected nbr flowroutes ($numDest_v4)"
              } else {
                log_msg ERROR "$dut1: Couldn't  find expected nbr flowroutes.  Found: $flowIpv4ActRts_dut1_ngbrdut3 (exp: $numDest_v4)"
              }
            } else {
              log_msg ERROR "Empty thisFlowIpv4ActRtsResultList"
            }
            for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
              # starts from offRampVprnId + 0
              set thisOffRampVprnId [expr $firstOffRampVprnId + $thisDestCnt_v4 - 1]
              # start from 100.0.0.1/32
              set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
              if {[flowspec_getIpFlowspecFilter $dut1 -findDestPrefixMsk $thisDstPrefix -findFwdRtr $thisOffRampVprnId -expectIngressMatches false]} {
                log_msg INFO "$dut1: Found the expected IP flowspec filter"
              } else {
                log_msg ERROR "$dut1: Couldn't find the expected IP flowspec filter"
              }
            }
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            log_msg INFO "Inject IPv6 flowroute"
            for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
              # start from 100::/128
              set thisDstPrefix_v6 100::$thisDestCnt_v6/128
              # set thisDstPrefix_v6 [ipv4ToIpv6 100.0.0.1]/128
              # starts from firstOffRampVprnId
              set thisRT_v6 "target:1:[expr $firstOffRampVprnId + $thisDestCnt_v6 - 1]"
              set flow1_v6 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix_v6]
              set comm1_v6 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT_v6]
              sbgp.add -id peer$linuxFirstVlanId -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs "$linuxAS 65001 65002" -mpAfi ipv6 -mpSafi flow-base -mpNHop [ipv4ToIpv6 $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.Linux)]
              log_msg INFO "Linux: Add flowroute for \"$flow1_v6\" with extCommunityAttr \"$comm1_v6\""
            }
            sbgp.run -id peer$linuxFirstVlanId
            log_msg INFO "Linux: Send $numDest_v6 flowroute(s)"
            set gridDepth 2 ; set tBgpPeerGroupMinRouteAdvertisementSecs [expr ($tBgpPeerGroupMinRouteAdvertisement + 5) * $gridDepth]
            log_msg INFO "Waiting $tBgpPeerGroupMinRouteAdvertisementSecs secs" ; after [expr $tBgpPeerGroupMinRouteAdvertisementSecs * 1000]
            set rCli [$dut1 sendCliCommand "show router bgp routes flow-ipv6"] ; log_msg INFO "$rCli"
            set thisFlowIpv6ActRtsResultList [flowspec_getFlowIpv6ActRts [list flowIpv6ActRts_[set dut1_N]_ngbr[set dut3_N]]]
            if {$thisFlowIpv6ActRtsResultList != 0} {
              foreach {flowIpv6ActRts_dut1_ngbrdut3} $thisFlowIpv6ActRtsResultList {break}
              if {$flowIpv6ActRts_dut1_ngbrdut3 == $numDest_v6} {
                log_msg INFO "$dut1: Found expected nbr flowroutes ($numDest_v6)"
              } else {
                log_msg ERROR "$dut1: Couldn't  find expected nbr flowroutes.  Found: $flowIpv6ActRts_dut1_ngbrdut3 (exp: $numDest_v6)"
              }
            } else {
              log_msg ERROR "Empty thisFlowIpv6ActRtsResultList"
            }
            for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
              # starts from offRampVprnId + 0
              set thisOffRampVprnId [expr $firstOffRampVprnId + $thisDestCnt_v6 - 1]
              # start from 100::1/128
              set thisDstPrefix 100::$thisDestCnt_v6/128
              if {[flowspec_getIpFlowspecFilter $dut1 -findDestPrefixMsk $thisDstPrefix -findFwdRtr $thisOffRampVprnId -expectIngressMatches false -family ipv6]} {
                log_msg INFO "$dut1: Found the expected IP flowspec-ipv6 filter"
              } else {
                log_msg ERROR "$dut1: Couldn't find the expected IP flowspec-ipv6 filter"
              }
            }
        }

    }
# Start mitigation

    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
        for {set mCnt 1} {$mCnt <= $option(numMitigations_v4)} {incr mCnt} {
          set thisMitigation "reg_[set ::TestDB::thisTestBed]_v4dst_100_[set mCnt]_fwd_[set mitTxtTail]"
          set mySubtest "Start mitigation $thisMitigation (off-ramp all traffic ; no drop): Traffic should go via path $dut1->$dut3->$dut2"
          arbor_startMitigationTms Dut-J $thisMitigation
        }
      }
      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
        for {set mCnt 1} {$mCnt <= $option(numMitigations_v6)} {incr mCnt} {
          set thisMitigation "reg_[set ::TestDB::thisTestBed]_v6dst_100_[set mCnt]_fwd_[set mitTxtTail]"
          set mySubtest "Start mitigation $thisMitigation (off-ramp all traffic ; no drop): Traffic should go via path $dut1->$dut3->$dut2"
          arbor_startMitigationTms Dut-J $thisMitigation
        }
      }
    }

# Check mitigation
    if {$option(offRampRedirectToVrf_order) == "redirectActionBeforeTmsRoute"} {
        if {! [testFailed] && $Result == "OK"} {
          foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
            if {$hasMitigations} {
              set thisVprnId $onRampVprnId
              foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
              # ecmp => all mitigations should be received by all isa-tms's
              set nbrMitigationsExp 0
              if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set nbrMitigationsExp [expr $nbrMitigationsExp + $option(numMitigations_v4)]
              }
              if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set nbrMitigationsExp [expr $nbrMitigationsExp + $option(numMitigations_v6)]
              }
              if {[tms_checkTmsInterface_tmsHealthInfo $dut3 $onRampVprnId $thisIpAddr nbrMitigations $nbrMitigationsExp]} {
                log_msg INFO "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Expected nbr mitigations found ($nbrMitigationsExp)"
              } else {
                log_msg ERROR "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Couldn't find expected nbr mitigations ($nbrMitigationsExp)"
              }
            }
          }
        }
    }

    if {$option(offRampRedirectToVrf_order) == "redirectActionAfterTmsRoute"} {  
        foreach filterIpType $filterType  {
            set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $offRampVprnId"]
            # Verify
            log_msg INFO "=> Verify action forward router $offRampVprnId"
            # CLI
            set r1 [ $dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id) | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
                if { $name != $offRampVprnId } { log_msg ERROR "Wrong router name: $name"; set testResultFlag "FAILED" }
            } else { log_msg ERROR "Not possible to parse string for routerId"; set testResultFlag "FAILED" }
            puts [$dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id)"]
            # SNMP
            set r [$dut1 getT[getVar3 $filterIpType]FilterParamsFwdRtrId $option(filter_[getVar4 $filterIpType]_id) $option(entry_[getVar4 $filterIpType]_id) ]
            set testResultFlag [wccpCompareOutputString [$dut1 getVRtrInstanceId $offRampVprnId] $r]

            foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
                if {$hasMitigations} {
                  set thisVprnId $onRampVprnId
                  foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
                  # ecmp => all mitigations should be received by all isa-tms's
                  set nbrMitigationsExp 0
                  if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                    set nbrMitigationsExp [expr $nbrMitigationsExp + $option(numMitigations_v4)]
                  }
                  if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                    set nbrMitigationsExp [expr $nbrMitigationsExp + $option(numMitigations_v6)]
                  }
                  if {[tms_checkTmsInterface_tmsHealthInfo $dut3 $onRampVprnId $thisIpAddr nbrMitigations $nbrMitigationsExp]} {
                    log_msg INFO "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Expected nbr mitigations found ($nbrMitigationsExp)"
                  } else {
                    log_msg ERROR "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Couldn't find expected nbr mitigations ($nbrMitigationsExp)"
                  }
                }
            }
        }
    }

    if {! [testFailed] && $Result == "OK"} {
      log_msg INFO "Wait 20sec ..." ; after 20000
      foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
        if {$hasMitigations} {
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            getFib -match "route 100.0.0.1" -dut $dut3 -tryTime 120 -errorIfNotFound true -vprn [tms_toVprnId $offRampVprnId]
            if {$offRampConnectivity == "CE-PE" || $offRampRedirectToVrf} {
              log_msg INFO "Skip \"Check fib check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" or offRampRedirectToVrf: $offRampRedirectToVrf"
            } else {
              getFib -match "route 100.0.0.1" -dut $dut1 -tryTime 120 -errorIfNotFound true -vprn [tms_toVprnId $offRampVprnId]
            }
            if {$offRampVprnId == "Base"} {
              foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)"} ; after 10000
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
              # skip this check.  No filter match for encapsulated traffic (LDP + BGP-VPN label)
            }
          }
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            getFib -match "route 100::1" -dut $dut3 -tryTime 120 -errorIfNotFound true -vprn [tms_toVprnId $offRampVprnId]
            if {$offRampConnectivity == "CE-PE"} {
              log_msg INFO "Skip \"Check fib check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" "
            } else {
              getFib -match "route 100::1" -dut $dut1 -tryTime 120 -errorIfNotFound true -vprn [tms_toVprnId $offRampVprnId]
            }
            if {$offRampVprnId == "Base"} {
              foreach dut $dutList {$dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
              # skip this check.  No filter match for encapsulated traffic (LDP + BGP-VPN label)
            }
          }
        }
        if {[testFailed] || $Result != "OK"} {break}
      }
    }
    if {! [testFailed] && $Result == "OK"} {
      log_msg INFO "Check if HEALTH CHECK msgs Tx/Rx between tmsD(our side) and alud(tms side) during 1min"
      foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
        if {$hasMitigations} {
          set rCli [$dut3 sendCliCommand "no debug"] ; log_msg INFO "$rCli"
          set rCli [$dut3 sendCliCommand "clear log $isaTmsDebugLogId"] ; log_msg INFO "$rCli"
          set thisVprnId $onRampVprnId
          foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
          tms_enableDebugTmsInterface $dut3 $thisVprnId $thisIpAddr -detail true
          after 60000
          if {[tms_analyseDebugTmsInterface $dut3 $isaTmsDebugLogId checkIfHealthInfoIsRxTx_withCorrectRouterInstanceId -vprnId $thisVprnId -ip $thisIpAddr]} {
            log_msg INFO "$dut3: Successful verified (checkIfHealthInfoIsRxTx) tms-interface debug log $isaTmsDebugLogId."
            log_msg INFO "      Gain some time ... it's enough to verify only one tms-interface" ; break
          } else {
            log_msg ERROR "$dut3: Not successful verified (checkIfHealthInfoIsRxTx) tms-interface debug log $isaTmsDebugLogId." ; set Result FAIL ; break
          }
        }
      }
    }

# Verify number of TMS routes
    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            set thisVprnId $onRampVprnId
            foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
            if {$allTmsItfsOnSameVprn} {
              set nbrTotalTmsRoutesExp_v4 [expr $option(numMitigations_v4) * $nbrIsaTmsToVerifyWithMitigations] ; set nbrActiveTmsRoutesExp_v4 [expr $option(numMitigations_v4) * $nbrIsaTmsToVerifyWithMitigations] ; set nbrInactiveTmsRoutesExp_v4 0
            } else {
              set nbrTotalTmsRoutesExp_v4 $option(numMitigations_v4)  ; set nbrActiveTmsRoutesExp_v4 $option(numMitigations_v4) ; set nbrInactiveTmsRoutesExp_v4 0
            }
            if {[tms_checkTmsRoutes $dut3 $thisVprnId $nbrTotalTmsRoutesExp_v4 $nbrActiveTmsRoutesExp_v4 $nbrInactiveTmsRoutesExp_v4 -family ipv4]} {
              log_msg INFO "$dut3 (vprnId: $thisVprnId) checkTmsRoutes successful"
            } else {
              log_msg ERROR "$dut3 (vprnId: $thisVprnId) checkTmsRoutes not successful" ; set Result FAIL ; break
            }
          }
        }
      }

      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            set thisVprnId $onRampVprnId
            foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
            if {$allTmsItfsOnSameVprn} {
              set nbrTotalTmsRoutesExp_v6 [expr $option(numMitigations_v6) * $nbrIsaTmsToVerifyWithMitigations] ; set nbrActiveTmsRoutesExp_v6 [expr $option(numMitigations_v6) * $nbrIsaTmsToVerifyWithMitigations] ; set nbrInactiveTmsRoutesExp_v6 0
            } else {
              set nbrTotalTmsRoutesExp_v6 $option(numMitigations_v6) ; set nbrActiveTmsRoutesExp_v6 $option(numMitigations_v6) ; set nbrInactiveTmsRoutesExp_v6 0
            }
            if {[tms_checkTmsRoutes $dut3 $thisVprnId $nbrTotalTmsRoutesExp_v6 $nbrActiveTmsRoutesExp_v6 $nbrInactiveTmsRoutesExp_v6 -family ipv6]} {
              log_msg INFO "$dut3 (vprnId: $thisVprnId) checkTmsRoutes successful"
            } else {
              log_msg ERROR "$dut3 (vprnId: $thisVprnId) checkTmsRoutes not successful" ; set Result FAIL ; break
            }
          }
        }
      }
    }

# Verify active/available tms routes in show router 13 route-table summary ipv4
    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            log_msg INFO "Check \"show router $offRampVprnId route-table summary ipv4\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set activeTmsRts_v4 [tms_getRouteTableSummary_nbrOfActiveTmsRoutes $dut3 -family ipv4 -vprn $offRampVprnId]
              set availableTmsRts_v4 [tms_getRouteTableSummary_nbrOfAvailableTmsRoutes $dut3 -family ipv4 -vprn $offRampVprnId]
              set activeTmsRtsExp_v4 $option(numMitigations_v4)
              set availableTmsRtsExp_v4 [expr $option(numMitigations_v4) * [expr $nbrIsaTmsToVerifyWithMitigations / $nbrOffRampVprn]]
              if {$activeTmsRts_v4 == $activeTmsRtsExp_v4 && $availableTmsRts_v4 == $availableTmsRtsExp_v4} {
                log_msg INFO "$dut3: Successful verified active/available tms routes in \"show router $offRampVprnId route-table summary ipv4\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified active/available tms routes in \"show router $offRampVprnId route-table summary ipv4\" ; activeTmsRts_v4: $activeTmsRts_v4 (exp: $activeTmsRtsExp_v4) ; availableTmsRts_v4: $availableTmsRts_v4 (exp: $availableTmsRtsExp_v4)" ; set Result FAIL ; break
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
      }
    }
    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            log_msg INFO "Check \"show router $offRampVprnId route-table summary ipv6\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set activeTmsRts_v6 [tms_getRouteTableSummary_nbrOfActiveTmsRoutes $dut3 -family ipv6 -vprn $offRampVprnId]
              set availableTmsRts_v6 [tms_getRouteTableSummary_nbrOfAvailableTmsRoutes $dut3 -family ipv6 -vprn $offRampVprnId]
              set activeTmsRtsExp_v6 $option(numMitigations_v6)
              set availableTmsRtsExp_v6 [expr $option(numMitigations_v6) * [expr $nbrIsaTmsToVerifyWithMitigations / $nbrOffRampVprn]]
              if {$activeTmsRts_v6 == $activeTmsRtsExp_v6 && $availableTmsRts_v6 == $availableTmsRtsExp_v6} {
                log_msg INFO "$dut3: Successful verified active/available tms routes in \"show router route-table summary ipv6\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified active/available tms routes in \"show router $offRampVprnId route-table summary ipv6\" ; activeTmsRts_v6: $activeTmsRts_v6 (exp: $activeTmsRtsExp_v6) ; availableTmsRts_v6: $availableTmsRts_v6 (exp: $availableTmsRtsExp_v6)" ; set Result FAIL ; break
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
      }
    }
# Verify nbr routes in "show router 13 route-table protocol tms ip
    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            log_msg INFO "Check \"show router $offRampVprnId route-table protocol tms ipv4\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set nbrRts_v4 [tms_getRouteTableProtocolTms_nbrOfRoutes $dut3 -family ipv4 -vprn $offRampVprnId]
              set nbrRtsExp_v4 [expr $option(numMitigations_v4) * [expr $nbrIsaTmsToVerifyWithMitigations / $nbrOffRampVprn]]
              if {$nbrRts_v4 == $nbrRtsExp_v4} {
                log_msg INFO "$dut3: Successful verified nbr routes in \"show router $offRampVprnId route-table protocol tms ipv4\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified nbr routes in \"show router $offRampVprnId route-table protocol tms ipv4\" ; nbrRts_v4: $nbrRts_v4 (exp: $nbrRtsExp_v4)" ; set Result FAIL ; break
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
      }
    }

    if {! [testFailed] && $Result == "OK"} {
      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            log_msg INFO "Check \"show router $offRampVprnId route-table protocol tms ipv6\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set nbrRts_v6 [tms_getRouteTableProtocolTms_nbrOfRoutes $dut3 -family ipv6 -vprn $offRampVprnId]
              set nbrRtsExp_v6 [expr $option(numMitigations_v6) * [expr $nbrIsaTmsToVerifyWithMitigations / $nbrOffRampVprn]]
              if {$nbrRts_v6 == $nbrRtsExp_v6} {
                log_msg INFO "$dut3: Successful verified nbr routes in \"show router $offRampVprnId route-table protocol tms ipv6\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified nbr routes in \"show router $offRampVprnId route-table protocol tms ipv6\" ; nbrRts_v6: $nbrRts_v6 (exp: $nbrRtsExp_v6)" ; set Result FAIL ; break
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
      }
    }
# Verify if packets are hitting the filter correctly
    foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
    if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
      getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
      getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
      getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
      getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
      getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
    }
    if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
      getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
      getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
      getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
      getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
      getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
    }
# Verify packet drop
    if {! [testFailed] && $Result == "OK"} {
      log_msg INFO "Check end-to-end packet loss while mitigation is ongoing"
      handlePacket -port $portA(Ixia.$dut1) -action stop ; after 1000
      foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)"}
      foreach dut $dutList {$dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"}
      foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
        set thisVprnId $onRampVprnId
        foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
        tms_clearTmsInterface_counters $dut3 $thisVprnId $thisIpAddr
      }

      log_msg INFO "Clear Ixia stats and start traffic"
      ixClearStats portListIx
      handlePacket -port $portA(Ixia.$dut1) -action start
      set startTimeStampSec [clock seconds]
      set whileContinue 1 ; set elapsedMinCnt 0
      while {$whileContinue} {
        switch $option(trafficDurationMethod) {
          "quick" - "regular" - "long" {
            set wTxt "of [set [set option(trafficDurationMethod)]TrafficDurationMin] min (elapsed min: $elapsedMinCnt)"
          }
          "ifFileExists" {
            set wTxt "till file $option(fileExistsName) exists (elapsed min: $elapsedMinCnt)"
          }
        }
        log_msg INFO "Waiting 1min $wTxt" ; after 60000 ; incr elapsedMinCnt
        switch $option(trafficDurationMethod) {
          "quick" - "regular" - "long" {
            if {$elapsedMinCnt == [set [set option(trafficDurationMethod)]TrafficDurationMin]} {set whileContinue 0}
          }
          "ifFileExists" {
            if {! [file exists $option(fileExistsName)]} {set whileContinue 0}
          }
        }
      }
      handlePacket -port $portA(Ixia.$dut1) -action stop ; after 1000

      if {$option(getIxiaStatsViaHandlePacket)} {
        set ixiaRxPkt [handlePacket -action getstats -port $portA(Ixia.$dut2) -stat userDefinedStat1]
        if {$option(family) == "ipv4v6"} {
          # there are 2 userDefinedStat (one for ipv4/one for ipv6)
          set ixiaRxPkt [expr $ixiaRxPkt +  [handlePacket -action getstats -port $portA(Ixia.$dut2) -stat userDefinedStat2]]
        }
        set ixiaTxPkt [handlePacket -action getstats -port $portA(Ixia.$dut1) -stat scheduledFramesSent]
      } else {
        set ixiaRxPkt [IXIAgetPortStats [list [set chassisRx] [set cardRx] [set portRx]] userDefinedStat1]
        if {$option(family) == "ipv4v6"} {
          # there are 2 userDefinedStat (one for ipv4/one for ipv6)
          set ixiaRxPkt [expr $ixiaRxPkt + [IXIAgetPortStats [list [set chassisRx] [set cardRx] [set portRx]] userDefinedStat2]]
        }
        set ixiaTxPkt [IXIAgetPortStats [list [set chassisTx] [set cardTx] [set portTx]] scheduledFramesSent]
      }
      if {$ixiaTxPkt != 0 && $ixiaRxPkt == $ixiaTxPkt} {
        log_msg INFO "Successful verified end-to-end traffic.  NO packet loss (ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)"
      } else {
        if {[GGV tmsRestartTrafficIcoFailure] == "true"} {
          log_msg DEBUG "Restart traffic on port $portA(Ixia.$dut1) for debugging"
          handlePacket -port $portA(Ixia.$dut1) -action start
        }
        log_msg ERROR "Not successful verified end-to-end traffic.  PACKET LOSS (ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)" ; set Result FAIL
      }

      foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
        if {$hasMitigations} {
          set thisVprnId $onRampVprnId
          foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
          tms_getTmsInterface_counters $dut $thisVprnId $thisIpAddr rxPkts rxBytes txPkts txBytes txDiscardPkts
          log_msg INFO "$dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda ($isaTmsPfxMsk)"
          log_msg INFO "  => rxPkts: $rxPkts rxBytes: $rxBytes txPkts: $txPkts txBytes: $txBytes txDiscardPkts: $txDiscardPkts"
          if {$txDiscardPkts != 0} {
            log_msg ERROR "Found unacceptable \"DiscardPkts\" (TMS is not able to process traffic without drops)" ; set Result FAIL
          }
        }
      }
    }

# Verify SWO during mitigation
    if {! [testFailed] && $Result == "OK"} {
      if {$verifySwo} {
        log_msg INFO "Check end-to-end packet loss while mitigation is ongoing during double swo"
        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 1000
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)"}
        foreach dut $dutList {$dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"}
        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          set thisVprnId $onRampVprnId
          foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
          tms_clearTmsInterface_counters $dut3 $thisVprnId $thisIpAddr
        }
        log_msg INFO "Clear Ixia stats and start traffic"
        ixClearStats portListIx
        handlePacket -port $portA(Ixia.$dut1) -action start
        set startTimeStampSec [clock seconds]
        set whileContinue 1 ; set elapsedMinCnt 0
        while {$whileContinue} {
          set wTxt "of $swoTestTrafficDurationMin min (elapsed min: $elapsedMinCnt)"
          log_msg INFO "Waiting 1min $wTxt" ; after 60000 ; incr elapsedMinCnt
          if {$elapsedMinCnt == $swoTestPerformActionAfterMin} {
            log_msg INFO "Perform double switchover after $swoTestPerformActionAfterMin min"
            set rCli [$dut3 sendCliCommand "show version"] ; log_msg INFO "$rCli"

            set actionTodo doubleSwo
            if {$actionTodo == "swo"} {set  nbrSwoToDo 1} else {set nbrSwoToDo 2}
            for {set swoNbr 1} {$swoNbr <= $nbrSwoToDo} {incr swoNbr} {
              set activitySwitchMethod [lindex $tmsSwoMethodList [random $tmsSwoMethodListLen]]
              log_msg INFO "$dut3: Switchover $swoNbr/$nbrSwoToDo activitySwitchMethod: $activitySwitchMethod"
              if {[$dut3 activitySwitch -inSyncTime1 11 -skipCheck true -inSyncTime3 2000 -Method $activitySwitchMethod -performISSU $performISSU] == "OK"} {
                # nop
              } else {
                log_msg ERROR "$dut3: Switchover failed" ; set Result FAIL ; break
              }
              after 1000 ; $dut3 closeExpectSession ; after 1000 ; $dut3 openExpectSession ; after 1000
              set rCli [$dut3 sendCliCommand "show version"] ; log_msg INFO "$rCli"
              log_msg INFO "$dut3: Wait until standby is synchronized"
              if {[$dut3 CnWSecInSync] == "OK"} {
                log_msg INFO "$dut3: Standby is in sync now - a new switchover is allowed"
                after 5000
                $dut3 closeExpectSession ; after 1000 ; $dut3 openExpectSession ; after 1000
              } else {
                log_msg DEBUG "$dut3: Standby not yet in sync" ; set Result FAIL ; break
              }
            }
            set mySubtest "activitySwitchMethod: $activitySwitchMethod"

          }
          if {$elapsedMinCnt == $swoTestTrafficDurationMin} {set whileContinue 0}

        }
        if {! [testFailed] && $Result == "OK"} {
          if {[tms_checkMitigationThroughEcmpTms $dut3 $expectedTmsRunningEcmpList $ecmpPktTolerancePercentage -dropAmountExp noDrop]} {
            log_msg INFO "checkMitigationThroughEcmpTms $dut3 $expectedTmsRunningEcmpList ok"
          } else {
            log_msg ERROR "checkMitigationThroughEcmpTms $dut3 $expectedTmsRunningEcmpList nok" ; set Result FAIL
          }
        }

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 1000

        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          if {$offRampConnectivity == "CE-PE" || $offRampRedirectToVrf} {
            log_msg INFO "Skip \"Check filter check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" or offRampRedirectToVrf: $offRampRedirectToVrf "
          } else {
            getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          }
          if {$onRampConnectivity == "CE-PE"} {
            log_msg INFO "Skip \"Check filter check in $dut2\" for onRampConnectivity: \"$onRampConnectivity\" "
          } else {
            getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          }
          # skip this check.  No filter match for encapsulated traffic (LDP + BGP-VPN label)
          # getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          if {$offRampConnectivity == "CE-PE" || $offRampRedirectToVrf} {
            log_msg INFO "Skip \"Check filter check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" or offRampRedirectToVrf: $offRampRedirectToVrf "
          } else {
            getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          }
          if {$onRampConnectivity == "CE-PE"} {
            log_msg INFO "Skip \"Check filter check in $dut2\" for onRampConnectivity: \"$onRampConnectivity\" "
          } else {
            getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          }
          # skip this check.  No filter match for encapsulated traffic (LDP + BGP-VPN label)
          # getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if {$option(getIxiaStatsViaHandlePacket)} {
          set ixiaRxPkt [handlePacket -action getstats -port $portA(Ixia.$dut2) -stat userDefinedStat1]
          if {$option(family) == "ipv4v6"} {
            # there are 2 userDefinedStat (one for ipv4/one for ipv6)
            set ixiaRxPkt [expr $ixiaRxPkt +  [handlePacket -action getstats -port $portA(Ixia.$dut2) -stat userDefinedStat2]]
          }
          set ixiaTxPkt [handlePacket -action getstats -port $portA(Ixia.$dut1) -stat scheduledFramesSent]
        } else {
          set ixiaRxPkt [IXIAgetPortStats [list [set chassisRx] [set cardRx] [set portRx]] userDefinedStat1]
          if {$option(family) == "ipv4v6"} {
            # there are 2 userDefinedStat (one for ipv4/one for ipv6)
            set ixiaRxPkt [expr $ixiaRxPkt + [IXIAgetPortStats [list [set chassisRx] [set cardRx] [set portRx]] userDefinedStat2]]
          }
          set ixiaTxPkt [IXIAgetPortStats [list [set chassisTx] [set cardTx] [set portTx]] scheduledFramesSent]
        }
        if {$option(tmsHotStandby)} {
          if {$ixiaTxPkt != 0 && $ixiaRxPkt == $ixiaTxPkt} {
            log_msg INFO "Successful verified end-to-end traffic.  NO packet loss (tmsHotStandby: $option(tmsHotStandby) ; ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)"
          } else {
            log_msg ERROR "Not successful verified end-to-end traffic.  PACKET LOSS (tmsHotStandby: $option(tmsHotStandby) ; ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)" ; set Result FAIL
          }
        } else {
          if {$ixiaTxPkt != 0 && $ixiaRxPkt <= $ixiaTxPkt} {
            log_msg INFO "Successful verified end-to-end traffic.  ACCEPTABLE packet loss (tmsHotStandby: $option(tmsHotStandby) ; ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)"
          } else {
            log_msg ERROR "Not successful verified end-to-end traffic.  (tmsHotStandby: $option(tmsHotStandby) ; ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)" ; set Result FAIL
          }
        }

        if {! [testFailed] && $Result == "OK"} {
          log_msg INFO "Check end-to-end packet loss while mitigation is ongoing after a double swo"
          handlePacket -port $portA(Ixia.$dut1) -action stop ; after 1000
          foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)"}
          foreach dut $dutList {$dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"}
          foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
            set thisVprnId $onRampVprnId
            foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
            tms_clearTmsInterface_counters $dut3 $thisVprnId $thisIpAddr
          }
          log_msg INFO "Clear Ixia stats and start traffic"
          ixClearStats portListIx
          handlePacket -port $portA(Ixia.$dut1) -action start
          set startTimeStampSec [clock seconds]
          set whileContinue 1 ; set elapsedMinCnt 0
          while {$whileContinue} {
            switch $option(trafficDurationMethod) {
              "quick" - "regular" - "long" {
                set wTxt "of [set [set option(trafficDurationMethod)]TrafficDurationMin] min (elapsed min: $elapsedMinCnt)"
              }
              "ifFileExists" {
                set wTxt "till file $option(fileExistsName) exists (elapsed min: $elapsedMinCnt)"
              }
            }
            log_msg INFO "Waiting 1min $wTxt" ; after 60000 ; incr elapsedMinCnt
            switch $option(trafficDurationMethod) {
              "quick" - "regular" - "long" {
                if {$elapsedMinCnt == [set [set option(trafficDurationMethod)]TrafficDurationMin]} {set whileContinue 0}
              }
              "ifFileExists" {
                if {! [file exists $option(fileExistsName)]} {set whileContinue 0}
              }
            }
          }
          handlePacket -port $portA(Ixia.$dut1) -action stop ; after 1000
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            if {$offRampConnectivity == "CE-PE" || $offRampRedirectToVrf} {
              log_msg INFO "Skip \"Check filter check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" or offRampRedirectToVrf: $offRampRedirectToVrf "
            } else {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if {$onRampConnectivity == "CE-PE"} {
              log_msg INFO "Skip \"Check filter check in $dut2\" for onRampConnectivity: \"$onRampConnectivity\" "
            } else {
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
            }
            # skip this check.  No filter match for encapsulated traffic (LDP + BGP-VPN label)
            # getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          }
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            if {$offRampConnectivity == "CE-PE" || $offRampRedirectToVrf} {
              log_msg INFO "Skip \"Check filter check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" or offRampRedirectToVrf: $offRampRedirectToVrf "
            } else {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if {$onRampConnectivity == "CE-PE"} {
              log_msg INFO "Skip \"Check filter check in $dut2\" for onRampConnectivity: \"$onRampConnectivity\" "
            } else {
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
            }
            # skip this check.  No filter match for encapsulated traffic (LDP + BGP-VPN label)
            # getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          }
          if {$option(getIxiaStatsViaHandlePacket)} {
            set ixiaRxPkt [handlePacket -action getstats -port $portA(Ixia.$dut2) -stat userDefinedStat1]
            if {$option(family) == "ipv4v6"} {
              # there are 2 userDefinedStat (one for ipv4/one for ipv6)
              set ixiaRxPkt [expr $ixiaRxPkt +  [handlePacket -action getstats -port $portA(Ixia.$dut2) -stat userDefinedStat2]]
            }
            set ixiaTxPkt [handlePacket -action getstats -port $portA(Ixia.$dut1) -stat scheduledFramesSent]
          } else {
            set ixiaRxPkt [IXIAgetPortStats [list [set chassisRx] [set cardRx] [set portRx]] userDefinedStat1]
            if {$option(family) == "ipv4v6"} {
              # there are 2 userDefinedStat (one for ipv4/one for ipv6)
              set ixiaRxPkt [expr $ixiaRxPkt + [IXIAgetPortStats [list [set chassisRx] [set cardRx] [set portRx]] userDefinedStat2]]
            }
            set ixiaTxPkt [IXIAgetPortStats [list [set chassisTx] [set cardTx] [set portTx]] scheduledFramesSent]
          }
          if {$ixiaTxPkt != 0 && $ixiaRxPkt == $ixiaTxPkt} {
            log_msg INFO "Successful verified end-to-end traffic.  NO packet loss (ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)"
          } else {
            log_msg ERROR "Not successful verified end-to-end traffic.  PACKET LOSS (ixiaTxPkt: $ixiaTxPkt => ixiaRxPkt: $ixiaRxPkt)" ; set Result FAIL
          }

          foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
            if {$hasMitigations} {
              set thisVprnId $onRampVprnId
              foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
              tms_getTmsInterface_counters $dut $thisVprnId $thisIpAddr rxPkts rxBytes txPkts txBytes txDiscardPkts
              log_msg INFO "$dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda ($isaTmsPfxMsk)"
              log_msg INFO "  => rxPkts: $rxPkts rxBytes: $rxBytes txPkts: $txPkts txBytes: $txBytes txDiscardPkts: $txDiscardPkts"
              if {$txDiscardPkts != 0} {
                log_msg ERROR "Found unacceptable \"DiscardPkts\" (TMS is not able to process traffic without drops)" ; set Result FAIL
              }
            }
          }
        }
      }
    } ; #verifySwo

    if {! [testFailed] && $Result == "OK"} {
      if {$option(offRampRedirectToVrf) && $option(withdrawFlowroute)} {
        set thisTrafficDurSecs 20
        log_msg INFO ""
        log_msg INFO "Start traffic and check (after $thisTrafficDurSecs secs) that traffic goes through $dut3 (ecmp via [llength $expectedTmsRunningEcmpList] TMSs) "
        log_msg INFO "Afterwards, change action on filter to forward and check that traffic doesn't go through $dut3"
        log_msg INFO ""

        handlePacket -port $portA(Ixia.$dut1) -action start ; after 1000

        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          set thisVprnId $onRampVprnId
          foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
          tms_clearTmsInterface_counters $dut3 $thisVprnId $thisIpAddr
        }
        after [expr $thisTrafficDurSecs * 1000]

        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          if {$hasMitigations} {
            set thisVprnId $onRampVprnId
            foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
            tms_getTmsInterface_counters $dut $thisVprnId $thisIpAddr rxPkts rxBytes txPkts txBytes txDiscardPkts
            log_msg INFO "$dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda ($isaTmsPfxMsk)"
            log_msg INFO "  => rxPkts: $rxPkts rxBytes: $rxBytes txPkts: $txPkts txBytes: $txBytes txDiscardPkts: $txDiscardPkts"
            if {$txDiscardPkts != 0} {
              log_msg ERROR "Found unacceptable \"DiscardPkts\" (TMS is not able to process traffic without drops)" ; break
            }
            set minRxTxPkts [expr ($thisTrafficDurSecs * $pktRatePerStream / [llength $expectedTmsRunningEcmpList]) / 2]
            if {$rxPkts > $minRxTxPkts && $txPkts > $minRxTxPkts} {
              log_msg INFO "Traffic goes through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda)"
            } else {
              log_msg ERROR "Traffic does't go through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda)" ; break
            }
          }
        }
        if {$option(flowspecInteraction) == "true"} {
# withdraw flowroute and verify, that based filter is not affected and traffic is still redirected to router 13
            log_msg INFO "Withdraw flowroutes and verify, that based filter is not affected and traffic is still redirected to VPRN $offRampVprnId"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
# withdraw IPv4 flowroute
                for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
                  # start from 100.0.0.1/32
                  set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
                  set flow1 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix]
                  set comm1 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT]
                  sbgp.add -id peer$linuxFirstVlanId -mpUnReachRaw $flow1 -mpAfi ipv4 -mpSafi flow-base
                  log_msg INFO "Linux: Add flowroute withdraw for \"$flow1\" "
                }
                sbgp.run -id peer$linuxFirstVlanId
                log_msg INFO "Linux: Send $numDest_v4 withdraw flowroute(s)"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
# withdraw IPv6 flowroute
            for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
              # start from 100::/128
              set thisDstPrefix_v6 100::$thisDestCnt_v6/128
              set flow1_v6 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix_v6]
              set comm1_v6 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT_v6]
              sbgp.add -id peer$linuxFirstVlanId -mpUnReachRaw $flow1_v6 -mpAfi ipv6 -mpSafi flow-base -mpNHop [ipv4ToIpv6 $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.Linux)]
              log_msg INFO "Linux: Add flowroute withdraw for \"$flow1_v6\" "
            }
            sbgp.run -id peer$linuxFirstVlanId
            log_msg INFO "Linux: Send $numDest_v6 withdraw flowroute(s)"           
            }
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
# Add again flowroutes
            log_msg INFO "Inject again flowroutes"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                log_msg INFO "Inject IPv4 flowroute"
                for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
                  # start from 100.0.0.1/32
                  set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
                  # starts from firstOffRampVprnId
                  set thisRT "target:1:[expr $firstOffRampVprnId + $thisDestCnt_v4 - 1]"
                  set flow1 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix]
                  set comm1 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT]
                  sbgp.add -id peer$linuxFirstVlanId -mpReachRaw $flow1 -community $comm1 -nlriAs "$linuxAS 65001 65002" -mpAfi ipv4 -mpSafi flow-base
                  log_msg INFO "Linux: Add flowroute for \"$flow1\" with extCommunityAttr \"$comm1\""
                }
                sbgp.run -id peer$linuxFirstVlanId
                log_msg INFO "Linux: Send $numDest_v4 flowroute(s)"
                set gridDepth 2 ; set tBgpPeerGroupMinRouteAdvertisementSecs [expr ($tBgpPeerGroupMinRouteAdvertisement + 5) * $gridDepth]
                log_msg INFO "Waiting $tBgpPeerGroupMinRouteAdvertisementSecs secs" ; after [expr $tBgpPeerGroupMinRouteAdvertisementSecs * 1000]
                set rCli [$dut1 sendCliCommand "show router bgp routes flow-ipv4"] ; log_msg INFO "$rCli"
                set thisFlowIpv4ActRtsResultList [flowspec_getFlowIpv4ActRts [list flowIpv4ActRts_[set dut1_N]_ngbr[set dut3_N]]]
                if {$thisFlowIpv4ActRtsResultList != 0} {
                  foreach {flowIpv4ActRts_dut1_ngbrdut3} $thisFlowIpv4ActRtsResultList {break}
                  if {$flowIpv4ActRts_dut1_ngbrdut3 == $numDest_v4} {
                    log_msg INFO "$dut1: Found expected nbr flowroutes ($numDest_v4)"
                  } else {
                    log_msg ERROR "$dut1: Couldn't  find expected nbr flowroutes.  Found: $flowIpv4ActRts_dut1_ngbrdut3 (exp: $numDest_v4)"
                  }
                } else {
                  log_msg ERROR "Empty thisFlowIpv4ActRtsResultList"
                }
                for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
                  # starts from offRampVprnId + 0
                  set thisOffRampVprnId [expr $firstOffRampVprnId + $thisDestCnt_v4 - 1]
                  # start from 100.0.0.1/32
                  set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
                  if {[flowspec_getIpFlowspecFilter $dut1 -findDestPrefixMsk $thisDstPrefix -findFwdRtr $thisOffRampVprnId -expectIngressMatches false]} {
                    log_msg INFO "$dut1: Found the expected IP flowspec filter"
                  } else {
                    log_msg ERROR "$dut1: Couldn't find the expected IP flowspec filter"
                  }
                }
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                log_msg INFO "Inject IPv6 flowroute"
                for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
                  # start from 100::/128
                  set thisDstPrefix_v6 100::$thisDestCnt_v6/128
                  # set thisDstPrefix_v6 [ipv4ToIpv6 100.0.0.1]/128
                  # starts from firstOffRampVprnId
                  set thisRT_v6 "target:1:[expr $firstOffRampVprnId + $thisDestCnt_v6 - 1]"
                  set flow1_v6 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix_v6]
                  set comm1_v6 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT_v6]
                  sbgp.add -id peer$linuxFirstVlanId -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs "$linuxAS 65001 65002" -mpAfi ipv6 -mpSafi flow-base -mpNHop [ipv4ToIpv6 $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.Linux)]
                  log_msg INFO "Linux: Add flowroute for \"$flow1_v6\" with extCommunityAttr \"$comm1_v6\""
                }
                sbgp.run -id peer$linuxFirstVlanId
                log_msg INFO "Linux: Send $numDest_v6 flowroute(s)"
                set gridDepth 2 ; set tBgpPeerGroupMinRouteAdvertisementSecs [expr ($tBgpPeerGroupMinRouteAdvertisement + 5) * $gridDepth]
                log_msg INFO "Waiting $tBgpPeerGroupMinRouteAdvertisementSecs secs" ; after [expr $tBgpPeerGroupMinRouteAdvertisementSecs * 1000]
                set rCli [$dut1 sendCliCommand "show router bgp routes flow-ipv6"] ; log_msg INFO "$rCli"
                set thisFlowIpv6ActRtsResultList [flowspec_getFlowIpv6ActRts [list flowIpv6ActRts_[set dut1_N]_ngbr[set dut3_N]]]
                if {$thisFlowIpv6ActRtsResultList != 0} {
                  foreach {flowIpv6ActRts_dut1_ngbrdut3} $thisFlowIpv6ActRtsResultList {break}
                  if {$flowIpv6ActRts_dut1_ngbrdut3 == $numDest_v6} {
                    log_msg INFO "$dut1: Found expected nbr flowroutes ($numDest_v6)"
                  } else {
                    log_msg ERROR "$dut1: Couldn't  find expected nbr flowroutes.  Found: $flowIpv6ActRts_dut1_ngbrdut3 (exp: $numDest_v6)"
                  }
                } else {
                  log_msg ERROR "Empty thisFlowIpv6ActRtsResultList"
                }
                for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
                  # starts from offRampVprnId + 0
                  set thisOffRampVprnId [expr $firstOffRampVprnId + $thisDestCnt_v6 - 1]
                  # start from 100::1/128
                  set thisDstPrefix 100::$thisDestCnt_v6/128
                  if {[flowspec_getIpFlowspecFilter $dut1 -findDestPrefixMsk $thisDstPrefix -findFwdRtr $thisOffRampVprnId -expectIngressMatches false -family ipv6]} {
                    log_msg INFO "$dut1: Found the expected IP flowspec-ipv6 filter"
                  } else {
                    log_msg ERROR "$dut1: Couldn't find the expected IP flowspec-ipv6 filter"
                  }
                }
            }
# Verify if packets are hitting the filter correctly
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
# change base entry filter to inactive
            log_msg INFO "Change base entry filter to inactive and again set action forward router $offRampVprnId"
            set r1 [cliCne $dut1 "/configure filter ip-filter $option(filter_ip_id) entry $option(entry_ip_id) no action"]
            set r1 [cliCne $dut1 "/configure filter ipv6-filter $option(filter_ipv6_id) entry $option(entry_ipv6_id) no action"]
            log_msg INFO "Verify, that traffic is still redirected to VPRN: $offRampVprnId through TMS to $dut2"
            foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
              if {$hasMitigations} {
                set thisVprnId $onRampVprnId
                foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
                tms_getTmsInterface_counters $dut $thisVprnId $thisIpAddr rxPkts rxBytes txPkts txBytes txDiscardPkts
                log_msg INFO "$dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda ($isaTmsPfxMsk)"
                log_msg INFO "  => rxPkts: $rxPkts rxBytes: $rxBytes txPkts: $txPkts txBytes: $txBytes txDiscardPkts: $txDiscardPkts"
                if {$txDiscardPkts != 0} {
                  log_msg ERROR "Found unacceptable \"DiscardPkts\" (TMS is not able to process traffic without drops)" ; break
                }
                set minRxTxPkts [expr ($thisTrafficDurSecs * $pktRatePerStream / [llength $expectedTmsRunningEcmpList]) / 2]
                if {$rxPkts > $minRxTxPkts && $txPkts > $minRxTxPkts} {
                  log_msg INFO "Traffic goes through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda)"
                } else {
                  log_msg ERROR "Traffic does't go through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda)" ; break
                }
              }
            }
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
            }
# change base entry filter action to forward router
            set r1 [cliCne $dut1 "/configure filter ip-filter $option(filter_ip_id) entry $option(entry_ip_id) action forward router $offRampVprnId"]
            set r1 [cliCne $dut1 "/configure filter ipv6-filter $option(filter_ipv6_id) entry $option(entry_ipv6_id) action forward router $offRampVprnId"]
            foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
              if {$hasMitigations} {
                set thisVprnId $onRampVprnId
                foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
                tms_getTmsInterface_counters $dut $thisVprnId $thisIpAddr rxPkts rxBytes txPkts txBytes txDiscardPkts
                log_msg INFO "$dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda ($isaTmsPfxMsk)"
                log_msg INFO "  => rxPkts: $rxPkts rxBytes: $rxBytes txPkts: $txPkts txBytes: $txBytes txDiscardPkts: $txDiscardPkts"
                if {$txDiscardPkts != 0} {
                  log_msg ERROR "Found unacceptable \"DiscardPkts\" (TMS is not able to process traffic without drops)" ; break
                }
                set minRxTxPkts [expr ($thisTrafficDurSecs * $pktRatePerStream / [llength $expectedTmsRunningEcmpList]) / 2]
                if {$rxPkts > $minRxTxPkts && $txPkts > $minRxTxPkts} {
                  log_msg INFO "Traffic goes through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda)"
                } else {
                  log_msg ERROR "Traffic does't go through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda)" ; break
                }
              }
            }
# Verify if packets are hitting the filter correctly
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
# disable flowspec flag on interface
            log_msg INFO "Disable flowspec flag on interface"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "configure router interface to_Ixia ingress no flowspec"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "configure router interface to_Ixia ingress no flowspec-ipv6"] ; log_msg INFO "$rCli"
            }
# Verify if packets are hitting the filter correctly
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Enable flowspec flag on interface again"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "configure router interface to_Ixia ingress flowspec"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "configure router interface to_Ixia ingress flowspec-ipv6"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                log_msg INFO "Inject IPv4 flowroute"
                for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
                  # start from 100.0.0.1/32
                  set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
                  # starts from firstOffRampVprnId
                  set thisRT "target:1:[expr $firstOffRampVprnId + $thisDestCnt_v4 - 1]"
                  set flow1 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix]
                  set comm1 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT]
                  sbgp.add -id peer$linuxFirstVlanId -mpReachRaw $flow1 -community $comm1 -nlriAs "$linuxAS 65001 65002" -mpAfi ipv4 -mpSafi flow-base
                  log_msg INFO "Linux: Add flowroute for \"$flow1\" with extCommunityAttr \"$comm1\""
                }
                sbgp.run -id peer$linuxFirstVlanId
                log_msg INFO "Linux: Send $numDest_v4 flowroute(s)"
                set gridDepth 2 ; set tBgpPeerGroupMinRouteAdvertisementSecs [expr ($tBgpPeerGroupMinRouteAdvertisement + 5) * $gridDepth]
                log_msg INFO "Waiting $tBgpPeerGroupMinRouteAdvertisementSecs secs" ; after [expr $tBgpPeerGroupMinRouteAdvertisementSecs * 1000]
                set rCli [$dut1 sendCliCommand "show router bgp routes flow-ipv4"] ; log_msg INFO "$rCli"
                set thisFlowIpv4ActRtsResultList [flowspec_getFlowIpv4ActRts [list flowIpv4ActRts_[set dut1_N]_ngbr[set dut3_N]]]
                if {$thisFlowIpv4ActRtsResultList != 0} {
                  foreach {flowIpv4ActRts_dut1_ngbrdut3} $thisFlowIpv4ActRtsResultList {break}
                  if {$flowIpv4ActRts_dut1_ngbrdut3 == $numDest_v4} {
                    log_msg INFO "$dut1: Found expected nbr flowroutes ($numDest_v4)"
                  } else {
                    log_msg ERROR "$dut1: Couldn't  find expected nbr flowroutes.  Found: $flowIpv4ActRts_dut1_ngbrdut3 (exp: $numDest_v4)"
                  }
                } else {
                  log_msg ERROR "Empty thisFlowIpv4ActRtsResultList"
                }
                for {set thisDestCnt_v4 1} {$thisDestCnt_v4 <= $numDest_v4} {incr thisDestCnt_v4} {
                  # starts from offRampVprnId + 0
                  set thisOffRampVprnId [expr $firstOffRampVprnId + $thisDestCnt_v4 - 1]
                  # start from 100.0.0.1/32
                  set thisDstPrefix 100.0.0.$thisDestCnt_v4/32
                  if {[flowspec_getIpFlowspecFilter $dut1 -findDestPrefixMsk $thisDstPrefix -findFwdRtr $thisOffRampVprnId -expectIngressMatches false]} {
                    log_msg INFO "$dut1: Found the expected IP flowspec filter"
                  } else {
                    log_msg ERROR "$dut1: Couldn't find the expected IP flowspec filter"
                  }
                }
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
                  # start from 100::/128
                  set thisDstPrefix_v6 100::$thisDestCnt_v6/128
                  # set thisDstPrefix_v6 [ipv4ToIpv6 100.0.0.1]/128
                  # starts from firstOffRampVprnId
                  set thisRT_v6 "target:1:[expr $firstOffRampVprnId + $thisDestCnt_v6 - 1]"
                  set flow1_v6 [createFlowSpecNLRIType -dstPrefix $thisDstPrefix_v6]
                  set comm1_v6 [createFlowSpecExtCommunityAttr redirectVrf -target $thisRT_v6]
                  sbgp.add -id peer$linuxFirstVlanId -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs "$linuxAS 65001 65002" -mpAfi ipv6 -mpSafi flow-base -mpNHop [ipv4ToIpv6 $linuxFirstVlanId.$dataip(id.$dut3).$dataip(id.Linux).$dataip(id.Linux)]
                  log_msg INFO "Linux: Add flowroute for \"$flow1_v6\" with extCommunityAttr \"$comm1_v6\""
                }
                sbgp.run -id peer$linuxFirstVlanId
                log_msg INFO "Linux: Send $numDest_v6 flowroute(s)"
                set gridDepth 2 ; set tBgpPeerGroupMinRouteAdvertisementSecs [expr ($tBgpPeerGroupMinRouteAdvertisement + 5) * $gridDepth]
                log_msg INFO "Waiting $tBgpPeerGroupMinRouteAdvertisementSecs secs" ; after [expr $tBgpPeerGroupMinRouteAdvertisementSecs * 1000]
                set rCli [$dut1 sendCliCommand "show router bgp routes flow-ipv6"] ; log_msg INFO "$rCli"
                set thisFlowIpv6ActRtsResultList [flowspec_getFlowIpv6ActRts [list flowIpv6ActRts_[set dut1_N]_ngbr[set dut3_N]]]
                if {$thisFlowIpv6ActRtsResultList != 0} {
                  foreach {flowIpv6ActRts_dut1_ngbrdut3} $thisFlowIpv6ActRtsResultList {break}
                  if {$flowIpv6ActRts_dut1_ngbrdut3 == $numDest_v6} {
                    log_msg INFO "$dut1: Found expected nbr flowroutes ($numDest_v6)"
                  } else {
                    log_msg ERROR "$dut1: Couldn't  find expected nbr flowroutes.  Found: $flowIpv6ActRts_dut1_ngbrdut3 (exp: $numDest_v6)"
                  }
                } else {
                  log_msg ERROR "Empty thisFlowIpv6ActRtsResultList"
                }
                for {set thisDestCnt_v6 1} {$thisDestCnt_v6 <= $numDest_v6} {incr thisDestCnt_v6} {
                  # starts from offRampVprnId + 0
                  set thisOffRampVprnId [expr $firstOffRampVprnId + $thisDestCnt_v6 - 1]
                  # start from 100::1/128
                  set thisDstPrefix 100::$thisDestCnt_v6/128
                  if {[flowspec_getIpFlowspecFilter $dut1 -findDestPrefixMsk $thisDstPrefix -findFwdRtr $thisOffRampVprnId -expectIngressMatches false -family ipv6]} {
                    log_msg INFO "$dut1: Found the expected IP flowspec-ipv6 filter"
                  } else {
                    log_msg ERROR "$dut1: Couldn't find the expected IP flowspec-ipv6 filter"
                  }
                }
            }
# Verify if packets are hitting the filter correctly
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
        }
# change action to forward
        log_msg INFO "Change action to forward"
            set r1 [cliCne $dut1 "/configure filter ip-filter $option(filter_ip_id) entry $option(entry_ip_id) action forward"]
            set r1 [cliCne $dut1 "/configure filter ipv6-filter $option(filter_ipv6_id) entry $option(entry_ipv6_id) action forward"]
            if {! [testFailed] && $Result == "OK"} {
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
              if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                puts [$dut1 sendCliCommand "/show filter ip $option(filter_ip_id)"]
                getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              }
              if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                puts [$dut1 sendCliCommand "/show filter ipv6 $option(filter_ipv6_id)"]
                getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              }
            }
            foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
              set thisVprnId $onRampVprnId
              foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
              tms_clearTmsInterface_counters $dut3 $thisVprnId $thisIpAddr
            }
            after 5000 
            foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
              if {$hasMitigations} {
                set thisVprnId $onRampVprnId
                foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
                tms_getTmsInterface_counters $dut $thisVprnId $thisIpAddr rxPkts rxBytes txPkts txBytes txDiscardPkts
                log_msg INFO "$dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda ($isaTmsPfxMsk)"
                log_msg INFO "  => rxPkts: $rxPkts rxBytes: $rxBytes txPkts: $txPkts txBytes: $txBytes txDiscardPkts: $txDiscardPkts"
                if {$txDiscardPkts != 0} {
                  log_msg ERROR "Found unacceptable \"DiscardPkts\" (TMS is not able to process traffic without drops)" ; break
                }
                if {$rxPkts < "20" } {
                  log_msg INFO "Traffic doesn't go through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda) ; Expected behavior"
                } else {
                  log_msg ERROR "Traffic goes through TMS ($dut vprn: $onRampVprnId isaTmsCardMda: $isaTmsCardMda) ; Not expected behavior" ; break
                }
              }
            }

      }
    }
    if {! [testFailed] && $Result == "OK"} {
      if {$onRampBaseIesShut || $onRampVprnVprnShut} {
        if {$onRampBaseIesShut} {
          set svcTxt "ies" ; set thisSvcId $baseIesVprnId
        } elseif {$onRampVprnVprnShut} {
          set svcTxt "vprn" ; set thisSvcId $onRampVprnId
        } else {
          set svcTxt "invalid" ; set thisSvcId "invalid"
        }
        log_msg INFO "$dut3: Shutdown $svcTxt service (wait 5secs) => Verify that tms-interfaces are going down + tms-routes disappears"
        set rCli [$dut3 sendCliCommand "configure service $svcTxt $thisSvcId shutdown"] ; log_msg INFO "$rCli"
        after 5000

        foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
          set thisVprnId $onRampVprnId
          foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
          tms_getTmsInterface_operStatus $dut $thisVprnId $thisIpAddr ipv4OperStatus ipv6OperStatus
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            if {$ipv4OperStatus == "outOfService"} {
              log_msg INFO "$dut (vprnId: $thisVprnId) check ipv4 operational status successful"
            } else {
              log_msg ERROR "$dut (vprnId: $thisVprnId) check ipv4 operational status not successful ; ipv4OperStatus: $ipv4OperStatus (exp: \"outOfService\")" ; break
            }
          }
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            if {$ipv6OperStatus == "outOfService"} {
              log_msg INFO "$dut (vprnId: $thisVprnId) check ipv6 operational status successful"
            } else {
              log_msg ERROR "$dut (vprnId: $thisVprnId) check ipv6 operational status not successful ; ipv6OperStatus: $ipv4OperStatus (exp: \"outOfService\")" ; break
            }
          }

          if {$hasMitigations} {
            set nbrTotalTmsRoutesExp 0 ; set nbrActiveTmsRoutesExp 0 ; set nbrInactiveTmsRoutesExp 0
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              if {[tms_checkTmsRoutes $dut $thisVprnId $nbrTotalTmsRoutesExp $nbrActiveTmsRoutesExp $nbrInactiveTmsRoutesExp -family ipv4]} {
                log_msg INFO "$dut (vprnId: $thisVprnId) checkTmsRoutes successful"
              } else {
                log_msg ERROR "$dut (vprnId: $thisVprnId) checkTmsRoutes not successful" ; break
              }
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              if {[tms_checkTmsRoutes $dut3 $thisVprnId $nbrTotalTmsRoutesExp $nbrActiveTmsRoutesExp $nbrInactiveTmsRoutesExp -family ipv6]} {
                log_msg INFO "$dut (vprnId: $thisVprnId) checkTmsRoutes successful"
              } else {
                log_msg ERROR "$dut (vprnId: $thisVprnId) checkTmsRoutes not successful" ; break
              }
            }
          }
        }
      }
    }
# Stop mitigation and verify behavior. Enable grt-leak in off-ramp VPRN in order to verify RFE162746
    if {! [testFailed] && $Result == "OK"} {
      if {$stopMitigationActionFwd} {
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 1000
        log_msg INFO "Check behavior when mitigation stops"
        if {! [testFailed] && $Result == "OK"} {
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            for {set mCnt 1} {$mCnt <= $option(numMitigations_v4)} {incr mCnt} {
              set thisMitigation "reg_[set ::TestDB::thisTestBed]_v4dst_100_[set mCnt]_fwd_[set mitTxtTail]"
              set mySubtest "Stop mitigation $thisMitigation (off-ramp all traffic ; no drop): Traffic should go via path $dut1->$dut3->$dut2"
              arbor_stopMitigationTms Dut-J $thisMitigation
            }
          }
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            for {set mCnt 1} {$mCnt <= $option(numMitigations_v6)} {incr mCnt} {
              set thisMitigation "reg_[set ::TestDB::thisTestBed]_v6dst_100_[set mCnt]_fwd_[set mitTxtTail]"
              set mySubtest "Stop mitigation $thisMitigation (off-ramp all traffic ; no drop): Traffic should go via path $dut1->$dut3->$dut2"
              arbor_stopMitigationTms Dut-J $thisMitigation
            }
          }
        }

        if {! [testFailed] && $Result == "OK"} {
          foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
            if {$hasMitigations} {
              set thisVprnId $onRampVprnId
              foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
              set nbrMitigationsExp 0
              if {[tms_checkTmsInterface_tmsHealthInfo $dut3 $onRampVprnId $thisIpAddr nbrMitigations $nbrMitigationsExp]} {
                log_msg INFO "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Expected nbr mitigations found ($nbrMitigationsExp)"
              } else {
                log_msg ERROR "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Couldn't find expected nbr mitigations ($nbrMitigationsExp)"
              }
            }
          }
        }
        if {! [testFailed] && $Result == "OK"} {
          log_msg INFO "Wait 20sec ..." ; after 20000
          foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
            if {$hasMitigations} {
              if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                getFib -match "route 100.0.0.1" -dut $dut3 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
                if {$offRampConnectivity == "CE-PE"} {
                  log_msg INFO "Skip \"Check fib check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" "
                } else {
                  getFib -match "route 100.0.0.1" -dut $dut1 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
                }
              }
              if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                getFib -match "route 100::1" -dut $dut3 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
                if {$offRampConnectivity == "CE-PE"} {
                  log_msg INFO "Skip \"Check fib check in $dut1\" for offRampConnectivity: \"$offRampConnectivity\" "
                } else {
                  getFib -match "route 100::1" -dut $dut1 -tryTime 120 -errorIfFound true -vprn [tms_toVprnId $offRampVprnId]
                }
              }
            }
            if {[testFailed] || $Result != "OK"} {break}
          }
# Verify path Dut-A -> Dut-B
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
          set nbrTotalTmsRoutesExp 0 ; set nbrActiveTmsRoutesExp 0 ; set nbrInactiveTmsRoutesExp 0
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            if {[tms_checkTmsRoutes $dut3 $thisVprnId $nbrTotalTmsRoutesExp $nbrActiveTmsRoutesExp $nbrInactiveTmsRoutesExp -family ipv4]} {
              log_msg INFO "$dut3 (vprnId: $thisVprnId) checkTmsRoutes successful"
            } else {
              log_msg ERROR "$dut3 (vprnId: $thisVprnId) checkTmsRoutes not successful"
            }
          }
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            if {[tms_checkTmsRoutes $dut3 $thisVprnId $nbrTotalTmsRoutesExp $nbrActiveTmsRoutesExp $nbrInactiveTmsRoutesExp -family ipv6]} {
              log_msg INFO "$dut3 (vprnId: $thisVprnId) checkTmsRoutes successful"
            } else {
              log_msg ERROR "$dut3 (vprnId: $thisVprnId) checkTmsRoutes not successful"
            }
          }
        }

        if {! [testFailed] && $Result == "OK"} {
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            log_msg INFO "Check \"show router route-table summary ipv4\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set activeTmsRts_v4 [tms_getRouteTableSummary_nbrOfActiveTmsRoutes $dut3 -family ipv4]
              set availableTmsRts_v4 [tms_getRouteTableSummary_nbrOfAvailableTmsRoutes $dut3 -family ipv4]
              set activeTmsRtsExp_v4 0
              set availableTmsRtsExp_v4 0
              if {$activeTmsRts_v4 == $activeTmsRtsExp_v4 && $availableTmsRts_v4 == $availableTmsRtsExp_v4} {
                log_msg INFO "$dut3: Successful verified active/available tms routes in \"show router route-table summary ipv4\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified active/available tms routes in \"show router route-table summary ipv4\" ; activeTmsRts_v4: $activeTmsRts_v4 (exp: $activeTmsRtsExp_v4) ; availableTmsRts_v4: $availableTmsRts_v4 (exp: $availableTmsRtsExp_v4)" ; set Result FAIL
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
        if {! [testFailed] && $Result == "OK"} {
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            log_msg INFO "Check \"show router route-table summary ipv6\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set activeTmsRts_v6 [tms_getRouteTableSummary_nbrOfActiveTmsRoutes $dut3 -family ipv6]
              set availableTmsRts_v6 [tms_getRouteTableSummary_nbrOfAvailableTmsRoutes $dut3 -family ipv6]
              set activeTmsRtsExp_v6 0
              set availableTmsRtsExp_v6 0
              if {$activeTmsRts_v6 == $activeTmsRtsExp_v6 && $availableTmsRts_v6 == $availableTmsRtsExp_v6} {
                log_msg INFO "$dut3: Successful verified active/available tms routes in \"show router route-table summary ipv6\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified active/available tms routes in \"show router route-table summary ipv6\" ; activeTmsRts_v6: $activeTmsRts_v6 (exp: $activeTmsRtsExp_v6) ; availableTmsRts_v6: $availableTmsRts_v6 (exp: $availableTmsRtsExp_v6)" ; set Result FAIL
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }

        if {! [testFailed] && $Result == "OK"} {
          if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            log_msg INFO "Check \"show router route-table protocol tms ipv4\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set nbrRts_v4 [tms_getRouteTableProtocolTms_nbrOfRoutes $dut3 -family ipv4]
              set nbrRtsExp_v4 0
              if {$nbrRts_v4 == $nbrRtsExp_v4} {
                log_msg INFO "$dut3: Successful verified nbr routes in \"show router route-table protocol tms ipv4\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified nbr routes in \"show router route-table protocol tms ipv4\" ; nbrRts_v4: $nbrRts_v4 (exp: $nbrRtsExp_v4)" ; set Result FAIL
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
        if {! [testFailed] && $Result == "OK"} {
          if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            log_msg INFO "Check \"show router route-table protocol tms ipv6\" "
            for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
              set nbrRts_v6 [tms_getRouteTableProtocolTms_nbrOfRoutes $dut3 -family ipv6]
              set nbrRtsExp_v6 0
              if {$nbrRts_v6 == $nbrRtsExp_v6} {
                log_msg INFO "$dut3: Successful verified nbr routes in \"show router route-table protocol tms ipv6\"" ; break
              } else {
                if {$rCnt == $option(maxRetryCnt)} {
                  log_msg ERROR "$dut3: Not successful verified nbr routes in \"show router route-table protocol tms ipv6\" ; nbrRts_v6: $nbrRts_v6 (exp: $nbrRtsExp_v6)" ; set Result FAIL
                } else {
                  log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) before retry ..." ; after [expr $option(interRetryTimeSec) * 1000]
                }
              }
            }
          }
        }
        log_msg INFO "Verify RFE162746 - enable-grt under off-ramp VPRN and verify, that when route is not available in VRF, successful GRT lookup will be done"
        if {$onRampVprnId != "Base"} {
            set rCli [$dut1 sendCliCommand "/configure router static-route 100.0.0.0/24 next-hop 1.1.2.2"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router static-route 100::/120 next-hop 3FFE::2002:909"] ; log_msg INFO "$rCli"
        }
        set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt"] ; log_msg INFO "$rCli"
        set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        foreach filterIpType $filterType {
            set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $offRampVprnId"]
        }
        set rCli [$dut2 sendCliCommand "/configure router no static-route 100::/120 black-hole"] ; log_msg INFO "$rCli"
        after 15000
        log_msg INFO "Verify path Dut-A -> Dut-B"
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)"; after 2000; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
        log_msg INFO "Disable grt-leak under off-ramp VPRN and verify, that traffic is not routed into $dut2"
        set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
        set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
        log_msg INFO "Enable-grt under off-ramp VPRN again and verify traffic"
        set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt"] ; log_msg INFO "$rCli"
        set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        after 15000
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
        log_msg INFO "Disable grt-leak under off-ramp VPRN and verify, that traffic is not routed into $dut2"
        set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
        set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
        log_msg INFO "Enable-grt for static-route under off-ramp VPRN and verify traffic"
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt static-route 100.0.0.0/24 grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt static-route 100::/120 grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        }
        after 15000
        foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
          getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
        }
# disable static routes
        if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt no static-route 100.0.0.0/24 grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        }
        if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt no static-route 100::/120 grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        }
        log_msg INFO "Disable grt-leak under off-ramp VPRN"
        set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
        set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"

       
# Configure more VPRN context in order to verify GRT leak with multiple VRFs
        log_msg INFO "Configure more VPRN context in order to verify GRT leak with multiple VRFs"
        set i 10
        foreach vprnCtx { 100 12345 2147483647 } {
            set rCli [$dut1 sendCliCommand "configure service"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "vprn $vprnCtx customer 1 create"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    snmp-community 1tk5Hg2ofL$i hash2 version both"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    ecmp 16"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    router-id 0.0.1.$i"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    autonomous-system 1"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    route-distinguisher 1.1.1.1:$i"] ; log_msg INFO "$rCli"
            if {($buildVersion == 0) || ($buildVersion > 12)} {
                set rCli [$dut1 sendCliCommand "    auto-bind-tunnel resolution-filter ldp"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "    auto-bind-tunnel resolution filter"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut1 sendCliCommand "    auto-bind ldp"] ; log_msg INFO "$rCli"
            }
            set rCli [$dut1 sendCliCommand "    vrf-target target:1:$vprnCtx"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            incr i
        }
        foreach vprnCtx { 100 12345 2147483647 } {
            foreach filterIpType $filterType {
                set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $vprnCtx"]
                puts [$dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id)"]
            }
            log_msg INFO "Enable-grt under VPRN: $vprnCtx and verify trafficd"
            set rCli [$dut1 sendCliCommand "/configure service vprn $vprnCtx grt-lookup enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            
        }
        if { $option(shutOffRampVprn) == "true" } {
            log_msg INFO "Shutdown the off-ramp VPRN in order to verify DTS166486 - PBR: packet redirected to VRF is leaked to GRT although the VPRN with GRT leak enabled is shutdown"
            foreach filterIpType $filterType {
                set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $offRampVprnId"]
                puts [$dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id)"]
            }
            log_msg INFO "Enable grt-leak under off-ramp VPRN"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId shutdown"] ; log_msg INFO "$rCli"
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Enable VPRN and verify that packet is again leaked to GRT"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId no shutdown"] ; log_msg INFO "$rCli"
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Enable-grt for static-route under off-ramp VPRN and verify traffic"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt static-route 100.0.0.0/24 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt static-route 100::/120 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Shutdown the off-ramp VPRN again"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId shutdown"] ; log_msg INFO "$rCli"
            after 5000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Enable VPRN and verify that packet is again leaked to GRT"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId no shutdown"] ; log_msg INFO "$rCli"
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt no static-route 100.0.0.0/24 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt no static-route 100::/120 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            log_msg INFO "Disable grt-leak under off-ramp VPRN"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
        }
        if { $ixiaInVprn == "true" } {
# Configure interface to Ixia under new VPRN and verify to action forward router - redirection from VRF to another VRF
            foreach filterIpType $filterType {
                set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $offRampVprnId"]
                puts [$dut1 sendCliCommand "/show filter [getVar4 $filterIpType] $option(filter_[getVar4 $filterIpType]_id)"]
            }

            log_msg INFO "Configure interface to Ixia under new VPRN and verify to action forward router - redirection from VRF to another VRF"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia egress no filter ip $option(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia egress no filter ipv6 $option(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia ingress no filter ip $option(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia ingress no filter ipv6 $option(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia no port"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia shutdown"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure router no interface to_Ixia"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure port $portA($dut1.Ixia) shutdown"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure port $portA($dut1.Ixia) ethernet mode access"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "/configure port $portA($dut1.Ixia) no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "    configure service"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "        vprn 1 customer 1 create"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            ecmp 16"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            router-id 0.0.1.1"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            autonomous-system 1"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            route-distinguisher 1.1.1.1:1"] ; log_msg INFO "$rCli"
            if {($buildVersion == 0) || ($buildVersion > 12)} {
                set rCli [$dut1 sendCliCommand "    auto-bind-tunnel resolution-filter ldp"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "    auto-bind-tunnel resolution filter"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut1 sendCliCommand "    auto-bind ldp"] ; log_msg INFO "$rCli"
            }
            set rCli [$dut1 sendCliCommand "            vrf-target target:1:1"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            interface to_Ixia create"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                address 1.1.9.1/24"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                mac 00:00:00:00:00:01"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                static-arp 1.1.9.9 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                ipv6"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                    address 3FFE::101:901/120"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                    neighbor 3FFE::101:909 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                exit"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                sap $portA($dut1.Ixia) create"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                    ingress"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                        filter ip $option(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                        filter ipv6 $option(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                    exit"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                    egress"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                        filter ip $option(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                        filter ipv6 $option(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                    exit"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "                exit"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            exit"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "            no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "        exit"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "      exit"] ; log_msg INFO "$rCli"

            log_msg INFO "Verify, that traffic is blackholed"
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Enable-grt under off-ramp VPRN and verify traffic"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Disable grt-leak under off-ramp VPRN and verify, that traffic is not routed into $dut2"
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            after 5000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Enable-grt for static-route under off-ramp VPRN and verify traffic"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt static-route 100.0.0.0/24 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt static-route 100::/120 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Disable grt-leak under off-ramp VPRN and verify, that traffic is not routed into $dut2"
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt no static-route 100.0.0.0/24 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup enable-grt no static-route 100::/120 grt"] ; log_msg INFO "$rCli"
                set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            }
            set rCli [$dut1 sendCliCommand "/configure service vprn $offRampVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            after 5000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Verify GRT leak using action forward router Base"
            foreach filterIpType $filterType {
                set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router Base"]
            }
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            foreach filterIpType $filterType {
                set r1 [cliCne $dut1 "/configure filter [getVar4 $filterIpType]-filter $option(filter_[getVar4 $filterIpType]_id) entry $option(entry_[getVar4 $filterIpType]_id) action forward router $offRampVprnId"]
            }
# Verify, that when GRT leak flag is enabled on source VPRN, it is not taken into account in target VRF
            log_msg INFO "Verify, that when GRT leak flag is enabled on source VPRN, it is not taken into account in target VRF"
            log_msg INFO "Enable-grt under new VPRN: 1 and verify traffic - no GRT leaking expected in VPRN: $offRampVprnId"
            set rCli [$dut1 sendCliCommand "/configure service vprn 1 grt-lookup enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            after 15000
            foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }
            log_msg INFO "Disable grt-leak under VPRN: 1"
            set rCli [$dut1 sendCliCommand "/configure service vprn 1 grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
            set rCli [$dut1 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            
            log_msg INFO "Start mitigation and verify traffic"
            if {! [testFailed] && $Result == "OK"} {
              if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                for {set mCnt 1} {$mCnt <= $option(numMitigations_v4)} {incr mCnt} {
                  set thisMitigation "reg_[set ::TestDB::thisTestBed]_v4dst_100_[set mCnt]_fwd_[set mitTxtTail]"
                  set mySubtest "Start mitigation $thisMitigation (off-ramp all traffic ; no drop): Traffic should go via path $dut1->$dut3->$dut2"
                  arbor_startMitigationTms Dut-J $thisMitigation
                }
              }
              if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                for {set mCnt 1} {$mCnt <= $option(numMitigations_v6)} {incr mCnt} {
                  set thisMitigation "reg_[set ::TestDB::thisTestBed]_v6dst_100_[set mCnt]_fwd_[set mitTxtTail]"
                  set mySubtest "Start mitigation $thisMitigation (off-ramp all traffic ; no drop): Traffic should go via path $dut1->$dut3->$dut2"
                  arbor_startMitigationTms Dut-J $thisMitigation
                }
              }
            }
# Check mitigation
            if {$option(offRampRedirectToVrf_order) == "redirectActionBeforeTmsRoute"} {
                if {! [testFailed] && $Result == "OK"} {
                  foreach {dut onRampVprnId offRampVprnId isaTmsCardMda isaTmsPfxMsk hasMitigations toArborCpList} $isaTmsList {
                    if {$hasMitigations} {
                      set thisVprnId $onRampVprnId
                      foreach {isaTmsPfx isaTmsMsk} [split $isaTmsPfxMsk "/"] {break} ; set thisIpAddr $isaTmsPfx
                      # ecmp => all mitigations should be received by all isa-tms's
                      set nbrMitigationsExp 0
                      if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
                        set nbrMitigationsExp [expr $nbrMitigationsExp + $option(numMitigations_v4)]
                      }
                      if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
                        set nbrMitigationsExp [expr $nbrMitigationsExp + $option(numMitigations_v6)]
                      }
                      if {[tms_checkTmsInterface_tmsHealthInfo $dut3 $onRampVprnId $thisIpAddr nbrMitigations $nbrMitigationsExp]} {
                        log_msg INFO "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Expected nbr mitigations found ($nbrMitigationsExp)"
                      } else {
                        log_msg ERROR "$dut (vprn $thisVprnId) isa-tms $thisIpAddr: Couldn't find expected nbr mitigations ($nbrMitigationsExp)"
                      }
                    }
                  }
                }
            }
           foreach dut $dutList {$dut sendCliCommand "clear filter ip $option(filter_ip_id)" ; $dut sendCliCommand "clear filter ipv6 $option(filter_ipv6_id)"} ; after 10000
            if {$option(family) == "ipv4" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ip_id) dir egress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ip_id) dir egress version ipv4 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ip_id) dir ingress version ipv4 count 0" -errorIfNotFound true
            }
            if {$option(family) == "ipv6" || $option(family) == "ipv4v6"} {
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut1 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
              getFilter -print true -dut $dut2 -match "entry $option(entry_ipv6_id) dir egress version ipv6 count !=0" -errorIfNotFound true
              getFilter -print true -dut $dut3 -match "entry $option(entry_ipv6_id) dir ingress version ipv6 count 0" -errorIfNotFound true
            }

          }


      } ; # stopMitigationActionFwd
    }

  if {$option(deconfig)} {
    foreach dut $dutList {$dut sendCliCommand "exit all"}
    saveOrRestore restore -nodebug true
    set rCli [$dut3 sendCliCommand "no debug"] ; log_msg INFO "$rCli"
    if {$option(stopAllOngoingMitigationsDuringDeconfig)} {
      log_msg INFO "Stop all ongoing mitigations during deconfig"
      arbor_stopAllMitigationTms Dut-J
    }
    if {$offRampRedirectToVrf} {
      sbgp.closeall
    }
    tms_areThereCleanupIssues $dutList
  }

  $dut3 configure -cli_timeout $cliTimeoutOrig
  if {$option(logResult)} {
    testcaseTrailer
  }
  }
}

####################################################################################
#
# Test ID   : filterActionFwdRtr_hashLabel_vprn
#
# Description : Test all combinations of lag members between ingress-transit-egress with a VPRN service
#                      and make use of different traffic streams. Redirect to VPRN.
#                      Enable mpls hash-label under the sdp in target VPRN and check the behaviour.
#                      VPRN = with autobind
#                      VPRN_SDP = spoke-sdp is defined under a second interface "lag"
#
# Description : cover RFE162746 (PBR: Support grt-leak and hash-label with the redirect to VRF action)
#     - verify hash-label feature in the target VRF (the one we redirect to) with hash-label flag enabled
#     - verify, that when hash-label flag is enabled in source VPRN, it is not taken into account in target VRF (redirect from VPRN to another VPRN case)
#
# Brief Test Process Description :
#                   - Test runs on stdsixdutnode - subTopology lag32LavaIom or lagLavaIom
#
# Possible combinations:
# filterActionFwdRtrHashLabelVprn -sig_type rsvp -routing static -autobind mpls
# filterActionFwdRtrHashLabelVprn -sig_type ldp -routing static -autobind ldp
# filterActionFwdRtrHashLabelVprn -svc vprn_sdp -sig_type rsvp -routing static
# filterActionFwdRtrHashLabelVprn -svc vprn_sdp -sig_type ldp -routing static
# filterActionFwdRtrHashLabelVprn -svc vprn_sdp -sig_type rsvp -routing static -hash_label signal
# filterActionFwdRtrHashLabelVprn -sig_type rsvp -routing static -autobind mpls -family ipv6
# filterActionFwdRtrHashLabelVprn -sig_type ldp -routing static -autobind ldp -family ipv6
# filterActionFwdRtrHashLabelVprn -svc vprn_sdp -sig_type rsvp -routing static -family ipv6
# filterActionFwdRtrHashLabelVprn -svc vprn_sdp -sig_type ldp -routing static -family ipv6
# filterActionFwdRtrHashLabelVprn -svc vprn_sdp -sig_type rsvp -routing static -hash_label signal -family ipv6
# 
####################################################################################
proc filterActionFwdRtrHashLabelVprn {args} {

    set opt(svc)     "vprn"
    set opt(sig_type)     "rsvp"
    set opt(sdp)            "spoke"
    set opt(routing)       "static"
    set opt(autobind)       ""
    set opt(ha) no
    set pps 300
    set opt(filter_ip_id)       1
    set opt(entry_ip_id)        100
    set opt(filter_ipv6_id)       2
    set opt(entry_ipv6_id)        200
    set opt(redirectToVrf)      "true"
    set opt(family)         "ipv4"
# hash_label = static|signal
    set opt(hash_label)         "static"
# grtToVrf | vrfToVrf
    set opt(redirectType)       "grtToVrf"

    getopt opt $args

    global testdir ixia_port testResultFlag
    source $testdir/testsuites/lag/lag_hash_config.tcl
    source $testdir/testsuites/lag/lag_hash_ixia_procs.tcl
    source $testdir/testsuites/lag/hash_params.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl

#    if {$opt(autobind) != ""} {
        # Here we have a vprn which makes use of an sdp via autobind
#        if { $opt(family) == "ipv6" } {
#            set testID     "filterActionFwdRtr_hashLabel_vprn_$opt(sig_type)_$opt(routing)_bind_ipv6"
#        } else {
#            set testID     "filterActionFwdRtr_hashLabel_vprn_$opt(sig_type)_$opt(routing)_bind"
#        }
#    } else  {
        # Here we have a vprn which makes use of an sdp defined under an extra interface
#        if { $opt(family) == "ipv6" } {
#            if { $opt(hash_label) == "signal" } {
#                set testID     "filterActionFwdRtr_hashLabel_vprn_sigCap_$opt(sig_type)_$opt(sdp)_$opt(routing)_ipv6"
#            } else {
#                set testID     "filterActionFwdRtr_hashLabel_vprn_$opt(sig_type)_$opt(sdp)_$opt(routing)_ipv6"
#            }
#        } else {
#            if { $opt(hash_label) == "signal" } {
#                set testID     "filterActionFwdRtr_hashLabel_vprn_sigCap_$opt(sig_type)_$opt(sdp)_$opt(routing)"
#            } else {
#               set testID     "filterActionFwdRtr_hashLabel_vprn_$opt(sig_type)_$opt(sdp)_$opt(routing)"
#            }
#        }
#    }

    set testID $::TestDB::currentTestCase
    print_test_id $testID
    set Result Passed
    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"
    
    if { ! [info exists DUTA] } { set DUTA "Dut-A" }
    if { ! [info exists DUTB] } { set DUTB "Dut-B" }
    if { ! [info exists DUTC] } { set DUTC "Dut-C" }
    

    # Display the sw version,product and time
    set s [swversion $DUTA]
    set p [product_check $DUTA]
    log_msg INFO "Currently used sw build and product : $s $p"
    log_msg INFO "[exec date]"
    log_msg INFO "Mpls hash-label is supported on at least Chassis mode C/D and IOM2/IOM3"
    log_msg INFO "To be able to use 16 lag members and perform lsr-hashing we need at least mode D and IOM3"
    set code [lag_hash_chassis_iom_check -dut $DUTB]
    if { $code != "OK" } {log_msg ERROR "Chassis mode not modeD and IOM no IOM-3 -> no lsr-load-balancing and 16 lag members"}

    log_msg INFO "-----------------------------------------------------------------------------------------"
    log_msg INFO "We have 3 nodes Dut-A, Dut-B and Dut-C with maximum 16 lag members between each"
    log_msg INFO "We vary the amount of lag members between the boxes and check with diff streams the hash "
    log_msg INFO "We have 1 lsp configured - Tolerance is set per case"
    log_msg INFO "-----------------------------------------------------------------------------------------"

    set code [lag_sixdut_3nodes_config -svc $opt(svc) -sig_type $opt(sig_type) -sdp $opt(sdp) -routing $opt(routing) -autobind $opt(autobind)]
    if { $code != "OK" } { set Result ERROR }

    if { $opt(family) == "ipv6" } {
        lag_hash_ipv6_3nodes_network_config -svc vprn
    }

    if { $opt(redirectToVrf) == "true" } {
        # create IP filter with action forward router
        $DUTA setTIPFilterRowStatus $opt(filter_ip_id) "createAndGo"
        $DUTA setTIPFilterParamsRowStatus $opt(filter_ip_id) $opt(entry_ip_id) "createAndGo"
        $DUTA setTIPv6FilterRowStatus $opt(filter_ipv6_id) "createAndGo"
        $DUTA setTIPv6FilterParamsRowStatus $opt(filter_ipv6_id) $opt(entry_ipv6_id) "createAndGo"
        foreach filterIpType "ip ipv6" {
            set r1 [cliCne $DUTA "/configure filter [getVar4 $filterIpType]-filter $opt(filter_[getVar4 $filterIpType]_id) entry $opt(entry_[getVar4 $filterIpType]_id) action forward router $svc_id"]
            # Verify
            log_msg INFO "=> Verify action forward router $svc_id"
            # CLI
            set r1 [ $DUTA sendCliCommand "/show filter [getVar4 $filterIpType] $opt(filter_[getVar4 $filterIpType]_id) | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
                if { $name != $svc_id } { log_msg ERROR "Wrong router name: $name"; set Result FAIL }
            } else { log_msg ERROR "Not possible to parse string for routerId"; set Result FAIL }
            # SNMP
            set r [$DUTA getT[getVar3 $filterIpType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterIpType]_id) $opt(entry_[getVar4 $filterIpType]_id) ]
            set Result [wccpCompareOutputString [$DUTA getVRtrInstanceId $svc_id] $r]
        }

        set r1 [cliCne $DUTA "/configure filter ip-filter $opt(filter_ip_id) entry $opt(entry_ip_id) match dst-ip 10.0.0.0/8"]
        set r1 [cliCne $DUTA "/configure filter ipv6-filter $opt(filter_ipv6_id) entry $opt(entry_ipv6_id) match dst-ip 2111:2222:2333:2444:2555:2666:2777:2888/104"]
        set r1 [cliCne $DUTA "/configure filter ip-filter $opt(filter_ip_id) default-action forward"]
        set r1 [cliCne $DUTA "/configure filter ipv6-filter $opt(filter_ipv6_id) default-action forward"]

        puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
        puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

        if { $opt(redirectType) == "grtToVrf" } {
            # remove interface from VPRN and create it in Base router 
            log_msg INFO "Remove interface to Ixia from VPRN and create it in Base router (in order to install filter with action forward router - GrtToVrf redirect)"
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 no sap $topoMap(Dut-A,1/1/3):4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"

            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 address 10.10.13.1/24"] ; log_msg INFO "$rCli"
            if { $opt(family) == "ipv6" } {
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ipv6 address 2000::7777/120"] ; log_msg INFO "$rCli"
            }
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet mode network"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 port 1/1/3:4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id) associations"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id) associations"]
        } elseif { $opt(redirectType) == "vrfToVrf" } {
            # remove interface from VPRN: 2 and create it in another VPRN: 2147483647
            log_msg INFO "Remove interface to Ixia from VPRN: $svc_id  and create it in another VPRN: 2147483647 (in order to install filter with action forward router - VrfToVrf redirect)"
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 no sap $topoMap(Dut-A,1/1/3):4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"

            set rCli [$DUTA sendCliCommand "    configure service"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "        vprn 2147483647 customer 1 create"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            description \"VPRN 2147483647\""] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            router-id 10.20.1.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            autonomous-system 100"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            route-distinguisher 100:2147483647"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            interface ies-2-10.10.13.1 create"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                address 10.10.13.1/24"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                ipv6"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    address 2000::7777/120"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                sap $topoMap(Dut-A,1/1/3):4 create"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    description sap-2-10.10.13.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    ingress"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            service-name \"VPRN 2147483647\""] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "        exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "    exit"] ; log_msg INFO "$rCli"
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id) associations"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id) associations"]
        }
    }

    if { $opt(family) == "ipv6" } {
        if {$opt(autobind) == ""} {
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 interface lag ipv6 address 2000::5554/120"] ; log_msg INFO "$rCli"
            set rCli [$DUTC sendCliCommand "/configure service vprn 2 interface lag ipv6 address 2000::5555/120"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 static-route ::/0 next-hop 2000::5555"] ; log_msg INFO "$rCli"
        }
    }
   

    if {$opt(autobind) != ""} {
        # for a VPRN the hash-label field is at service level and at interface -> sdp level
        # both can be seen via 'show service id 2 all'
        log_msg INFO "Check the output of 'show service id $svc_id all' - hash-label is disabled - VPRN"
        cliConfigNoError $DUTA "exit all"
        set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id all"]]
        set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
        if {$Hashstate == "Disabled"} {
            log_msg INFO "Default Hash Label state = $Hashstate => OK"
            set Result Passed
        } else  {
            log_msg ERROR "Default Hash Label state = $Hashstate => NOK - expected Disabled"
            log_msg DEBUG "$data"
            set Result Failed
        }
    } else  {
        if { $opt(hash_label) == "signal" } {
        # specific command to see the has-label signal-capability field of the interface with the spoke-sdp under -> show service id $svc_id interface "lag" detail
            log_msg INFO "Check the output of 'show service id $svc_id interface lag detail' - hash-label signal-capability is disabled - VPRN"
            cliConfigNoError $DUTA "exit all"
            set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id interface lag detail"]]
            set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash Lbl Sig Cap"]] 3]
            if {$Hashstate == "Disabled"} {
                log_msg INFO "Default Hash Label state = $Hashstate => OK"
                set Result Passed
            } else  {
                log_msg ERROR "Default Hash Label state = $Hashstate => NOK - expected Disabled"
                log_msg DEBUG "$data"
                set Result Failed
            }
        } else {
            # specific command to see the has-label field of the interface with the spoke-sdp under -> show service id $svc_id interface "lag" detail
            log_msg INFO "Check the output of 'show service id $svc_id interface lag detail' - hash-label is disabled - VPRN"
            cliConfigNoError $DUTA "exit all"
            set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id interface lag detail"]]
            set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
            if {$Hashstate == "Disabled"} {
                log_msg INFO "Default Hash Label state = $Hashstate => OK"
                set Result Passed
            } else  {
                log_msg ERROR "Default Hash Label state = $Hashstate => NOK - expected Disabled"
                log_msg DEBUG "$data"
                set Result Failed
            }
        }
    }


    log_msg INFO "Enable hash-label on the ingress and egress sdp"
    if {$opt(autobind) != ""} {
        cliConfigNoError $DUTA "exit all"
        cliConfigNoError $DUTA "configure service vprn $svc_id hash-label"
        cliConfigNoError $DUTC "exit all"
        cliConfigNoError $DUTC "configure service vprn $svc_id hash-label"
    } else  {
        if { $opt(hash_label) == "signal" } {
            cliConfigNoError $DUTA "exit all"
            cliConfigNoError $DUTA "configure service vprn $svc_id interface lag spoke-sdp $SdpId:$svc_id hash-label signal-capability"
            cliConfigNoError $DUTC "exit all"
            cliConfigNoError $DUTC "configure service vprn $svc_id interface lag spoke-sdp $SdpId:$svc_id hash-label signal-capability"
        } else {
            cliConfigNoError $DUTA "exit all"
            cliConfigNoError $DUTA "configure service vprn $svc_id interface lag spoke-sdp $SdpId:$svc_id hash-label"
            cliConfigNoError $DUTC "exit all"
            cliConfigNoError $DUTC "configure service vprn $svc_id interface lag spoke-sdp $SdpId:$svc_id hash-label"
        }
    }


    if {$opt(autobind) != ""} {
        # for a VPRN the hash-label field is at service level and at interface -> sdp level
        # both can be seen via 'show service id 2 all'
        log_msg INFO "Check the output of 'show service id $svc_id all' - hash-label is enabled - VPRN"
        cliConfigNoError $DUTA "exit all"
        set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id all"]]
        set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
        if {$Hashstate == "Enabled"} {
            log_msg INFO "Default Hash Label sdp show detail state = $Hashstate => OK"
            set Result Passed
        } else  {
            log_msg ERROR "Default Hash Label sdp show detail state = $Hashstate => NOK - expected Enabled"
            log_msg DEBUG "$data"
            set Result Failed
        }
    } else  {
        if { $opt(hash_label) == "signal" } {
            # specific command to see the has-label signal-capability field of the interface with the spoke-sdp under -> show service id $svc_id interface "lag" detail
            log_msg INFO "Check the output of 'show service id $svc_id interface lag detail' - hash-label signal-capability is enabled - VPRN"
            cliConfigNoError $DUTA "exit all"
            set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id interface lag detail"]]
            set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash Lbl Sig Cap"]] 3]
            if {$Hashstate == "Enabled"} {
                log_msg INFO "Default Hash Label sdp show detail state = $Hashstate => OK"
                set Result Passed
            } else  {
                log_msg ERROR "Default Hash Label sdp show detail state = $Hashstate => NOK - expected Enabled"
                log_msg DEBUG "$data"
                set Result Failed
            }
        } else {
            # specific command to see the has-label field of the interface with the spoke-sdp under -> show service id $svc_id interface "lag" detail
            log_msg INFO "Check the output of 'show service id $svc_id interface lag detail' - hash-label is enabled - VPRN"
            cliConfigNoError $DUTA "exit all"
            set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id interface lag detail"]]
            set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
            if {$Hashstate == "Enabled"} {
                log_msg INFO "Default Hash Label sdp show detail state = $Hashstate => OK"
                set Result Passed
            } else  {
                log_msg ERROR "Default Hash Label sdp show detail state = $Hashstate => NOK - expected Enabled"
                log_msg DEBUG "$data"
                set Result Failed
            }
        }
    }

    set code [$DUTA removeLAGPortMember $lag_id_AB [lrange $allPortsAB 1 32]]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB removeLAGPortMember $lag_id_BA [lrange $allPortsBA 1 32]]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB removeLAGPortMember $lag_id_BC [lrange $allPortsBC 1 32]]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTC removeLAGPortMember $lag_id_CB [lrange $allPortsCB 1 32]]
    if { $code != "OK" } { set Result ERROR }

#    if {[getGlobalVar subTopology] == "lag32LavaIom"} {
        log_msg INFO ""
        log_msg INFO "Create a mirror source in order to mirror the ingress lag port member on $DUTC"
        log_msg INFO "This to see whether the hash-label is actually there in the packet"
        cliConfigNoError $DUTC "exit all"
        cliConfigNoError $DUTC "configure port $mirrorportC ethernet mode access"
        cliConfigNoError $DUTC "configure port $mirrorportC no shutdown"

        cliConfigNoError $DUTC "configure mirror"
        cliConfigNoError $DUTC "mirror-dest 1000 create"
        cliConfigNoError $DUTC "sap $mirrorportC create"
        cliConfigNoError $DUTC "exit"
        cliConfigNoError $DUTC "no shutdown"
        cliConfigNoError $DUTC "exit"
        cliConfigNoError $DUTC "exit all"

        cliConfigNoError $DUTC "debug"
        cliConfigNoError $DUTC "mirror-source 1000"
        cliConfigNoError $DUTC "port [lindex $lagportlistCB 0] egress ingress"
        cliConfigNoError $DUTC "no shutdown"
        cliConfigNoError $DUTC "exit"
        cliConfigNoError $DUTC "exit"

        sleep 60

        log_msg INFO "Open a pcap file and check in there whether the mpls hash label is added"
        # from tests_6PE_func.tcl under bgp
        # Select the interface to which the mirror is send
        set ethIntf eth1
        # To this file the conversion of the first filtered packet will be written in hex
        set fileWriteA "/tmp/gash.MplsHashLabel"
        set tin [startTethCapture -inf $ethIntf]
        set pps 300
        if { $opt(family) == "ipv6" } {
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -protocol ipV6 -ip_sa   "1111:1222:1333:1444:1555:1666:1777:1888" -ip_sa_mask   100 -ip_sa_mode incrHost -ip_sa_count      100 -ip_da        "2111:2222:2333:2444:2555:2666:2777:2888" -ip_da_mask 100 -ip_da_mode fixed -ip_da_count     100 -packets_per_sec $pps -vlan_tags "81 00 00 04" -ipProtocol ipV6
        } else {
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -ip_sa  "1.1.1.1" -ip_sa_mask "255.0.0.0" -ip_sa_mode random -ip_da "10.10.14.7" -ip_da_mask "255.0.0.0" -ip_da_mode random -packets_per_sec $pps  -vlan_tags "81 00 00 04" -framesize 64
        }
        q_ixia_start_tx $ixia_x1
        sleep 5
        # double SWO of CPM
        if { $opt(ha) == "yes" } {
            log_msg INFO "Going to perform restart of active CPM: $DUTA"
            $DUTA sendCliCommand "exit all"
            $DUTA activitySwitch
            log_msg INFO "Going to perform restart of new active CPM: $DUTA"
            $DUTA activitySwitch
        }
        q_ixia_stop_tx $ixia_x1
        sleep 3
        # we filter on mpls packets
        set filterA "mpls"
        set firstPacketA [processCapturePacket $tin $filterA]
        log_msg INFO ""
        log_msg INFO "===> FirstPacket which contains mpls is :"
        log_msg INFO ""
        log_msg INFO "$firstPacketA"
        log_msg INFO ""
        set hexPktA [writeCapturePktToFile $fileWriteA $firstPacketA]
        log_msg INFO "Converted packet to hex : $fileWriteA"
        log_msg INFO ""
        catch { exec rm $tin }
        set mplsLabelsRead [getMplsLabelValuesPkt $hexPktA]
        set mplsHashLabel [lindex $mplsLabelsRead 2]
        log_msg INFO ""
        log_msg INFO "Hash label found is : $mplsHashLabel , this should be between range 524288 and 1048575"
        log_msg INFO ""
        # MPLS hash label is between the range of 524288 and 1048575
        if {$mplsHashLabel >= 524288} {
            log_msg INFO "Found mpls hash label - correctly added - OK"
            log_msg INFO ""
        } else  {
            log_msg ERROR " Did not found mpls hash label"
            set Result Failed
        }

        cliConfigNoError $DUTC "debug no mirror-source 1000"

        cliConfigNoError $DUTC "configure mirror mirror-dest 1000 shutdown"
        cliConfigNoError $DUTC "configure mirror no mirror-dest 1000"

        cliConfigNoError $DUTC "configure port $mirrorportC shutdown"
        cliConfigNoError $DUTC "configure port $mirrorportC ethernet no mode"
        cliConfigNoError $DUTC "exit all"
#    }

    global lagportlistAB
    global lagportlistBA
    global lagportlistBC
    global lagportlistCB

    log_msg INFO "Select a random number of lag members between each ingress-transit-egress"
    if {[getGlobalVar subTopology] == "lagMagmaIom"} {
        set mbrs_lag2 [randomNum 1 4]
        set mbrs_lag1 [randomNum 1 15]
    } elseif {[getGlobalVar subTopology] == "lag32LavaIom"} {
        set mbrs_lag2 [randomNum 1 31]
        set mbrs_lag1 [randomNum 1 31]
    } else  {
        set mbrs_lag2 [randomNum 1 15]
        set mbrs_lag1 [randomNum 1 15]
    }
    set members [list $mbrs_lag2 $mbrs_lag1]

    foreach {Acnt Ccnt} $members {
        set lagportlistAB [lrange $lagportlistAB 0 $Acnt]
        set lagportlistBA [lrange $lagportlistBA 0 $Acnt]
        log_msg INFO "LAG member ports between ingres-transit node A = $lagportlistAB"
        set lagportlistBC [lrange $lagportlistBC 0 $Ccnt]
        set lagportlistCB [lrange $lagportlistCB 0 $Ccnt]
        log_msg INFO "LAG member ports between transit-egress node C = $lagportlistCB"

        set code [$DUTA addLAGPortMember $lag_id_AB $lagportlistAB]
        if { $code != "OK" } { set Result ERROR }
        set code [$DUTB addLAGPortMember $lag_id_BA $lagportlistBA]
        if { $code != "OK" } { set Result ERROR }
        set code [$DUTB addLAGPortMember $lag_id_BC $lagportlistBC]
        if { $code != "OK" } { set Result ERROR }
        set code [$DUTC addLAGPortMember $lag_id_CB $lagportlistCB]
        if { $code != "OK" } { set Result ERROR }

        # why don't we get no 1500 byte packets through ?
        # send some traffic first to insure a proper hashing during regression testing
        ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -ip_sa  "1.1.1.1" -ip_sa_mask "255.0.0.0" -ip_sa_mode random -ip_da "10.10.14.7" -ip_da_mask "255.0.0.0" -ip_da_mode random -packets_per_sec $pps  -vlan_tags "81 00 00 04" -framesize 64
        q_ixia_start_tx $ixia_x1
        sleep 5
        q_ixia_stop_tx $ixia_x1
        sleep 5
        puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
        puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]
        $DUTA sendCliCommand "clear filter ip $opt(filter_ip_id)"
        $DUTA sendCliCommand "clear filter ipv6 $opt(filter_ipv6_id)"
       
        if { $opt(family) == "ipv4" } {
            log_msg INFO "----------------------------------------------------------------------"
            log_msg INFO "| Traffic Profile used => Random src/dst IP address - Rate $pps pps    |"
            log_msg INFO "----------------------------------------------------------------------"
            set tolerance mpls-label
            set type ip
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -ip_sa  "1.1.1.1" -ip_sa_mask "255.0.0.0" -ip_sa_mode random -ip_da "10.10.14.7" -ip_da_mask "255.0.0.0" -ip_da_mode random -packets_per_sec $pps  -vlan_tags "81 00 00 04" -framesize 64
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

            log_msg INFO "------------------------------------------------------------------"
            log_msg INFO "====> Setup : Ingress -- [llength $lagportlistAB] lag members -- Transit [llength $lagportlistCB] lag members -- Egress"
            log_msg INFO "====> Hash check between Transit and Egress - tolerance used = $tolerance"
            set res [ixia_traffic_clear_send_check_sixdut $tolerance $type -dut $DUTB -lag $lag_id_BC -members $lagportlistBC -node transit]
            if {$res != "Passed"} {
                set Result Failed
            }
            log_msg INFO "Enable l4-load-balancing on port level "
            $DUTA sendCliCommand "configure port $accessportA ethernet load-balancing-algorithm include-l4"

            log_msg INFO "----------------------------------------------------------------------"
            log_msg INFO "| Traffic Profile used => Random src/dst IP address + incr L4 tcp port - Rate $pps pps    |"
            log_msg INFO "----------------------------------------------------------------------"
            set tolerance mpls-label
            set type tcp
            log_msg INFO "====> Hash check between Transit and Egress - tolerance used = $tolerance"
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -ip_sa  "1.1.1.1" -ip_sa_mask "255.0.0.0" -ip_sa_mode fixed -ip_da "10.10.14.7" -ip_da_mask "255.0.0.0" -ip_da_mode fixed -packets_per_sec $pps  -vlan_tags "81 00 00 04" -framesize 64 -ipProtocol tcp -srcdst src
            set res [ixia_traffic_clear_send_check_sixdut $tolerance $type -dut $DUTB -lag $lag_id_BC -members $lagportlistBC -node transit]
            if {$res != "Passed"} {
                set Result Failed
            }
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

            log_msg INFO "----------------------------------------------------------------------"
            log_msg INFO "| Traffic Profile used => Random src/dst IP address + incr L4 udp port - Rate $pps pps    |"
            log_msg INFO "----------------------------------------------------------------------"
            set tolerance mpls-label
            set type udp
            log_msg INFO "====> Hash check between Transit and Egress - tolerance used = $tolerance"
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -ip_sa  "1.1.1.1" -ip_sa_mask "255.0.0.0" -ip_sa_mode fixed -ip_da "10.10.14.7" -ip_da_mask "255.0.0.0" -ip_da_mode fixed -packets_per_sec $pps  -vlan_tags "81 00 00 04" -framesize 64 -ipProtocol udp -srcdst src
            set res [ixia_traffic_clear_send_check_sixdut $tolerance $type -dut $DUTB -lag $lag_id_BC -members $lagportlistBC -node transit]
            if {$res != "Passed"} {
                set Result Failed
            }
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

            # verify that filter was hit
            getFilter -print true -dut $DUTA -match "entry $opt(entry_ip_id) dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            log_msg INFO "----------------------------------------------------------------------"
            log_msg INFO "| Traffic Profile used => Incr src IPv6 address - Rate $pps pps    |"
            log_msg INFO "----------------------------------------------------------------------"

            set tolerance mpls-label
            set type ip
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -protocol ipV6 -ip_sa   "1111:1222:1333:1444:1555:1666:1777:1888" -ip_sa_mask   100 -ip_sa_mode incrHost -ip_sa_count      100 -ip_da        "2111:2222:2333:2444:2555:2666:2777:2888" -ip_da_mask 100 -ip_da_mode fixed -ip_da_count     100 -packets_per_sec $pps -vlan_tags "81 00 00 04" -ipProtocol ipV6

            log_msg INFO "------------------------------------------------------------------"
            log_msg INFO "====> Setup : Ingress -- [llength $lagportlistAB] lag members -- Transit [llength $lagportlistCB] lag members -- Egress"
            log_msg INFO "====> Hash check between Transit and Egress - tolerance used = $tolerance"
            set res [ixia_traffic_clear_send_check_sixdut $tolerance $type -dut $DUTB -lag $lag_id_BC -members $lagportlistBC -node transit]
            if {$res != "Passed"} {
                set Result Failed
            }
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

            log_msg INFO "Enable l4-load-balancing on port level "
            $DUTA sendCliCommand "configure port $accessportA ethernet load-balancing-algorithm include-l4"

            log_msg INFO "----------------------------------------------------------------------"
            log_msg INFO "| Traffic Profile used => Fixed src IPv6 address, only incr L4 tcp port - Rate $pps pps with lsr-ip hash enabled"   |"
            log_msg INFO "----------------------------------------------------------------------"
            set tolerance mpls-label
            set type tcp
            log_msg INFO "====> Hash check between Transit and Egress - tolerance used = $tolerance"
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -protocol ipV6 -ip_sa   "1111:1222:1333:1444:1555:1666:1777:1888" -ip_sa_mask   100 -ip_sa_mode fixed -ip_sa_count      100 -ip_da        "2111:2222:2333:2444:2555:2666:2777:2888" -ip_da_mask 100 -ip_da_mode fixed -ip_da_count        100 -packets_per_sec $pps -vlan_tags "81 00 00 04" -ipProtocol tcpV6 -srcdst srcV6
            set res [ixia_traffic_clear_send_check_sixdut $tolerance $type -dut $DUTB -lag $lag_id_BC -members $lagportlistBC -node transit]
            if {$res != "Passed"} {
                set Result Failed
            }
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

            getFilter -print true -dut $DUTA -match "entry $opt(entry_ipv6_id) dir ingress version ipv6 count !=0" -errorIfNotFound true

        }
        
        set code [$DUTA removeLAGPortMember $lag_id_AB $lagportlistAB]
        if { $code != "OK" } { set Result ERROR }
        set code [$DUTB removeLAGPortMember $lag_id_BA $lagportlistBA]
        if { $code != "OK" } { set Result ERROR }
        set code [$DUTB removeLAGPortMember $lag_id_BC $lagportlistBC]
        if { $code != "OK" } { set Result ERROR }
        set code [$DUTC removeLAGPortMember $lag_id_CB $lagportlistCB]
        if { $code != "OK" } { set Result ERROR }

        unset lagportlistBC
        unset lagportlistCB
        unset tolerance
        source $testdir/testsuites/lag/hash_params.tcl

        unset lagportlistAB
        unset lagportlistBA
        source $testdir/testsuites/lag/hash_params.tcl
    }

    set code [$DUTA addLAGPortMember $lag_id_AB $allPortsAB]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB addLAGPortMember $lag_id_BA $allPortsBA]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB addLAGPortMember $lag_id_BC $allPortsBC]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTC addLAGPortMember $lag_id_CB $allPortsCB]
    if { $code != "OK" } { set Result ERROR }

    if { $opt(family) == "ipv6" } {
        if {$opt(autobind) == ""} {
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 interface lag no ipv6"] ; log_msg INFO "$rCli"
            set rCli [$DUTC sendCliCommand "/configure service vprn 2 interface lag no ipv6"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 no static-route ::/0 next-hop 2000::5555"] ; log_msg INFO "$rCli"
        }
    }

    if { $opt(redirectToVrf) == "true" } {
        if { $opt(redirectType) == "grtToVrf" } {
            # configure back the changes, which were done
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress no filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress no filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress no filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress no filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 no port"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet mode access"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 no shutdown"] ; log_msg INFO "$rCli"
        } elseif { $opt(redirectType) == "vrfToVrf" } {
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 ingress no filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 ingress no filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 no sap $topoMap(Dut-A,1/1/3):4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service no vprn 2147483647"] ; log_msg INFO "$rCli"
        }
        set rCli [$DUTA sendCliCommand "    configure service"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "        vprn $svc_id customer 1 create"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "            interface ies-2-10.10.13.1 create"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "                address 10.10.13.1/24"] ; log_msg INFO "$rCli"
        if { $opt(family) == "ipv6" } {
            set rCli [$DUTA sendCliCommand "                ipv6 address 2000::7777/120"] ; log_msg INFO "$rCli"
        }
        set rCli [$DUTA sendCliCommand "                sap $topoMap(Dut-A,1/1/3):4 create"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "                    description sap-2-10.10.13.1"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "                exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "            exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "        exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "      exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"

        $DUTA setTIPFilterRowStatus $opt(filter_ip_id) "destroy"
        $DUTA setTIPv6FilterRowStatus $opt(filter_ipv6_id) "destroy"
    }    

    if { $opt(family) == "ipv6" } {
        lag_hash_ipv6_3nodes_network_deconfig -svc vprn
    }

    set code [lag_sixdut_3nodes_deconfig -svc $opt(svc) -sig_type $opt(sig_type) -routing $opt(routing) -sdp $opt(sdp) -autobind $opt(autobind)]
    if { $code != "OK" } { set Result ERROR }

    log_msg INFO "[exec date]"
    # ---- Common end for regression
    if { $Result == "Passed" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }
    return $Result

}

proc filterActionFwdRtrHashLabelVprnNeg {args} {

    set opt(svc)     "vprn"
    set opt(sig_type)     "rsvp"
    set opt(sdp)            "spoke"
    set opt(routing)       "static"
    set opt(autobind)       ""
    set opt(ha) no
    set pps 300
    set opt(filter_ip_id)       1
    set opt(entry_ip_id)        100
    set opt(filter_ipv6_id)       2
    set opt(entry_ipv6_id)        200
    set opt(redirectToVrf)      "true"
    set opt(family)         "ipv4"
# hash_label = static|signal
    set opt(hash_label)         "static"
# grtToVrf | vrfToVrf 
    set opt(redirectType)       "grtToVrf"

    getopt opt $args

    global testdir ixia_port testResultFlag
    source $testdir/testsuites/lag/lag_hash_config.tcl
    source $testdir/testsuites/lag/lag_hash_ixia_procs.tcl
    source $testdir/testsuites/lag/hash_params.tcl
    source $testdir/testsuites/filter/tests/wccp_procs.tcl
    source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl

    set testID $::TestDB::currentTestCase
    print_test_id $testID
    set Result Passed
    set testResultFlag "PASSED"
    set setupErrorFlag "NOERROR"


    # Display the sw version,product and time
    set s [swversion $DUTA]
    set p [product_check $DUTA]
    log_msg INFO "Currently used sw build and product : $s $p"
    log_msg INFO "[exec date]"
    log_msg INFO "Mpls hash-label is supported on at least Chassis mode C/D and IOM2/IOM3"
    log_msg INFO "To be able to use 16 lag members and perform lsr-hashing we need at least mode D and IOM3"
    set code [lag_hash_chassis_iom_check]
    if { $code != "OK" } {log_msg ERROR "Chassis mode not modeD and IOM no IOM-3 -> no lsr-load-balancing and 16 lag members"}

    log_msg INFO "-----------------------------------------------------------------------------------------"
    log_msg INFO "We have 3 nodes Dut-A, Dut-B and Dut-C with maximum 16 lag members between each"
    log_msg INFO "We vary the amount of lag members between the boxes and check with diff streams the hash "
    log_msg INFO "We have 1 lsp configured - Tolerance is set per case"
    log_msg INFO "-----------------------------------------------------------------------------------------"

    set code [lag_sixdut_3nodes_config -svc $opt(svc) -sig_type $opt(sig_type) -sdp $opt(sdp) -routing $opt(routing) -autobind $opt(autobind)]
    if { $code != "OK" } { set Result ERROR }

    if { $opt(family) == "ipv6" } {
        lag_hash_ipv6_3nodes_network_config -svc vprn
    }

    if { $opt(redirectToVrf) == "true" } {
        # create IP filter with action forward router
        $DUTA setTIPFilterRowStatus $opt(filter_ip_id) "createAndGo"
        $DUTA setTIPFilterParamsRowStatus $opt(filter_ip_id) $opt(entry_ip_id) "createAndGo"
        $DUTA setTIPv6FilterRowStatus $opt(filter_ipv6_id) "createAndGo"
        $DUTA setTIPv6FilterParamsRowStatus $opt(filter_ipv6_id) $opt(entry_ipv6_id) "createAndGo"
        foreach filterIpType "ip ipv6" {
            set r1 [cliCne $DUTA "/configure filter [getVar4 $filterIpType]-filter $opt(filter_[getVar4 $filterIpType]_id) entry $opt(entry_[getVar4 $filterIpType]_id) action forward router $svc_id"]
            # Verify
            log_msg INFO "=> Verify action forward router $svc_id"
            # CLI
            set r1 [ $DUTA sendCliCommand "/show filter [getVar4 $filterIpType] $opt(filter_[getVar4 $filterIpType]_id) | match Fwd"]
            if { [regexp {Fwd Rtr/SvcId: (\S+)} $r1 match name] } {
                if { $name != $svc_id } { log_msg ERROR "Wrong router name: $name"; set Result FAIL }
            } else { log_msg ERROR "Not possible to parse string for routerId"; set Result FAIL }
            # SNMP
            set r [$DUTA getT[getVar3 $filterIpType]FilterParamsFwdRtrId $opt(filter_[getVar4 $filterIpType]_id) $opt(entry_[getVar4 $filterIpType]_id) ]
            set Result [wccpCompareOutputString [$DUTA getVRtrInstanceId $svc_id] $r]
        }

        set r1 [cliCne $DUTA "/configure filter ip-filter $opt(filter_ip_id) entry $opt(entry_ip_id) match dst-ip 10.0.0.0/8"]
        set r1 [cliCne $DUTA "/configure filter ipv6-filter $opt(filter_ipv6_id) entry $opt(entry_ipv6_id) match dst-ip 2111:2222:2333:2444:2555:2666:2777:2888/104"]
        set r1 [cliCne $DUTA "/configure filter ip-filter $opt(filter_ip_id) default-action forward"]
        set r1 [cliCne $DUTA "/configure filter ipv6-filter $opt(filter_ipv6_id) default-action forward"]

        puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id)"]
        puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id)"]

        if { $opt(redirectType) == "grtToVrf" } {
            # remove interface from VPRN and create it in Base router
            log_msg INFO "Remove interface to Ixia from VPRN and create it in Base router (in order to install filter with action forward router - GrtToVrf redirect)"
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 no sap $topoMap(Dut-A,1/1/3):4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"

            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 address 10.10.13.1/24"] ; log_msg INFO "$rCli"
            if { $opt(family) == "ipv6" } {
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ipv6 address 2000::7777/120"] ; log_msg INFO "$rCli"
            }
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet mode network"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 port 1/1/3:4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id) associations"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id) associations"]
        } elseif { $opt(redirectType) == "vrfToVrf" } {
            # remove interface from VPRN: 2 and create it in another VPRN: 2147483647
            log_msg INFO "Remove interface to Ixia from VPRN: $svc_id  and create it in another VPRN: 2147483647 (in order to install filter with action forward router - VrfToVrf redirect)"
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 no sap $topoMap(Dut-A,1/1/3):4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn $svc_id no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"

            set rCli [$DUTA sendCliCommand "    configure service"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "        vprn 2147483647 customer 1 create"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            description \"VPRN 2147483647\""] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            router-id 10.20.1.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            autonomous-system 100"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            route-distinguisher 100:2147483647"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            interface ies-2-10.10.13.1 create"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                address 10.10.13.1/24"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                ipv6"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    address 2000::7777/120"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                sap $topoMap(Dut-A,1/1/3):4 create"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    description sap-2-10.10.13.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    ingress"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                    exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "                exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            service-name \"VPRN 2147483647\""] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "            no shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "        exit"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "    exit"] ; log_msg INFO "$rCli"
            puts [$DUTA sendCliCommand "/show filter ip $opt(filter_ip_id) associations"]
            puts [$DUTA sendCliCommand "/show filter ipv6 $opt(filter_ipv6_id) associations"]
        }
    }

    if { $opt(family) == "ipv6" } {
        if {$opt(autobind) == ""} {
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 interface lag ipv6 address 2000::5554/120"] ; log_msg INFO "$rCli"
            set rCli [$DUTC sendCliCommand "/configure service vprn 2 interface lag ipv6 address 2000::5555/120"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 static-route ::/0 next-hop 2000::5555"] ; log_msg INFO "$rCli"
        }
    }
    if {$opt(autobind) != ""} {
        # for a VPRN the hash-label field is at service level and at interface -> sdp level
        # both can be seen via 'show service id 2 all'
        log_msg INFO "Check the output of 'show service id $svc_id all' - hash-label is disabled - VPRN"
        cliConfigNoError $DUTA "exit all"
        set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id all"]]
        set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
        if {$Hashstate == "Disabled"} {
            log_msg INFO "Default Hash Label state = $Hashstate => OK"
            set Result Passed
        } else  {
            log_msg ERROR "Default Hash Label state = $Hashstate => NOK - expected Disabled"
            log_msg DEBUG "$data"
            set Result Failed
        }
    } else  {
        if { $opt(hash_label) == "signal" } {
        # specific command to see the has-label signal-capability field of the interface with the spoke-sdp under -> show service id $svc_id interface "lag" detail
            log_msg INFO "Check the output of 'show service id $svc_id interface lag detail' - hash-label signal-capability is disabled - VPRN"
            cliConfigNoError $DUTA "exit all"
            set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id interface lag detail"]]
            set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash Lbl Sig Cap"]] 3]
            if {$Hashstate == "Disabled"} {
                log_msg INFO "Default Hash Label state = $Hashstate => OK"
                set Result Passed
            } else  {
                log_msg ERROR "Default Hash Label state = $Hashstate => NOK - expected Disabled"
                log_msg DEBUG "$data"
                set Result Failed
            }
        } else {
            # specific command to see the has-label field of the interface with the spoke-sdp under -> show service id $svc_id interface "lag" detail
            log_msg INFO "Check the output of 'show service id $svc_id interface lag detail' - hash-label is disabled - VPRN"
            cliConfigNoError $DUTA "exit all"
            set data [cookCliData [$DUTA sendCliCommand "show service id $svc_id interface lag detail"]]
            set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
            if {$Hashstate == "Disabled"} {
                log_msg INFO "Default Hash Label state = $Hashstate => OK"
                set Result Passed
            } else  {
                log_msg ERROR "Default Hash Label state = $Hashstate => NOK - expected Disabled"
                log_msg DEBUG "$data"
                set Result Failed
            }
        }
    }

    log_msg INFO "Enable hash-label flag in source VRF - negative case (RFE162746)"
    log_msg INFO "Verify, that it is not taken into account in target VRF"

    if { $opt(redirectType) == "vrfToVrf" } {
        cliConfigNoError $DUTA "exit all"
        cliConfigNoError $DUTA "configure service vprn 2147483647 hash-label"
    }

    log_msg INFO "Check the output of 'show service id 2147483647 all' - hash-label is enabled - VPRN"
    cliConfigNoError $DUTA "exit all"
    set data [cookCliData [$DUTA sendCliCommand "show service id 2147483647 all"]]
    set Hashstate [lindex [lindex [ split $data "\n"] [lsearch -regexp [split $data "\n"] "Hash"]] 3]
    if {$Hashstate == "Enabled"} {
        log_msg INFO "Hash Label show detail state = $Hashstate => OK"
        set Result Passed
    } else  {
        log_msg ERROR "Hash Label show detail state = $Hashstate => NOK - expected Enabled"
        log_msg DEBUG "$data"
        set Result Failed
    }

    set code [$DUTA removeLAGPortMember $lag_id_AB [lrange $allPortsAB 1 32]]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB removeLAGPortMember $lag_id_BA [lrange $allPortsBA 1 32]]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB removeLAGPortMember $lag_id_BC [lrange $allPortsBC 1 32]]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTC removeLAGPortMember $lag_id_CB [lrange $allPortsCB 1 32]]
    if { $code != "OK" } { set Result ERROR }

#    if {[getGlobalVar subTopology] == "lag32LavaIom"} {
        log_msg INFO ""
        log_msg INFO "Create a mirror source in order to mirror the ingress lag port member on $DUTC"
        log_msg INFO "This to see whether the hash-label is actually there in the packet"
        cliConfigNoError $DUTC "exit all"
        cliConfigNoError $DUTC "configure port $mirrorportC ethernet mode access"
        cliConfigNoError $DUTC "configure port $mirrorportC no shutdown"

        cliConfigNoError $DUTC "configure mirror"
        cliConfigNoError $DUTC "mirror-dest 1000 create"
        cliConfigNoError $DUTC "sap $mirrorportC create"
        cliConfigNoError $DUTC "exit"
        cliConfigNoError $DUTC "no shutdown"
        cliConfigNoError $DUTC "exit"
        cliConfigNoError $DUTC "exit all"

        cliConfigNoError $DUTC "debug"
        cliConfigNoError $DUTC "mirror-source 1000"
        cliConfigNoError $DUTC "port [lindex $lagportlistCB 0] egress ingress"
        cliConfigNoError $DUTC "no shutdown"
        cliConfigNoError $DUTC "exit"
        cliConfigNoError $DUTC "exit"

        sleep 60
        log_msg INFO "Open a pcap file and check in there whether the mpls hash label is added"
        # from tests_6PE_func.tcl under bgp
        # Select the interface to which the mirror is send
        set ethIntf eth1
        # To this file the conversion of the first filtered packet will be written in hex
        set fileWriteA "/tmp/gash.MplsHashLabel"
        set tin [startTethCapture -inf $ethIntf]
        set pps 300
        if { $opt(family) == "ipv6" } {
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -protocol ipV6 -ip_sa   "1111:1222:1333:1444:1555:1666:1777:1888" -ip_sa_mask   100 -ip_sa_mode incrHost -ip_sa_count      100 -ip_da        "2111:2222:2333:2444:2555:2666:2777:2888" -ip_da_mask 100 -ip_da_mode fixed -ip_da_count     100 -packets_per_sec $pps -vlan_tags "81 00 00 04" -ipProtocol ipV6
        } else {
            ixia_create_stream_fver $ixia_x1 1 -mac_sa "00 00 01 01 01 01" -mac_sa_mode fixed -mac_da "00 81 00 00 01 00" -mac_da_mode fixed -ip_sa  "1.1.1.1" -ip_sa_mask "255.0.0.0" -ip_sa_mode random -ip_da "10.10.14.7" -ip_da_mask "255.0.0.0" -ip_da_mode random -packets_per_sec $pps  -vlan_tags "81 00 00 04" -framesize 64
        }
        q_ixia_start_tx $ixia_x1
        sleep 5
        # double SWO of CPM
        if { $opt(ha) == "yes" } {
            log_msg INFO "Going to perform restart of active CPM: $DUTA"
            $DUTA sendCliCommand "exit all"
            $DUTA activitySwitch
            log_msg INFO "Going to perform restart of new active CPM: $DUTA"
            $DUTA activitySwitch
        }
        q_ixia_stop_tx $ixia_x1
        sleep 3
        # we filter on mpls packets
        set filterA "mpls"
        set firstPacketA [processCapturePacket $tin $filterA]
        log_msg INFO ""
        log_msg INFO "===> FirstPacket which contains mpls is :"
        log_msg INFO ""
        log_msg INFO "$firstPacketA"
        log_msg INFO ""
        set hexPktA [writeCapturePktToFile $fileWriteA $firstPacketA]
        log_msg INFO "Converted packet to hex : $fileWriteA"
        log_msg INFO ""
        catch { exec rm $tin }
        set mplsLabelsRead [getMplsLabelValuesPkt $hexPktA]
        set mplsHashLabel [lindex $mplsLabelsRead 2]
        log_msg INFO ""
        log_msg INFO "Hash label found is : $mplsHashLabel , this should be between range 524288 and 1048575"
        log_msg INFO ""
        # MPLS hash label is between the range of 524288 and 1048575
        if {$mplsHashLabel >= 524288} {
            log_msg ERROR "Found mpls hash label - NOT expected - NOK"
            log_msg ERROR ""
            set Result Failed
        } else  {
            log_msg INFO " Did not found mpls hash label - expected - OK"
        }

        cliConfigNoError $DUTC "debug no mirror-source 1000"

        cliConfigNoError $DUTC "configure mirror mirror-dest 1000 shutdown"
        cliConfigNoError $DUTC "configure mirror no mirror-dest 1000"

        cliConfigNoError $DUTC "configure port $mirrorportC shutdown"
        cliConfigNoError $DUTC "configure port $mirrorportC ethernet no mode"
        cliConfigNoError $DUTC "exit all"
#    }


    set code [$DUTA addLAGPortMember $lag_id_AB $lagportlistAB]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB addLAGPortMember $lag_id_BA $lagportlistBA]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTB addLAGPortMember $lag_id_BC $lagportlistBC]
    if { $code != "OK" } { set Result ERROR }
    set code [$DUTC addLAGPortMember $lag_id_CB $lagportlistCB]
    if { $code != "OK" } { set Result ERROR }

    if { $opt(family) == "ipv6" } {
        if {$opt(autobind) == ""} {
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 interface lag no ipv6"] ; log_msg INFO "$rCli"
            set rCli [$DUTC sendCliCommand "/configure service vprn 2 interface lag no ipv6"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2 no static-route ::/0 next-hop 2000::5555"] ; log_msg INFO "$rCli"
        }
    }

    if { $opt(redirectToVrf) == "true" } {
        if { $opt(redirectType) == "grtToVrf" } {
            # configure back the changes, which were done
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress no filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 egress no filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress no filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 ingress no filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 no port"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure router no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet mode access"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure port 1/1/3 no shutdown"] ; log_msg INFO "$rCli"
        } elseif { $opt(redirectType) == "vrfToVrf" } {
            set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 ingress no filter ip $opt(filter_ip_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 ingress no filter ipv6 $opt(filter_ipv6_id)"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 sap $topoMap(Dut-A,1/1/3):4 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 no sap $topoMap(Dut-A,1/1/3):4"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 interface ies-2-10.10.13.1 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 no interface ies-2-10.10.13.1"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service vprn 2147483647 shutdown"] ; log_msg INFO "$rCli"
            set rCli [$DUTA sendCliCommand "/configure service no vprn 2147483647"] ; log_msg INFO "$rCli"
        }
        set rCli [$DUTA sendCliCommand "    configure service"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "        vprn $svc_id customer 1 create"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "            interface ies-2-10.10.13.1 create"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "                address 10.10.13.1/24"] ; log_msg INFO "$rCli"
        if { $opt(family) == "ipv6" } {
            set rCli [$DUTA sendCliCommand "                ipv6 address 2000::7777/120"] ; log_msg INFO "$rCli"
        }
        set rCli [$DUTA sendCliCommand "                sap $topoMap(Dut-A,1/1/3):4 create"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "                    description sap-2-10.10.13.1"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "                exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "            exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "        exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "      exit"] ; log_msg INFO "$rCli"
        set rCli [$DUTA sendCliCommand "exit all"] ; log_msg INFO "$rCli"

        $DUTA setTIPFilterRowStatus $opt(filter_ip_id) "destroy"
        $DUTA setTIPv6FilterRowStatus $opt(filter_ipv6_id) "destroy"
    }

    if { $opt(family) == "ipv6" } {
        lag_hash_ipv6_3nodes_network_deconfig -svc vprn
    }

    set code [lag_sixdut_3nodes_deconfig -svc $opt(svc) -sig_type $opt(sig_type) -routing $opt(routing) -sdp $opt(sdp) -autobind $opt(autobind)]
    if { $code != "OK" } { set Result ERROR }

    log_msg INFO "[exec date]"
    # ---- Common end for regression
    if { $Result == "Passed" } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }
    return $Result

}


####################################################################################
#
# Test ID   : filterActionFwdRtr_grtLeak_vprn
#
# Description : cover RFE162746 (PBR: Support grt-leak and hash-label with the redirect to VRF action) 
#     - verify GRT lookup in the target VRF (the one we redirect to) with enable-grt flag, when route in target VRF is not available                 
#     - same case with enabled 'enable-grt static-route' (Belgacom use case)                  
#     - verify, that when enable-grt flag is enabled on source VPRN, it is not taken into account in target VRF (redirect from VPRN to another VPRN case)
#     - verify 'enable-grt' flag configured under multiple VPRNs
#     - when there is filter installed on interface under VPRN service, verify GRT leaking also by setting the action forward router "Base"
#                      
#
#                   - Test runs on stdsixdutnode - IOM3+ (-constraints {{40GSupport true}})
#
# Possible combinations:
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap gre
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 sap -redirectVprnTunnelMethod sdp -redirectVprnTunnelEncap rsvp
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 sap -redirectVprnTunnelMethod sdp -redirectVprnTunnelEncap gre
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap gre
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 spoke -redirectVprnTunnelMethod sdp -redirectVprnTunnelEncap rsvp
# filterActionFwdRtrGrtLeakVprn -itfType_dut1dut2 spoke -redirectVprnTunnelMethod sdp -redirectVprnTunnelEncap gre
#
####################################################################################
proc filterActionFwdRtrGrtLeakVprn {args} {

  global masterlog testdir ixia_port logdir
  global portA dataip

  source $testdir/testsuites/flowspec/flowspec_vprnParams.tcl
  source $testdir/testsuites/flowspec/flowspec_Procs.tcl
  source $testdir/testsuites/filter/tests/wccp_procs.tcl
  source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl

  set option(config) true
  set option(test) true
  set option(deconfig) true
  set option(debug) false
  set option(verbose) false
  set option(bugxxxxx) false
  set option(returnResult) false
  set option(sbgpDebug) false
  set option(dumpDebugLog) false
  set option(cliTimeout) 600
  set option(maxRetryCnt) 6
  set option(interRetryTimeSec) 30
  set option(addDefFilterInFirstVprnBeforeFlowroutesAreInjected) true
  set option(addDefFilterInLastVprnAfterFlowroutesAreInjected) true
  set option(nbrVprns) 3
  set option(nbrFlowroutesPerVprn) 1
  set option(actionListPerVprn) [list redirectVrf]
  set option(enableFilterTrace) false
  set option(enableBgpFlowspecTrace) false
  set option(sendBgpPrefixUpd_v4) false
  set option(sendBgpPrefixUpd_v6) false
  set option(sendBgpFlowrouteUpd_v4) true
  set option(sendBgpFlowrouteUpd_v6) true
  set option(sendTraffic_v4) true
  set option(sendTraffic_v6) true
  set option(enableIngressFlowspec_v4) false
  set option(enableIngressFlowspec_v6) false
  set option(flowspecInteraction) false
  set option(vrfTargetDirectUnderVprn_noImportPolicy) true
  set option(verifySwo) false
  set option(enableFlowspecBeforeFlowroutesAreInjected) false
  if {$option(verifySwo) == "true"} {
      set option(actionExpectedBehaviorList) [list "none" "defaultBehavior" \
                                                                    "adminTech" "none" \
                                                                    "swo" "defaultBehavior" \
                                                                    "removeAllIpv4v6RoutesFromRedirectVprn" "noRedirectToVrfTraffic_allTrafficViaGrtLeaking" \
                                                                    "addAllIpv4v6RoutesFromRedirectVprn" "defaultBehavior" \
                                                                    "addGrtLookupEnableGrtStaticRoute" "noRedirectToVrfTraffic_allTrafficViaGrtLeaking" \
                                                                    "removeGrtLookupEnableGrtStaticRoute" "defaultBehavior" \
                                                                    "negTest_addGrtLookupInFlowrouteVprn" "defaultBehavior" \
                                                                    "negTest_removeGrtLookupInFlowrouteVprn" "defaultBehavior" \
                                                                    "shutAllRedirectVprn" "noRedirectToVrfTraffic_noTrafficViaGrtLeaking" \
                                                                    "noShutAllRedirectVprn" "defaultBehavior" \
                                                                    "stopTrafficAndClearFilters" "zeroIngMatchesExpInDut" \
                                                                    "startTraffic" "defaultBehavior" \
                                                                    "rollback" "defaultBehavior" \
                                                            ]
  } else {
      set option(actionExpectedBehaviorList) [list "none" "defaultBehavior" \
                                                                    "adminTech" "none" \
                                                                    "removeAllIpv4v6RoutesFromRedirectVprn" "noRedirectToVrfTraffic_allTrafficViaGrtLeaking" \
                                                                    "addAllIpv4v6RoutesFromRedirectVprn" "defaultBehavior" \
                                                                    "addGrtLookupEnableGrtStaticRoute" "noRedirectToVrfTraffic_allTrafficViaGrtLeaking" \
                                                                    "removeGrtLookupEnableGrtStaticRoute" "defaultBehavior" \
                                                                    "negTest_addGrtLookupInFlowrouteVprn" "defaultBehavior" \
                                                                    "negTest_removeGrtLookupInFlowrouteVprn" "defaultBehavior" \
                                                                    "shutAllRedirectVprn" "noRedirectToVrfTraffic_noTrafficViaGrtLeaking" \
                                                                    "noShutAllRedirectVprn" "defaultBehavior" \
                                                                    "stopTrafficAndClearFilters" "zeroIngMatchesExpInDut" \
                                                                    "startTraffic" "defaultBehavior" \
                                                                    "rollback" "defaultBehavior" \
                                                            ]
  }
  # spoke (flowroute vprn)
  set option(itfType_dut1dut2) ""
  set option(addFlowroutesInBase) true

  # maxNbrIterations | maxDuration [hours] | ifFileExists
  set option(iterationMethod) maxNbrIterations
  set option(maxNbrIterations) 1
  set option(maxDurationHrs) 5
  set option(fileExistsName) "/tmp/fwdRtrVprn_running.txt"

  # there are 4 combinations
  #   autobind - ldp (default)
  #   autobind - gre
  #   sdp - rsvp
  #   sdp - gre
  set option(redirectVprnTunnelMethod) autobind
  set option(redirectVprnTunnelEncap) ldp

  # grtLookupEnableGrt should be set only to false to test some hash-label interactions
  set option(grtLookupEnableGrt) true
  # none | static | signal (sdp only)
  set option(hashLabel) "none"

  getopt option      $args

  set testID $::TestDB::currentTestCase
  set Result OK

  testcaseHeader

  ##### Testcase GGV paramerters (begin)
  if {[GGV fspecNbrVprns] != "ERROR"} {
    set nbrVprns [GGV fspecNbrVprns]
  } else {
    set nbrVprns $option(nbrVprns)
  }
  if {[GGV fspecNbrFlowroutesPerVprn] != "ERROR"} {
    set nbrFlowroutesPerVprn [GGV fspecNbrFlowroutesPerVprn]
  } else {
    set nbrFlowroutesPerVprn $option(nbrFlowroutesPerVprn)
  }
  if {[GGV fspecEnableFilterTrace] != "ERROR"} {
    set enableFilterTrace [GGV fspecEnableFilterTrace]
  } else {
    set enableFilterTrace $option(enableFilterTrace)
  }
  if {[GGV fspecEnableBgpFlowspecTrace] != "ERROR"} {
    set enableBgpFlowspecTrace [GGV fspecEnableBgpFlowspecTrace]
  } else {
    set enableBgpFlowspecTrace $option(enableBgpFlowspecTrace)
  }
  if {[GGV fspecSendBgpPrefixUpd_v4] != "ERROR"} {
    set sendBgpPrefixUpd_v4 [GGV fspecSendBgpPrefixUpd_v4]
  } else {
    set sendBgpPrefixUpd_v4 $option(sendBgpPrefixUpd_v4)
  }
  if {[GGV fspecSendBgpPrefixUpd_v6] != "ERROR"} {
    set sendBgpPrefixUpd_v6 [GGV fspecSendBgpPrefixUpd_v6]
  } else {
    set sendBgpPrefixUpd_v6 $option(sendBgpPrefixUpd_v6)
  }
  if {[GGV fspecSendBgpFlowrouteUpd_v4] != "ERROR"} {
    set sendBgpFlowrouteUpd_v4 [GGV fspecSendBgpFlowrouteUpd_v4]
  } else {
    set sendBgpFlowrouteUpd_v4 $option(sendBgpFlowrouteUpd_v4)
  }
  if {[GGV fspecSendBgpFlowrouteUpd_v6] != "ERROR"} {
    set sendBgpFlowrouteUpd_v6 [GGV fspecSendBgpFlowrouteUpd_v6]
  } else {
    set sendBgpFlowrouteUpd_v6 $option(sendBgpFlowrouteUpd_v6)
  }
  if {[GGV fspecActionListPerVprn] != "ERROR"} {
    set actionListPerVprn [GGV fspecActionListPerVprn]
  } else {
    set actionListPerVprn $option(actionListPerVprn)
  }
  if {[GGV fspecDumpDebugLog] != "ERROR"} {
    set dumpDebugLog [GGV fspecDumpDebugLog]
  } else {
    set dumpDebugLog $option(dumpDebugLog)
  }
  if {[GGV fspecSendTraffic_v4] != "ERROR"} {
    set sendTraffic_v4 [GGV fspecSendTraffic_v4]
  } else {
    set sendTraffic_v4 $option(sendTraffic_v4)
  }
  if {[GGV fspecSendTraffic_v6] != "ERROR"} {
    set sendTraffic_v6 [GGV fspecSendTraffic_v6]
  } else {
    set sendTraffic_v6 $option(sendTraffic_v6)
  }
  if {[GGV fspecEnableIngressFlowspec_v4] != "ERROR"} {
    set enableIngressFlowspec_v4 [GGV fspecEnableIngressFlowspec_v4]
  } else {
    set enableIngressFlowspec_v4 $option(enableIngressFlowspec_v4)
  }
  if {[GGV fspecEnableIngressFlowspec_v6] != "ERROR"} {
    set enableIngressFlowspec_v6 [GGV fspecEnableIngressFlowspec_v6]
  } else {
    set enableIngressFlowspec_v6 $option(enableIngressFlowspec_v6)
  }
  if {[GGV fspecVrfTargetDirectUnderVprn_noImportPolicy] != "ERROR"} {
    set vrfTargetDirectUnderVprn_noImportPolicy [GGV fspecVrfTargetDirectUnderVprn_noImportPolicy]
  } else {
    set vrfTargetDirectUnderVprn_noImportPolicy $option(vrfTargetDirectUnderVprn_noImportPolicy)
  }
  if {[GGV fspecItfType_dut1dut2] != "ERROR"} {
    set itfType_dut1dut2 [GGV fspecItfType_dut1dut2]
  } else {
    set itfType_dut1dut2 $option(itfType_dut1dut2)
  }
  if {[GGV fspecActionExpectedBehaviorList] != "ERROR"} {
    set actionExpectedBehaviorList [GGV fspecActionExpectedBehaviorList]
  } else {
    set actionExpectedBehaviorList $option(actionExpectedBehaviorList)
  }
  if {[GGV fspecAddDefFilterInFirstVprnBeforeFlowroutesAreInjected] != "ERROR"} {
    set addDefFilterInFirstVprnBeforeFlowroutesAreInjected [GGV fspecAddDefFilterInFirstVprnBeforeFlowroutesAreInjected]
  } else {
    set addDefFilterInFirstVprnBeforeFlowroutesAreInjected $option(addDefFilterInFirstVprnBeforeFlowroutesAreInjected)
  }
  if {[GGV fspecAddDefFilterInLastVprnAfterFlowroutesAreInjected] != "ERROR"} {
    set addDefFilterInLastVprnAfterFlowroutesAreInjected [GGV fspecAddDefFilterInLastVprnAfterFlowroutesAreInjected]
  } else {
    set addDefFilterInLastVprnAfterFlowroutesAreInjected $option(addDefFilterInLastVprnAfterFlowroutesAreInjected)
  }
  if {[GGV fspecAddFlowroutesInBase] != "ERROR"} {
    set addFlowroutesInBase [GGV fspecAddFlowroutesInBase]
  } else {
    set addFlowroutesInBase $option(addFlowroutesInBase)
  }
  if {[GGV fspecIterationMethod] != "ERROR"} {
    set iterationMethod [GGV fspecIterationMethod]
  } else {
    set iterationMethod $option(iterationMethod)
  }
  if {[GGV fspecMaxNbrIterations] != "ERROR"} {
    set maxNbrIterations [GGV fspecMaxNbrIterations]
  } else {
    set maxNbrIterations $option(maxNbrIterations)
  }
  if {[GGV fspecMaxDurationHrs] != "ERROR"} {
    set maxDurationHrs [GGV fspecMaxDurationHrs]
  } else {
    set maxDurationHrs $option(maxDurationHrs)
  }
  if {[GGV fspecEnableFlowspecBeforeFlowroutesAreInjected] != "ERROR"} {
    set enableFlowspecBeforeFlowroutesAreInjected [GGV fspecEnableFlowspecBeforeFlowroutesAreInjected]
  } else {
    set enableFlowspecBeforeFlowroutesAreInjected $option(enableFlowspecBeforeFlowroutesAreInjected)
  }
  if {[GGV fspecRedirectVprnTunnelMethod] != "ERROR"} {
    set redirectVprnTunnelMethod [GGV fspecRedirectVprnTunnelMethod]
  } else {
    set redirectVprnTunnelMethod $option(redirectVprnTunnelMethod)
  }
  if {[GGV fspecRedirectVprnTunnelEncap] != "ERROR"} {
    set redirectVprnTunnelEncap [GGV fspecRedirectVprnTunnelEncap]
  } else {
    set redirectVprnTunnelEncap $option(redirectVprnTunnelEncap)
  }
  if {[GGV fspecGrtLookupEnableGrt] != "ERROR"} {
    set grtLookupEnableGrt [GGV fspecGrtLookupEnableGrt]
  } else {
    set grtLookupEnableGrt $option(grtLookupEnableGrt)
  }
  if {[GGV fspecHashLabel] != "ERROR"} {
    set hashLabel [GGV fspecHashLabel]
  } else {
    set hashLabel $option(hashLabel)
  }
  ##### Testcase GGV paramerters (end)

  set dut1 Dut-A ; set dut2 Dut-B ; set dut3 Dut-C ; set dut4 Dut-D ; set dut5 Dut-E ; set dut6 Dut-F
  set dutList [list $dut1 $dut2 $dut3 $dut4 $dut5 $dut6]

  # vprnIdList => thisVprnId | thisNbrFlowroutesPerVprn | thisActionListPerVprn
  # vprnIdOnlyList => has only the vprnId's
  set vprnIdList "" ; set vprnIdOnlyList ""
  for {set vprnId 1} {$vprnId <= $nbrVprns} {incr vprnId} {
    lappend vprnIdList [expr $minVprnId - 1 + $vprnId] ; lappend vprnIdOnlyList [expr $minVprnId - 1 + $vprnId]
    lappend vprnIdList $nbrFlowroutesPerVprn
    lappend vprnIdList $actionListPerVprn
  }
  # Use the next dot1q tag for the Base
  set baseDot1qTag [expr [lindex $vprnIdOnlyList end] + 1]

  set nbrStreamsFamilies 0 ; if {$sendTraffic_v4} {incr nbrStreamsFamilies} ; if {$sendTraffic_v6} {incr nbrStreamsFamilies}
  if {$addFlowroutesInBase} {
    set nbrStreamsUsed [expr [expr $nbrVprns + 1] * [llength $actionListPerVprn] * $nbrStreamsFamilies]
  } else {
    set nbrStreamsUsed [expr $nbrVprns * [llength $actionListPerVprn] * $nbrStreamsFamilies]
  }

  # Check the testcase limitations (begin)
  if {$nbrVprns > 250} {
    log_msg ERROR "Testcase couldn't handle >250 vprn's because of ip address limitation" ; set Result FAIL
  }

  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
    if {$thisNbrFlowroutesPerVprn > 221} {
      log_msg ERROR "Testcase couldn't handle >221 (223-2 ; \"-2\" because dot1q=1 is reserved on Linux & one dot1q reserved for Base) flowroutes per vprn because of ip address limitation" ; set Result FAIL ; break
    }
  }
  # Check the testcase limitations (end)

  set pktRatePerStream 2 ; set pktSize 128 ; set streamData_ISATMS "49 53 41 54 4D 53" ; set rawProtocol 253
  set trafficDurationSecsDuringPrecondition 30

  # used in redirectToVrf
  set redirectVprnId 400 ; set customerId 1 ; set nbrRedirectVprn 4
  set firstRedirectVprnId $redirectVprnId
  set maxRedirectVprnId [expr $firstRedirectVprnId + $nbrRedirectVprn - 1]
  set minRedirectVprnId $redirectVprnId
  # the vprn (to redirect) is between dut2/dut4
  set thisRT "target:42:1"

  set enableTraceDutList [list $dut2 $dut3]
  # spokeSdp case
  set spokeIesId 5000 ; set spokeSdpId 1 ; set spokeSdpVcId 1

  if {$sendBgpFlowrouteUpd_v4 && $sendBgpFlowrouteUpd_v6} {
    set thisFilterFamilyList [list ipv4 ipv6]
  } elseif {$sendBgpFlowrouteUpd_v6} {
    set thisFilterFamilyList [list ipv6]
  } else {
    set thisFilterFamilyList [list ipv4]
  }
  set groupName "onegroup"

  # 101..199 => always 101 for flowspec
  set filterLogId 101

  set rollbackLocation "ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs"

  log_msg INFO "########################################################################"
  log_msg INFO "# Test : $testID"
  log_msg INFO "# Descr : Validate RFE162746 (PBR: Support grt-leak and hash-label with the redirect to VRF action)"
  log_msg INFO "#   "
  log_msg INFO "# Setup:"
  log_msg INFO "# "
  log_msg INFO "#                              PE($dut4)----------> scrubber (Ixia)"
  log_msg INFO "#                               dut4 (dest for redirect actions)"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |       +-- Base-Base(dut2-dut3): BGP to exchange IPv4, IPv6 & flowroutes"
  log_msg INFO "#                                |       +-- PE-PE(dut2-dut3): BGP in the VPRN to exchange flowroutes"
  log_msg INFO "#                                |       +-- PE-PE(dut2-dut3): L3-VPN to exchange IPv4 & IPv6 routes"
  log_msg INFO "#                                |       |"
  log_msg INFO "#                                |       v"
  log_msg INFO "#   Ixia----------dut1----------dut2----------dut3----------dut6"
  log_msg INFO "#                CE1($dut1)    PE($dut2)     PE($dut3)     CE2($dut6)"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                             Linux (In VPRN & Base: Injects flowroutes via sbgp)"
  log_msg INFO "# "
  log_msg INFO "# Important testcase parameters:"
  log_msg INFO "#   vprnIdOnlyList: $vprnIdOnlyList"
  log_msg INFO "#   redirectVprn => vrpnId: $firstRedirectVprnId till $maxRedirectVprnId (#$nbrRedirectVprn) ; redirectVprnTunnelMethod: $redirectVprnTunnelMethod ; redirectVprnTunnelEncap: $redirectVprnTunnelEncap"
  log_msg INFO "#   grtLookupEnableGrt: $grtLookupEnableGrt hashLabel: $hashLabel (none | static | signal)"
  log_msg INFO "#   vprnIdList: vprnId | nbrFiltersWithFwdRtrPerVprn | thisActionListPerVprn"
  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
  set actionPrefixAString ""
  foreach thisAction $thisActionListPerVprn {
    append actionPrefixAString "$thisAction\([set a_[set thisAction]].x.x.x\) "
  }
  log_msg INFO [format "%1s %13s %6s | %20s | \"%30s\" " "#" " "  $thisVprnId $thisNbrFlowroutesPerVprn $actionPrefixAString]
  }
  if {$addFlowroutesInBase} {set fTxt "(baseDot1qTag: $baseDot1qTag)"} else {set fTxt ""}
  log_msg INFO "#   addFilterWithFwdRtrInBase: $addFlowroutesInBase $fTxt"
  log_msg INFO "#   sendTraffic_v4: $sendTraffic_v4 sendTraffic_v6: $sendTraffic_v6 (nbrStreamsFamilies: $nbrStreamsFamilies nbrStreamsUsed: $nbrStreamsUsed)"
  log_msg INFO "#   vrfTargetDirectUnderVprn_noImportPolicy: $vrfTargetDirectUnderVprn_noImportPolicy"
  log_msg INFO "#   itfType_dut1dut2: $itfType_dut1dut2"
  switch $iterationMethod {
    "maxNbrIterations" {set iMethTxt "maxNbrIterations: $maxNbrIterations"}
    "maxDuration" {set iMethTxt "maxDurationHrs: $maxDurationHrs"}
    "ifFileExists" {set iMethTxt "fileExistsName: $option(fileExistsName)"}
  }
  log_msg INFO "#   iterationMethod: $iterationMethod => $iMethTxt"
  log_msg INFO "#   actionExpectedBehaviorList:"
  log_msg INFO [format "%1s %5s %50s | %45s " "#" " " action expectedBehavior] ; log_msg INFO [format "%1s %5s %50s + %45s " "#" " " "--------------------------------------------------" "--------------------------------------------"]
  foreach {action expectedBehavior} $actionExpectedBehaviorList {
  log_msg INFO [format "%1s %5s %50s | %45s " "#" " " $action $expectedBehavior]
  }
  log_msg INFO "# "
  log_msg INFO "########################################################################"

  set dutLoggingDisabled false

  # handlePacket -action reset -portList all
  CLN.reset
  set cliTimeoutOrig [$dut2 cget -cli_timeout]
  $dut2 configure -cli_timeout $option(cliTimeout)

  if {$option(config) && ! [testFailed] && $Result == "OK"} {
    CLN.reset
    CLN "dut $dut1 systemip [set [set dut1]_ifsystem_ip] isisarea $isisAreaId as [set [set dut1]_AS]"
    CLN "dut $dut2 systemip [set [set dut2]_ifsystem_ip] isisarea $isisAreaId as [set [set dut2]_AS]"
    CLN "dut $dut3 systemip [set [set dut3]_ifsystem_ip] isisarea $isisAreaId as [set [set dut3]_AS]"
    CLN "dut $dut4 systemip [set [set dut4]_ifsystem_ip] isisarea $isisAreaId as [set [set dut4]_AS]"
    CLN "dut $dut5 systemip [set [set dut5]_ifsystem_ip] isisarea $isisAreaId as [set [set dut5]_AS]"
    CLN "dut $dut6 systemip [set [set dut6]_ifsystem_ip] isisarea $isisAreaId as [set [set dut6]_AS]"

    set a 30 ; set b [expr 20 + [lindex $vprnIdOnlyList 0]] ; set c 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn } $vprnIdList {
      CLN "dut $dut2 vprnid $thisVprnId systemip $a.$b.$c.2 as [set [set dut2]_AS]"
      CLN "dut $dut3 vprnid $thisVprnId systemip $a.$b.$c.3 as [set [set dut3]_AS]"
      incr b ; if {$b > 255} {set b 0 ; incr a}
    }

    # used for spokes dut1/dut2
    if { [GGV subTopology] == "ess6MixedMode" } {
        CLN "dut $dut1 tonode $dut2 porttype network dot1q 1 ip 1.1.1.1 ldp true mpls true"
    } else {
        CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q 1 ip 1.1.1.1 ldp true mpls true"
    }
    CLN "dut $dut2 tonode $dut1 porttype hybrid dot1q 1 ip 1.1.1.2 ldp true mpls true"

    # In the CE's, bgp routes are learned from different peers (the neighbor end point is in different vprn).
    # The learned bgp routes are installed in the Base routing-table and exported again to all neighbors (default ebgp behavior).
    # To avoid that the neigbor end points (in different vprn's) receive the exported bgp routes (CE's Base instance) a reject policy should be installed.
    CLN "dut $dut1 policy rejectBgpExport entry 1 action reject descr avoidExportFromBaseToNeighborVprns"
    CLN "dut $dut6 policy rejectBgpExport entry 1 action reject descr avoidExportFromBaseToNeighborVprns"

    # Exchange flowroutes via BGP peer in the VPRN, because SAFI=134 (exchange flowroutes via L3-VPN) is not supported
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      CLN "dut $dut3 tonode $dut2 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'flow-ipv4 flow-ipv6' "
      CLN "dut $dut2 tonode $dut3 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'flow-ipv4 flow-ipv6' "
    }

    # redistribute bgp-vpn in ospf
    CLN "dut $dut2 policy fromBgpVpnToOspf_v4 entry 1 from 'protocol bgp-vpn' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v4 entry 1 to 'protocol ospf' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v6 entry 1 from 'protocol bgp-vpn' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v6 entry 1 to 'protocol ospf3' action accept"

    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      #
      if {$itfType_dut1dut2 == "spoke"} {
        if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut1 tonode $dut2 porttype network iesid $spokeIesId iftype spoke sdpid '$spokeSdpId gre [set [set dut2]_ifsystem_ip]' dot1q $thisVprnId ip $thisVprnId.$dataip(id.$dut1).$dataip(id.$dut2).$dataip(id.$dut1) ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        } else {
            CLN "dut $dut1 tonode $dut2 porttype hybrid iesid $spokeIesId iftype spoke sdpid '$spokeSdpId gre [set [set dut2]_ifsystem_ip]' dot1q $thisVprnId ip $thisVprnId.$dataip(id.$dut1).$dataip(id.$dut2).$dataip(id.$dut1) ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        }
        CLN "dut $dut2 tonode $dut1 porttype hybrid iftype spoke sdpid '$spokeSdpId gre [set [set dut1]_ifsystem_ip]' vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId ospfexport fromBgpVpnToOspf_v4 ospf3export fromBgpVpnToOspf_v6 as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      } else {
        if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut1 tonode $dut2 porttype network dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        } else {
            CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        }
        CLN "dut $dut2 tonode $dut1 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId ospfexport fromBgpVpnToOspf_v4 ospf3export fromBgpVpnToOspf_v6 as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      }

      if { [GGV subTopology] == "ess6MixedMode" } {
        CLN "dut $dut6 tonode $dut3 porttype network dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut6]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut6]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
      } else {
          CLN "dut $dut6 tonode $dut3 porttype hybrid dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut6]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut6]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
      }
      CLN "dut $dut3 tonode $dut6 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut3]_ifsystem_ip] as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set [set dut6]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "

      CLN "dut $dut3 link Linux porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId passive true as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set Linux_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
    }

    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      CLN "dut $dut2 logid $debugLog from debug to 'memory 3000' debug {router $thisVprnId bgp update}"
      CLN "dut $dut3 logid $debugLog from debug to 'memory 3000' debug {router $thisVprnId bgp update}"
    }

    if {$addFlowroutesInBase} {
      CLN "dut $dut3 tonode $dut2 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor [set [set dut2]_ifsystem_ip]  bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6' ldp true"
      CLN "dut $dut2 tonode $dut3 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6' ldp true"
      #
      CLN "dut $dut3 tonode $dut6 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut6]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      if { [GGV subTopology] == "ess6MixedMode" } {
        CLN "dut $dut6 tonode $dut3 porttype network dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
        CLN "dut $dut1 tonode $dut2 porttype network dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      } else {
        CLN "dut $dut6 tonode $dut3 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
        CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      }
      #
      CLN "dut $dut2 tonode $dut1 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      #
      CLN "dut $dut3 link Linux porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId passive true as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set Linux_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
    }

    # Ixia connections
    set filterEntryId 1
    set filterEntryId2 123
    set filterEntryId3 2139
    set filterEntryId4 65535
    foreach thisAction $actionListPerVprn {
      CLN "dut $dut1 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].0.0.0/$cntPktsViaFilter_mask_v4"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].1.2.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId2 dstip [set a_[set thisAction]].1.3.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId3 dstip [set a_[set thisAction]].1.4.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId4 dstip [set a_[set thisAction]].1.5.0/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].0.0.0/$cntPktsViaFilter_mask_v4"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].0.0.0/$cntPktsViaFilter_mask_v4"
      CLN "dut $dut1 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].0.0.0]/$cntPktsViaFilter_mask_v6"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].1.2.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId2 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.3.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId3 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.4.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId4 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.5.0]/120"
      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].0.0.0]/$cntPktsViaFilter_mask_v6"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].0.0.0]/$cntPktsViaFilter_mask_v6"
    }
    CLN "dut $dut1 tonode Ixia inegfilter $cntPktsViaFilter_filterId inegfilterv6 $cntPktsViaFilter_filterId"
    CLN "dut $dut6 tonode Ixia inegfilter $cntPktsViaFilter_filterId inegfilterv6 $cntPktsViaFilter_filterId"
    CLN "dut Ixia tonode $dut1"
    CLN "dut Ixia tonode $dut6"

    # CE2: static routes and policies to destine traffic from different vprn's to Ixia
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v4 next-hop $dataip(ip.1.Ixia.$dut6)'"
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $dataip(ip.1.Ixia.$dut6)]'"
        CLN "dut $dut6 policy fromStaticToVprns_v4 entry 1 from 'protocol static' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v4 entry 1 to 'protocol ospf' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v6 entry 1 from 'protocol static' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v6 entry 1 to 'protocol ospf3' action accept"
        CLN "dut $dut6 ospf 'export fromStaticToVprns_v4' "
        CLN "dut $dut6 ospf3 'export fromStaticToVprns_v6' "
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }

    # policies to destine traffic from different vprn's to Ixia
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        CLN "dut $dut3 prefixlist 'pfxListVprn[set thisVprnId]_v4 prefix $thisDstPrefixMask_v4 longer' "
        CLN "dut $dut3 prefixlist 'pfxListVprn[set thisVprnId]_v6 prefix $thisDstPrefixMask_v6 longer' "
        CLN "dut $dut3 policy fromStaticToVprn[set thisVprnId]_v4 defaultaction reject entry 1 from 'prefix-list pfxListVprn[set thisVprnId]_v4' action accept"
        CLN "dut $dut3 policy fromStaticToVprn[set thisVprnId]_v6 defaultaction reject entry 1 from 'prefix-list pfxListVprn[set thisVprnId]_v6' action accept"
        CLN "dut $dut3 vprnid $thisVprnId ospf 'import fromStaticToVprn[set thisVprnId]_v4' "
        CLN "dut $dut3 vprnid $thisVprnId ospf3 'import fromStaticToVprn[set thisVprnId]_v6' "
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }

    if {$addFlowroutesInBase} {
      # - Use isis in the Base instance
      # - Use mask16 to have a route in the Base for all grt-leak's (2nd lookup in Base) of all vprn's
      set c 0 ; set d 0
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask16_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask16_v6
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v4 next-hop $dataip(ip.1.Ixia.$dut6)'"
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $dataip(ip.1.Ixia.$dut6)]'"
        CLN "dut $dut6 prefixlist 'pfxListBase[set baseDot1qTag]_v4 prefix $thisDstPrefixMask_v4 exact' "
        CLN "dut $dut6 prefixlist 'pfxListBase[set baseDot1qTag]_v6 prefix $thisDstPrefixMask_v6 exact' "
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v4 entry 1 from 'prefix-list pfxListBase[set baseDot1qTag]_v4' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v4 entry 1 to 'protocol isis' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v6 entry 1 from 'prefix-list pfxListBase[set baseDot1qTag]_v6' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v6 entry 1 to 'protocol isis' action accept"
        CLN "dut $dut6 isis 'export fromStaticToBase[set baseDot1qTag]_v4 fromStaticToBase[set baseDot1qTag]_v6'"
      }
    }

    # used in redirectToVrf
    if {$redirectVprnTunnelMethod == "autobind" && $redirectVprnTunnelEncap == "gre" || \
         $redirectVprnTunnelMethod == "sdp" && $redirectVprnTunnelEncap == "rsvp"} {
      CLN "dut $dut2 tonode $dut4 mpls true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut2 mpls true isisarea $isisAreaId"
    } else {
      CLN "dut $dut2 tonode $dut4 ldp true mpls true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut2 ldp true mpls true isisarea $isisAreaId"
    }
    CLN "dut $dut2 bgpneighbor [set [set dut4]_ifsystem_ip] bgppeeras [set [set dut4]_AS] bgpfamily 'vpn-ipv4 vpn-ipv6'"
    CLN "dut $dut4 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras [set [set dut2]_AS] bgpfamily 'vpn-ipv4 vpn-ipv6'"

    CLN.exec
    CLN.reset

    set thisPePeList [list $dut2 $dut3 $dut3 $dut2]
    foreach {dut ngbDut} $thisPePeList {
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        set thisExportRT [expr ($thisVprnId * 100) + ($dataip(id.$dut) * 10) + $dataip(id.$ngbDut)]
        set thisImportRT [expr ($thisVprnId * 100) + ($dataip(id.$ngbDut) * 10) + $dataip(id.$dut)]
        docli $dut "configure router"
        docli $dut "         policy-options"
        docli $dut "            begin"
        docli $dut "            community vprn_[set thisVprnId]_exportRouteTarget members target:1982:$thisExportRT"
        docli $dut "            community vprn_[set thisVprnId]_importRouteTarget members target:1982:$thisImportRT"
        docli $dut "            policy-statement vprn_[set thisVprnId]_exportPol"
        docli $dut "                entry 1"
        docli $dut "                    from"
        docli $dut "                        protocol ospf"
        docli $dut "                    exit"
        docli $dut "                    to"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                        community add vprn_[set thisVprnId]_exportRouteTarget"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "                entry 2"
        docli $dut "                    from"
        docli $dut "                        protocol ospf3"
        docli $dut "                    exit"
        docli $dut "                    to"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                        community add vprn_[set thisVprnId]_exportRouteTarget"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "            exit"
        docli $dut "            policy-statement vprn_[set thisVprnId]_importPol"
        docli $dut "                entry 1"
        docli $dut "                    from"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                        community vprn_[set thisVprnId]_importRouteTarget"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "            exit"
        docli $dut "            commit"
        docli $dut "        exit all"
      }
    }
    foreach {dut ngbDut} $thisPePeList {
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        docli $dut "configure service vprn $thisVprnId"
        docli $dut "no vrf-target"
        docli $dut "vrf-import vprn_[set thisVprnId]_importPol"
        docli $dut "vrf-export vprn_[set thisVprnId]_exportPol"
        docli $dut "exit all"
      }
    }

    # used in redirectToVrf
    #                                        dut     thisDutId            ngbrDut  ngbrDutId       itfToNgbr
    set redirectVprnDutList [list $dut2 $dataip(id.$dut2) $dut4 $dataip(id.$dut4) $dataip(ip.1.$dut2.$dut4) \
                                              $dut4 $dataip(id.$dut4) $dut2 $dataip(id.$dut2) $dataip(ip.1.$dut4.$dut2)]
    #
    # Also needed is a path from Dut-D to Ixia2 (scrubber).
    #   - In Dut-D: add port to Dut-E in vprn
    #   - In Dut-E: epipe between port to Dut-D and port to Dut-C
    #   - In Dut-C: epipe between port to Dut-E and port to Ixia2
    #                                         dut  epipeId fromPort toPort
    set epipeListToScrubber [list $dut5 666 $portA($dut5.$dut4) $portA($dut5.$dut3) \
                                                $dut3 667 $portA($dut3.$dut5) $portA($dut3.Ixia)]
    # Redirect is done in Dut-B
    set checkIpFilterDutList [list $dut2]

    foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
      docli $dut "configure router"
      docli $dut "         policy-options"
      docli $dut "            begin"
      docli $dut "            community \"vprn1_exportRouteTarget\" members \"target:[set thisDutId][set ngbrDutId]:1\" "
      docli $dut "            community \"vprn1_importRouteTarget_[set ngbrDutId]\" members \"target:[set ngbrDutId][set thisDutId]:1\" "
      docli $dut "            policy-statement vprn_exportPol_[set thisDutId]"
      docli $dut "                entry 1"
      docli $dut "                    from"
      docli $dut "                        protocol direct"
      docli $dut "                    exit"
      docli $dut "                    to"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                        community add vprn1_exportRouteTarget"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "                entry 2"
      docli $dut "                    from"
      docli $dut "                        protocol static"
      docli $dut "                    exit"
      docli $dut "                    to"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                        community add vprn1_exportRouteTarget"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "            exit"
      docli $dut "            policy-statement vprn_importPol_[set thisDutId]_[set ngbrDutId]"
      docli $dut "                entry 1"
      docli $dut "                    from"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                        community vprn1_importRouteTarget_[set ngbrDutId]"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "            exit"
      docli $dut "            commit"
      docli $dut "        exit all"
    }
    foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
      # redirect rsvp part
      docli $dut "exit all"
      docli $dut "configure router"
      docli $dut "mpls"
      docli $dut "    path pathTo_[set ngbrDut]"
      docli $dut "        hop 1 [set [set ngbrDut]_ifsystem_ip] loose"
      docli $dut "        no shutdown"
      docli $dut "    exit"
      docli $dut "    lsp to_[set ngbrDut]"
      docli $dut "        to [set [set ngbrDut]_ifsystem_ip]"
      docli $dut "        primary pathTo_[set ngbrDut]"
      docli $dut "        exit"
      docli $dut "        no shutdown"
      docli $dut "    exit"
      docli $dut "    no shutdown"
      docli $dut "exit"
      docli $dut "exit all"
      # redirect service part
      docli $dut "configure service" -verbose $option(verbose)
      for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
        # add here the sdp's if needed
        if {$redirectVprnTunnelMethod == "sdp"} {
            switch $redirectVprnTunnelEncap {
              "gre" {
                docli $dut "" -verbose $option(verbose)
                docli $dut "sdp [set thisDutId][set ngbrDutId] gre create"
                docli $dut "    far-end [set [set ngbrDut]_ifsystem_ip]"
                docli $dut "    signaling off"
                docli $dut "    keep-alive"
                docli $dut "        shutdown"
                docli $dut "    exit"
                docli $dut "    no shutdown"
                docli $dut "exit"
              }
              "rsvp" {
                docli $dut "sdp [set thisDutId][set ngbrDutId] mpls create" -verbose $option(verbose)
                docli $dut "    far-end [set [set ngbrDut]_ifsystem_ip]"
                docli $dut "    lsp to_[set ngbrDut]"
                docli $dut "    signaling off"
                docli $dut "    keep-alive"
                docli $dut "        shutdown"
                docli $dut "    exit"
                docli $dut "    no shutdown"
                docli $dut "exit"
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | rsvp)" ; set Result FAIL ; break
              }
            }
        }
        # add here the vprn's
        set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
        docli $dut "        vprn $thisRedirectVprnId customer 1 create" -verbose $option(verbose)
        docli $dut "            no shutdown" -verbose $option(verbose)
        if {$vCnt == [expr $nbrRedirectVprn - 1] && $vrfTargetDirectUnderVprn_noImportPolicy} {
          log_msg INFO "Don't use vrf-import policy for the last vprn $thisRedirectVprnId"
          docli $dut "            vrf-target target:[set ngbrDutId][set thisDutId]:1" -verbose $option(verbose)
        } else {
          docli $dut "            vrf-import vprn_importPol_[set thisDutId]_[set ngbrDutId]" -verbose $option(verbose)
        }
        docli $dut "            vrf-export vprn_exportPol_[set thisDutId]" -verbose $option(verbose)
        docli $dut "            route-distinguisher $thisRedirectVprnId:1" -verbose $option(verbose)
        #
        switch $redirectVprnTunnelMethod {
          "autobind" {
            switch $redirectVprnTunnelEncap {
              "gre" {
                # ldp between dut2/dut4 is disabled
                docli $dut "            auto-bind gre" -verbose $option(verbose)
              }
              "ldp" {
                docli $dut "            auto-bind ldp" -verbose $option(verbose)
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | ldp)" ; set Result FAIL ; break
              }
            }
          }
          "sdp" {
            switch $redirectVprnTunnelEncap {
              "gre" {
                # ldp between dut2/dut4 is disabled ??? to be checked
                docli $dut "spoke-sdp [set thisDutId][set ngbrDutId] create" -verbose $option(verbose)
                docli $dut "no shutdown"
                docli $dut "exit"
              }
              "rsvp" {
                # ldp between dut2/dut4 is disabled
                docli $dut "spoke-sdp [set thisDutId][set ngbrDutId] create" -verbose $option(verbose)
                docli $dut "no shutdown"
                docli $dut "exit"
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | rsvp)" ; set Result FAIL ; break
              }
            }
          }
          default {
            log_msg ERROR "Invalid redirectVprnTunnelMethod: $redirectVprnTunnelMethod (should be autobind | sdp)" ; set Result FAIL ; break
          }
        }
        if {$grtLookupEnableGrt} {
          docli $dut "            grt-lookup enable-grt" -verbose $option(verbose)
        }
        if {$hashLabel == "static"} {
          docli $dut "            hash-label" -verbose $option(verbose)
        }
        docli $dut "            exit" -verbose $option(verbose)
        docli $dut "        exit"  -verbose $option(verbose)
      }
      docli $dut "exit all" -verbose $option(verbose)
    }


    if {$epipeListToScrubber != ""} {
      foreach {epipeDut epipeId epipeFromPort epipeToPort} $epipeListToScrubber {
        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
          set thisVlanId [expr $vCnt + 1] ; set thisEpipeId [expr $epipeId + $vCnt]
          flowspec_createEpipe $epipeDut $thisEpipeId $epipeFromPort $epipeToPort -fromEncapType dot1q -fromSap "$epipeFromPort:$thisVlanId" -toEncapType dot1q -toSap "$epipeToPort:$thisVlanId"
        }
      }
    }
    log_msg INFO "$dut4: Create dot1q itfs (#$nbrRedirectVprn) via $portA($dut4.$dut5) and default-route (in vprn) to scrubber (Ixia $portA(Ixia.$dut3))"
    # create itf to scrubber (Ixia2)
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) shut"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) ethernet mode access"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) no shut"] ; log_msg INFO "$rCli"
    for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
      set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
      set thisVlanId [expr $vCnt + 1]
      set rCli [$dut4 sendCliCommand "exit all"]
      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "interface toScrubber_[set thisVlanId] create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "sap $portA($dut4.$dut5):$thisVlanId create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "egress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "egress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
      foreach {thisA thisB thisC thisD} [split "1.66.9.$dataip(id.$dut3)" "."] {break} ; set thisB [expr $thisB + $vCnt]
      set rCli [$dut4 sendCliCommand "address $thisA.$thisB.$thisC.$thisD/$clnItfMask_v4"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "ipv6 address [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]/$clnItfMask_v6"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
      foreach {thisA thisB thisC thisD} [split "1.66.9.9" "."] {break} ; set thisB [expr $thisB + $vCnt]
      # Add here static-routes for the redirectToVrf vprn
      set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        foreach thisAction $thisActionListPerVprn {
          if {$thisAction == "redirectVrf"} {
            set a [set a_[set thisAction]]
            set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
            set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
          }
        }
        incr c ; if {$c > 255} {set c 0 ; incr b}
      }
      if {$addFlowroutesInBase} {
        # - Don't reset b, c and d because they point to the next values to be used
        # - Use isis in the Base instance
        foreach thisAction $thisActionListPerVprn {
          if {$thisAction == "redirectVrf"} {
            set a [set a_[set thisAction]]
            set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
            set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
          }
        }
      }
      #
      set rCli [$dut4 sendCliCommand "interface toScrubber_[set thisVlanId] create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "static-arp $thisA.$thisB.$thisC.$thisD 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "ipv6 neighbor [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD] 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
    }

    if {$enableFilterTrace} {
      foreach dut $enableTraceDutList {
        docli $dut "debug trace trace-point module \"FILTER\" " -verbose $option(verbose)
        docli $dut "debug trace enable" -verbose $option(verbose)
        docli $dut "shell traceLimitDisable" -verbose $option(verbose)
      }
    }
    if {$enableBgpFlowspecTrace} {
      foreach dut $enableTraceDutList {
        docli $dut "debug trace trace-point module \"BGP\" " -verbose $option(verbose)
        docli $dut "debug trace trace-point module \"BGP_VPRN\" " -verbose $option(verbose)
        docli $dut "debug trace enable" -verbose $option(verbose)
        docli $dut "shell traceLimitDisable" -verbose $option(verbose)
        # enableBgpFlowspecTrace $dut
        # foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        #  enableBgpFlowspecTrace $dut2 -vprnId $thisVprnId
        # }
      }
    }

    foreach dut $dutList {
      $dut sendCliCommand "exit all"
    }

  } ; # config

  if {$option(test) && ! [testFailed] && $Result == "OK"} {
    # Ixia part
    handlePacket -port $portA(Ixia.$dut1) -action stop
    set thisDA 00:00:00:00:00:[int2Hex1 $dataip(id.$dut1)]
    set totalNbrOfFlowroutes 0
    set startStreamId 1
    set streamId $startStreamId
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        set thisHandlePacketAction create
        if {$sendTraffic_v4} {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 2 -src $dataip(ip.1.Ixia.$dut1) -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 2 -src $dataip(ip.1.Ixia.$dut1) -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -packetsPerBurst 2 -action $thisHandlePacketAction
          incr streamId
          set totalNbrOfFlowroutes [expr $totalNbrOfFlowroutes + $thisNbrFlowroutesPerVprn]
        }
        if {$streamId == $nbrStreamsUsed} {
          # this is the last stream (IPv6)
          set thisHandlePacketAction ""
        } else {
          set thisHandlePacketAction create
        }
        if {$sendTraffic_v6} {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 2 -src [ipv4ToIpv6  $dataip(ip.1.Ixia.$dut1)] -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 2 -src [ipv4ToIpv6  $dataip(ip.1.Ixia.$dut1)] -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -packetsPerBurst 2 -action $thisHandlePacketAction
          incr streamId
          set totalNbrOfFlowroutes [expr $totalNbrOfFlowroutes + $thisNbrFlowroutesPerVprn]
        }
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }
    if {$addFlowroutesInBase} {
      # - Don't reset b, c and d because they point to the next values to be used
      # - Use isis in the Base instance
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        set thisHandlePacketAction create
        if {$sendTraffic_v4} {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 2 -src $dataip(ip.1.Ixia.$dut1) -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 2 -src $dataip(ip.1.Ixia.$dut1) -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -packetsPerBurst 2 -action $thisHandlePacketAction
          incr streamId
          set totalNbrOfFlowroutes [expr $totalNbrOfFlowroutes + $thisNbrFlowroutesPerVprn]
        }
        if {$streamId == $nbrStreamsUsed} {
          # this is the last stream (IPv6)
          set thisHandlePacketAction ""
        } else {
          set thisHandlePacketAction create
        }
        if {$sendTraffic_v6} {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 2 -src [ipv4ToIpv6  $dataip(ip.1.Ixia.$dut1)] -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 2 -src [ipv4ToIpv6  $dataip(ip.1.Ixia.$dut1)] -numSource 1 -damac $thisDA -stream $streamId -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -packetsPerBurst 2 -action $thisHandlePacketAction
          incr streamId
          set totalNbrOfFlowroutes [expr $totalNbrOfFlowroutes + $thisNbrFlowroutesPerVprn]
        }
      }
    }

    # scrubber
    handlePacket -port $portA(Ixia.$dut3) -action capture

    log_msg INFO "Wait till all vprn's are operational before installed action forward router"
    set nbrRedirectVprnOperStateUp 0
    foreach {dut} $checkIpFilterDutList {break}
    for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
      for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
        set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
        set rCli [$dut sendCliCommand "show service id $thisRedirectVprnId base | match \"Oper State\" "]
        # Admin State       : Up                  Oper State        : Up
        if {[regexp {.*Oper State[ ]+:[ ]+([A-Za-z]+).*} $rCli match vprnOperState]} {
          if {$vprnOperState == "Up"} {
            incr nbrRedirectVprnOperStateUp
          }
        }
      }
      if {$nbrRedirectVprnOperStateUp == $nbrRedirectVprn} {
        log_msg INFO "All redirectVprn are Up ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn)"
        log_msg INFO "" ; log_msg INFO "Display some interesting info for the redirect vprn's" ; log_msg INFO ""
        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
          set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
          set rCli [$dut sendCliCommand "show service id $thisRedirectVprnId all"] ; log_msg INFO "$rCli"
        }
        set rCli [$dut sendCliCommand "show router tunnel-table"] ; log_msg INFO "$rCli"
        if {$redirectVprnTunnelEncap == "rsvp"} {
          set rCli [$dut sendCliCommand "show router mpls lsp"] ; log_msg INFO "$rCli"
        }
        if {$redirectVprnTunnelMethod == "sdp"} {
          set rCli [$dut sendCliCommand "show service sdp detail"] ; log_msg INFO "$rCli"
        }
        break
      } else {
        if {$rCnt == $option(maxRetryCnt)} {
          log_msg ERROR "Not all redirectVprn ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn) are Up after $option(maxRetryCnt) retries" ; set Result FAIL
        } else {
          log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) till all redirectVprn ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn) are Up ..." ; after [expr $option(interRetryTimeSec) * 1000]
        }
      }
    }
    if {! [testFailed] && $Result == "OK"} {
      set mySubtest "Precondition: Waiting 20secs and check that traffic flows from $dut1 to $dut6" ; after 20000
      log_msg INFO "$mySubtest"
      if {[flowspec_allTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
        log_msg INFO "Traffic from $dut1 to $dut6 ok"
      } else {
        log_msg ERROR "Traffic from $dut1 to $dut6 nok" ; set Result FAIL
      }
      subtest "$mySubtest"
    }

    # apply filters on $dut2
    cliCne $dut2 "/environment no create"
    foreach filterIpType "ip ipv6" {
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId2 action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId3 action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId4 action forward"]; log_msg INFO $rCli
    }

    log_msg INFO "$dut2: Apply ingress filter (ip/ipv6) $cntPktsViaFilter_filterId (on itf $dut1 => $dut2)"
    set vprnCnt 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        if {$itfType_dut1dut2 == "spoke"} {
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        } else {
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        }
    }

# in case of flowspec interaction
    if {$option(flowspecInteraction) == "true"} {
        if {! [testFailed] && $Result == "OK"} {
          # sbgp part
          set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
          foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
            foreach thisAction $thisActionListPerVprn {
              set a [set a_[set thisAction]]
              set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
              if {! $sendBgpPrefixUpd_v4} {
                set thisDstPrefix_v4 $dummyNetw
              }
              set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
              sbgp.init -linuxItf $portA(Linux.$dut3) -id peer$thisVprnId -linuxIp $dataip(ip.$thisVprnId.Linux.$dut3) -linuxAs $Linux_AS -dutIp $dataip(ip.$thisVprnId.$dut3.Linux) -dutAs [set [set dut3]_AS] \
                -capability $sbgpDefCapabilityList \
                -announce $thisDstPrefixMask_v4 -linuxDot1q $thisVprnId \
                -debug $option(sbgpDebug) -verbose $option(sbgpDebug)
              if {$sendBgpPrefixUpd_v6} {
                sbgp.add -id peer$thisVprnId -mpReach "prefix $thisDstPrefixMask_v6" -mpNHop [ipv4ToIpv6 $dataip(ip.$thisVprnId.Linux.$dut3)]
              }
            }
            incr c ; if {$c > 255} {set c 0 ; incr b}
          }
          #
          if {$addFlowroutesInBase} {
            # - Don't reset b and c because they point to the next values to be used
            foreach thisAction $thisActionListPerVprn {
              set a [set a_[set thisAction]]
              set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
              if {! $sendBgpPrefixUpd_v4} {
                set thisDstPrefix_v4 $dummyNetw
              }
              set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
              sbgp.init -linuxItf $portA(Linux.$dut3) -id peer$baseDot1qTag -linuxIp $dataip(ip.$baseDot1qTag.Linux.$dut3) -linuxAs $Linux_AS -dutIp $dataip(ip.$baseDot1qTag.$dut3.Linux) -dutAs [set [set dut3]_AS] \
                -capability $sbgpDefCapabilityList \
                -announce $thisDstPrefixMask_v4 -linuxDot1q $baseDot1qTag \
                -debug $option(sbgpDebug) -verbose $option(sbgpDebug)
              if {$sendBgpPrefixUpd_v6} {
                sbgp.add -id peer$baseDot1qTag -mpReach "prefix $thisDstPrefixMask_v6" -mpNHop [ipv4ToIpv6 $dataip(ip.$baseDot1qTag.Linux.$dut3)]
                  }
                }
              }
          #
          set b 1 ; set c [lindex $vprnIdOnlyList 0]          
          foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
            foreach thisAction $thisActionListPerVprn {
              set a [set a_[set thisAction]]
              set d 0
              for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                set flow1_v4 [createFlowSpecNLRIType -dstPrefix $thisDstPrefixMask_v4]
                set flow1_v6 [createFlowSpecNLRIType -dstPrefix $thisDstPrefixMask_v6]
                if {$thisAction == "redirectVrf"} {
                  set comm1_v4 [createFlowSpecExtCommunityAttr $thisAction -target $thisRT]
                  set comm1_v6 [createFlowSpecExtCommunityAttr $thisAction -target $thisRT]
                } else {
                  set comm1_v4 [createFlowSpecExtCommunityAttr $thisAction]
                  set comm1_v6 [createFlowSpecExtCommunityAttr $thisAction]
                }
                if {$sendBgpFlowrouteUpd_v4} {
                  log_msg INFO "Inject flowroute $thisDstPrefixMask_v4 $thisAction"
                  set mpAfi "ipv4" ; set mpSafi "flow-base" ; set nlriAs "$Linux_AS 65001 65002"
                  log_msg INFO " =>sbgp.add -id peer$thisVprnId -mpReachRaw $flow1_v4 -community $comm1_v4 -nlriAs \"$nlriAs\" -mpAfi $mpAfi -mpSafi $mpSafi"
                  sbgp.add -id peer$thisVprnId -mpReachRaw $flow1_v4 -community $comm1_v4 -nlriAs $nlriAs -mpAfi $mpAfi -mpSafi $mpSafi
                }
                if {$sendBgpFlowrouteUpd_v6} {
                  log_msg INFO "Inject flowroute $thisDstPrefixMask_v6 $thisAction"
                  set mpAfi "ipv6" ; set mpSafi "flow-base" ; set nlriAs "$Linux_AS 65001 65002"
                  log_msg INFO " =>sbgp.add -id peer$thisVprnId -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs \"$nlriAs\" -mpAfi $mpAfi -mpSafi $mpSafi -mpNHop [ipv4ToIpv6 $dataip(ip.$thisVprnId.Linux.$dut3)]"
                  sbgp.add -id peer$thisVprnId -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs $nlriAs -mpAfi $mpAfi -mpSafi $mpSafi -mpNHop [ipv4ToIpv6 $dataip(ip.$thisVprnId.Linux.$dut3)]
                }
                incr d
              }
            }
            incr c ; if {$c > 255} {set c 0 ; incr b}
          }
          #
          if {$addFlowroutesInBase} {
            # - Don't reset b and c because they point to the next values to be used
            foreach thisAction $thisActionListPerVprn {
              set a [set a_[set thisAction]]
              set d 0
              for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                set flow1_v4 [createFlowSpecNLRIType -dstPrefix $thisDstPrefixMask_v4]
                set flow1_v6 [createFlowSpecNLRIType -dstPrefix $thisDstPrefixMask_v6]
                if {$thisAction == "redirectVrf"} {
                  set comm1_v4 [createFlowSpecExtCommunityAttr $thisAction -target $thisRT]
                  set comm1_v6 [createFlowSpecExtCommunityAttr $thisAction -target $thisRT]
                } else {
                  set comm1_v4 [createFlowSpecExtCommunityAttr $thisAction]
                  set comm1_v6 [createFlowSpecExtCommunityAttr $thisAction]
                }
                if {$sendBgpFlowrouteUpd_v4} {
                  log_msg INFO "Inject flowroute $thisDstPrefixMask_v4 $thisAction"
                  set mpAfi "ipv4" ; set mpSafi "flow-base" ; set nlriAs "$Linux_AS 65001 65002"
                  log_msg INFO " =>sbgp.add -id peer$baseDot1qTag -mpReachRaw $flow1_v4 -community $comm1_v4 -nlriAs \"$nlriAs\" -mpAfi $mpAfi -mpSafi $mpSafi"
                  sbgp.add -id peer$baseDot1qTag -mpReachRaw $flow1_v4 -community $comm1_v4 -nlriAs $nlriAs -mpAfi $mpAfi -mpSafi $mpSafi
                }
                if {$sendBgpFlowrouteUpd_v6} {
                  log_msg INFO "Inject flowroute $thisDstPrefixMask_v6 $thisAction"
                  set mpAfi "ipv6" ; set mpSafi "flow-base" ; set nlriAs "$Linux_AS 65001 65002"
                  log_msg INFO " =>sbgp.add -id peer$baseDot1qTag -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs \"$nlriAs\" -mpAfi $mpAfi -mpSafi $mpSafi -mpNHop [ipv4ToIpv6 $dataip(ip.$baseDot1qTag.Linux.$dut3)]"
                  sbgp.add -id peer$baseDot1qTag -mpReachRaw $flow1_v6 -community $comm1_v6 -nlriAs $nlriAs -mpAfi $mpAfi -mpSafi $mpSafi -mpNHop [ipv4ToIpv6 $dataip(ip.$baseDot1qTag.Linux.$dut3)]
                }
                incr d
              }
            }
          }
          #
          foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
            sbgp.run -id peer$thisVprnId
          }
          if {$addFlowroutesInBase} {
            sbgp.run -id peer$baseDot1qTag
          }
        }

        if {! [testFailed] && $Result == "OK"} {
          set mySubtest "$dut3: Check that debug log has no unexpected \"Optional Attribute Error\""
          log_msg INFO "$mySubtest"
          set rCli [$dut3 sendCliCommand "show log log-id $debugLog count 200 descending" -bufferedMode true] ; if {$dumpDebugLog} {log_msg INFO "$rCli"}
          if {[regexp {.*Optional Attribute Error.*} $rCli match]} {
            log_msg ERROR "Found unexpected \"Optional Attribute Error\""
          } else {
            log_msg INFO "No unexpected \"Optional Attribute Error\" found"
          }
          subtest "$mySubtest"
        }

        if {! [testFailed] && $Result == "OK"} {
          if {[expr $nbrVprns * $nbrFlowroutesPerVprn] > 16} {
            log_msg WARNING "Skip debug log check because scale is too high"
          } else {
            set mySubtest "$dut3: Check that debug log has all expected vprn's ($vprnIdOnlyList)"
            log_msg INFO "$mySubtest"
            if {[flowspec_checkBgpDebugLogForVprnId $dut3 $debugLog $vprnIdOnlyList]} {
              log_msg INFO "$dut3: Found all expected vprn's ($vprnIdOnlyList) in debug log (log-id: $debugLog)"
            } else {
              log_msg ERROR "$dut3: Couldn't find all expected vprn's ($vprnIdOnlyList) in debug log (log-id: $debugLog)"
            }
            subtest "$mySubtest"
          }
        }
    }

    if {! [testFailed] && $Result == "OK"} {
      if {$enableFlowspecBeforeFlowroutesAreInjected} {
        # skip traffic check
      } else {
        set mySubtest "Check that traffic still flows from $dut1 to $dut6, because ingress action forward router is not yet applied"
        log_msg INFO "$mySubtest"
        if {[flowspec_allTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
          log_msg INFO "Traffic from $dut1 to $dut6 ok"
        } else {
          log_msg ERROR "Traffic from $dut1 to $dut6 nok" ; set Result FAIL
        }
        subtest "$mySubtest"
      }
    }

    if {$option(flowspecInteraction) == "true"} {
        if {! [testFailed] && $Result == "OK"} {
          if {$enableFlowspecBeforeFlowroutesAreInjected} {
            # already done earlier
          } else {
            if {$enableIngressFlowspec_v4 || $enableIngressFlowspec_v6} {
              if {$enableIngressFlowspec_v4 && $enableIngressFlowspec_v6} {set thisTxt "flowspec/flowspec-ipv6"} elseif {$enableIngressFlowspec_v4} {set thisTxt "flowspec"} else {set thisTxt "flowspec-ipv6"}
              set mySubtest "$dut2: Apply now ingress $thisTxt (on itf $dut1 => $dut2)"
              log_msg INFO "$mySubtest"
              foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                if {$itfType_dut1dut2 == "spoke"} {
                  set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress flowspec"] ; log_msg INFO $rCli
                  set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress flowspec-ipv6"] ; log_msg INFO $rCli
                } else {
                  set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress flowspec"] ; log_msg INFO $rCli
                  set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress flowspec-ipv6"] ; log_msg INFO $rCli
                }
              }
              #
              if {$addFlowroutesInBase} {
                set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress flowspec"] ; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress flowspec-ipv6"] ; log_msg INFO $rCli
              }
              subtest "$mySubtest"
            }
          }
        }
    }
    if {! [testFailed] && $Result == "OK"} {
      if {$addDefFilterInLastVprnAfterFlowroutesAreInjected} {
        log_msg INFO "$dut2: Apply ingress filter (ip/ipv6) $cntPktsViaFilter_filterId (on itf $dut1 => $dut2)"
        set vprnCnt 1
        foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
          if {$vprnCnt == $nbrVprns} {
            if {$itfType_dut1dut2 == "spoke"} {
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
            } else {
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
            }
          }
          incr vprnCnt
        }
      }
    }
    # configure filter $cntPktsViaFilter_filterId in Base router
    if {$addFlowroutesInBase} {
        set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
    }

    # configure service name for target VPRN
    log_msg INFO "Configure service name for target VPRN: $firstRedirectVprnId"
    set rCli [$dut2 sendCliCommand "/configure service vprn $firstRedirectVprnId service-name \"Target VPRN 400\""]; log_msg INFO $rCli

    # Configure action forward router for filters on $dut2
    foreach filterIpType "ip ipv6" {
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward router $firstRedirectVprnId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId2 action forward router service-name \"Target VPRN 400\""]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId3 action forward router $firstRedirectVprnId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId4 action forward router service-name \"Target VPRN 400\""]; log_msg INFO $rCli
    }

#interpreter

    if {! [testFailed] && $Result == "OK"} {
      set startTimeStampSec [clock seconds]
      set whileContinue 1 ; set iterationCnt 0
      while {$whileContinue} {
        incr iterationCnt
        foreach {action expectedBehavior} $actionExpectedBehaviorList {
          log_msg INFO "" ; log_msg INFO "======================================================================"
          log_msg INFO "iteration: $iterationCnt | action: \"$action\" => expectedBehavior: \"$expectedBehavior\" "
          log_msg INFO "======================================================================" ; log_msg INFO ""
          # These are the different actions
          switch $action {
            "none" {
              # no action needed
            }

            "swo" - "doubleSwo" {
              #
              log_msg INFO "" ; log_msg INFO "$dut2: Show filter $cntPktsViaFilter_filterId before switchover" ; log_msg INFO ""
              foreach thisFamily $thisFilterFamilyList {
                switch $thisFamily {
                  "ipv4" {set fTxt "ip" }
                  "ipv6" {set fTxt "ipv6"}
                }
                  set rCli [$dut2 sendCliCommand "show filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  log_msg INFO ""
                #
              } ; #thisFilterFamilyList
              #
              set actionTodo doubleSwo
              if {$actionTodo == "swo"} {set  nbrSwoToDo 1} else {set nbrSwoToDo 2}
              for {set swoNbr 1} {$swoNbr <= $nbrSwoToDo} {incr swoNbr} {
                set activitySwitchMethod [lindex $fspecSwoMethodList [random $fspecSwoMethodListLen]]
                log_msg INFO "$dut2: Switchover $swoNbr/$nbrSwoToDo activitySwitchMethod: $activitySwitchMethod"
                if {[$dut2 activitySwitch -inSyncTime1 11 -skipCheck true -inSyncTime3 2000 -Method $activitySwitchMethod] == "OK"} {
                  # nop
                } else {
                  log_msg ERROR "$dut2: Switchover failed" ; set Result FAIL ; break
                }
                after 1000 ; $dut2 closeExpectSession ; after 1000 ; $dut2 openExpectSession ; after 1000
                log_msg INFO "$dut2: Wait until standby is synchronized"
                if {[$dut2 CnWSecInSync] == "OK"} {
                  log_msg INFO "$dut2: Standby is in sync now - a new switchover is allowed"
                  after 5000
                  $dut2 closeExpectSession ; after 1000 ; $dut2 openExpectSession ; after 1000
                } else {
                  log_msg ERROR "$dut2: Standby not yet in sync" ; set Result FAIL ; break
                }
              }
              #
               log_msg INFO "" ; log_msg INFO "$dut2: Show filter $cntPktsViaFilter_filterId after switchover" ; log_msg INFO ""
              foreach thisFamily $thisFilterFamilyList {
                switch $thisFamily {
                  "ipv4" {set fTxt "ip"}
                  "ipv6" {set fTxt "ipv6"}
                }
                  set rCli [$dut2 sendCliCommand "show filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  log_msg INFO ""
                #
              } ; #thisFilterFamilyList
            }



            "stopTrafficAndClearFilters" {
              handlePacket -port $portA(Ixia.$dut1) -action stop ; after 5000
              #
              foreach thisFamily $thisFilterFamilyList {
                switch $thisFamily {
                  "ipv4" {set fTxt "ip"}
                  "ipv6" {set fTxt "ipv6"}
                }
                set vprnCnt 1
                set b 1 ; set c [lindex $vprnIdOnlyList 0]
                set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
              } ; #thisFilterFamilyList
              #
              log_msg INFO "Waiting 10secs..." ; after 10000
            }

            "startTraffic" {
              handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000
            }

            "rollback" {
              log_msg INFO "Create rollback checkpoint, remove configuration and restore via rollback revert"
              set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
              set rCli [$dut2 sendCliCommand "admin rollback save"] ; log_msg INFO "$rCli"
              #
              after 1000
              saveOrRestore delete -dut $dut2
              after 1000
              # configure rollback-location again because it was removed during saveOrRestore delete
              set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
              set rCli [$dut2 sendCliCommand "admin rollback revert latest-rb now"] ; log_msg INFO "$rCli"
              set rCli [$dut2 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
              set rCli [$dut2 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"
              log_msg INFO "Waiting 20secs ...." ; after 20000
              #
            }


            "adminTech" {
              set rCli [$dut2 sendCliCommand "admin tech-support ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs/thisAT_[tms_uptimeSecs $dut2]"] ; log_msg INFO "$rCli"
            }


            "removeAllIpv4v6RoutesFromRedirectVprn" {
              for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                set thisVlanId [expr $vCnt + 1]
                set rCli [$dut4 sendCliCommand "exit all"]
                foreach {thisA thisB thisC thisD} [split "1.66.9.9" "."] {break} ; set thisB [expr $thisB + $vCnt]
                # Add here static-routes for the redirectToVrf vprn
                set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
                foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                  foreach thisAction $thisActionListPerVprn {
                    if {$thisAction == "redirectVrf"} {
                      set a [set a_[set thisAction]]
                      set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                      set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId no static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId no static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
                    }
                  }
                  incr c ; if {$c > 255} {set c 0 ; incr b}
                }
                if {$addFlowroutesInBase} {
                  # - Don't reset b, c and d because they point to the next values to be used
                  # - Use isis in the Base instance
                  foreach thisAction $thisActionListPerVprn {
                    if {$thisAction == "redirectVrf"} {
                      set a [set a_[set thisAction]]
                      set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                      set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId no static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId no static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
                    }
                  }
                }
                #
              }
              set rCli [$dut4 sendCliCommand "exit all"]
              log_msg INFO "Waiting 30secs..." ; after 30000
            }

            "addAllIpv4v6RoutesFromRedirectVprn" {
              for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                set thisVlanId [expr $vCnt + 1]
                set rCli [$dut4 sendCliCommand "exit all"]
                foreach {thisA thisB thisC thisD} [split "1.66.9.9" "."] {break} ; set thisB [expr $thisB + $vCnt]
                # Add here static-routes for the redirectToVrf vprn
                set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
                foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                  foreach thisAction $thisActionListPerVprn {
                    if {$thisAction == "redirectVrf"} {
                      set a [set a_[set thisAction]]
                      set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                      set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
                    }
                  }
                  incr c ; if {$c > 255} {set c 0 ; incr b}
                }
                if {$addFlowroutesInBase} {
                  # - Don't reset b, c and d because they point to the next values to be used
                  # - Use isis in the Base instance
                  foreach thisAction $thisActionListPerVprn {
                    if {$thisAction == "redirectVrf"} {
                      set a [set a_[set thisAction]]
                      set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                      set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
                      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
                    }
                  }
                }
                #
              }
              set rCli [$dut4 sendCliCommand "exit all"]
              log_msg INFO "Waiting 30secs..." ; after 30000
            }

            "addGrtLookupEnableGrtStaticRoute" {
              foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
                if {$dut == $dut2} {
                  # do this only in dut2
                  set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
                  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                    foreach thisAction $thisActionListPerVprn {
                      if {$thisAction == "redirectVrf"} {
                        set a [set a_[set thisAction]]
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                        set rCli [$dut sendCliCommand "exit all"]
                        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                            set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                            set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt static-route $thisDstPrefixMask_v4 grt"] ; log_msg INFO "$rCli"
                            set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt static-route $thisDstPrefixMask_v6 grt"] ; log_msg INFO "$rCli"
                        }
                        set rCli [$dut sendCliCommand "exit all"]
                      }
                      incr c ; if {$c > 255} {set c 0 ; incr b}
                    }
                  }
                  #
                  if {$addFlowroutesInBase} {
                    # - Don't reset b, c and d because they point to the next values to be used
                    # - Use isis in the Base instance
                    foreach thisAction $thisActionListPerVprn {
                      if {$thisAction == "redirectVrf"} {
                        set a [set a_[set thisAction]]
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                        set rCli [$dut sendCliCommand "exit all"]
                        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                          set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                          set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt static-route $thisDstPrefixMask_v4 grt"] ; log_msg INFO "$rCli"
                          set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt static-route $thisDstPrefixMask_v6 grt"] ; log_msg INFO "$rCli"
                        }
                        set rCli [$dut sendCliCommand "exit all"]
                      }
                    }
                  }
                  #
                }
              }
              log_msg INFO "Waiting 5secs..." ; after 5000
            }

            "removeGrtLookupEnableGrtStaticRoute" {
              foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
                if {$dut == $dut2} {
                  # do this only in dut2
                  set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
                  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                    foreach thisAction $thisActionListPerVprn {
                      if {$thisAction == "redirectVrf"} {
                        set a [set a_[set thisAction]]
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                        set rCli [$dut sendCliCommand "exit all"]
                        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                            set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                            set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt no static-route $thisDstPrefixMask_v4 grt"] ; log_msg INFO "$rCli"
                            set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt no static-route $thisDstPrefixMask_v6 grt"] ; log_msg INFO "$rCli"
                        }
                        set rCli [$dut sendCliCommand "exit all"]
                      }
                      incr c ; if {$c > 255} {set c 0 ; incr b}
                    }
                  }
                  #
                  if {$addFlowroutesInBase} {
                    # - Don't reset b, c and d because they point to the next values to be used
                    # - Use isis in the Base instance
                    foreach thisAction $thisActionListPerVprn {
                      if {$thisAction == "redirectVrf"} {
                        set a [set a_[set thisAction]]
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
                        set rCli [$dut sendCliCommand "exit all"]
                        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                          set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                          set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt no static-route $thisDstPrefixMask_v4 grt"] ; log_msg INFO "$rCli"
                          set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId grt-lookup enable-grt no static-route $thisDstPrefixMask_v6 grt"] ; log_msg INFO "$rCli"
                        }
                        set rCli [$dut sendCliCommand "exit all"]
                      }
                    }
                  }
                  #
                }
              }
              log_msg INFO "Waiting 5secs..." ; after 5000
            }

            "shutAllRedirectVprn" {
              foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
                if {$dut == $dut2} {
                  # do this only in dut2
                  for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                    set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                    set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId shutdown"] ; log_msg INFO "$rCli"
                  }
                }
              }
            }

            "noShutAllRedirectVprn" {
              foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
                if {$dut == $dut2} {
                  # do this only in dut2
                  for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
                    set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
                    set rCli [$dut sendCliCommand "configure service vprn $thisRedirectVprnId no shutdown"] ; log_msg INFO "$rCli"
                  }
                }
              }
            }

            "negTest_addGrtLookupInFlowrouteVprn" {
              set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" "
              log_msg INFO "$mySubtest"
              log_msg INFO ""
              log_msg INFO "This is a negative test to cover following scenario:"
              log_msg INFO "  It's the intention to enable grt lookup in the redirectVprn (vrpnId: $firstRedirectVprnId ; nbrRedirectVprn: $nbrRedirectVprn)."
              log_msg INFO "  But, it's not forbidden to enable grt lookup in the flowroute vprn's (vrpnId's: $vprnIdOnlyList)."
              log_msg INFO "  This should have no impact. Verify, that not all traffic is GRT leaked (behavior before fix of RFE162746)"
              log_msg INFO ""

              foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                set rCli [$dut2 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId grt-lookup enable-grt"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
              }
            }

            "negTest_removeGrtLookupInFlowrouteVprn" {
              set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" "
              log_msg INFO "$mySubtest"
              log_msg INFO ""

              foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                set rCli [$dut2 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "exit all"] ; log_msg INFO "$rCli"
              }
            }

          } ; # action

          # And here the expected behavior
          switch $expectedBehavior {
            "none" {
              # nothing expected
            }

            "defaultBehavior" {
              set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => Check traffic goes through $dut4 (redirected) and $dut6 (redirected with 2nd lookup to Base - for second host IPs 85.x.x.2)"
              log_msg INFO "$mySubtest"

              if {! [testFailed] && $Result == "OK"} {
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                if {$option(sendTraffic_v4)} {
                  set rCli [$dut1 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut6 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut4 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                }
                if {$option(sendTraffic_v6)} {
                  set rCli [$dut1 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut6 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut4 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                }
                log_msg INFO "Wait 5secs and display egress counters in $dut4 and $dut6 before traffic starts" ; after 5000
                if {$option(sendTraffic_v4)} {
                  log_msg INFO "$dut4: IPv4 egress vvvvv"
                  getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count
                  log_msg INFO "$dut6: IPv4 egress vvvvv"
                  getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count
                }
                if {$option(sendTraffic_v6)} {
                  log_msg INFO "$dut4: IPv6 egress vvvvv"
                  getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count
                  log_msg INFO "$dut6: IPv6 egress vvvvv"
                  getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count
                }
                #
                handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                log_msg INFO "Traffic started, waiting 20secs and check that all traffic is redirected" ; after 20000
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                #
                if {$option(sendTraffic_v4)} {
                  set ingressTrafficList_[set dut1]_v4 [getFilter -print true -dut $dut1 -match [list id $cntPktsViaFilter_filterId version ipv4 dir ingress] -return count]
                  set egressTrafficList_[set dut4]_v4 [getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count]
                  set egressTrafficList_[set dut6]_v4 [getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count]
                  if {[set ingressTrafficList_[set dut1]_v4] == [expr [set egressTrafficList_[set dut4]_v4] + [set egressTrafficList_[set dut6]_v4]]  && [set egressTrafficList_[set dut4]_v4] != 0 && [set egressTrafficList_[set dut6]_v4] != 0} {
                    log_msg INFO "Traffic (IPv4) goes like expected: partial redirected to $dut4, partial to $dut6 (redirect 1st lookup fails, but 2nd lookup in GRT is ok)"
                    log_msg INFO "  => ingressTrafficList_[set dut1]_v4: [set ingressTrafficList_[set dut1]_v4] == egressTrafficList_[set dut4]_v4: [set egressTrafficList_[set dut4]_v4] + egressTrafficList_[set dut6]_v4: [set egressTrafficList_[set dut6]_v4]"
                  } else {
                    log_msg DEBUG "Traffic (IPv4) doesn't goes like expected => restart traffic for debugging ..."
                    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                    log_msg ERROR "Traffic (IPv4) doesn't goes like expected: partial redirected to $dut4, partial to $dut6 (ingressTrafficList_[set dut1]_v4: [set ingressTrafficList_[set dut1]_v4] <> egressTrafficList_[set dut4]_v4: [set egressTrafficList_[set dut4]_v4] + egressTrafficList_[set dut6]_v4: [set egressTrafficList_[set dut6]_v4])"
                    set Result FAIL ; break
                  }
                }
                if {$option(sendTraffic_v6)} {
                  set ingressTrafficList_[set dut1]_v6 [getFilter -print true -dut $dut1 -match [list id $cntPktsViaFilter_filterId version ipv6 dir ingress] -return count]
                  set egressTrafficList_[set dut4]_v6 [getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count]
                  set egressTrafficList_[set dut6]_v6 [getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count]
                  if {[set ingressTrafficList_[set dut1]_v6] == [expr [set egressTrafficList_[set dut4]_v6] + [set egressTrafficList_[set dut6]_v6]] && [set egressTrafficList_[set dut4]_v6] != 0 && [set egressTrafficList_[set dut6]_v6] != 0} {
                    log_msg INFO "Traffic (IPv6) goes like expected: partial redirected to $dut4, partial to $dut6 (redirect 1st lookup fails, but 2nd lookup in GRT is ok)"
                    log_msg INFO "  => ingressTrafficList_[set dut1]_v6: [set ingressTrafficList_[set dut1]_v6] == egressTrafficList_[set dut4]_v6: [set egressTrafficList_[set dut4]_v6] + egressTrafficList_[set dut6]_v6: [set egressTrafficList_[set dut6]_v6]"
                  } else {
                    log_msg DEBUG "Traffic (IPv6) doesn't goes like expected => restart traffic for debugging ..."
                    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                    log_msg ERROR "Traffic (IPv6) doesn't goes like expected: partial redirected to $dut4, partial to $dut6Traffic loss (ingressTrafficList_[set dut1]_v6: [set ingressTrafficList_[set dut1]_v6] <> egressTrafficList_[set dut4]_v6: [set set egressTrafficList_[set dut4]_v6] + egressTrafficList_[set dut6]_v6: [set egressTrafficList_[set dut6]_v6])"
                    set Result FAIL ; break
                  }
                }
                #
                subtest "$mySubtest"
              }

              if {! [testFailed] && $Result == "OK"} {
                set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => $dut2: Check filter for \"Ing. Matches\" - \"Dest. IP\" - \"Fwd Rtr\""
                log_msg INFO "$mySubtest"
                foreach thisFamily $thisFilterFamilyList {
                  set vprnCnt 1
                  set b 1 ; set c [lindex $vprnIdOnlyList 0]
                  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                    set thisFilterId $cntPktsViaFilter_filterId
                    
                    incr vprnCnt

                    foreach thisAction $thisActionListPerVprn {
                      set a [set a_[set thisAction]]
                      set d 0
                      for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                        switch $thisFamily {
                          "ipv4" {set findDestPrefixMsk $thisDstPrefixMask_v4}
                          "ipv6" {set findDestPrefixMsk $thisDstPrefixMask_v6}
                        }
                        if {$thisAction == "redirectVrf"} {set findFwdRtr $firstRedirectVprnId} else {set findFwdRtr ""}
                        incr d
                      }
                    }
                    if {[testFailed] || $Result == "FAIL"} {break}
                    incr c ; if {$c > 255} {set c 0 ; incr b}
                  }
                  #
                  if {$addFlowroutesInBase} {
                    # - Don't reset b and c because they point to the next values to be used
                    foreach thisAction $thisActionListPerVprn {
                      set a [set a_[set thisAction]]
                      set d 0
                      for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                        switch $thisFamily {
                          "ipv4" {set findDestPrefixMsk $thisDstPrefixMask_v4}
                          "ipv6" {set findDestPrefixMsk $thisDstPrefixMask_v6}
                        }
                        if {$thisAction == "redirectVrf"} {set findFwdRtr $firstRedirectVprnId} else {set findFwdRtr ""}
                        incr d
                      }
                    }
                  }
                  #
                  if {[testFailed] || $Result == "FAIL"} {break}
                }
                subtest "$mySubtest"
              }
            }


            "zeroIngMatchesExpInDut" {
              set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => $dut2: All filter entries should have \"Ing. Matches\" with 0 pkts & bytes"
              log_msg INFO "$mySubtest"
              foreach thisFamily $thisFilterFamilyList {
                switch $thisFamily {
                  "ipv4" {set fTxt "ip" ; set fSpecTxt "flowspec"}
                  "ipv6" {set fTxt "ipv6" ; set fSpecTxt "flowspec-ipv6"}
                }
                set vprnCnt 1
                set b 1 ; set c [lindex $vprnIdOnlyList 0]
                foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {

                  set thisFilterId $cntPktsViaFilter_filterId

                  incr vprnCnt

                  if {[flowspec_zeroCountersInFilterId $dut2 $thisFilterId]} {
                    log_msg INFO "$dut2: Found zeroCounters in filterId: $thisFilterId"
                  } else {
                    log_msg ERROR "$dut2: Found unexpected non zeroCounters in filterId: $thisFilterId" ; set Result FAIL ; break
                  }
                  incr c ; if {$c > 255} {set c 0 ; incr b}
                }
                #
                if {$addFlowroutesInBase} {
                  set thisFilterId $cntPktsViaFilter_filterId
                  if {[flowspec_zeroCountersInFilterId $dut2 $thisFilterId]} {
                    log_msg INFO "$dut2: Found zeroCounters in filterId: $thisFilterId"
                  } else {
                    log_msg ERROR "$dut2: Found unexpected non zeroCounters in filterId: $thisFilterId" ; set Result FAIL ; break
                  }
                }
                #
              } ; #thisFilterFamilyList
              subtest "$mySubtest"
            }

            "noRedirectToVrfTraffic_allTrafficViaGrtLeaking" {
              set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => Check traffic doesn't go through $dut4 (redirected).  Instead all traffic should go through $dut6 (redirected with 2nd lookup to Base)"
              log_msg INFO "$mySubtest"
              set nbrInstalledExp $totalNbrOfFlowroutes
              #

              if {! [testFailed] && $Result == "OK"} {
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                if {$option(sendTraffic_v4)} {
                  set rCli [$dut1 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut6 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut4 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                }
                if {$option(sendTraffic_v6)} {
                  set rCli [$dut1 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut6 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut4 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                }
                log_msg INFO "Wait 5secs and display egress counters in $dut4 and $dut6 before traffic starts" ; after 5000
                if {$option(sendTraffic_v4)} {
                  log_msg INFO "$dut4: IPv4 egress vvvvv"
                  getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count
                  log_msg INFO "$dut6: IPv4 egress vvvvv"
                  getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count
                }
                if {$option(sendTraffic_v6)} {
                  log_msg INFO "$dut4: IPv6 egress vvvvv"
                  getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count
                  log_msg INFO "$dut6: IPv6 egress vvvvv"
                  getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count
                }
                #
                handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                log_msg INFO "Traffic started, waiting 20secs and check that all traffic is redirected" ; after 20000
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                #
                if {$option(sendTraffic_v4)} {
                  set ingressTrafficList_[set dut1]_v4 [getFilter -print true -dut $dut1 -match [list id $cntPktsViaFilter_filterId version ipv4 dir ingress] -return count]
                  set egressTrafficList_[set dut4]_v4 [getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count]
                  set egressTrafficList_[set dut6]_v4 [getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count]
                  if {[set ingressTrafficList_[set dut1]_v4] == [set egressTrafficList_[set dut6]_v4] && [set egressTrafficList_[set dut4]_v4] == 0} {
                    log_msg INFO "Traffic (IPv4) goes like expected: nothing redirected to $dut4, all to $dut6 (redirect 1st lookup fails, but 2nd lookup in GRT is ok)"
                    log_msg INFO "  => ingressTrafficList_[set dut1]_v4: [set ingressTrafficList_[set dut1]_v4] == egressTrafficList_[set dut6]_v4: [set egressTrafficList_[set dut6]_v4] and egressTrafficList_[set dut4]_v4: [set egressTrafficList_[set dut4]_v4] == 0"
                  } else {
                    log_msg DEBUG "Traffic (IPv4) doesn't goes like expected => restart traffic for debugging ..."
                    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                    log_msg ERROR "Traffic (IPv4) doesn't goes like expected: nothing redirected to $dut4, all to $dut6 (ingressTrafficList_[set dut1]_v4: [set ingressTrafficList_[set dut1]_v4] <> egressTrafficList_[set dut6]_v4: [set egressTrafficList_[set dut6]_v4] and egressTrafficList_[set dut4]_v4: [set egressTrafficList_[set dut4]_v4] (exp=0))"
                    set Result FAIL ; break
                  }
                }
                if {$option(sendTraffic_v6)} {
                  set ingressTrafficList_[set dut1]_v6 [getFilter -print true -dut $dut1 -match [list id $cntPktsViaFilter_filterId version ipv6 dir ingress] -return count]
                  set egressTrafficList_[set dut4]_v6 [getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count]
                  set egressTrafficList_[set dut6]_v6 [getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count]
                  if {[set ingressTrafficList_[set dut1]_v6] == [set egressTrafficList_[set dut6]_v6] && [set egressTrafficList_[set dut4]_v6] == 0} {
                    log_msg INFO "Traffic (IPv6) goes like expected: nothing redirected to $dut4, all to $dut6 (redirect 1st lookup fails, but 2nd lookup in GRT is ok)"
                    log_msg INFO "  => ingressTrafficList_[set dut1]_v6: [set ingressTrafficList_[set dut1]_v6] == egressTrafficList_[set dut6]_v6: [set egressTrafficList_[set dut6]_v6] and egressTrafficList_[set dut4]_v6: [set egressTrafficList_[set dut4]_v6] == 0"
                  } else {
                    log_msg DEBUG "Traffic (IPv6) doesn't goes like expected => restart traffic for debugging ..."
                    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                    log_msg ERROR "Traffic (IPv6) doesn't goes like expected: nothing redirected to $dut4, all to $dut6 (ingressTrafficList_[set dut1]_v6: [set ingressTrafficList_[set dut1]_v6] <> egressTrafficList_[set dut6]_v6: [set egressTrafficList_[set dut6]_v6] and egressTrafficList_[set dut4]_v6: [set egressTrafficList_[set dut4]_v6] (exp=0))"
                    set Result FAIL ; break
                  }
                }
                #
                subtest "$mySubtest"
              }

              if {! [testFailed] && $Result == "OK"} {
                set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => $dut2: Check filter for \"Ing. Matches\" - \"Dest. IP\" - \"Fwd Rtr\""
                log_msg INFO "$mySubtest"
                foreach thisFamily $thisFilterFamilyList {
                  set vprnCnt 1
                  set b 1 ; set c [lindex $vprnIdOnlyList 0]
                  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                    set thisFilterId $cntPktsViaFilter_filterId
                    incr vprnCnt

                    foreach thisAction $thisActionListPerVprn {
                      set a [set a_[set thisAction]]
                      set d 0
                      for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                        switch $thisFamily {
                          "ipv4" {set findDestPrefixMsk $thisDstPrefixMask_v4}
                          "ipv6" {set findDestPrefixMsk $thisDstPrefixMask_v6}
                        }
                        if {$thisAction == "redirectVrf"} {set findFwdRtr $firstRedirectVprnId} else {set findFwdRtr ""}
                        incr d
                      }
                    }
                    if {[testFailed] || $Result == "FAIL"} {break}
                    incr c ; if {$c > 255} {set c 0 ; incr b}
                  }
                  #
                  if {$addFlowroutesInBase} {
                    # - Don't reset b and c because they point to the next values to be used
                    foreach thisAction $thisActionListPerVprn {
                      set a [set a_[set thisAction]]
                      set d 0
                      for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                        switch $thisFamily {
                          "ipv4" {set findDestPrefixMsk $thisDstPrefixMask_v4}
                          "ipv6" {set findDestPrefixMsk $thisDstPrefixMask_v6}
                        }
                        if {$thisAction == "redirectVrf"} {set findFwdRtr $firstRedirectVprnId} else {set findFwdRtr ""}
                        incr d
                      }
                    }
                  }
                  #
                  if {[testFailed] || $Result == "FAIL"} {break}
                }
                subtest "$mySubtest"
              }
            }

            "noRedirectToVrfTraffic_noTrafficViaGrtLeaking" {
              set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => Check traffic doesn't go through $dut4 (redirected) and not through $dut6 (redirected with 2nd lookup to Base) ... typical because the redirect vprn is shut"
              log_msg INFO "$mySubtest"
              set nbrInstalledExp $totalNbrOfFlowroutes
              #

              if {! [testFailed] && $Result == "OK"} {
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                if {$option(sendTraffic_v4)} {
                  set rCli [$dut1 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut6 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut4 sendCliCommand "clear filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                }
                if {$option(sendTraffic_v6)} {
                  set rCli [$dut1 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut6 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                  set rCli [$dut4 sendCliCommand "clear filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                }
                log_msg INFO "Wait 5secs and display egress counters in $dut4 and $dut6 before traffic starts" ; after 5000
                if {$option(sendTraffic_v4)} {
                  log_msg INFO "$dut4: IPv4 egress vvvvv"
                  getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count
                  log_msg INFO "$dut6: IPv4 egress vvvvv"
                  getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count
                }
                if {$option(sendTraffic_v6)} {
                  log_msg INFO "$dut4: IPv6 egress vvvvv"
                  getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count
                  log_msg INFO "$dut6: IPv6 egress vvvvv"
                  getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count
                }
                #
                handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                log_msg INFO "Traffic started, waiting 20secs and check that all traffic is redirected" ; after 20000
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                #
                if {$option(sendTraffic_v4)} {
                  set ingressTrafficList_[set dut1]_v4 [getFilter -print true -dut $dut1 -match [list id $cntPktsViaFilter_filterId version ipv4 dir ingress] -return count]
                  set egressTrafficList_[set dut4]_v4 [getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count]
                  set egressTrafficList_[set dut6]_v4 [getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv4 dir egress] -return count]
                  if {[set ingressTrafficList_[set dut1]_v4] != 0 && [set egressTrafficList_[set dut6]_v4] == 0 && [set egressTrafficList_[set dut4]_v4] == 0} {
                    log_msg INFO "Traffic (IPv4) goes like expected: nothing redirected to $dut4, noting to $dut6"
                    log_msg INFO "  => ingressTrafficList_[set dut1]_v4: [set ingressTrafficList_[set dut1]_v4] ; egressTrafficList_[set dut6]_v4: [set egressTrafficList_[set dut6]_v4] ; egressTrafficList_[set dut4]_v4: [set egressTrafficList_[set dut4]_v4]"
                  } else {
                    log_msg DEBUG "Traffic (IPv4) doesn't goes like expected => restart traffic for debugging ..."
                    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                    log_msg ERROR "Traffic (IPv4) doesn't goes like expected: nothing redirected to $dut4, nothing to $dut6 (ingressTrafficList_[set dut1]_v4: [set ingressTrafficList_[set dut1]_v4] ; egressTrafficList_[set dut6]_v4: [set egressTrafficList_[set dut6]_v4] (exp=0) ; egressTrafficList_[set dut4]_v4: [set egressTrafficList_[set dut4]_v4] (exp=0))"
                    set Result FAIL ; break
                  }
                }
                if {$option(sendTraffic_v6)} {
                  set ingressTrafficList_[set dut1]_v6 [getFilter -print true -dut $dut1 -match [list id $cntPktsViaFilter_filterId version ipv6 dir ingress] -return count]
                  set egressTrafficList_[set dut4]_v6 [getFilter -print true -dut $dut4 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count]
                  set egressTrafficList_[set dut6]_v6 [getFilter -print true -dut $dut6 -match [list id $cntPktsViaFilter_filterId version ipv6 dir egress] -return count]
                  if {[set ingressTrafficList_[set dut1]_v6] != 0 && [set egressTrafficList_[set dut6]_v6] == 0 && [set egressTrafficList_[set dut4]_v6] == 0} {
                    log_msg INFO "Traffic (IPv6) goes like expected: nothing redirected to $dut4, nothing to $dut6"
                    log_msg INFO "  => ingressTrafficList_[set dut1]_v6: [set ingressTrafficList_[set dut1]_v6] ; egressTrafficList_[set dut6]_v6: [set egressTrafficList_[set dut6]_v6] ; egressTrafficList_[set dut4]_v6: [set egressTrafficList_[set dut4]_v6]"
                  } else {
                    log_msg DEBUG "Traffic (IPv6) doesn't goes like expected => restart traffic for debugging ..."
                    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
                    log_msg ERROR "Traffic (IPv6) doesn't goes like expected: nothing redirected to $dut4, nothing to $dut6 (ingressTrafficList_[set dut1]_v6: [set ingressTrafficList_[set dut1]_v6] ; egressTrafficList_[set dut6]_v6: [set egressTrafficList_[set dut6]_v6] (exp=0) ; egressTrafficList_[set dut4]_v6: [set egressTrafficList_[set dut4]_v6] (exp=0))"
                    set Result FAIL ; break
                  }
                }
                #
                subtest "$mySubtest"
              }

              if {! [testFailed] && $Result == "OK"} {
                set mySubtest "action: \"$action\" expectedBehavior: \"$expectedBehavior\" => $dut2: Check filter for \"Ing. Matches\" - \"Dest. IP\" - \"Fwd Rtr\""
                log_msg INFO "$mySubtest"
                foreach thisFamily $thisFilterFamilyList {
                  set vprnCnt 1
                  set b 1 ; set c [lindex $vprnIdOnlyList 0]
                  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
                    set thisFilterId $cntPktsViaFilter_filterId
                    incr vprnCnt

                    foreach thisAction $thisActionListPerVprn {
                      set a [set a_[set thisAction]]
                      set d 0
                      for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                        switch $thisFamily {
                          "ipv4" {set findDestPrefixMsk $thisDstPrefixMask_v4}
                          "ipv6" {set findDestPrefixMsk $thisDstPrefixMask_v6}
                        }
                        if {$thisAction == "redirectVrf"} {set findFwdRtr $firstRedirectVprnId} else {set findFwdRtr ""}
                        incr d
                      }
                    }
                    if {[testFailed] || $Result == "FAIL"} {break}
                    incr c ; if {$c > 255} {set c 0 ; incr b}
                  }
                  #
                  if {$addFlowroutesInBase} {
                    # - Don't reset b and c because they point to the next values to be used
                    foreach thisAction $thisActionListPerVprn {
                      set a [set a_[set thisAction]]
                      set d 0
                      for {set flowroutePerVprnCnt 1} {$flowroutePerVprnCnt <= $thisNbrFlowroutesPerVprn} {incr flowroutePerVprnCnt} {
                        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
                        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
                        switch $thisFamily {
                          "ipv4" {set findDestPrefixMsk $thisDstPrefixMask_v4}
                          "ipv6" {set findDestPrefixMsk $thisDstPrefixMask_v6}
                        }
                        if {$thisAction == "redirectVrf"} {set findFwdRtr $firstRedirectVprnId} else {set findFwdRtr ""}
                        incr d
                      }
                    }
                  }
                  #
                  if {[testFailed] || $Result == "FAIL"} {break}
                }
                subtest "$mySubtest"
              }
            }

          }; # expectedBehavior

          if {[testFailed] || $Result == "FAIL"} {break}
        }
        if {[testFailed] || $Result == "FAIL"} {break}
        #
        # Check if a new iteration should start
        switch $iterationMethod {
          "maxNbrIterations" {
            if {$iterationCnt == $maxNbrIterations} {set whileContinue 0}
          }
          "maxDuration" {
            set stopTimeStampSec [clock seconds]
            set deltaTimeHrs [exec echo "($stopTimeStampSec  - $startTimeStampSec) / 3600"  | bc]
            if {$deltaTimeHrs >= $maxDurationHrs } {set whileContinue 0}
          }
          "ifFileExists" {
            if {! [file exists $option(fileExistsName)]} {set whileContinue 0}
          }
        }
        #
      }

    }


  }

  if {$option(deconfig)} {
    saveOrRestore delete
    sbgp.closeall
  }

  testcaseTrailer
  $dut2 configure -cli_timeout $cliTimeoutOrig
  if {$dutLoggingDisabled} {
    log_msg WARNING "Logging in dut-logs was disabled, enable it again"
    foreach dut $dutList {
      $dut configure -logging logging
    }
  }


}

####################################################################################
#
# Test ID   : filterActionFwdRtr_urpfCheck
#
# Description : Cover RFE158878: When PBR to VRF is applied (filter or flow-spec) uRPF should be done in source routing instance
#     - verify interaction between uRPF and the 'redirect to router' action so that uRPF always uses the original/source
#       routing instance to do the source IP address lookup for uRPF and not target/destination VRF
#     - verify redirect from GRT to VRF, VRF to VRF and VRF to GRT
#     - verify strict and loose mode
#     - verify it for host, loose and spoofed IPs
#     - verify it with ECMP disabled/enabled
#
#
#                   - Test runs on stdsixdutnode - IOM3+ (-constraints {{40GSupport true}})
#
# Possible combinations:
# filterActionFwdRtrUrpf -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToVrf
# filterActionFwdRtrUrpf -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToVrf
# filterActionFwdRtrUrpf -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType grtToVrf
# filterActionFwdRtrUrpf -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType grtToVrf
# filterActionFwdRtrUrpf -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToGrt
# filterActionFwdRtrUrpf -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToGrt
# filterActionFwdRtrUrpf -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToVrf -ecmpEnabled true
# filterActionFwdRtrUrpf -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToVrf -ecmpEnabled true
# filterActionFwdRtrUrpf -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType grtToVrf -ecmpEnabled true
# filterActionFwdRtrUrpf -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType grtToVrf -ecmpEnabled true
# filterActionFwdRtrUrpf -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToGrt -ecmpEnabled true
# filterActionFwdRtrUrpf -itfType_dut1dut2 spoke -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToGrt -ecmpEnabled true
#
####################################################################################
proc filterActionFwdRtrUrpf {args} {

  global masterlog testdir ixia_port logdir
  global portA dataip

  source $testdir/testsuites/flowspec/flowspec_vprnParams.tcl
  source $testdir/testsuites/flowspec/flowspec_Procs.tcl
  source $testdir/testsuites/filter/tests/wccp_procs.tcl
  source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl

  set option(config) true
  set option(test) true
  set option(deconfig) true
  set option(debug) false
  set option(verbose) false
  set option(bugxxxxx) false
  set option(returnResult) false
  set option(sbgpDebug) false
  set option(dumpDebugLog) false
  set option(cliTimeout) 600
  set option(maxRetryCnt) 6
  set option(interRetryTimeSec) 30
  set option(addDefFilterInFirstVprnBeforeFlowroutesAreInjected) true
  set option(addDefFilterInLastVprnAfterFlowroutesAreInjected) true
  set option(nbrVprns) 3
  set option(nbrFlowroutesPerVprn) 1
  set option(actionListPerVprn) [list redirectVrf]
  set option(enableFilterTrace) false
  set option(enableBgpFlowspecTrace) false
  set option(sendBgpPrefixUpd_v4) false
  set option(sendBgpPrefixUpd_v6) false
  set option(sendBgpFlowrouteUpd_v4) true
  set option(sendBgpFlowrouteUpd_v6) true
  set option(sendTraffic_v4) true
  set option(sendTraffic_v6) true
  set option(enableIngressFlowspec_v4) false
  set option(enableIngressFlowspec_v6) false
  set option(flowspecInteraction) false
  set option(vrfTargetDirectUnderVprn_noImportPolicy) true
  set option(enableFlowspecBeforeFlowroutesAreInjected) false
  # spoke (flowroute vprn)
  set option(itfType_dut1dut2) ""
  set option(addFlowroutesInBase) true

  # maxNbrIterations | maxDuration [hours] | ifFileExists
  set option(iterationMethod) maxNbrIterations
  set option(maxNbrIterations) 1
  set option(maxDurationHrs) 5
  set option(fileExistsName) "/tmp/fwdRtrVprn_running.txt"

  # vrfToVrf | grtToVrf | vrfToGrt
  set option(redirectType)     "vrfToVrf"
  set option(verifySwo)     "false"
  set option(ecmpEnabled)     "false"
  # there are 4 combinations
  #   autobind - ldp (default)
  #   autobind - gre
  #   sdp - rsvp
  #   sdp - gre
  set option(redirectVprnTunnelMethod) autobind
  set option(redirectVprnTunnelEncap) ldp

  set option(grtLookupEnableGrt) false 
  getopt option      $args

  set testID $::TestDB::currentTestCase
  set Result OK

  testcaseHeader

  ##### Testcase GGV paramerters (begin)
  if {[GGV fspecNbrVprns] != "ERROR"} {
    set nbrVprns [GGV fspecNbrVprns]
  } else {
    set nbrVprns $option(nbrVprns)
  }
  if {[GGV fspecNbrFlowroutesPerVprn] != "ERROR"} {
    set nbrFlowroutesPerVprn [GGV fspecNbrFlowroutesPerVprn]
  } else {
    set nbrFlowroutesPerVprn $option(nbrFlowroutesPerVprn)
  }
  if {[GGV fspecEnableFilterTrace] != "ERROR"} {
    set enableFilterTrace [GGV fspecEnableFilterTrace]
  } else {
    set enableFilterTrace $option(enableFilterTrace)
  }
  if {[GGV fspecEnableBgpFlowspecTrace] != "ERROR"} {
    set enableBgpFlowspecTrace [GGV fspecEnableBgpFlowspecTrace]
  } else {
    set enableBgpFlowspecTrace $option(enableBgpFlowspecTrace)
  }
  if {[GGV fspecSendBgpPrefixUpd_v4] != "ERROR"} {
    set sendBgpPrefixUpd_v4 [GGV fspecSendBgpPrefixUpd_v4]
  } else {
    set sendBgpPrefixUpd_v4 $option(sendBgpPrefixUpd_v4)
  }
  if {[GGV fspecSendBgpPrefixUpd_v6] != "ERROR"} {
    set sendBgpPrefixUpd_v6 [GGV fspecSendBgpPrefixUpd_v6]
  } else {
    set sendBgpPrefixUpd_v6 $option(sendBgpPrefixUpd_v6)
  }
  if {[GGV fspecSendBgpFlowrouteUpd_v4] != "ERROR"} {
    set sendBgpFlowrouteUpd_v4 [GGV fspecSendBgpFlowrouteUpd_v4]
  } else {
    set sendBgpFlowrouteUpd_v4 $option(sendBgpFlowrouteUpd_v4)
  }
  if {[GGV fspecSendBgpFlowrouteUpd_v6] != "ERROR"} {
    set sendBgpFlowrouteUpd_v6 [GGV fspecSendBgpFlowrouteUpd_v6]
  } else {
    set sendBgpFlowrouteUpd_v6 $option(sendBgpFlowrouteUpd_v6)
  }
  if {[GGV fspecActionListPerVprn] != "ERROR"} {
    set actionListPerVprn [GGV fspecActionListPerVprn]
  } else {
    set actionListPerVprn $option(actionListPerVprn)
  }
  if {[GGV fspecDumpDebugLog] != "ERROR"} {
    set dumpDebugLog [GGV fspecDumpDebugLog]
  } else {
    set dumpDebugLog $option(dumpDebugLog)
  }
  if {[GGV fspecSendTraffic_v4] != "ERROR"} {
    set sendTraffic_v4 [GGV fspecSendTraffic_v4]
  } else {
    set sendTraffic_v4 $option(sendTraffic_v4)
  }
  if {[GGV fspecSendTraffic_v6] != "ERROR"} {
    set sendTraffic_v6 [GGV fspecSendTraffic_v6]
  } else {
    set sendTraffic_v6 $option(sendTraffic_v6)
  }
  if {[GGV fspecEnableIngressFlowspec_v4] != "ERROR"} {
    set enableIngressFlowspec_v4 [GGV fspecEnableIngressFlowspec_v4]
  } else {
    set enableIngressFlowspec_v4 $option(enableIngressFlowspec_v4)
  }
  if {[GGV fspecEnableIngressFlowspec_v6] != "ERROR"} {
    set enableIngressFlowspec_v6 [GGV fspecEnableIngressFlowspec_v6]
  } else {
    set enableIngressFlowspec_v6 $option(enableIngressFlowspec_v6)
  }
  if {[GGV fspecVrfTargetDirectUnderVprn_noImportPolicy] != "ERROR"} {
    set vrfTargetDirectUnderVprn_noImportPolicy [GGV fspecVrfTargetDirectUnderVprn_noImportPolicy]
  } else {
    set vrfTargetDirectUnderVprn_noImportPolicy $option(vrfTargetDirectUnderVprn_noImportPolicy)
  }
  if {[GGV fspecItfType_dut1dut2] != "ERROR"} {
    set itfType_dut1dut2 [GGV fspecItfType_dut1dut2]
  } else {
    set itfType_dut1dut2 $option(itfType_dut1dut2)
  }
  if {[GGV fspecAddDefFilterInFirstVprnBeforeFlowroutesAreInjected] != "ERROR"} {
    set addDefFilterInFirstVprnBeforeFlowroutesAreInjected [GGV fspecAddDefFilterInFirstVprnBeforeFlowroutesAreInjected]
  } else {
    set addDefFilterInFirstVprnBeforeFlowroutesAreInjected $option(addDefFilterInFirstVprnBeforeFlowroutesAreInjected)
  }
  if {[GGV fspecAddDefFilterInLastVprnAfterFlowroutesAreInjected] != "ERROR"} {
    set addDefFilterInLastVprnAfterFlowroutesAreInjected [GGV fspecAddDefFilterInLastVprnAfterFlowroutesAreInjected]
  } else {
    set addDefFilterInLastVprnAfterFlowroutesAreInjected $option(addDefFilterInLastVprnAfterFlowroutesAreInjected)
  }
  if {[GGV fspecAddFlowroutesInBase] != "ERROR"} {
    set addFlowroutesInBase [GGV fspecAddFlowroutesInBase]
  } else {
    set addFlowroutesInBase $option(addFlowroutesInBase)
  }
  if {[GGV fspecIterationMethod] != "ERROR"} {
    set iterationMethod [GGV fspecIterationMethod]
  } else {
    set iterationMethod $option(iterationMethod)
  }
  if {[GGV fspecMaxNbrIterations] != "ERROR"} {
    set maxNbrIterations [GGV fspecMaxNbrIterations]
  } else {
    set maxNbrIterations $option(maxNbrIterations)
  }
  if {[GGV fspecMaxDurationHrs] != "ERROR"} {
    set maxDurationHrs [GGV fspecMaxDurationHrs]
  } else {
    set maxDurationHrs $option(maxDurationHrs)
  }
  if {[GGV fspecEnableFlowspecBeforeFlowroutesAreInjected] != "ERROR"} {
    set enableFlowspecBeforeFlowroutesAreInjected [GGV fspecEnableFlowspecBeforeFlowroutesAreInjected]
  } else {
    set enableFlowspecBeforeFlowroutesAreInjected $option(enableFlowspecBeforeFlowroutesAreInjected)
  }
  if {[GGV fspecRedirectVprnTunnelMethod] != "ERROR"} {
    set redirectVprnTunnelMethod [GGV fspecRedirectVprnTunnelMethod]
  } else {
    set redirectVprnTunnelMethod $option(redirectVprnTunnelMethod)
  }
  if {[GGV fspecRedirectVprnTunnelEncap] != "ERROR"} {
    set redirectVprnTunnelEncap [GGV fspecRedirectVprnTunnelEncap]
  } else {
    set redirectVprnTunnelEncap $option(redirectVprnTunnelEncap)
  }
  if {[GGV fspecGrtLookupEnableGrt] != "ERROR"} {
    set grtLookupEnableGrt [GGV fspecGrtLookupEnableGrt]
  } else {
    set grtLookupEnableGrt $option(grtLookupEnableGrt)
  }
  ##### Testcase GGV paramerters (end)

  set dut1 Dut-A ; set dut2 Dut-B ; set dut3 Dut-C ; set dut4 Dut-D ; set dut5 Dut-E ; set dut6 Dut-F
  set dutList [list $dut1 $dut2 $dut3 $dut4 $dut5 $dut6]

  # vprnIdList => thisVprnId | thisNbrFlowroutesPerVprn | thisActionListPerVprn
  # vprnIdOnlyList => has only the vprnId's
  set vprnIdList "" ; set vprnIdOnlyList ""
  for {set vprnId 1} {$vprnId <= $nbrVprns} {incr vprnId} {
    lappend vprnIdList [expr $minVprnId - 1 + $vprnId] ; lappend vprnIdOnlyList [expr $minVprnId - 1 + $vprnId]
    lappend vprnIdList $nbrFlowroutesPerVprn
    lappend vprnIdList $actionListPerVprn
  }
  # Use the next dot1q tag for the Base
  set baseDot1qTag [expr [lindex $vprnIdOnlyList end] + 1]

  set nbrStreamsFamilies 0 ; if {$sendTraffic_v4} {incr nbrStreamsFamilies} ; if {$sendTraffic_v6} {incr nbrStreamsFamilies}
  if {$addFlowroutesInBase} {
    set nbrStreamsUsed [expr [expr $nbrVprns + 1] * [llength $actionListPerVprn] * $nbrStreamsFamilies]
  } else {
    set nbrStreamsUsed [expr $nbrVprns * [llength $actionListPerVprn] * $nbrStreamsFamilies]
  }

  # Check the testcase limitations (begin)
  if {$nbrVprns > 250} {
    log_msg ERROR "Testcase couldn't handle >250 vprn's because of ip address limitation" ; set Result FAIL
  }

  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
    if {$thisNbrFlowroutesPerVprn > 221} {
      log_msg ERROR "Testcase couldn't handle >221 (223-2 ; \"-2\" because dot1q=1 is reserved on Linux & one dot1q reserved for Base) flowroutes per vprn because of ip address limitation" ; set Result FAIL ; break
    }
  }
  # Check the testcase limitations (end)

  set pktRatePerStream 2 ; set pktSize 128 ; set streamData_ISATMS "49 53 41 54 4D 53" ; set rawProtocol 253
  set trafficDurationSecsDuringPrecondition 30

  # used in redirectToVrf
  set redirectVprnId 400 ; set customerId 1 ; set nbrRedirectVprn 4
  set firstRedirectVprnId $redirectVprnId
  set maxRedirectVprnId [expr $firstRedirectVprnId + $nbrRedirectVprn - 1]
  set minRedirectVprnId $redirectVprnId
  # the vprn (to redirect) is between dut2/dut4
  set thisRT "target:42:1"

  set enableTraceDutList [list $dut2 $dut3]
  # spokeSdp case
  set spokeIesId 5000 ; set spokeSdpId 1 ; set spokeSdpVcId 1

  if {$sendBgpFlowrouteUpd_v4 && $sendBgpFlowrouteUpd_v6} {
    set thisFilterFamilyList [list ipv4 ipv6]
  } elseif {$sendBgpFlowrouteUpd_v6} {
    set thisFilterFamilyList [list ipv6]
  } else {
    set thisFilterFamilyList [list ipv4]
  }
  set groupName "onegroup"

  # 101..199 => always 101 for flowspec
  set filterLogId 101

  set rollbackLocation "ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs"

  log_msg INFO "########################################################################"
  log_msg INFO "# Test : $testID"
  log_msg INFO "# Descr : Cover RFE158878: When PBR to VRF is applied (filter or flow-spec) uRPF should be done in source routing instance"
  log_msg INFO "#         - verify interaction between uRPF and the 'redirect to router' action so that uRPF always uses the original/source"
  log_msg INFO "#           routing instance to do the source IP address lookup for uRPF and not target/destination VRF  "
  log_msg INFO "#   "
  log_msg INFO "# Setup:"
  log_msg INFO "# "
  log_msg INFO "#                              PE($dut4)----------> scrubber (Ixia)"
  log_msg INFO "#                               dut4 (dest for redirect actions)"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |       +-- Base-Base(dut2-dut3): BGP to exchange IPv4, IPv6 & flowroutes"
  log_msg INFO "#                                |       +-- PE-PE(dut2-dut3): BGP in the VPRN to exchange flowroutes"
  log_msg INFO "#                                |       +-- PE-PE(dut2-dut3): L3-VPN to exchange IPv4 & IPv6 routes"
  log_msg INFO "#                                |       |"
  log_msg INFO "#                                |       v"
  log_msg INFO "#   Ixia----------dut1----------dut2----------dut3----------dut6"
  log_msg INFO "#                CE1($dut1)    PE($dut2)     PE($dut3)     CE2($dut6)"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                             Linux (In VPRN & Base: Injects flowroutes via sbgp)"
  log_msg INFO "# "
  log_msg INFO "# Important testcase parameters:"
  log_msg INFO "#   vprnIdOnlyList: $vprnIdOnlyList"
  log_msg INFO "#   redirectType: $option(redirectType)"
  log_msg INFO "#   redirectVprn => vrpnId: $firstRedirectVprnId till $maxRedirectVprnId (#$nbrRedirectVprn) ; redirectVprnTunnelMethod: $redirectVprnTunnelMethod ; redirectVprnTunnelEncap: $redirectVprnTunnelEncap"
  log_msg INFO "#   vprnIdList: vprnId | nbrFiltersWithFwdRtrPerVprn | thisActionListPerVprn"
  foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
  set actionPrefixAString ""
  foreach thisAction $thisActionListPerVprn {
    append actionPrefixAString "$thisAction\([set a_[set thisAction]].x.x.x\) "
  }
  log_msg INFO [format "%1s %13s %6s | %20s | \"%30s\" " "#" " "  $thisVprnId $thisNbrFlowroutesPerVprn $actionPrefixAString]
  }
  if {$addFlowroutesInBase} {set fTxt "(baseDot1qTag: $baseDot1qTag)"} else {set fTxt ""}
  log_msg INFO "#   addFilterWithFwdRtrInBase: $addFlowroutesInBase $fTxt"
  log_msg INFO "#   sendTraffic_v4: $sendTraffic_v4 sendTraffic_v6: $sendTraffic_v6 (nbrStreamsFamilies: $nbrStreamsFamilies nbrStreamsUsed: $nbrStreamsUsed)"
  log_msg INFO "#   vrfTargetDirectUnderVprn_noImportPolicy: $vrfTargetDirectUnderVprn_noImportPolicy"
  log_msg INFO "#   itfType_dut1dut2: $itfType_dut1dut2"
  switch $iterationMethod {
    "maxNbrIterations" {set iMethTxt "maxNbrIterations: $maxNbrIterations"}
    "maxDuration" {set iMethTxt "maxDurationHrs: $maxDurationHrs"}
    "ifFileExists" {set iMethTxt "fileExistsName: $option(fileExistsName)"}
  }
  log_msg INFO "# "
  log_msg INFO "########################################################################"

  set dutLoggingDisabled false

  # handlePacket -action reset -portList all
  CLN.reset
  set cliTimeoutOrig [$dut2 cget -cli_timeout]
  $dut2 configure -cli_timeout $option(cliTimeout)

  if {$option(config) && ! [testFailed] && $Result == "OK"} {
    CLN.reset
    CLN "dut $dut1 systemip [set [set dut1]_ifsystem_ip] isisarea $isisAreaId as [set [set dut1]_AS]"
    CLN "dut $dut2 systemip [set [set dut2]_ifsystem_ip] isisarea $isisAreaId as [set [set dut2]_AS]"
    CLN "dut $dut3 systemip [set [set dut3]_ifsystem_ip] isisarea $isisAreaId as [set [set dut3]_AS]"
    CLN "dut $dut4 systemip [set [set dut4]_ifsystem_ip] isisarea $isisAreaId as [set [set dut4]_AS]"
    CLN "dut $dut5 systemip [set [set dut5]_ifsystem_ip] isisarea $isisAreaId as [set [set dut5]_AS]"
    CLN "dut $dut6 systemip [set [set dut6]_ifsystem_ip] isisarea $isisAreaId as [set [set dut6]_AS]"

    set a 30 ; set b [expr 20 + [lindex $vprnIdOnlyList 0]] ; set c 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn } $vprnIdList {
      CLN "dut $dut2 vprnid $thisVprnId systemip $a.$b.$c.2 as [set [set dut2]_AS]"
      CLN "dut $dut3 vprnid $thisVprnId systemip $a.$b.$c.3 as [set [set dut3]_AS]"
      incr b ; if {$b > 255} {set b 0 ; incr a}
    }

    # used for spokes dut1/dut2
    if { [GGV subTopology] == "ess6MixedMode" } {
        CLN "dut $dut1 tonode $dut2 porttype network dot1q 1 ip 1.1.1.1 ldp true mpls true"
    } else {
        CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q 1 ip 1.1.1.1 ldp true mpls true"
    }
    CLN "dut $dut2 tonode $dut1 porttype hybrid dot1q 1 ip 1.1.1.2 ldp true mpls true"

    # In the CE's, bgp routes are learned from different peers (the neighbor end point is in different vprn).
    # The learned bgp routes are installed in the Base routing-table and exported again to all neighbors (default ebgp behavior).
    # To avoid that the neigbor end points (in different vprn's) receive the exported bgp routes (CE's Base instance) a reject policy should be installed.
    CLN "dut $dut1 policy rejectBgpExport entry 1 action reject descr avoidExportFromBaseToNeighborVprns"
    CLN "dut $dut6 policy rejectBgpExport entry 1 action reject descr avoidExportFromBaseToNeighborVprns"

    # Exchange flowroutes via BGP peer in the VPRN, because SAFI=134 (exchange flowroutes via L3-VPN) is not supported
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      CLN "dut $dut3 tonode $dut2 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'flow-ipv4 flow-ipv6' "
      CLN "dut $dut2 tonode $dut3 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'flow-ipv4 flow-ipv6' "
    }

    # redistribute bgp-vpn in ospf
    CLN "dut $dut2 policy fromBgpVpnToOspf_v4 entry 1 from 'protocol bgp-vpn' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v4 entry 1 to 'protocol ospf' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v6 entry 1 from 'protocol bgp-vpn' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v6 entry 1 to 'protocol ospf3' action accept"

    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      #
      if {$itfType_dut1dut2 == "spoke"} {
        if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut1 tonode $dut2 porttype network iesid $spokeIesId iftype spoke sdpid '$spokeSdpId gre [set [set dut2]_ifsystem_ip]' dot1q $thisVprnId ip $thisVprnId.$dataip(id.$dut1).$dataip(id.$dut2).$dataip(id.$dut1) ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        } else {
            CLN "dut $dut1 tonode $dut2 porttype hybrid iesid $spokeIesId iftype spoke sdpid '$spokeSdpId gre [set [set dut2]_ifsystem_ip]' dot1q $thisVprnId ip $thisVprnId.$dataip(id.$dut1).$dataip(id.$dut2).$dataip(id.$dut1) ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        }
        CLN "dut $dut2 tonode $dut1 porttype hybrid iftype spoke sdpid '$spokeSdpId gre [set [set dut1]_ifsystem_ip]' vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId ospfexport fromBgpVpnToOspf_v4 ospf3export fromBgpVpnToOspf_v6 as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      } else {
        if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut1 tonode $dut2 porttype network dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        } else {
            CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        }
        CLN "dut $dut2 tonode $dut1 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId ospfexport fromBgpVpnToOspf_v4 ospf3export fromBgpVpnToOspf_v6 as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      }

      if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut6 tonode $dut3 porttype network dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut6]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut6]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
      } else {
          CLN "dut $dut6 tonode $dut3 porttype hybrid dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut6]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut6]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
      }
      CLN "dut $dut3 tonode $dut6 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut3]_ifsystem_ip] as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set [set dut6]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "

      CLN "dut $dut3 link Linux porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId passive true as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set Linux_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
    }

    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      CLN "dut $dut2 logid $debugLog from debug to 'memory 3000' debug {router $thisVprnId bgp update}"
      CLN "dut $dut3 logid $debugLog from debug to 'memory 3000' debug {router $thisVprnId bgp update}"
    }

    if {$addFlowroutesInBase} {
      CLN "dut $dut3 tonode $dut2 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor [set [set dut2]_ifsystem_ip]  bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6' ldp true"
      CLN "dut $dut2 tonode $dut3 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6' ldp true"
      #
      CLN "dut $dut3 tonode $dut6 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut6]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      if { [GGV subTopology] == "ess6MixedMode" } {
        CLN "dut $dut6 tonode $dut3 porttype network dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
        CLN "dut $dut1 tonode $dut2 porttype network dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      } else {
        CLN "dut $dut6 tonode $dut3 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
        CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      }
      #
      CLN "dut $dut2 tonode $dut1 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      #
      CLN "dut $dut3 link Linux porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId passive true as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set Linux_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
    }

    # Ixia connections
    set filterEntryId 1
    set filterEntryId2 123
    set filterEntryId3 2139
    set filterEntryId4 65535
    if { $option(redirectType) == "grtToVrf" } {
        set host_ip 5.1.2.0
        set loose_ip 1.2.4.0
    } else {
        set host_ip 2.1.2.0
        set loose_ip 85.1.2.0
    }
    set spoofed_ip 1.1.9.0
    foreach thisAction $actionListPerVprn {
      CLN "dut $dut1 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].0.0.0/$cntPktsViaFilter_mask_v4"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].1.2.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId2 dstip [set a_[set thisAction]].1.3.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId3 dstip [set a_[set thisAction]].1.4.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId4 dstip [set a_[set thisAction]].1.5.0/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry $filterEntryId srcip $host_ip/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip $loose_ip/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip $spoofed_ip/24"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry $filterEntryId srcip $host_ip/24"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip $loose_ip/24"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip $spoofed_ip/24"
 
      CLN "dut $dut1 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].0.0.0]/$cntPktsViaFilter_mask_v6"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].1.2.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId2 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.3.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId3 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.4.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId4 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.5.0]/120"

      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId srcip [ipv4ToIpv6 $host_ip]/120"
      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip [ipv4ToIpv6 $loose_ip]/120"
      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip [ipv4ToIpv6 $spoofed_ip]/120"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId srcip [ipv4ToIpv6 $host_ip]/120"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip [ipv4ToIpv6 $loose_ip]/120"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip [ipv4ToIpv6 $spoofed_ip]/120"

    }
    CLN "dut $dut1 tonode Ixia inegfilter $cntPktsViaFilter_filterId inegfilterv6 $cntPktsViaFilter_filterId"
    CLN "dut $dut6 tonode Ixia inegfilter $cntPktsViaFilter_filterId inegfilterv6 $cntPktsViaFilter_filterId"
    CLN "dut Ixia tonode $dut1"
    CLN "dut Ixia tonode $dut6"

    # CE2: static routes and policies to destine traffic from different vprn's to Ixia
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v4 next-hop $dataip(ip.1.Ixia.$dut6)'"
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $dataip(ip.1.Ixia.$dut6)]'"
        CLN "dut $dut6 policy fromStaticToVprns_v4 entry 1 from 'protocol static' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v4 entry 1 to 'protocol ospf' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v6 entry 1 from 'protocol static' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v6 entry 1 to 'protocol ospf3' action accept"
        CLN "dut $dut6 ospf 'export fromStaticToVprns_v4' "
        CLN "dut $dut6 ospf3 'export fromStaticToVprns_v6' "
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }

    # policies to destine traffic from different vprn's to Ixia
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        CLN "dut $dut3 prefixlist 'pfxListVprn[set thisVprnId]_v4 prefix $thisDstPrefixMask_v4 longer' "
        CLN "dut $dut3 prefixlist 'pfxListVprn[set thisVprnId]_v6 prefix $thisDstPrefixMask_v6 longer' "
        CLN "dut $dut3 policy fromStaticToVprn[set thisVprnId]_v4 defaultaction reject entry 1 from 'prefix-list pfxListVprn[set thisVprnId]_v4' action accept"
        CLN "dut $dut3 policy fromStaticToVprn[set thisVprnId]_v6 defaultaction reject entry 1 from 'prefix-list pfxListVprn[set thisVprnId]_v6' action accept"
        CLN "dut $dut3 vprnid $thisVprnId ospf 'import fromStaticToVprn[set thisVprnId]_v4' "
        CLN "dut $dut3 vprnid $thisVprnId ospf3 'import fromStaticToVprn[set thisVprnId]_v6' "
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }

    if {$addFlowroutesInBase} {
      # - Use isis in the Base instance
      # - Use mask16 to have a route in the Base for all grt-leak's (2nd lookup in Base) of all vprn's
      set c 0 ; set d 0
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask16_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask16_v6
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v4 next-hop $dataip(ip.1.Ixia.$dut6)'"
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $dataip(ip.1.Ixia.$dut6)]'"
        CLN "dut $dut6 prefixlist 'pfxListBase[set baseDot1qTag]_v4 prefix $thisDstPrefixMask_v4 exact' "
        CLN "dut $dut6 prefixlist 'pfxListBase[set baseDot1qTag]_v6 prefix $thisDstPrefixMask_v6 exact' "
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v4 entry 1 from 'prefix-list pfxListBase[set baseDot1qTag]_v4' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v4 entry 1 to 'protocol isis' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v6 entry 1 from 'prefix-list pfxListBase[set baseDot1qTag]_v6' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v6 entry 1 to 'protocol isis' action accept"
        CLN "dut $dut6 isis 'export fromStaticToBase[set baseDot1qTag]_v4 fromStaticToBase[set baseDot1qTag]_v6'"
      }
    }

    # used in redirectToVrf
    if {$redirectVprnTunnelMethod == "autobind" && $redirectVprnTunnelEncap == "gre" || \
         $redirectVprnTunnelMethod == "sdp" && $redirectVprnTunnelEncap == "rsvp"} {
      CLN "dut $dut2 tonode $dut4 mpls true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut2 mpls true isisarea $isisAreaId"
    } else {
      CLN "dut $dut2 tonode $dut4 ldp true mpls true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut2 ldp true mpls true isisarea $isisAreaId"
    }
    CLN "dut $dut2 bgpneighbor [set [set dut4]_ifsystem_ip] bgppeeras [set [set dut4]_AS] bgpfamily 'vpn-ipv4 vpn-ipv6'"
    CLN "dut $dut4 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras [set [set dut2]_AS] bgpfamily 'vpn-ipv4 vpn-ipv6'"

    CLN.exec
    CLN.reset

    set thisPePeList [list $dut2 $dut3 $dut3 $dut2]
    foreach {dut ngbDut} $thisPePeList {
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        set thisExportRT [expr ($thisVprnId * 100) + ($dataip(id.$dut) * 10) + $dataip(id.$ngbDut)]
        set thisImportRT [expr ($thisVprnId * 100) + ($dataip(id.$ngbDut) * 10) + $dataip(id.$dut)]
        docli $dut "configure router"
        docli $dut "         policy-options"
        docli $dut "            begin"
        docli $dut "            community vprn_[set thisVprnId]_exportRouteTarget members target:1982:$thisExportRT"
        docli $dut "            community vprn_[set thisVprnId]_importRouteTarget members target:1982:$thisImportRT"
        docli $dut "            policy-statement vprn_[set thisVprnId]_exportPol"
        docli $dut "                entry 1"
        docli $dut "                    from"
        docli $dut "                        protocol ospf"
        docli $dut "                    exit"
        docli $dut "                    to"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                        community add vprn_[set thisVprnId]_exportRouteTarget"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "                entry 2"
        docli $dut "                    from"
        docli $dut "                        protocol ospf3"
        docli $dut "                    exit"
        docli $dut "                    to"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                        community add vprn_[set thisVprnId]_exportRouteTarget"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "            exit"
        docli $dut "            policy-statement vprn_[set thisVprnId]_importPol"
        docli $dut "                entry 1"
        docli $dut "                    from"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                        community vprn_[set thisVprnId]_importRouteTarget"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "            exit"
        docli $dut "            commit"
        docli $dut "        exit all"
      }
    }
    foreach {dut ngbDut} $thisPePeList {
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        docli $dut "configure service vprn $thisVprnId"
        docli $dut "no vrf-target"
        docli $dut "vrf-import vprn_[set thisVprnId]_importPol"
        docli $dut "vrf-export vprn_[set thisVprnId]_exportPol"
        docli $dut "exit all"
      }
    }

    # used in redirectToVrf
    #                                        dut     thisDutId            ngbrDut  ngbrDutId       itfToNgbr
    set redirectVprnDutList [list $dut2 $dataip(id.$dut2) $dut4 $dataip(id.$dut4) $dataip(ip.1.$dut2.$dut4) \
                                              $dut4 $dataip(id.$dut4) $dut2 $dataip(id.$dut2) $dataip(ip.1.$dut4.$dut2)]
    #
    # Also needed is a path from Dut-D to Ixia2 (scrubber).
    #   - In Dut-D: add port to Dut-E in vprn
    #   - In Dut-E: epipe between port to Dut-D and port to Dut-C
    #   - In Dut-C: epipe between port to Dut-E and port to Ixia2
    #                                         dut  epipeId fromPort toPort
    set epipeListToScrubber [list $dut5 666 $portA($dut5.$dut4) $portA($dut5.$dut3) \
                                                $dut3 667 $portA($dut3.$dut5) $portA($dut3.Ixia)]
    # Redirect is done in Dut-B
    set checkIpFilterDutList [list $dut2]

    foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
      docli $dut "configure router"
      docli $dut "         policy-options"
      docli $dut "            begin"
      docli $dut "            community \"vprn1_exportRouteTarget\" members \"target:[set thisDutId][set ngbrDutId]:1\" "
      docli $dut "            community \"vprn1_importRouteTarget_[set ngbrDutId]\" members \"target:[set ngbrDutId][set thisDutId]:1\" "
      docli $dut "            policy-statement vprn_exportPol_[set thisDutId]"
      docli $dut "                entry 1"
      docli $dut "                    from"
      docli $dut "                        protocol direct"
      docli $dut "                    exit"
      docli $dut "                    to"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                        community add vprn1_exportRouteTarget"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "                entry 2"
      docli $dut "                    from"
      docli $dut "                        protocol static"
      docli $dut "                    exit"
      docli $dut "                    to"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                        community add vprn1_exportRouteTarget"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "            exit"
      docli $dut "            policy-statement vprn_importPol_[set thisDutId]_[set ngbrDutId]"
      docli $dut "                entry 1"
      docli $dut "                    from"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                        community vprn1_importRouteTarget_[set ngbrDutId]"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "            exit"
      docli $dut "            commit"
      docli $dut "        exit all"
    }
    foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
      # redirect rsvp part
      docli $dut "exit all"
      docli $dut "configure router"
      docli $dut "mpls"
      docli $dut "    path pathTo_[set ngbrDut]"
      docli $dut "        hop 1 [set [set ngbrDut]_ifsystem_ip] loose"
      docli $dut "        no shutdown"
      docli $dut "    exit"
      docli $dut "    lsp to_[set ngbrDut]"
      docli $dut "        to [set [set ngbrDut]_ifsystem_ip]"
      docli $dut "        primary pathTo_[set ngbrDut]"
      docli $dut "        exit"
      docli $dut "        no shutdown"
      docli $dut "    exit"
      docli $dut "    no shutdown"
      docli $dut "exit"
      docli $dut "exit all"
      # redirect service part
      docli $dut "configure service" -verbose $option(verbose)
      for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
        # add here the sdp's if needed
        if {$redirectVprnTunnelMethod == "sdp"} {
            switch $redirectVprnTunnelEncap {
              "gre" {
                docli $dut "" -verbose $option(verbose)
                docli $dut "sdp [set thisDutId][set ngbrDutId] gre create"
                docli $dut "    far-end [set [set ngbrDut]_ifsystem_ip]"
                docli $dut "    signaling off"
                docli $dut "    keep-alive"
                docli $dut "        shutdown"
                docli $dut "    exit"
                docli $dut "    no shutdown"
                docli $dut "exit"
              }
              "rsvp" {
                docli $dut "sdp [set thisDutId][set ngbrDutId] mpls create" -verbose $option(verbose)
                docli $dut "    far-end [set [set ngbrDut]_ifsystem_ip]"
                docli $dut "    lsp to_[set ngbrDut]"
                docli $dut "    signaling off"
                docli $dut "    keep-alive"
                docli $dut "        shutdown"
                docli $dut "    exit"
                docli $dut "    no shutdown"
                docli $dut "exit"
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | rsvp)" ; set Result FAIL ; break
              }
            }
        }
        # add here the vprn's
        set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
        docli $dut "        vprn $thisRedirectVprnId customer 1 create" -verbose $option(verbose)
        docli $dut "            no shutdown" -verbose $option(verbose)
        if {$vCnt == [expr $nbrRedirectVprn - 1] && $vrfTargetDirectUnderVprn_noImportPolicy} {
          log_msg INFO "Don't use vrf-import policy for the last vprn $thisRedirectVprnId"
          docli $dut "            vrf-target target:[set ngbrDutId][set thisDutId]:1" -verbose $option(verbose)
        } else {
          docli $dut "            vrf-import vprn_importPol_[set thisDutId]_[set ngbrDutId]" -verbose $option(verbose)
        }
        docli $dut "            vrf-export vprn_exportPol_[set thisDutId]" -verbose $option(verbose)
        docli $dut "            route-distinguisher $thisRedirectVprnId:1" -verbose $option(verbose)
        #
        switch $redirectVprnTunnelMethod {
          "autobind" {
            switch $redirectVprnTunnelEncap {
              "gre" {
                # ldp between dut2/dut4 is disabled
                docli $dut "            auto-bind gre" -verbose $option(verbose)
              }
              "ldp" {
                docli $dut "            auto-bind ldp" -verbose $option(verbose)
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | ldp)" ; set Result FAIL ; break
              }
            }
          }
          "sdp" {
            switch $redirectVprnTunnelEncap {
              "gre" {
                # ldp between dut2/dut4 is disabled ??? to be checked
                docli $dut "spoke-sdp [set thisDutId][set ngbrDutId] create" -verbose $option(verbose)
                docli $dut "no shutdown"
                docli $dut "exit"
              }
              "rsvp" {
                # ldp between dut2/dut4 is disabled
                docli $dut "spoke-sdp [set thisDutId][set ngbrDutId] create" -verbose $option(verbose)
                docli $dut "no shutdown"
                docli $dut "exit"
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | rsvp)" ; set Result FAIL ; break
              }
            }
          }
          default {
            log_msg ERROR "Invalid redirectVprnTunnelMethod: $redirectVprnTunnelMethod (should be autobind | sdp)" ; set Result FAIL ; break
          }
        }
        if {$grtLookupEnableGrt} {
          docli $dut "            grt-lookup enable-grt" -verbose $option(verbose)
          docli $dut "            exit" -verbose $option(verbose)
        }
        docli $dut "        exit"  -verbose $option(verbose)
      }
      docli $dut "exit all" -verbose $option(verbose)
    }
    if {$epipeListToScrubber != ""} {
      foreach {epipeDut epipeId epipeFromPort epipeToPort} $epipeListToScrubber {
        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
          set thisVlanId [expr $vCnt + 1] ; set thisEpipeId [expr $epipeId + $vCnt]
          flowspec_createEpipe $epipeDut $thisEpipeId $epipeFromPort $epipeToPort -fromEncapType dot1q -fromSap "$epipeFromPort:$thisVlanId" -toEncapType dot1q -toSap "$epipeToPort:$thisVlanId"
        }
      }
    }
    log_msg INFO "$dut4: Create dot1q itfs (#$nbrRedirectVprn) via $portA($dut4.$dut5) and default-route (in vprn) to scrubber (Ixia $portA(Ixia.$dut3))"
    # create itf to scrubber (Ixia2)
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) shut"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) ethernet mode access"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) no shut"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "environment no create"]
    for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
      set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
      set thisVlanId [expr $vCnt + 1]
      set rCli [$dut4 sendCliCommand "exit all"]
      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId customer 1"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "interface toScrubber_[set thisVlanId] create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "sap $portA($dut4.$dut5):$thisVlanId create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "egress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "egress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
      foreach {thisA thisB thisC thisD} [split "1.66.9.$dataip(id.$dut3)" "."] {break} ; set thisB [expr $thisB + $vCnt]
      set rCli [$dut4 sendCliCommand "address $thisA.$thisB.$thisC.$thisD/$clnItfMask_v4"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "ipv6 address [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]/$clnItfMask_v6"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
      foreach {thisA thisB thisC thisD} [split "1.66.9.9" "."] {break} ; set thisB [expr $thisB + $vCnt]
      # Add here static-routes for the redirectToVrf vprn
      set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        foreach thisAction $thisActionListPerVprn {
          if {$thisAction == "redirectVrf"} {
            set a [set a_[set thisAction]]
            set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
            set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
          }
        }
        incr c ; if {$c > 255} {set c 0 ; incr b}
      }
      if {$addFlowroutesInBase} {
        # - Don't reset b, c and d because they point to the next values to be used
        # - Use isis in the Base instance
        foreach thisAction $thisActionListPerVprn {
          if {$thisAction == "redirectVrf"} {
            set a [set a_[set thisAction]]
            set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
            set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
          }
        }
      }
      #
      set rCli [$dut4 sendCliCommand "interface toScrubber_[set thisVlanId] create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "static-arp $thisA.$thisB.$thisC.$thisD 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "ipv6 neighbor [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD] 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
    }

    if {$enableFilterTrace} {
      foreach dut $enableTraceDutList {
        docli $dut "debug trace trace-point module \"FILTER\" " -verbose $option(verbose)
        docli $dut "debug trace enable" -verbose $option(verbose)
        docli $dut "shell traceLimitDisable" -verbose $option(verbose)
      }
    }
    if {$enableBgpFlowspecTrace} {
      foreach dut $enableTraceDutList {
        docli $dut "debug trace trace-point module \"BGP\" " -verbose $option(verbose)
        docli $dut "debug trace trace-point module \"BGP_VPRN\" " -verbose $option(verbose)
        docli $dut "debug trace enable" -verbose $option(verbose)
        docli $dut "shell traceLimitDisable" -verbose $option(verbose)
        # enableBgpFlowspecTrace $dut
        # foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        #  enableBgpFlowspecTrace $dut2 -vprnId $thisVprnId
        # }
      }
    }

    foreach dut $dutList {
      $dut sendCliCommand "exit all"
    }

  } ; # config

    # Ixia part
    handlePacket -port $portA(Ixia.$dut1) -action stop
    set thisDA 00:00:00:00:00:[int2Hex1 $dataip(id.$dut1)]
    set totalNbrOfFlowroutes 0
    if { $option(redirectType) == "vrfToVrf" } {
        set thisDstPrefix_v4 85.1.2.1
        set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
    } elseif { $option(redirectType) == "grtToVrf" } {
        set thisDstPrefix_v4 85.1.5.1
        set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
    } elseif { $option(redirectType) == "vrfToGrt" } {
        set thisDstPrefix_v4 85.1.2.1
        set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
    }
    set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
    set thisHandlePacketAction create

## 2.1.2.50 - host IP
## 85.1.2.50 - loose IP
## 1.1.9.9 - foreign IP (spoofed)

    if {$sendTraffic_v4} {
        if { $option(redirectType) == "vrfToVrf" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 85.1.2.50 -numSource 1 -damac $thisDA -stream 2 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 85.1.2.50 -numSource 1 -damac $thisDA -stream 2 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.1.9.9 -numSource 1 -damac $thisDA -stream 3 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.1.9.9 -numSource 1 -damac $thisDA -stream 3 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction    
        } elseif { $option(redirectType) == "grtToVrf" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.2.4.50 -numSource 1 -damac $thisDA -stream 2 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.2.4.50 -numSource 1 -damac $thisDA -stream 2 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.1.9.9 -numSource 1 -damac $thisDA -stream 3 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.1.9.9 -numSource 1 -damac $thisDA -stream 3 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction
        } elseif { $option(redirectType) == "vrfToGrt" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 85.1.2.50 -numSource 1 -damac $thisDA -stream 2 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 85.1.2.50 -numSource 1 -damac $thisDA -stream 2 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.1.9.9 -numSource 1 -damac $thisDA -stream 3 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v4 -numDest 1 -src 1.1.9.9 -numSource 1 -damac $thisDA -stream 3 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction
        }
    }

    if {$sendTraffic_v6} {
        if { $option(redirectType) == "vrfToVrf" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 4 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 4 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  85.1.2.50] -numSource 1 -damac $thisDA -stream 5 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  85.1.2.50] -numSource 1 -damac $thisDA -stream 5 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.1.9.9] -numSource 1 -damac $thisDA -stream 6 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.1.9.9] -numSource 1 -damac $thisDA -stream 6 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        } elseif { $option(redirectType) == "grtToVrf" } {
         log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 4 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 4 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.2.4.50] -numSource 1 -damac $thisDA -stream 5 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.2.4.50] -numSource 1 -damac $thisDA -stream 5 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.1.9.9] -numSource 1 -damac $thisDA -stream 6 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.1.9.9] -numSource 1 -damac $thisDA -stream 6 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        } elseif { $option(redirectType) == "vrfToGrt" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 4 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 4 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  85.1.2.50] -numSource 1 -damac $thisDA -stream 5 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  85.1.2.50] -numSource 1 -damac $thisDA -stream 5 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction

          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.1.9.9] -numSource 1 -damac $thisDA -stream 6 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  1.1.9.9] -numSource 1 -damac $thisDA -stream 6 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        }
    }

    # scrubber
    handlePacket -port $portA(Ixia.$dut3) -action capture

    log_msg INFO "Wait till all vprn's are operational before installed action forward router"
    set nbrRedirectVprnOperStateUp 0
    foreach {dut} $checkIpFilterDutList {break}
    for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
      for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
        set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
        set rCli [$dut sendCliCommand "show service id $thisRedirectVprnId base | match \"Oper State\" "]
        # Admin State       : Up                  Oper State        : Up
        if {[regexp {.*Oper State[ ]+:[ ]+([A-Za-z]+).*} $rCli match vprnOperState]} {
          if {$vprnOperState == "Up"} {
            incr nbrRedirectVprnOperStateUp
          }
        }
      }
      if {$nbrRedirectVprnOperStateUp == $nbrRedirectVprn} {
        log_msg INFO "All redirectVprn are Up ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn)"
        log_msg INFO "" ; log_msg INFO "Display some interesting info for the redirect vprn's" ; log_msg INFO ""
        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
          set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
          set rCli [$dut sendCliCommand "show service id $thisRedirectVprnId all"] ; log_msg INFO "$rCli"
        }
        set rCli [$dut sendCliCommand "show router tunnel-table"] ; log_msg INFO "$rCli"
        if {$redirectVprnTunnelEncap == "rsvp"} {
          set rCli [$dut sendCliCommand "show router mpls lsp"] ; log_msg INFO "$rCli"
        }
        if {$redirectVprnTunnelMethod == "sdp"} {
          set rCli [$dut sendCliCommand "show service sdp detail"] ; log_msg INFO "$rCli"
        }
        break
      } else {
        if {$rCnt == $option(maxRetryCnt)} {
          log_msg ERROR "Not all redirectVprn ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn) are Up after $option(maxRetryCnt) retries" ; set Result FAIL
        } else {
          log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) till all redirectVprn ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn) are Up ..." ; after [expr $option(interRetryTimeSec) * 100]
        }
      }
    }
    if {! [testFailed] && $Result == "OK"} {
      set mySubtest "Precondition: Waiting 5 secs and check that traffic flows from $dut1 to $dut6" ; after 5000
      log_msg INFO "$mySubtest"
      if {[checkTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
        log_msg INFO "Traffic from $dut1 to $dut6 ok"
      } else {
        log_msg ERROR "Traffic from $dut1 to $dut6 nok" ; set Result FAIL
      }
      subtest "$mySubtest"
    }

    # apply filters on $dut2
    cliCne $dut2 "/environment no create"
    foreach filterIpType "ip ipv6" {
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId2 action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId3 action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId4 action forward"]; log_msg INFO $rCli
    }

    log_msg INFO "$dut2: Apply ingress filter (ip/ipv6) $cntPktsViaFilter_filterId (on itf $dut1 => $dut2)"
    set vprnCnt 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        if {$itfType_dut1dut2 == "spoke"} {
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        } else {
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        }
    }

    if {! [testFailed] && $Result == "OK"} {
      if {$enableFlowspecBeforeFlowroutesAreInjected} {
        # skip traffic check
      } else {
        set mySubtest "Check that traffic still flows from $dut1 to $dut6, because ingress action forward router is not yet applied"
        log_msg INFO "$mySubtest"
        if {[checkTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
          log_msg INFO "Traffic from $dut1 to $dut6 ok"
        } else {
          log_msg ERROR "Traffic from $dut1 to $dut6 nok" ; set Result FAIL
        }
        subtest "$mySubtest"
      }
    }
    if {! [testFailed] && $Result == "OK"} {
      if {$addDefFilterInLastVprnAfterFlowroutesAreInjected} {
        log_msg INFO "$dut2: Apply ingress filter (ip/ipv6) $cntPktsViaFilter_filterId (on itf $dut1 => $dut2)"
        set vprnCnt 1
        foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
          if {$vprnCnt == $nbrVprns} {
            if {$itfType_dut1dut2 == "spoke"} {
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
            } else {
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
            }
          }
          incr vprnCnt
        }
      }
    }
    # configure filter $cntPktsViaFilter_filterId in Base router
    if {$addFlowroutesInBase} {
        set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
    }

    # configure service name for target VPRN
    log_msg INFO "Configure service name for target VPRN: $firstRedirectVprnId"
    set rCli [$dut2 sendCliCommand "/configure service vprn $firstRedirectVprnId service-name \"Target VPRN 400\""]; log_msg INFO $rCli

    # Configure action forward router for filters on $dut2
    foreach filterIpType "ip ipv6" {
        if { $option(redirectType) == "vrfToGrt" } {
            set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward router Base"]; log_msg INFO $rCli
        } else {
            set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward router $firstRedirectVprnId"]; log_msg INFO $rCli
        }
        set rCli [$dut2 sendCliCommand "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId2 action forward router service-name \"Target VPRN 400\""]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId3 action forward router $firstRedirectVprnId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId4 action forward router service-name \"Target VPRN 400\""]; log_msg INFO $rCli
    }

    set rCli [$dut2 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"

# interpreter

    if { $option(ecmpEnabled) == "true"} {
        # configure additional interface under VPRN 2 on $dut2 and $dut3 (in order to have multiple paths for loose IP)
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure service vprn 2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            interface to_Dut-C create"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                address 2.9.9.2/24"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                mac 00:00:00:00:09:02"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                ipv6"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    address 3FFE::209:902/120"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                sap $topoMap(Dut-B,1/1/3):9 create"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            bgp"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                group onegroup"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                  neighbor 2.9.9.3"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    family flow-ipv4 flow-ipv6"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    peer-as 103"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                  exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "exit"]; log_msg INFO $rCli

        set rCli [$dut3 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "configure service vprn 2"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "            interface to_Dut-B create"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                address 2.9.9.3/24"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                mac 00:00:00:00:09:03"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                ipv6"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                    address 3FFE::209:903/120"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                sap $topoMap(Dut-C,1/1/2):9 create"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "            bgp"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                group onegroup"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                  neighbor 2.9.9.2"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                    family flow-ipv4 flow-ipv6"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                    peer-as 102"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                  exit"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut3 sendCliCommand "exit"]; log_msg INFO $rCli

        log_msg INFO "ECMP is enabled - add static routes for host and loose IPs in order to verify uRPF with multiple paths"
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router static-route 5.1.2.50/32 next-hop 5.1.2.1"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router static-route 5.1.2.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
                # loose IP
                set rCli [$dut2 sendCliCommand "/configure router static-route 1.2.4.50/32 next-hop 1.2.4.1"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router static-route 1.2.4.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::501:232/128 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::501:232/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
                # loose IP
                set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::102:432/128 next-hop 3FFE::102:401"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::102:432/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.1.2.1"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.2.3.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
                # loose IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 85.1.2.50/32 next-hop 2.9.9.1"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 85.1.2.50/32 next-hop 2.2.3.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::202:301"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
                # loose IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::5501:232/128 next-hop 3FFE::209:901"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::5501:232/128 next-hop 3FFE::202:301"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify routes in FIB"
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
        }
    }


    # verify traffic with uRPF check disabled
    log_msg INFO "--------------------------------------"
    log_msg INFO "Verify traffic with uRPF check disabled"
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Expected behavior:"
    if { $option(redirectType) == "grtToVrf" } {
        log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
        log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
    } else {
        log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
        log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
    }
    log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
    log_msg INFO " "
    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    log_msg INFO "Display route tables on $dut2"
    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "show router route-table"] ; log_msg INFO "$rCli"
    } else {
        set rCli [$dut2 sendCliCommand "show router $minVprnId route-table"] ; log_msg INFO "$rCli"
    }

    log_msg INFO "Start traffic streams"
    log_msg INFO "Traffic started, waiting 20secs and check that all traffic is redirected"
    if { $option(redirectType) == "vrfToGrt" } {
        if {[checkTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
          log_msg INFO "Traffic goes like expected: all traffic streams from host, loose and spoofed IPs are correctly forwarded"
        } else {
          log_msg ERROR "Traffic doesn't goes like expected: all traffic streams from host, loose and spoofed IPs are incorrectly forwarded" ; set Result FAIL
        }
    } else {
        if {[checkTrafficFlows $dut1 $dut4 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
          log_msg INFO "Traffic goes like expected: all traffic streams from host, loose and spoofed IPs are correctly forwarded"
        } else {
          log_msg ERROR "Traffic doesn't goes like expected: all traffic streams from host, loose and spoofed IPs are incorrectly forwarded" ; set Result FAIL
        }
    }

    set rCli [$dut2 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut6 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut6 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"


    # check uRPF check counters
    log_msg INFO "Check uRPF Fail counters -> expected uRPF Chk: Disabled"
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        if { [regexp {uRPF Chk \s+: (disabled)} $rCli match state] } {
            log_msg INFO "uRPF Chk: Disabled - OK"
        } else {
            log_msg ERROR "State of uRPF Chk failed"; set Result FAIL
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
            if { [regexp {uRPF Ipv6 Chk \s+: (disabled)} $rCli match state] } {
                log_msg INFO "uRPF Ipv6 Chk: Disabled - OK"
            } else {
                log_msg ERROR "State of uRPF Ipv6 Chk failed"; set Result FAIL
            }
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
            if { [regexp {uRPF Ipv6 Chk: (disabled)} $rCli match state] } {
                log_msg INFO "uRPF Ipv6 Chk: Disabled - OK"
            } else {
                log_msg ERROR "State of uRPF Ipv6 Chk failed"; set Result FAIL
            }
        }
    }


    # verify traffic with uRPF check mode loose
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Verify traffic with uRPF check mode loose"
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Expected behavior:"
    if { $option(redirectType) == "grtToVrf" } {
        log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
        log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
    } else {
        log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
        log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
    }
    log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
    log_msg INFO " "
    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    ### enable statistics on interface
    log_msg INFO "Enable ingress stats on interface"
    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 enable-ingress-stats"] ; log_msg INFO "$rCli"
    } else {
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 enable-ingress-stats"] ; log_msg INFO "$rCli"
    }


    # enable urpf-check mode loose
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check mode loose"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check mode loose"] ; log_msg INFO "$rCli"
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check mode loose"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check mode loose"] ; log_msg INFO "$rCli"
        }
    }

    log_msg INFO "Start traffic streams"
    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
    log_msg INFO "Traffic started, check that all traffic is redirected except spoofed" 
    # check uRPF check counters
    log_msg INFO "Check uRPF Fail counters"

    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
    } else {
        set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
    }
    after 60000
    if { $option(redirectType) == "grtToVrf" } {
        set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
    } else {
        set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
    }
    
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
            regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
        } else {
            regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
            regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
        }
        if { $cnt1 < $cnt2 } {
            log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
        } else {
            log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
        }

    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
            regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
        } else {
            regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
            regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
        }
        if { $cnt1_v6 < $cnt2_v6 } {
            log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
        } else {
            log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
        }

    }

    
    handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true            
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        }
    }

    ### check ignore-default option under all modes
    ### When urpf-check ignore-default is not enabled, the packets are matching the default-route and pass - old and 12.0R6 default behaviour
    ### When urpf-check ignore-default is enabled, the packets are dropped by urpf-check because the default-route is not considered any more
    ### DTS176550
    set buildVersion [lindex [split [lindex [split [cookCliData [$dut2 sendCliCommand "show version"]] .] 0] "-"] 2 ]

    set buildVersion1 [$dut2 sendCliCommand "show version"]
    if {[regexp {12\.0\.S} $buildVersion1]} {
       log_msg INFO " Build 12_0_current "
       set buildVersion "12_0_S"
    } else {
       if {[regexp {12\.0\.B} $buildVersion1]} {
       log_msg INFO " Build 12_0_B version "
       set buildVersion "12_0_B"
       }
    }

    set buildVers [lindex [split [lindex [$dut2 sendCliCommand "show version"] 2 ]]]
    # e.g. TiMOS-C-12.0.B1-133
    set buildVersNbr [split "$buildVers" .- ]
    # e.g. TiMOS C 12 0 B1 133
    set buildVersNbrRel [lindex  $buildVersNbr 2]
    # Release version, e.g. 12
    set buildVersNbrRef [lindex  $buildVersNbr 5]
    # Release build, e.g. 133

    if { ($buildVersNbrRef >= "133") && ($buildVersNbrRel == "12") } {
        log_msg INFO " Build 12_0_R5, as from 12_0_B1-133 onwards "
        set buildVersion "12_0_R5"
    }
    log_msg INFO " Build Version = $buildVersion"

    if {(($buildVersion == 0) || ($buildVersion == "12_0_R5") || ($buildVersion >="13") || ($buildVersion =="12_0_S"))} {
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Verify traffic with uRPF check mode loose and ignore-default set to false"
        log_msg INFO " - default routes configured"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        log_msg INFO "Add default routes in order to verify that uRPF is not working in case of ignore-default is set to false"
        log_msg INFO "Traffic with a source address that matches only the default route is considered NOT to fail the uRPF check and is NOT discarded"
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # default route
                set rCli [$dut2 sendCliCommand "/configure router static-route 0.0.0.0/0 next-hop 5.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router static-route ::/0 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 0.0.0.0/0 next-hop 2.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route ::/0 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }

        after 60000

        log_msg INFO "Start traffic streams"
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
        log_msg INFO "Traffic started, check that all traffic is redirected included spoofed - default route is matched"
        # check uRPF check counters
        log_msg INFO "Check uRPF Fail counters"

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        after 60000
        if { $option(redirectType) == "grtToVrf" } {
            set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
        } else {
            set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
        }

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
            } else {
                regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
            }
            if { $cnt1 == $cnt2 } {
                log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
            } else {
                log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
            }

        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
            } else {
                regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
            }
            if { $cnt1_v6 == $cnt2_v6 } {
                log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
            } else {
                log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
            }

        }


        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
        }

        # enable ignore-default
        log_msg INFO "Enable ignore-default"
        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            }
        }

        log_msg INFO "With ignore-default enabled, traffic with a source address that matches only the default route is considered to fail the uRPF check and is discarded"

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        log_msg INFO "Start traffic streams"
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
        log_msg INFO "Traffic started, check that all traffic is redirected except spoofed - default route is ignored"
        # check uRPF check counters
        log_msg INFO "Check uRPF Fail counters"

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        after 60000
        if { $option(redirectType) == "grtToVrf" } {
            set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
        } else {
            set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
        }

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
            } else {
                regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
            }
            if { $cnt1 < $cnt2 } {
                log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
            } else {
                log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
            }

        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
            } else {
                regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
            }
            if { $cnt1_v6 < $cnt2_v6 } {
                log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
            } else {
                log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
            }

        }


        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }
        log_msg INFO "Disable ignore-default and remove default routes"
        log_msg INFO "Disable ignore-default"
        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # default route
                set rCli [$dut2 sendCliCommand "/configure router no static-route 0.0.0.0/0 next-hop 5.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 0 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router no static-route ::/0 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn base -errorIfNotFound 0 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 0.0.0.0/0 next-hop 2.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn 2 -errorIfNotFound 0 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route ::/0 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn 2 -errorIfNotFound 0 -tryTime 60
            }
        }
    }

# interpreter

    # perform rollback
      log_msg INFO "Create rollback checkpoint, remove configuration and restore via rollback revert"
      set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback save"] ; log_msg INFO "$rCli"
      #
      after 1000
      saveOrRestore delete -dut $dut2
      after 1000
      # configure rollback-location again because it was removed during saveOrRestore delete
      set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback revert latest-rb now"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"
      log_msg INFO "Waiting 20secs ...." ; after 20000

    # wait until route 85.1.2.0/24 and 3FFE::5501:200/120 will be distributed to $dut1
    log_msg INFO "Wait for route distribution to $dut1 from VPRN 2 on $dut2"
    set whileContinue 1
    set try 1
    while { $whileContinue } {
        set rCli [$dut1 sendCliCommand "show router fib 1"] ; log_msg INFO "$rCli"
        set rCli2 [$dut1 sendCliCommand "show router fib 1 ipv6"] ; log_msg INFO "$rCli2"
        if { [regexp 85.1.2.0/24 $rCli] } {
            log_msg INFO "IPv4 Route is present in route-table of $dut1"
                if { [regexp (3FFE|3ffe)::5501:200/120 $rCli2] } {
                    log_msg INFO "IPv6 Route is present in route-table of $dut1"
                    set whileContinue 0
                } else { 
                    incr try
                    if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv6 Route (3FFE::5501:200/120) is not present in route-table of $dut1"; set whileContinue 0 } 
                }
        } else {
            incr try
            if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv4 Route (85.1.2.0/24) is not present in route-table of $dut1"; set whileContinue 0 }
        }
    }

    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList
    
    # verify traffic
    handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

    handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        }
    }

    set rCli [$dut4 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut6 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut6 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"


    if { $option(redirectType) != "grtToVrf" } {
        # shutdown/no shutdown VPRN 2
        log_msg INFO "Perform shutdown/no shutdown of VPRN 2 and verify the traffic"
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 shutdown"] ; log_msg INFO "$rCli"
        after 2000
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 no shutdown"] ; log_msg INFO "$rCli"
        after 2000

        # wait until route 85.1.2.0/24 and 3FFE::5501:200/120 will be distributed to $dut1
        log_msg INFO "Wait for route distribution to $dut1 from VPRN 2 on $dut2"
        set whileContinue 1
        set try 1
        while { $whileContinue } {
            set rCli [$dut1 sendCliCommand "show router fib 1"] ; log_msg INFO "$rCli"
            set rCli2 [$dut1 sendCliCommand "show router fib 1 ipv6"] ; log_msg INFO "$rCli2"
            if { [regexp 85.1.2.0/24 $rCli] } {
                log_msg INFO "IPv4 Route is present in route-table of $dut1"
                    if { [regexp (3FFE|3ffe)::5501:200/120 $rCli2] } {
                        log_msg INFO "IPv6 Route is present in route-table of $dut1"
                        set whileContinue 0
                    } else {
                        incr try
                        if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv6 Route (3FFE::5501:200/120) is not present in route-table of $dut1"; set whileContinue 0 }
                    }
            } else {
                incr try
                if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv4 Route (85.1.2.0/24) is not present in route-table of $dut1"; set whileContinue 0 }
            }
        }

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }
    }


    # verify traffic with uRPF check mode strict
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Verify traffic with uRPF check mode strict"
    log_msg INFO "--------------------------------------"
    log_msg INFO " "

    if { $option(ecmpEnabled) == "true"} {
        log_msg INFO "Expected behavior when ECMP is enabled:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "
    } else {
        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "
    }
    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    # enable urpf-check mode strict
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check mode strict"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check mode strict"] ; log_msg INFO "$rCli"
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check mode strict"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check mode strict"] ; log_msg INFO "$rCli"
        }
    }
    log_msg INFO "Start traffic streams"
    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
    if { $option(ecmpEnabled) == "true"} {
        log_msg INFO "Traffic started, check that only spoofed traffic is dropped"
    } else {
        log_msg INFO "Traffic started, check that only host traffic is redirected"
    }
    # check uRPF check counters
    log_msg INFO "Check uRPF Fail counters"

    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
    } else {
        set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
    }
    after 60000
    if { $option(redirectType) == "grtToVrf" } {
        set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
    } else {
        set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
    }

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
            regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
        } else {
            regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
            regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
        }
        if { $cnt1 < $cnt2 } {
            log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
        } else {
            log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
        }

    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
            regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
        } else {
            regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
            regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
        }
        if { $cnt1_v6 < $cnt2_v6 } {
            log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
        } else {
            log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
        }

    }

    handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        }
    }

    if {(($buildVersion == 0) || ($buildVersion == "12_0_R5") || ($buildVersion >="13") || ($buildVersion =="12_0_S"))} {
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Verify traffic with uRPF check mode strict and ignore-default set to false"
        log_msg INFO " - default routes configured"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Expected behavior:"
        if { $option(ecmpEnabled) == "true"} {
            log_msg INFO "Expected behavior when ECMP is enabled:"
            if { $option(redirectType) == "grtToVrf" } {
                log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
                log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
            } else {
                log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
                log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
            }
            log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
            log_msg INFO " "
        } else {
            log_msg INFO "Expected behavior:"
            if { $option(redirectType) == "grtToVrf" } {
                log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
                log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
            } else {
                log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
                log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
            }
            log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
            log_msg INFO " "
        }

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        log_msg INFO "Add default routes in order to verify that uRPF is not working in case of ignore-default is set to false"
        log_msg INFO "Traffic with a source address that matches only the default route is considered NOT to fail the uRPF check and is NOT discarded"
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # default route
                set rCli [$dut2 sendCliCommand "/configure router static-route 0.0.0.0/0 next-hop 5.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router static-route ::/0 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 0.0.0.0/0 next-hop 2.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route ::/0 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }
        log_msg INFO "Start traffic streams"
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
        if { $option(ecmpEnabled) == "true"} {
            log_msg INFO "Traffic started, check that all traffic is redirected"
        } else {
            log_msg INFO "Traffic started, check that all traffic is redirected except loose"
        }
        # check uRPF check counters
        after 60000
        log_msg INFO "Check uRPF Fail counters"

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        after 60000
        if { $option(redirectType) == "grtToVrf" } {
            set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
        } else {
            set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
        }

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
            } else {
                regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
            }
            if { $option(ecmpEnabled) == "true"} {
                if { $cnt1 == $cnt2 } {
                    log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
                } else {
                    log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
                }
            } else {
                if { $cnt1 < $cnt2 } {
                    log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
                } else {
                    log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
                }
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
            } else {
                regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
            }
            if { $option(ecmpEnabled) == "true"} {
                if { $cnt1_v6 == $cnt2_v6 } {
                    log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
                } else {
                    log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
                }
            } else {
                if { $cnt1_v6 < $cnt2_v6 } {
                    log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
                } else {
                    log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
                }
            }
        }


        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
        }

        # enable ignore-default
        log_msg INFO "Enable ignore-default"
        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            }
        }

        log_msg INFO "With ignore-default enabled, traffic with a source address that matches only the default route is considered to fail the uRPF check and is discarded"

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        log_msg INFO "Start traffic streams"
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
        if { $option(ecmpEnabled) == "true"} {
            log_msg INFO "Traffic started, check that all traffic is redirected except spoofed"
        } else {
            log_msg INFO "Traffic started, check that only host traffic is redirected"
        }
        # check uRPF check counters
        log_msg INFO "Check uRPF Fail counters"

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        after 60000
        if { $option(redirectType) == "grtToVrf" } {
            set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
        } else {
            set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
        }

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
            } else {
                regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
            }
            if { $cnt1 < $cnt2 } {
                log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
            } else {
                log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
            }

        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
            } else {
                regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
            }
            if { $cnt1_v6 < $cnt2_v6 } {
                log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
            } else {
                log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
            }

        }


        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        log_msg INFO "Disable ignore-default and remove default routes"
        log_msg INFO "Disable ignore-default"
        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # default route
                set rCli [$dut2 sendCliCommand "/configure router no static-route 0.0.0.0/0 next-hop 5.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 0 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router no static-route ::/0 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn base -errorIfNotFound 0 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 0.0.0.0/0 next-hop 2.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 0 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route ::/0 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn 2 -errorIfNotFound 0 -tryTime 60
            }
        }
    }


    # perform rollback
      log_msg INFO "Create rollback checkpoint, remove configuration and restore via rollback revert"
      set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback save"] ; log_msg INFO "$rCli"
      #
      after 1000
      saveOrRestore delete -dut $dut2
      after 1000
      # configure rollback-location again because it was removed during saveOrRestore delete
      set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback revert latest-rb now"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"
      log_msg INFO "Waiting 20secs ...." ; after 20000

    # wait until route 85.1.2.0/24 and 3FFE::5501:200/120 will be distributed to $dut1
    log_msg INFO "Wait for route distribution to $dut1 from VPRN 2 on $dut2"
    set whileContinue 1
    set try 1
    while { $whileContinue } {
        set rCli [$dut1 sendCliCommand "show router fib 1"] ; log_msg INFO "$rCli"
        set rCli2 [$dut1 sendCliCommand "show router fib 1 ipv6"] ; log_msg INFO "$rCli2"
        if { [regexp 85.1.2.0/24 $rCli] } {
            log_msg INFO "IPv4 Route is present in route-table of $dut1"
                if { [regexp (3FFE|3ffe)::5501:200/120 $rCli2] } {
                    log_msg INFO "IPv6 Route is present in route-table of $dut1"
                    set whileContinue 0
                } else {
                    incr try
                    if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv6 Route (3FFE::5501:200/120) is not present in route-table of $dut1"; set whileContinue 0 }
                }
        } else {
            incr try
            if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv4 Route (85.1.2.0/24) is not present in route-table of $dut1"; set whileContinue 0 }
        }
    }

    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    # verify traffic
    handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

    handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        }
    }

    # double SWO
    if { $option(verifySwo) } {
        set actionTodo doubleSwo
        if {$actionTodo == "swo"} {set  nbrSwoToDo 1} else {set nbrSwoToDo 2}
        for {set swoNbr 1} {$swoNbr <= $nbrSwoToDo} {incr swoNbr} {
          set activitySwitchMethod [lindex $fspecSwoMethodList [random $fspecSwoMethodListLen]]
          log_msg INFO "$dut2: Switchover $swoNbr/$nbrSwoToDo activitySwitchMethod: $activitySwitchMethod"
          if {[$dut2 activitySwitch -inSyncTime1 11 -skipCheck true -inSyncTime3 2000 -Method $activitySwitchMethod] == "OK"} {
            # nop
          } else {
            log_msg ERROR "$dut2: Switchover failed" ; set Result FAIL ; break
          }
          after 1000 ; $dut2 closeExpectSession ; after 1000 ; $dut2 openExpectSession ; after 1000
          log_msg INFO "$dut2: Wait until standby is synchronized"
          if {[$dut2 CnWSecInSync] == "OK"} {
            log_msg INFO "$dut2: Standby is in sync now - a new switchover is allowed"
            after 5000
            $dut2 closeExpectSession ; after 1000 ; $dut2 openExpectSession ; after 1000
          } else {
            log_msg ERROR "$dut2: Standby not yet in sync" ; set Result FAIL ; break
          }
        }
   
        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }
    }

    if { $option(redirectType) != "grtToVrf" } {
        # shutdown/no shutdown VPRN 2
        log_msg INFO "Perform shutdown/no shutdown of VPRN 2 and verify the traffic"
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 shutdown"] ; log_msg INFO "$rCli"
        after 2000
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 no shutdown"] ; log_msg INFO "$rCli"
        after 2000

        # wait until route 85.1.2.0/24 and 3FFE::5501:200/120 will be distributed to $dut1
        log_msg INFO "Wait for route distribution to $dut1 from VPRN 2 on $dut2"
        set whileContinue 1
        set try 1
        while { $whileContinue } {
            set rCli [$dut1 sendCliCommand "show router fib 1"] ; log_msg INFO "$rCli"
            set rCli2 [$dut1 sendCliCommand "show router fib 1 ipv6"] ; log_msg INFO "$rCli2"
            if { [regexp 85.1.2.0/24 $rCli] } {
                log_msg INFO "IPv4 Route is present in route-table of $dut1"
                    if { [regexp (3FFE|3ffe)::5501:200/120 $rCli2] } {
                      log_msg INFO "IPv6 Route is present in route-table of $dut1"
                      set whileContinue 0
                    } else {
                        incr try
                        if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv6 Route (3FFE::5501:200/120) is not present in route-table of $dut1"; set whileContinue 0 }
                    }
            } else {
                incr try
                if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv4 Route (85.1.2.0/24) is not present in route-table of $dut1"; set whileContinue 0 }
            }
        }

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }
    }

    if { $option(ecmpEnabled) == "true"} {
        # disable ECMP
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Disable ECMP and verify the traffic"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router no ecmp"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 no ecmp"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }
        after 5000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        # enable ECMP
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Enable ECMP again and verify the traffic"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router ecmp 16"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 ecmp 16"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
        }
        after 2000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        # disable one interface for loose IP (2 routes remain for host IPs only)
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Disable one interface for loose IP (2 routes will remain for host IPs only)"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                set rCli [$dut2 sendCliCommand "/configure router no static-route 1.2.4.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                set rCli [$dut2 sendCliCommand "/configure router no static-route 3FFE::102:432/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-C shutdown"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }
        after 2000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Enable interface back for loose IP, disable one interface for host IP (2 routes will remain for loose IPs only)"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                set rCli [$dut2 sendCliCommand "/configure router static-route 1.2.4.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router no static-route 5.1.2.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::102:432/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router no static-route 3FFE::501:232/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-C no shutdown"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 2.1.2.50/32 next-hop 2.2.3.1"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 3FFE::201:232/128 next-hop 3FFE::202:301"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
        }
        after 2000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router static-route 5.1.2.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::501:232/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.2.3.1"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::202:301"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
        }
    }


    # verify traffic with uRPF check mode strict-no-ecmp
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Verify traffic with uRPF check mode strict-no-ecmp"
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    if { $option(ecmpEnabled) == "true"} {
        log_msg INFO "Expected behavior when ECMP is enabled:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> dropped"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> dropped"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "
    } else {
        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "
    }

    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    # enable urpf-check mode strict-no-ecmp
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check mode strict-no-ecmp"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check mode strict-no-ecmp"] ; log_msg INFO "$rCli"
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check mode strict-no-ecmp"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check mode strict-no-ecmp"] ; log_msg INFO "$rCli"
        }
    }
    log_msg INFO "Start traffic streams"
    handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
    if { $option(ecmpEnabled) == "true"} {
        log_msg INFO "Traffic started, check that all traffic is dropped"
    } else {
        log_msg INFO "Traffic started, check that only host traffic is redirected"
    }
    # check uRPF check counters
    log_msg INFO "Check uRPF Fail counters"

    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
    } else {
        set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
    }
    after 60000
    if { $option(redirectType) == "grtToVrf" } {
        set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
    } else {
        set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
    }

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
            regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
        } else {
            regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
            regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
        }
        if { $cnt1 < $cnt2 } {
            log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
        } else {
            log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
        }

    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
            regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
        } else {
            regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
            regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
        }
        if { $cnt1_v6 < $cnt2_v6 } {
            log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
        } else {
            log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
        }

    }

    handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        } else {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        } else {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        }
    }

    if {(($buildVersion == 0) || ($buildVersion == "12_0_R5") || ($buildVersion >="13") || ($buildVersion =="12_0_S"))} {
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Verify traffic with uRPF check mode strict-no-ecmp and ignore-default set to false"
        log_msg INFO " - default routes configured"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Expected behavior:"
        if { $option(ecmpEnabled) == "true"} {
            log_msg INFO "Expected behavior when ECMP is enabled:"
            if { $option(redirectType) == "grtToVrf" } {
                log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> dropped"
                log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
            } else {
                log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> dropped"
                log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
            }
            log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
            log_msg INFO " "
        } else {
            log_msg INFO "Expected behavior:"
            if { $option(redirectType) == "grtToVrf" } {
                log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
                log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
            } else {
                log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
                log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
            }
            log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
            log_msg INFO " "
        }

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        log_msg INFO "Add default routes in order to verify that uRPF is not working in case of ignore-default is set to false"
        log_msg INFO "Traffic with a source address that matches only the default route is considered NOT to fail the uRPF check and is NOT discarded"
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # default route
                set rCli [$dut2 sendCliCommand "/configure router static-route 0.0.0.0/0 next-hop 5.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router static-route ::/0 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 0.0.0.0/0 next-hop 2.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route ::/0 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }
        log_msg INFO "Start traffic streams"
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
        if { $option(ecmpEnabled) == "true"} {
            log_msg INFO "Traffic started, check that all traffic is dropped except spoofed"
        } else {
            log_msg INFO "Traffic started, check that all traffic is redirected except loose"
        }
        # check uRPF check counters
        log_msg INFO "Check uRPF Fail counters"

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        after 60000
        if { $option(redirectType) == "grtToVrf" } {
            set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
        } else {
            set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
        }

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
            } else {
                regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
            }
            if { $cnt1 < $cnt2 } {
                log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
            } else {
                log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
            }

        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
            } else {
                regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
            }
            if { $cnt1_v6 < $cnt2_v6 } {
                log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
            } else {
                log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
            }

        }


        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count !=0" -errorIfNotFound true
            } else {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count !=0" -errorIfNotFound true
            } else {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
        }

        # enable ignore-default
        log_msg INFO "Enable ignore-default"
        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check ignore-default"] ; log_msg INFO "$rCli"
            }
        }

        log_msg INFO "With ignore-default enabled, traffic with a source address that matches only the default route is considered to fail the uRPF check and is discarded"

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        log_msg INFO "Start traffic streams"
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 2000
        if { $option(ecmpEnabled) == "true"} {
            log_msg INFO "Traffic started, check that all traffic dropped"
        } else {
            log_msg INFO "Traffic started, check that all traffic is dropped except host"
        }
        # check uRPF check counters
        log_msg INFO "Check uRPF Fail counters"

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        after 60000
        if { $option(redirectType) == "grtToVrf" } {
            set rCli2 [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli2"
        } else {
            set rCli2 [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli2"
        }

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4 Pk  : (\S+)} $rCli2  match cnt2
            } else {
                regexp {uRPF Fail V4.: (\S+)} $rCli  match cnt1
                regexp {uRPF Fail V4.: (\S+)} $rCli2  match cnt2
            }
            if { $cnt1 < $cnt2 } {
                log_msg INFO "Check for uRPF Fail V4 passed OK: first check - $cnt1, second check - $cnt2"
            } else {
                log_msg ERROR "Check for uRPF Fail V4 failed NOK: first check - $cnt1, second check - $cnt2"
            }

        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6 Pk  : (\S+)} $rCli2  match cnt2_v6
            } else {
                regexp {uRPF Fail V6.: (\S+)} $rCli  match cnt1_v6
                regexp {uRPF Fail V6.: (\S+)} $rCli2  match cnt2_v6
            }
            if { $cnt1_v6 < $cnt2_v6 } {
                log_msg INFO "Check for uRPF Fail V6 passed OK: first check - $cnt1_v6, second check - $cnt2_v6"
            } else {
                log_msg ERROR "Check for uRPF Fail V6 failed NOK: first check - $cnt1_v6, second check - $cnt2_v6"
            }

        }


        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        log_msg INFO "Disable ignore-default and remove default routes"
        log_msg INFO "Disable ignore-default"
        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 urpf-check no ignore-default"] ; log_msg INFO "$rCli"
            }
        }
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                # default route
                set rCli [$dut2 sendCliCommand "/configure router no static-route 0.0.0.0/0 next-hop 5.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 0 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure router no static-route ::/0 next-hop 3FFE::501:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn base -errorIfNotFound 0 -tryTime 60
            }
        } else {
            if {$option(sendTraffic_v4)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 0.0.0.0/0 next-hop 2.1.2.1"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route 0.0.0.0} -vprn base -errorIfNotFound 0 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                # host IP
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route ::/0 next-hop 3FFE::201:201"]; log_msg INFO $rCli
                after 1000
                log_msg INFO "Verify route in FIB"
                getFib -dut $dut2 -print only -match {route ::} -vprn 2 -errorIfNotFound 0 -tryTime 60
            }
        }
    }

    # perform rollback
      log_msg INFO "Create rollback checkpoint, remove configuration and restore via rollback revert"
      set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback save"] ; log_msg INFO "$rCli"
      #
      after 1000
      saveOrRestore delete -dut $dut2
      after 1000
      # configure rollback-location again because it was removed during saveOrRestore delete
      set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback revert latest-rb now"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
      set rCli [$dut2 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"
      log_msg INFO "Waiting 20secs ...." ; after 20000

    # wait until route 85.1.2.0/24 and 3FFE::5501:200/120 will be distributed to $dut1
    log_msg INFO "Wait for route distribution to $dut1 from VPRN 2 on $dut2"
    set whileContinue 1
    set try 1
    while { $whileContinue } {
        set rCli [$dut1 sendCliCommand "show router fib 1"] ; log_msg INFO "$rCli"
        set rCli2 [$dut1 sendCliCommand "show router fib 1 ipv6"] ; log_msg INFO "$rCli2"
        if { [regexp 85.1.2.0/24 $rCli] } {
            log_msg INFO "IPv4 Route is present in route-table of $dut1"
                if { [regexp (3FFE|3ffe)::5501:200/120 $rCli2] } {
                    log_msg INFO "IPv6 Route is present in route-table of $dut1"
                    set whileContinue 0
                } else {
                    incr try
                    if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv6 Route (3FFE::5501:200/120) is not present in route-table of $dut1"; set whileContinue 0 }
                }
        } else {
            incr try
            if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv4 Route (85.1.2.0/24) is not present in route-table of $dut1"; set whileContinue 0 }
        }
    }

    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    # verify traffic
    handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

    handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000


   if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        } else {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
        } else {
            getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
        }
        if { $option(redirectType) == "vrfToGrt" } {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        } else {
            if { $option(ecmpEnabled) == "true"} {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
            }
            getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
            getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
        }
    }

    if { $option(redirectType) != "grtToVrf" } {
         # shutdown/no shutdown VPRN 2
        log_msg INFO "Perform shutdown/no shutdown of VPRN 2 and verify the traffic"
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 shutdown"] ; log_msg INFO "$rCli"
        after 5000
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 no shutdown"] ; log_msg INFO "$rCli"
        after 5000

        # wait until route 85.1.2.0/24 and 3FFE::5501:200/120 will be distributed to $dut1
        log_msg INFO "Wait for route distribution to $dut1 from VPRN 2 on $dut2"
        set whileContinue 1
        set try 1
        while { $whileContinue } {
            set rCli [$dut1 sendCliCommand "show router fib 1"] ; log_msg INFO "$rCli"
            set rCli2 [$dut1 sendCliCommand "show router fib 1 ipv6"] ; log_msg INFO "$rCli2"
            if { [regexp 85.1.2.0/24 $rCli] } {
                log_msg INFO "IPv4 Route is present in route-table of $dut1"
                    if { [regexp (3FFE|3ffe)::5501:200/120 $rCli2] } {
                        log_msg INFO "IPv6 Route is present in route-table of $dut1"
                        set whileContinue 0
                    } else {
                        incr try
                        if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv6 Route (3FFE::5501:200/120) is not present in route-table of $dut1"; set whileContinue 0 }
                    }
            } else {
                incr try
                if { $try < "20" } { after 5000 } else { log_msg ERROR "IPv4 Route (85.1.2.0/24) is not present in route-table of $dut1"; set whileContinue 0 }
            }
        }

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                if { $option(ecmpEnabled) == "true"} {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                }
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }
    }

    if { $option(ecmpEnabled) == "true"} {
        # disable ECMP
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Disable ECMP and verify the traffic"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router no ecmp"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 no ecmp"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }
        after 5000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        # enable ECMP
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Enable ECMP again and verify the traffic"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router ecmp 16"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 ecmp 16"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
        }
        after 5000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> dropped"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> dropped"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        # disable one interface for loose IP (2 routes remain for host IPs only)
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Disable one interface for loose IP (2 routes will remain for host IPs only)"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                set rCli [$dut2 sendCliCommand "/configure router no static-route 1.2.4.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                set rCli [$dut2 sendCliCommand "/configure router no static-route 3FFE::102:432/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 1 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-C shutdown"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
            }
        }
        after 2000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> dropped"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> dropped"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        log_msg INFO "Enable interface back for loose IP, disable one interface for host IP (2 routes will remain for loose IPs only)"
        log_msg INFO "--------------------------------------"
        log_msg INFO " "
        if { $option(redirectType) == "grtToVrf" } {
            if {$option(sendTraffic_v4)} {
                set rCli [$dut2 sendCliCommand "/configure router static-route 1.2.4.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router no static-route 5.1.2.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::102:432/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure router no static-route 3FFE::501:232/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
            }
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-C no shutdown"] ; log_msg INFO "$rCli"
            if {$option(sendTraffic_v4)} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 2.1.2.50/32 next-hop 2.2.3.1"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
            if {$option(sendTraffic_v6)} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 no static-route 3FFE::201:232/128 next-hop 3FFE::202:301"]; log_msg INFO $rCli
                getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 1 -tryTime 60
                getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            }
        }
        after 2000

        log_msg INFO "Expected behavior:"
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> dropped"
        } else {
            log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
            log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> dropped"
        }
        log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> dropped"
        log_msg INFO " "

        log_msg INFO "Clear filter counters"
        foreach thisFamily $thisFilterFamilyList {
            switch $thisFamily {
            "ipv4" {set fTxt "ip"}
            "ipv6" {set fTxt "ipv6"}
            }
            set vprnCnt 1
            set b 1 ; set c [lindex $vprnIdOnlyList 0]
            set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
            set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        } ; #thisFilterFamilyList

        # verify traffic
        handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000

        handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000

        if {$option(sendTraffic_v4)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv4 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv4 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv4 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv4 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv4 count 0" -errorIfNotFound true
            }
        }
        if {$option(sendTraffic_v6)} {
            if { $option(redirectType) == "grtToVrf" } {
                getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version ipv6 count !=0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut2 -match "entry 1 dir ingress version ipv6 count !=0" -errorIfNotFound true
            }
            if { $option(redirectType) == "vrfToGrt" } {
                getFilter -print true -dut $dut6 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut6 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            } else {
                getFilter -print true -dut $dut4 -match "entry 1 dir egress version ipv6 count !=0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 2 dir egress version ipv6 count 0" -errorIfNotFound true
                getFilter -print true -dut $dut4 -match "entry 3 dir egress version ipv6 count 0" -errorIfNotFound true
            }
        }

        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router static-route 5.1.2.50/32 next-hop 5.2.3.1"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 5.1.2.50} -vprn base -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 1.2.4.50} -vprn base -errorIfNotFound 2 -tryTime 60
            set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::501:232/128 next-hop 3FFE::502:301"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 3FFE::501:232} -vprn base -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 3FFE::102:432} -vprn base -errorIfNotFound 2 -tryTime 60
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.2.3.1"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 2.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 85.1.2.50} -vprn 2 -errorIfNotFound 2 -tryTime 60
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::202:301"]; log_msg INFO $rCli
            getFib -dut $dut2 -print only -match {route 3FFE::201:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
            getFib -dut $dut2 -print only -match {route 3FFE::5501:232} -vprn 2 -errorIfNotFound 2 -tryTime 60
        }
    }


    
    # disable urpf-check and verify, that all traffic streams are correctly forwarded
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Disable urpf-check and verify, that all traffic streams are correctly forwarded"
    log_msg INFO "--------------------------------------"
    log_msg INFO " "
    log_msg INFO "Expected behavior:"
    if { $option(redirectType) == "grtToVrf" } {
        log_msg INFO "host traffic (5.1.2.50 or 3FFE::201:232) -> forwarded"
        log_msg INFO "loose traffic (1.2.4.50 or 3FFE::102:432) -> forwarded"
    } else {
        log_msg INFO "host traffic (2.1.2.50 or 3FFE::201:232) -> forwarded"
        log_msg INFO "loose traffic (85.1.2.50 or 3FFE::5501:232) -> forwarded"
    }
    log_msg INFO "spoofed traffic (1.1.9.9 or 3FFE::101:909) -> forwarded"
    log_msg INFO " "
    log_msg INFO "Clear filter counters"
    foreach thisFamily $thisFilterFamilyList {
        switch $thisFamily {
        "ipv4" {set fTxt "ip"}
        "ipv6" {set fTxt "ipv6"}
        }
        set vprnCnt 1
        set b 1 ; set c [lindex $vprnIdOnlyList 0]
        set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
        set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    } ; #thisFilterFamilyList

    # disable urpf-check 
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 no urpf-check"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 no urpf-check"] ; log_msg INFO "$rCli"
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "/configure router interface to_Dut-A5 ipv6 no urpf-check"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 ipv6 no urpf-check"] ; log_msg INFO "$rCli"
        }
    }

    log_msg INFO "Start traffic streams"
    log_msg INFO "Traffic started, waiting 20secs and check that all traffic is redirected"
    if { $option(redirectType) == "vrfToGrt" } {
        if {[checkTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
          log_msg INFO "Traffic goes like expected: all traffic streams from host, loose and spoofed IPs are correctly forwarded"
        } else {
          log_msg ERROR "Traffic doesn't goes like expected: all traffic streams from host, loose and spoofed IPs are incorrectly forwarded" ; set Result FAIL
        }
    } else {
        if {[checkTrafficFlows $dut1 $dut4 $cntPktsViaFilter_filterId -trafficDurationSecs $trafficDurationSecsDuringPrecondition]} {
          log_msg INFO "Traffic goes like expected: all traffic streams from host, loose and spoofed IPs are correctly forwarded"
        } else {
          log_msg ERROR "Traffic doesn't goes like expected: all traffic streams from host, loose and spoofed IPs are incorrectly forwarded" ; set Result FAIL
        }
    }


    # check uRPF check counters
    log_msg INFO "Check uRPF Fail counters -> expected uRPF Chk: Disabled"
    if {$option(sendTraffic_v4)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
        }
        if { [regexp {uRPF Chk \s+ : (disabled)} $rCli match state] } {
            log_msg INFO "uRPF Chk: Disabled - OK"
        } else {
            log_msg ERROR "State of uRPF Chk failed"; set Result FAIL
        }
    }
    if {$option(sendTraffic_v6)} {
        if { $option(redirectType) == "grtToVrf" } {
            set rCli [$dut2 sendCliCommand "show router interface to_Dut-A5 detail | match uRPF"] ; log_msg INFO "$rCli"
            if { [regexp {uRPF Ipv6 Chk \s+: (disabled)} $rCli match state] } {
                log_msg INFO "uRPF Ipv6 Chk: Disabled - OK"
            } else {
                log_msg ERROR "State of uRPF Ipv6 Chk failed"; set Result FAIL
            }
        } else {
            set rCli [$dut2 sendCliCommand "show service id 2 interface to_Dut-A2 detail | match uRPF"] ; log_msg INFO "$rCli"
            if { [regexp {uRPF Ipv6 Chk: (disabled)} $rCli match state] } {
                log_msg INFO "uRPF Ipv6 Chk: Disabled - OK"
            } else {
                log_msg ERROR "State of uRPF Ipv6 Chk failed"; set Result FAIL
            }
        }
    }

  if {$option(deconfig)} {
    saveOrRestore delete
  }

  testcaseTrailer
  $dut2 configure -cli_timeout $cliTimeoutOrig
  if {$dutLoggingDisabled} {
    log_msg WARNING "Logging in dut-logs was disabled, enable it again"
    foreach dut $dutList {
      $dut configure -logging logging
    }
  }

}

####################################################################################
#
# Test ID   : filterActionFwdRtr_qppb
#
# Description : Cover RFE158878: When PBR to VRF is applied (filter or flow-spec) uRPF should be done in source routing instance
#     - verify interaction between source-based QPPB and the 'redirect to router' action so that source address lookup is always 
#       done in the original/source routing instance
#     - verify redirect from GRT to VRF, VRF to VRF and VRF to GRT
#     - verify qos-route-lookup destination and source
#     - verify QPPB with uRPF-check enabled, GRT leak enabled (only possible with qos-route-lookup destination)
#     - verify rollback
#
#
#                   - Test runs on stdsixdutnode - IOM3+ (-constraints {{40GSupport true}})
#
# Possible combinations:
# filterActionFwdRtrQppb -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToVrf
# filterActionFwdRtrQppb -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType grtToVrf
# filterActionFwdRtrQppb -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToGrt
# filterActionFwdRtrQppb -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToVrf -family ipv6
# filterActionFwdRtrQppb -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType grtToVrf -family ipv6
# filterActionFwdRtrQppb -itfType_dut1dut2 sap -redirectVprnTunnelMethod autobind -redirectVprnTunnelEncap ldp -redirectType vrfToGrt -family ipv6
#
####################################################################################
proc filterActionFwdRtrQppb {args} {

  global masterlog testdir ixia_port logdir Result
  global portA dataip rollbackLocation

  source $testdir/testsuites/flowspec/flowspec_vprnParams.tcl
  source $testdir/testsuites/flowspec/flowspec_Procs.tcl
  source $testdir/testsuites/bgp/qppb/qppb_params.tcl
  source $testdir/testsuites/filter/tests/wccp_procs.tcl
  source $testdir/testsuites/filter/filter_actionFwdRtr_procs.tcl

  set option(config) true
  set option(test) true
  set option(deconfig) true
  set option(debug) false
  set option(verbose) false
  set option(bugxxxxx) false
  set option(returnResult) false
  set option(sbgpDebug) false
  set option(dumpDebugLog) false
  set option(cliTimeout) 600
  set option(maxRetryCnt) 6
  set option(interRetryTimeSec) 30
  set option(addDefFilterInFirstVprnBeforeFlowroutesAreInjected) true
  set option(addDefFilterInLastVprnAfterFlowroutesAreInjected) true
  set option(nbrVprns) 3
  set option(nbrFlowroutesPerVprn) 1
  set option(actionListPerVprn) [list redirectVrf]
  set option(enableFilterTrace) false
  set option(enableBgpFlowspecTrace) false
  set option(sendBgpPrefixUpd_v4) false
  set option(sendBgpPrefixUpd_v6) false
  set option(sendBgpFlowrouteUpd_v4) true
  set option(sendBgpFlowrouteUpd_v6) true
  set option(family)         "ipv4"
  set option(sendTraffic_v4) true
  set option(sendTraffic_v6) true
  set option(enableIngressFlowspec_v4) false
  set option(enableIngressFlowspec_v6) false
  set option(flowspecInteraction) false
  set option(vrfTargetDirectUnderVprn_noImportPolicy) true
  set option(enableFlowspecBeforeFlowroutesAreInjected) false
  # spoke (flowroute vprn)
  set option(itfType_dut1dut2) ""
  set option(addFlowroutesInBase) true

  # maxNbrIterations | maxDuration [hours] | ifFileExists
  set option(iterationMethod) maxNbrIterations
  set option(maxNbrIterations) 1
  set option(maxDurationHrs) 5
  set option(fileExistsName) "/tmp/fwdRtrVprn_running.txt"

  # vrfToVrf | grtToVrf | vrfToGrt
  set option(redirectType)     "vrfToVrf"
  set option(verifySwo)     "false"
  set option(ecmpEnabled)     "false"
  # there are 4 combinations
  #   autobind - ldp (default)
  #   autobind - gre
  #   sdp - rsvp
  #   sdp - gre
  set option(redirectVprnTunnelMethod) autobind
  set option(redirectVprnTunnelEncap) ldp

  set option(grtLookupEnableGrt) false
  getopt option      $args

  if {$option(family) == "ipv4"} {
      set option(sendTraffic_v4) true
      set option(sendTraffic_v6) false
  }  else {
      set option(sendTraffic_v4) false
      set option(sendTraffic_v6) true
  }

  set testID $::TestDB::currentTestCase
  set Result OK

  testcaseHeader

  ##### Testcase GGV paramerters (begin)
  if {[GGV fspecNbrVprns] != "ERROR"} {
    set nbrVprns [GGV fspecNbrVprns]
  } else {
    set nbrVprns $option(nbrVprns)
  }
  if {[GGV fspecNbrFlowroutesPerVprn] != "ERROR"} {
    set nbrFlowroutesPerVprn [GGV fspecNbrFlowroutesPerVprn]
  } else {
    set nbrFlowroutesPerVprn $option(nbrFlowroutesPerVprn)
  }
  if {[GGV fspecEnableFilterTrace] != "ERROR"} {
    set enableFilterTrace [GGV fspecEnableFilterTrace]
  } else {
    set enableFilterTrace $option(enableFilterTrace)
  }
  if {[GGV fspecEnableBgpFlowspecTrace] != "ERROR"} {
    set enableBgpFlowspecTrace [GGV fspecEnableBgpFlowspecTrace]
  } else {
    set enableBgpFlowspecTrace $option(enableBgpFlowspecTrace)
  }
  if {[GGV fspecSendBgpPrefixUpd_v4] != "ERROR"} {
    set sendBgpPrefixUpd_v4 [GGV fspecSendBgpPrefixUpd_v4]
  } else {
    set sendBgpPrefixUpd_v4 $option(sendBgpPrefixUpd_v4)
  }
  if {[GGV fspecSendBgpPrefixUpd_v6] != "ERROR"} {
    set sendBgpPrefixUpd_v6 [GGV fspecSendBgpPrefixUpd_v6]
  } else {
    set sendBgpPrefixUpd_v6 $option(sendBgpPrefixUpd_v6)
  }
  if {[GGV fspecSendBgpFlowrouteUpd_v4] != "ERROR"} {
    set sendBgpFlowrouteUpd_v4 [GGV fspecSendBgpFlowrouteUpd_v4]
  } else {
    set sendBgpFlowrouteUpd_v4 $option(sendBgpFlowrouteUpd_v4)
  }
  if {[GGV fspecSendBgpFlowrouteUpd_v6] != "ERROR"} {
    set sendBgpFlowrouteUpd_v6 [GGV fspecSendBgpFlowrouteUpd_v6]
  } else {
    set sendBgpFlowrouteUpd_v6 $option(sendBgpFlowrouteUpd_v6)
  }
  if {[GGV fspecActionListPerVprn] != "ERROR"} {
    set actionListPerVprn [GGV fspecActionListPerVprn]
  } else {
    set actionListPerVprn $option(actionListPerVprn)
  }
  if {[GGV fspecDumpDebugLog] != "ERROR"} {
    set dumpDebugLog [GGV fspecDumpDebugLog]
  } else {
    set dumpDebugLog $option(dumpDebugLog)
  }
  if {[GGV fspecSendTraffic_v4] != "ERROR"} {
    set sendTraffic_v4 [GGV fspecSendTraffic_v4]
  } else {
    set sendTraffic_v4 $option(sendTraffic_v4)
  }
  if {[GGV fspecSendTraffic_v6] != "ERROR"} {
    set sendTraffic_v6 [GGV fspecSendTraffic_v6]
  } else {
    set sendTraffic_v6 $option(sendTraffic_v6)
  }
  if {[GGV fspecEnableIngressFlowspec_v4] != "ERROR"} {
    set enableIngressFlowspec_v4 [GGV fspecEnableIngressFlowspec_v4]
  } else {
    set enableIngressFlowspec_v4 $option(enableIngressFlowspec_v4)
  }
  if {[GGV fspecEnableIngressFlowspec_v6] != "ERROR"} {
    set enableIngressFlowspec_v6 [GGV fspecEnableIngressFlowspec_v6]
  } else {
    set enableIngressFlowspec_v6 $option(enableIngressFlowspec_v6)
  }
  if {[GGV fspecVrfTargetDirectUnderVprn_noImportPolicy] != "ERROR"} {
    set vrfTargetDirectUnderVprn_noImportPolicy [GGV fspecVrfTargetDirectUnderVprn_noImportPolicy]
  } else {
    set vrfTargetDirectUnderVprn_noImportPolicy $option(vrfTargetDirectUnderVprn_noImportPolicy)
  }
  if {[GGV fspecItfType_dut1dut2] != "ERROR"} {
    set itfType_dut1dut2 [GGV fspecItfType_dut1dut2]
  } else {
    set itfType_dut1dut2 $option(itfType_dut1dut2)
  }
  if {[GGV fspecAddDefFilterInFirstVprnBeforeFlowroutesAreInjected] != "ERROR"} {
    set addDefFilterInFirstVprnBeforeFlowroutesAreInjected [GGV fspecAddDefFilterInFirstVprnBeforeFlowroutesAreInjected]
  } else {
    set addDefFilterInFirstVprnBeforeFlowroutesAreInjected $option(addDefFilterInFirstVprnBeforeFlowroutesAreInjected)
  }
  if {[GGV fspecAddDefFilterInLastVprnAfterFlowroutesAreInjected] != "ERROR"} {
    set addDefFilterInLastVprnAfterFlowroutesAreInjected [GGV fspecAddDefFilterInLastVprnAfterFlowroutesAreInjected]
  } else {
    set addDefFilterInLastVprnAfterFlowroutesAreInjected $option(addDefFilterInLastVprnAfterFlowroutesAreInjected)
  }
  if {[GGV fspecAddFlowroutesInBase] != "ERROR"} {
    set addFlowroutesInBase [GGV fspecAddFlowroutesInBase]
  } else {
    set addFlowroutesInBase $option(addFlowroutesInBase)
  }
  if {[GGV fspecIterationMethod] != "ERROR"} {
    set iterationMethod [GGV fspecIterationMethod]
  } else {
    set iterationMethod $option(iterationMethod)
  }
  if {[GGV fspecMaxNbrIterations] != "ERROR"} {
    set maxNbrIterations [GGV fspecMaxNbrIterations]
  } else {
    set maxNbrIterations $option(maxNbrIterations)
  }
  if {[GGV fspecMaxDurationHrs] != "ERROR"} {
    set maxDurationHrs [GGV fspecMaxDurationHrs]
  } else {
    set maxDurationHrs $option(maxDurationHrs)
  }
  if {[GGV fspecEnableFlowspecBeforeFlowroutesAreInjected] != "ERROR"} {
    set enableFlowspecBeforeFlowroutesAreInjected [GGV fspecEnableFlowspecBeforeFlowroutesAreInjected]
  } else {
    set enableFlowspecBeforeFlowroutesAreInjected $option(enableFlowspecBeforeFlowroutesAreInjected)
  }
  if {[GGV fspecRedirectVprnTunnelMethod] != "ERROR"} {
    set redirectVprnTunnelMethod [GGV fspecRedirectVprnTunnelMethod]
  } else {
    set redirectVprnTunnelMethod $option(redirectVprnTunnelMethod)
  }
  if {[GGV fspecRedirectVprnTunnelEncap] != "ERROR"} {
    set redirectVprnTunnelEncap [GGV fspecRedirectVprnTunnelEncap]
  } else {
    set redirectVprnTunnelEncap $option(redirectVprnTunnelEncap)
  }
  if {[GGV fspecGrtLookupEnableGrt] != "ERROR"} {
    set grtLookupEnableGrt [GGV fspecGrtLookupEnableGrt]
  } else {
    set grtLookupEnableGrt $option(grtLookupEnableGrt)
  }
  ##### Testcase GGV paramerters (end)

  set dut1 Dut-A ; set dut2 Dut-B ; set dut3 Dut-C ; set dut4 Dut-D ; set dut5 Dut-E ; set dut6 Dut-F
  set dutList [list $dut1 $dut2 $dut3 $dut4 $dut5 $dut6]

  # vprnIdList => thisVprnId | thisNbrFlowroutesPerVprn | thisActionListPerVprn
  # vprnIdOnlyList => has only the vprnId's
  set vprnIdList "" ; set vprnIdOnlyList ""
  for {set vprnId 1} {$vprnId <= $nbrVprns} {incr vprnId} {
    lappend vprnIdList [expr $minVprnId - 1 + $vprnId] ; lappend vprnIdOnlyList [expr $minVprnId - 1 + $vprnId]
    lappend vprnIdList $nbrFlowroutesPerVprn
    lappend vprnIdList $actionListPerVprn
  }
  # Use the next dot1q tag for the Base
  set baseDot1qTag [expr [lindex $vprnIdOnlyList end] + 1]

  set nbrStreamsFamilies 0 ; if {$sendTraffic_v4} {incr nbrStreamsFamilies} ; if {$sendTraffic_v6} {incr nbrStreamsFamilies}
  if {$addFlowroutesInBase} {
    set nbrStreamsUsed [expr [expr $nbrVprns + 1] * [llength $actionListPerVprn] * $nbrStreamsFamilies]
  } else {
    set nbrStreamsUsed [expr $nbrVprns * [llength $actionListPerVprn] * $nbrStreamsFamilies]
  }

  set pktRatePerStream 2 ; set pktSize 128 ; set streamData_ISATMS "49 53 41 54 4D 53" ; set rawProtocol 253
  set trafficDurationSecsDuringPrecondition 30

  # used in redirectToVrf
  set redirectVprnId 400 ; set customerId 1 ; set nbrRedirectVprn 4
  set firstRedirectVprnId $redirectVprnId
  set maxRedirectVprnId [expr $firstRedirectVprnId + $nbrRedirectVprn - 1]
  set minRedirectVprnId $redirectVprnId
  # the vprn (to redirect) is between dut2/dut4
  set thisRT "target:42:1"

  set enableTraceDutList [list $dut2 $dut3]
  # spokeSdp case
  set spokeIesId 5000 ; set spokeSdpId 1 ; set spokeSdpVcId 1

  if {$sendBgpFlowrouteUpd_v4 && $sendBgpFlowrouteUpd_v6} {
    set thisFilterFamilyList [list ipv4 ipv6]
  } elseif {$sendBgpFlowrouteUpd_v6} {
    set thisFilterFamilyList [list ipv6]
  } else {
    set thisFilterFamilyList [list ipv4]
  }
  set groupName "onegroup"

  # 101..199 => always 101 for flowspec
  set filterLogId 101

  set rollbackLocation "ftp://$::TestDB::thisTestBed:tigris@$::TestDB::thisHostIpAddr/$logdir/device_logs/saved_configs"

  log_msg INFO "########################################################################"
  log_msg INFO "# Test : $testID"
  log_msg INFO "# Descr : Cover RFE158878: When PBR to VRF is applied (filter or flow-spec) uRPF should be done in source routing instance"
  log_msg INFO "#         - verify interaction between source-based QPPB and the 'redirect to router' action so that source address lookup is always"
  log_msg INFO "#           done in the original/source routing instance  "
  log_msg INFO "#   "
  log_msg INFO "# Setup:"
  log_msg INFO "# "
  log_msg INFO "#                              PE($dut4)----------> scrubber (Ixia)"
  log_msg INFO "#                               dut4 (dest for redirect actions)"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#                                |"
  log_msg INFO "#   Ixia----------dut1----------dut2----------dut3----------dut6"
  log_msg INFO "#                CE1($dut1)    PE($dut2)     PE($dut3)     CE2($dut6)"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                              |"
  log_msg INFO "#                                             Linux"
  log_msg INFO "# "
  log_msg INFO "# Important testcase parameters:"
  log_msg INFO "#   vprnIdOnlyList: $vprnIdOnlyList"
  log_msg INFO "#   redirectType: $option(redirectType)"
  log_msg INFO "#   redirectVprn => vrpnId: $firstRedirectVprnId till $maxRedirectVprnId (#$nbrRedirectVprn) ; redirectVprnTunnelMethod: $redirectVprnTunnelMethod ; redirectVprnTunnelEncap: $redirectVprnTunnelEncap"
  log_msg INFO "#   ECMP enabled: $option(ecmpEnabled)"

  if {$addFlowroutesInBase} {set fTxt "(baseDot1qTag: $baseDot1qTag)"} else {set fTxt ""}
  log_msg INFO "#   addFilterWithFwdRtrInBase: $addFlowroutesInBase $fTxt"
  log_msg INFO "#   sendTraffic_v4: $sendTraffic_v4 sendTraffic_v6: $sendTraffic_v6 "
  log_msg INFO "#   vrfTargetDirectUnderVprn_noImportPolicy: $vrfTargetDirectUnderVprn_noImportPolicy"
  log_msg INFO "#   itfType_dut1dut2: $itfType_dut1dut2"
  switch $iterationMethod {
    "maxNbrIterations" {set iMethTxt "maxNbrIterations: $maxNbrIterations"}
    "maxDuration" {set iMethTxt "maxDurationHrs: $maxDurationHrs"}
    "ifFileExists" {set iMethTxt "fileExistsName: $option(fileExistsName)"}
  }
  log_msg INFO "# "
  log_msg INFO "########################################################################"

  set dutLoggingDisabled false

  # handlePacket -action reset -portList all
  CLN.reset
  set cliTimeoutOrig [$dut2 cget -cli_timeout]
  $dut2 configure -cli_timeout $option(cliTimeout)

  if {$option(config) && ! [testFailed] && $Result == "OK"} {
    CLN.reset
    CLN "dut $dut1 systemip [set [set dut1]_ifsystem_ip] isisarea $isisAreaId as [set [set dut1]_AS]"
    CLN "dut $dut2 systemip [set [set dut2]_ifsystem_ip] isisarea $isisAreaId as [set [set dut2]_AS]"
    CLN "dut $dut3 systemip [set [set dut3]_ifsystem_ip] isisarea $isisAreaId as [set [set dut3]_AS]"
    CLN "dut $dut4 systemip [set [set dut4]_ifsystem_ip] isisarea $isisAreaId as [set [set dut4]_AS]"
    CLN "dut $dut5 systemip [set [set dut5]_ifsystem_ip] isisarea $isisAreaId as [set [set dut5]_AS]"
    CLN "dut $dut6 systemip [set [set dut6]_ifsystem_ip] isisarea $isisAreaId as [set [set dut6]_AS]"

    set a 30 ; set b [expr 20 + [lindex $vprnIdOnlyList 0]] ; set c 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn } $vprnIdList {
      CLN "dut $dut2 vprnid $thisVprnId systemip $a.$b.$c.2 as [set [set dut2]_AS]"
      CLN "dut $dut3 vprnid $thisVprnId systemip $a.$b.$c.3 as [set [set dut3]_AS]"
      incr b ; if {$b > 255} {set b 0 ; incr a}
    }

    # used for spokes dut1/dut2
    if { [GGV subTopology] == "ess6MixedMode" } {
        CLN "dut $dut1 tonode $dut2 porttype network dot1q 1 ip 1.1.1.1 ldp true mpls true"
    } else {
        CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q 1 ip 1.1.1.1 ldp true mpls true"
    }
    CLN "dut $dut2 tonode $dut1 porttype hybrid dot1q 1 ip 1.1.1.2 ldp true mpls true"

    # In the CE's, bgp routes are learned from different peers (the neighbor end point is in different vprn).
    # The learned bgp routes are installed in the Base routing-table and exported again to all neighbors (default ebgp behavior).
    # To avoid that the neigbor end points (in different vprn's) receive the exported bgp routes (CE's Base instance) a reject policy should be installed.
    CLN "dut $dut1 policy rejectBgpExport entry 1 action reject descr avoidExportFromBaseToNeighborVprns"
    CLN "dut $dut6 policy rejectBgpExport entry 1 action reject descr avoidExportFromBaseToNeighborVprns"

    # Exchange flowroutes via BGP peer in the VPRN, because SAFI=134 (exchange flowroutes via L3-VPN) is not supported
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      CLN "dut $dut3 tonode $dut2 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'flow-ipv4 flow-ipv6' "
      CLN "dut $dut2 tonode $dut3 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'flow-ipv4 flow-ipv6' "
    }

    # redistribute bgp-vpn in ospf
    CLN "dut $dut2 policy fromBgpVpnToOspf_v4 entry 1 from 'protocol bgp-vpn' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v4 entry 1 to 'protocol ospf' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v6 entry 1 from 'protocol bgp-vpn' action accept"
    CLN "dut $dut2 policy fromBgpVpnToOspf_v6 entry 1 to 'protocol ospf3' action accept"

    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      #
      if {$itfType_dut1dut2 == "spoke"} {
        if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut1 tonode $dut2 porttype network iesid $spokeIesId iftype spoke sdpid '$spokeSdpId gre [set [set dut2]_ifsystem_ip]' dot1q $thisVprnId ip $thisVprnId.$dataip(id.$dut1).$dataip(id.$dut2).$dataip(id.$dut1) ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        } else {
            CLN "dut $dut1 tonode $dut2 porttype hybrid iesid $spokeIesId iftype spoke sdpid '$spokeSdpId gre [set [set dut2]_ifsystem_ip]' dot1q $thisVprnId ip $thisVprnId.$dataip(id.$dut1).$dataip(id.$dut2).$dataip(id.$dut1) ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        }
        CLN "dut $dut2 tonode $dut1 porttype hybrid iftype spoke sdpid '$spokeSdpId gre [set [set dut1]_ifsystem_ip]' vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId ospfexport fromBgpVpnToOspf_v4 ospf3export fromBgpVpnToOspf_v6 as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      } else {
        if { [GGV subTopology] == "ess6MixedMode" } {
            CLN "dut $dut1 tonode $dut2 porttype network dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        } else {
            CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut1]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut1]_AS] bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
        }
        CLN "dut $dut2 tonode $dut1 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId ospfexport fromBgpVpnToOspf_v4 ospf3export fromBgpVpnToOspf_v6 as [set [set dut2]_AS] bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      }

      if { [GGV subTopology] == "ess6MixedMode" } {
          CLN "dut $dut6 tonode $dut3 porttype network dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut6]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut6]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
      } else {
          CLN "dut $dut6 tonode $dut3 porttype hybrid dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut6]_ifsystem_ip] ospfasbr true ospf3asbr true as [set [set dut6]_AS] bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' bgpexport rejectBgpExport"
      }
      CLN "dut $dut3 tonode $dut6 porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId routerid [set [set dut3]_ifsystem_ip] as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set [set dut6]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "

      CLN "dut $dut3 link Linux porttype hybrid vprnid $thisVprnId dot1q $thisVprnId ospfarea $ospfAreaId ospf3area $ospfAreaId passive true as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set Linux_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
    }

    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      CLN "dut $dut2 logid $debugLog from debug to 'memory 3000' debug {router $thisVprnId bgp update}"
      CLN "dut $dut3 logid $debugLog from debug to 'memory 3000' debug {router $thisVprnId bgp update}"
    }

    if {$addFlowroutesInBase} {
      CLN "dut $dut3 tonode $dut2 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor [set [set dut2]_ifsystem_ip]  bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6' ldp true"
      CLN "dut $dut2 tonode $dut3 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor [set [set dut3]_ifsystem_ip] bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 vpn-ipv4 vpn-ipv6 flow-ipv4 flow-ipv6' ldp true"
      #
      CLN "dut $dut3 tonode $dut6 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut6]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      if { [GGV subTopology] == "ess6MixedMode" } {
          CLN "dut $dut6 tonode $dut3 porttype network dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
          CLN "dut $dut1 tonode $dut2 porttype network dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      } else {
          CLN "dut $dut6 tonode $dut3 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut3]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
          CLN "dut $dut1 tonode $dut2 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut2]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      }
      #
      CLN "dut $dut2 tonode $dut1 porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId bgpneighbor interface4 bgppeeras [set [set dut1]_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
      #
      CLN "dut $dut3 link Linux porttype hybrid dot1q $baseDot1qTag isisarea $isisAreaId passive true as [set [set dut3]_AS] bgpneighbor interface4 bgppeeras [set Linux_AS] bgpfamily 'ipv4 ipv6 flow-ipv4 flow-ipv6' "
    }

    # Ixia connections
    set filterEntryId 1
    set filterEntryId2 123
    set filterEntryId3 2139
    set filterEntryId4 65535
    if { $option(redirectType) == "grtToVrf" } {
        set host_ip 5.1.2.0
        set loose_ip 1.2.4.0
    } else {
        set host_ip 2.1.2.0
        set loose_ip 85.1.2.0
    }
    set spoofed_ip 1.1.9.0
    foreach thisAction $actionListPerVprn {
      CLN "dut $dut1 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].0.0.0/$cntPktsViaFilter_mask_v4"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId dstip [set a_[set thisAction]].1.2.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId2 dstip [set a_[set thisAction]].1.3.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId3 dstip [set a_[set thisAction]].1.4.0/24"
      CLN "dut $dut2 filter $cntPktsViaFilter_filterId entry $filterEntryId4 dstip [set a_[set thisAction]].1.5.0/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry $filterEntryId srcip $host_ip/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip $loose_ip/24"
      CLN "dut $dut6 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip $spoofed_ip/24"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry $filterEntryId srcip $host_ip/24"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip $loose_ip/24"
      CLN "dut $dut4 filter $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip $spoofed_ip/24"

      CLN "dut $dut1 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].0.0.0]/$cntPktsViaFilter_mask_v6"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId dstip [ipv4ToIpv6  [set a_[set thisAction]].1.2.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId2 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.3.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId3 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.4.0]/120"
      CLN "dut $dut2 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId4 dstip [ipv4ToIpv6  [set a_[set thisAction]].1.5.0]/120"

      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId srcip [ipv4ToIpv6 $host_ip]/120"
      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip [ipv4ToIpv6 $loose_ip]/120"
      CLN "dut $dut6 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip [ipv4ToIpv6 $spoofed_ip]/120"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry $filterEntryId srcip [ipv4ToIpv6 $host_ip]/120"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 1] srcip [ipv4ToIpv6 $loose_ip]/120"
      CLN "dut $dut4 filterv6 $cntPktsViaFilter_filterId entry [expr $filterEntryId + 2] srcip [ipv4ToIpv6 $spoofed_ip]/120"

    }
    CLN "dut $dut1 tonode Ixia inegfilter $cntPktsViaFilter_filterId inegfilterv6 $cntPktsViaFilter_filterId"
    CLN "dut $dut6 tonode Ixia inegfilter $cntPktsViaFilter_filterId inegfilterv6 $cntPktsViaFilter_filterId"
    CLN "dut Ixia tonode $dut1"
    CLN "dut Ixia tonode $dut6"

    # CE2: static routes and policies to destine traffic from different vprn's to Ixia
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v4 next-hop $dataip(ip.1.Ixia.$dut6)'"
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $dataip(ip.1.Ixia.$dut6)]'"
        CLN "dut $dut6 policy fromStaticToVprns_v4 entry 1 from 'protocol static' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v4 entry 1 to 'protocol ospf' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v6 entry 1 from 'protocol static' action accept"
        CLN "dut $dut6 policy fromStaticToVprns_v6 entry 1 to 'protocol ospf3' action accept"
        CLN "dut $dut6 ospf 'export fromStaticToVprns_v4' "
        CLN "dut $dut6 ospf3 'export fromStaticToVprns_v6' "
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }

    # policies to destine traffic from different vprn's to Ixia
    set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 0
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
        CLN "dut $dut3 prefixlist 'pfxListVprn[set thisVprnId]_v4 prefix $thisDstPrefixMask_v4 longer' "
        CLN "dut $dut3 prefixlist 'pfxListVprn[set thisVprnId]_v6 prefix $thisDstPrefixMask_v6 longer' "
        CLN "dut $dut3 policy fromStaticToVprn[set thisVprnId]_v4 defaultaction reject entry 1 from 'prefix-list pfxListVprn[set thisVprnId]_v4' action accept"
        CLN "dut $dut3 policy fromStaticToVprn[set thisVprnId]_v6 defaultaction reject entry 1 from 'prefix-list pfxListVprn[set thisVprnId]_v6' action accept"
        CLN "dut $dut3 vprnid $thisVprnId ospf 'import fromStaticToVprn[set thisVprnId]_v4' "
        CLN "dut $dut3 vprnid $thisVprnId ospf3 'import fromStaticToVprn[set thisVprnId]_v6' "
      }
      incr c ; if {$c > 255} {set c 0 ; incr b}
    }

    if {$addFlowroutesInBase} {
      # - Use isis in the Base instance
      # - Use mask16 to have a route in the Base for all grt-leak's (2nd lookup in Base) of all vprn's
      set c 0 ; set d 0
      foreach thisAction $thisActionListPerVprn {
        set a [set a_[set thisAction]]
        set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
        set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask16_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask16_v6
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v4 next-hop $dataip(ip.1.Ixia.$dut6)'"
        CLN "dut $dut6 staticroute '$thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $dataip(ip.1.Ixia.$dut6)]'"
        CLN "dut $dut6 prefixlist 'pfxListBase[set baseDot1qTag]_v4 prefix $thisDstPrefixMask_v4 exact' "
        CLN "dut $dut6 prefixlist 'pfxListBase[set baseDot1qTag]_v6 prefix $thisDstPrefixMask_v6 exact' "
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v4 entry 1 from 'prefix-list pfxListBase[set baseDot1qTag]_v4' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v4 entry 1 to 'protocol isis' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v6 entry 1 from 'prefix-list pfxListBase[set baseDot1qTag]_v6' action accept"
        CLN "dut $dut6 policy fromStaticToBase[set baseDot1qTag]_v6 entry 1 to 'protocol isis' action accept"
        CLN "dut $dut6 isis 'export fromStaticToBase[set baseDot1qTag]_v4 fromStaticToBase[set baseDot1qTag]_v6'"
      }
    }

    # used in redirectToVrf
    if {$redirectVprnTunnelMethod == "autobind" && $redirectVprnTunnelEncap == "gre" || \
         $redirectVprnTunnelMethod == "sdp" && $redirectVprnTunnelEncap == "rsvp"} {
      CLN "dut $dut2 tonode $dut4 mpls true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut2 mpls true isisarea $isisAreaId"
    } else {
      CLN "dut $dut2 tonode $dut4 ldp true mpls true isisarea $isisAreaId"
      CLN "dut $dut4 tonode $dut2 ldp true mpls true isisarea $isisAreaId"
    }
    CLN "dut $dut2 bgpneighbor [set [set dut4]_ifsystem_ip] bgppeeras [set [set dut4]_AS] bgpfamily 'vpn-ipv4 vpn-ipv6'"
    CLN "dut $dut4 bgpneighbor [set [set dut2]_ifsystem_ip] bgppeeras [set [set dut2]_AS] bgpfamily 'vpn-ipv4 vpn-ipv6'"

    CLN.exec
    CLN.reset

    set thisPePeList [list $dut2 $dut3 $dut3 $dut2]
    foreach {dut ngbDut} $thisPePeList {
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        set thisExportRT [expr ($thisVprnId * 100) + ($dataip(id.$dut) * 10) + $dataip(id.$ngbDut)]
        set thisImportRT [expr ($thisVprnId * 100) + ($dataip(id.$ngbDut) * 10) + $dataip(id.$dut)]
        docli $dut "configure router"
        docli $dut "         policy-options"
        docli $dut "            begin"
        docli $dut "            community vprn_[set thisVprnId]_exportRouteTarget members target:1982:$thisExportRT"
        docli $dut "            community vprn_[set thisVprnId]_importRouteTarget members target:1982:$thisImportRT"
        docli $dut "            policy-statement vprn_[set thisVprnId]_exportPol"
        docli $dut "                entry 1"
        docli $dut "                    from"
        docli $dut "                        protocol ospf"
        docli $dut "                    exit"
        docli $dut "                    to"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                        community add vprn_[set thisVprnId]_exportRouteTarget"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "                entry 2"
        docli $dut "                    from"
        docli $dut "                        protocol ospf3"
        docli $dut "                    exit"
        docli $dut "                    to"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                        community add vprn_[set thisVprnId]_exportRouteTarget"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "            exit"
        docli $dut "            policy-statement vprn_[set thisVprnId]_importPol"
        docli $dut "                entry 1"
        docli $dut "                    from"
        docli $dut "                        protocol bgp-vpn"
        docli $dut "                        community vprn_[set thisVprnId]_importRouteTarget"
        docli $dut "                    exit"
        docli $dut "                    action accept"
        docli $dut "                    exit"
        docli $dut "                exit"
        docli $dut "            exit"
        docli $dut "            commit"
        docli $dut "        exit all"
      }
    }
    foreach {dut ngbDut} $thisPePeList {
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        docli $dut "configure service vprn $thisVprnId"
        docli $dut "no vrf-target"
        docli $dut "vrf-import vprn_[set thisVprnId]_importPol"
        docli $dut "vrf-export vprn_[set thisVprnId]_exportPol"
        docli $dut "exit all"
      }
    }

    # used in redirectToVrf
    #                                        dut     thisDutId            ngbrDut  ngbrDutId       itfToNgbr
    set redirectVprnDutList [list $dut2 $dataip(id.$dut2) $dut4 $dataip(id.$dut4) $dataip(ip.1.$dut2.$dut4) \
                                              $dut4 $dataip(id.$dut4) $dut2 $dataip(id.$dut2) $dataip(ip.1.$dut4.$dut2)]
    #
    # Also needed is a path from Dut-D to Ixia2 (scrubber).
    #   - In Dut-D: add port to Dut-E in vprn
    #   - In Dut-E: epipe between port to Dut-D and port to Dut-C
    #   - In Dut-C: epipe between port to Dut-E and port to Ixia2
    #                                         dut  epipeId fromPort toPort
    set epipeListToScrubber [list $dut5 666 $portA($dut5.$dut4) $portA($dut5.$dut3) \
                                                $dut3 667 $portA($dut3.$dut5) $portA($dut3.Ixia)]
    # Redirect is done in Dut-B
    set checkIpFilterDutList [list $dut2]

    foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
      docli $dut "configure router"
      docli $dut "         policy-options"
      docli $dut "            begin"
      docli $dut "            community \"vprn1_exportRouteTarget\" members \"target:[set thisDutId][set ngbrDutId]:1\" "
      docli $dut "            community \"vprn1_importRouteTarget_[set ngbrDutId]\" members \"target:[set ngbrDutId][set thisDutId]:1\" "
      docli $dut "            policy-statement vprn_exportPol_[set thisDutId]"
      docli $dut "                entry 1"
      docli $dut "                    from"
      docli $dut "                        protocol direct"
      docli $dut "                    exit"
      docli $dut "                    to"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                        community add vprn1_exportRouteTarget"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "                entry 2"
      docli $dut "                    from"
      docli $dut "                        protocol static"
      docli $dut "                    exit"
      docli $dut "                    to"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                        community add vprn1_exportRouteTarget"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "            exit"
      docli $dut "            policy-statement vprn_importPol_[set thisDutId]_[set ngbrDutId]"
      docli $dut "                entry 1"
      docli $dut "                    from"
      docli $dut "                        protocol bgp-vpn"
      docli $dut "                        community vprn1_importRouteTarget_[set ngbrDutId]"
      docli $dut "                    exit"
      docli $dut "                    action accept"
      docli $dut "                    exit"
      docli $dut "                exit"
      docli $dut "            exit"
      docli $dut "            commit"
      docli $dut "        exit all"
    }
    foreach {dut thisDutId ngbrDut ngbrDutId itfToNgbr} $redirectVprnDutList {
      # redirect rsvp part
      docli $dut "exit all"
      docli $dut "configure router"
      docli $dut "mpls"
      docli $dut "    path pathTo_[set ngbrDut]"
      docli $dut "        hop 1 [set [set ngbrDut]_ifsystem_ip] loose"
      docli $dut "        no shutdown"
      docli $dut "    exit"
      docli $dut "    lsp to_[set ngbrDut]"
      docli $dut "        to [set [set ngbrDut]_ifsystem_ip]"
      docli $dut "        primary pathTo_[set ngbrDut]"
      docli $dut "        exit"
      docli $dut "        no shutdown"
      docli $dut "    exit"
      docli $dut "    no shutdown"
      docli $dut "exit"
      docli $dut "exit all"
      # redirect service part
      docli $dut "configure service" -verbose $option(verbose)
      for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
        # add here the sdp's if needed
        if {$redirectVprnTunnelMethod == "sdp"} {
            switch $redirectVprnTunnelEncap {
              "gre" {
                docli $dut "" -verbose $option(verbose)
                docli $dut "sdp [set thisDutId][set ngbrDutId] gre create"
                docli $dut "    far-end [set [set ngbrDut]_ifsystem_ip]"
                docli $dut "    signaling off"
                docli $dut "    keep-alive"
                docli $dut "        shutdown"
                docli $dut "    exit"
                docli $dut "    no shutdown"
                docli $dut "exit"
              }
              "rsvp" {
                docli $dut "sdp [set thisDutId][set ngbrDutId] mpls create" -verbose $option(verbose)
                docli $dut "    far-end [set [set ngbrDut]_ifsystem_ip]"
                docli $dut "    lsp to_[set ngbrDut]"
                docli $dut "    signaling off"
                docli $dut "    keep-alive"
                docli $dut "        shutdown"
                docli $dut "    exit"
                docli $dut "    no shutdown"
                docli $dut "exit"
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | rsvp)" ; set Result FAIL ; break
              }
            }
        }
        # add here the vprn's
        set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
        docli $dut "        vprn $thisRedirectVprnId customer 1 create" -verbose $option(verbose)
        docli $dut "            no shutdown" -verbose $option(verbose)
        if {$vCnt == [expr $nbrRedirectVprn - 1] && $vrfTargetDirectUnderVprn_noImportPolicy} {
          log_msg INFO "Don't use vrf-import policy for the last vprn $thisRedirectVprnId"
          docli $dut "            vrf-target target:[set ngbrDutId][set thisDutId]:1" -verbose $option(verbose)
        } else {
          docli $dut "            vrf-import vprn_importPol_[set thisDutId]_[set ngbrDutId]" -verbose $option(verbose)
        }
        docli $dut "            vrf-export vprn_exportPol_[set thisDutId]" -verbose $option(verbose)
        docli $dut "            route-distinguisher $thisRedirectVprnId:1" -verbose $option(verbose)
        #
        switch $redirectVprnTunnelMethod {
          "autobind" {
            switch $redirectVprnTunnelEncap {
              "gre" {
                # ldp between dut2/dut4 is disabled
                docli $dut "            auto-bind gre" -verbose $option(verbose)
              }
              "ldp" {
                docli $dut "            auto-bind ldp" -verbose $option(verbose)
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | ldp)" ; set Result FAIL ; break
              }
            }
          }
          "sdp" {
            switch $redirectVprnTunnelEncap {
              "gre" {
                # ldp between dut2/dut4 is disabled ??? to be checked
                docli $dut "spoke-sdp [set thisDutId][set ngbrDutId] create" -verbose $option(verbose)
                docli $dut "no shutdown"
                docli $dut "exit"
              }
              "rsvp" {
                # ldp between dut2/dut4 is disabled
                docli $dut "spoke-sdp [set thisDutId][set ngbrDutId] create" -verbose $option(verbose)
                docli $dut "no shutdown"
                docli $dut "exit"
              }
              default {
                log_msg ERROR "Invalid redirectVprnTunnelEncap: $redirectVprnTunnelEncap (should be gre | rsvp)" ; set Result FAIL ; break
              }
            }
          }
          default {
            log_msg ERROR "Invalid redirectVprnTunnelMethod: $redirectVprnTunnelMethod (should be autobind | sdp)" ; set Result FAIL ; break
          }
        }
        if {$grtLookupEnableGrt} {
          docli $dut "            grt-lookup enable-grt" -verbose $option(verbose)
          docli $dut "            exit" -verbose $option(verbose)
        }
        docli $dut "        exit"  -verbose $option(verbose)
      }
      docli $dut "exit all" -verbose $option(verbose)
    }
    if {$epipeListToScrubber != ""} {
      foreach {epipeDut epipeId epipeFromPort epipeToPort} $epipeListToScrubber {
        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
          set thisVlanId [expr $vCnt + 1] ; set thisEpipeId [expr $epipeId + $vCnt]
          flowspec_createEpipe $epipeDut $thisEpipeId $epipeFromPort $epipeToPort -fromEncapType dot1q -fromSap "$epipeFromPort:$thisVlanId" -toEncapType dot1q -toSap "$epipeToPort:$thisVlanId"
        }
      }
    }
    log_msg INFO "$dut4: Create dot1q itfs (#$nbrRedirectVprn) via $portA($dut4.$dut5) and default-route (in vprn) to scrubber (Ixia $portA(Ixia.$dut3))"
    # create itf to scrubber (Ixia2)
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) shut"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) ethernet mode access"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) ethernet encap-type dot1q"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "configure port $portA($dut4.$dut5) no shut"] ; log_msg INFO "$rCli"
    set rCli [$dut4 sendCliCommand "environment no create"]
    for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
      set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
      set thisVlanId [expr $vCnt + 1]
      set rCli [$dut4 sendCliCommand "exit all"]
      set rCli [$dut4 sendCliCommand "configure service vprn $thisRedirectVprnId customer 1"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "interface toScrubber_[set thisVlanId] create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "sap $portA($dut4.$dut5):$thisVlanId create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "egress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "egress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
      foreach {thisA thisB thisC thisD} [split "1.66.9.$dataip(id.$dut3)" "."] {break} ; set thisB [expr $thisB + $vCnt]
      set rCli [$dut4 sendCliCommand "address $thisA.$thisB.$thisC.$thisD/$clnItfMask_v4"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "ipv6 address [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]/$clnItfMask_v6"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
      foreach {thisA thisB thisC thisD} [split "1.66.9.9" "."] {break} ; set thisB [expr $thisB + $vCnt]
      # Add here static-routes for the redirectToVrf vprn
      set b 1 ; set c [lindex $vprnIdOnlyList 0] ; set d 1
      foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        foreach thisAction $thisActionListPerVprn {
          if {$thisAction == "redirectVrf"} {
            set a [set a_[set thisAction]]
            set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
            set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
          }
        }
        incr c ; if {$c > 255} {set c 0 ; incr b}
      }
      if {$addFlowroutesInBase} {
        # - Don't reset b, c and d because they point to the next values to be used
        # - Use isis in the Base instance
        foreach thisAction $thisActionListPerVprn {
          if {$thisAction == "redirectVrf"} {
            set a [set a_[set thisAction]]
            set thisDstPrefix_v4 $a.$b.$c.$d ; set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
            set thisDstPrefixMask_v4 $thisDstPrefix_v4/$srMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$srMask_v6
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v4 next-hop $thisA.$thisB.$thisC.$thisD"] ; log_msg INFO "$rCli"
            set rCli [$dut4 sendCliCommand "static-route $thisDstPrefixMask_v6 next-hop [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD]"] ; log_msg INFO "$rCli"
          }
        }
      }
      #
      set rCli [$dut4 sendCliCommand "interface toScrubber_[set thisVlanId] create"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "static-arp $thisA.$thisB.$thisC.$thisD 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "ipv6 neighbor [ipv4ToIpv6 $thisA.$thisB.$thisC.$thisD] 00:00:00:00:00:99"] ; log_msg INFO "$rCli"
      set rCli [$dut4 sendCliCommand "exit"] ; log_msg INFO "$rCli"
    }

    if {$enableFilterTrace} {
      foreach dut $enableTraceDutList {
        docli $dut "debug trace trace-point module \"FILTER\" " -verbose $option(verbose)
        docli $dut "debug trace enable" -verbose $option(verbose)
        docli $dut "shell traceLimitDisable" -verbose $option(verbose)
      }
    }
    if {$enableBgpFlowspecTrace} {
      foreach dut $enableTraceDutList {
        docli $dut "debug trace trace-point module \"BGP\" " -verbose $option(verbose)
        docli $dut "debug trace trace-point module \"BGP_VPRN\" " -verbose $option(verbose)
        docli $dut "debug trace enable" -verbose $option(verbose)
        docli $dut "shell traceLimitDisable" -verbose $option(verbose)
        # enableBgpFlowspecTrace $dut
        # foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        #  enableBgpFlowspecTrace $dut2 -vprnId $thisVprnId
        # }
      }
    }
    foreach dut $dutList {
      $dut sendCliCommand "exit all"
    }

  } ; # config

    # Ixia part
    handlePacket -port $portA(Ixia.$dut1) -action stop
    set thisDA 00:00:00:00:00:[int2Hex1 $dataip(id.$dut1)]
    set totalNbrOfFlowroutes 0
    if { $option(redirectType) == "vrfToVrf" } {
        set thisDstPrefix_v4 85.1.2.1
        set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
    } elseif { $option(redirectType) == "grtToVrf" } {
        set thisDstPrefix_v4 85.1.5.1
        set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
    } elseif { $option(redirectType) == "vrfToGrt" } {
        set thisDstPrefix_v4 85.1.2.1
        set thisDstPrefix_v6 [ipv4ToIpv6 $thisDstPrefix_v4]
    }
    set thisDstPrefixMask_v4 $thisDstPrefix_v4/$clnItfMask_v4 ; set thisDstPrefixMask_v6 $thisDstPrefix_v6/$clnItfMask_v6
    set thisHandlePacketAction create

    if {$sendTraffic_v4} {
        if { $option(redirectType) == "vrfToVrf" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p \"2 0\" -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        } elseif { $option(redirectType) == "grtToVrf" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p \"2 0\" -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        } elseif { $option(redirectType) == "vrfToGrt" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p \"2 0\" -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        }
    }
    if {$sendTraffic_v6} {
        if { $option(redirectType) == "vrfToVrf" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p \"2 0\" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        } elseif { $option(redirectType) == "grtToVrf" } {
         log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p \"2 0\" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        } elseif { $option(redirectType) == "vrfToGrt" } {
          log_msg INFO "=> handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p \"2 0\" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
          handlePacket -port $portA(Ixia.$dut1) -dot1q 2 -dot1p "2 0" -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
        }
    }

    # scrubber
    handlePacket -port $portA(Ixia.$dut3) -action capture

    log_msg INFO "Wait till all vprn's are operational before installed action forward router"
    set nbrRedirectVprnOperStateUp 0
    foreach {dut} $checkIpFilterDutList {break}
    for {set rCnt 1} {$rCnt <= $option(maxRetryCnt)} {incr rCnt} {
      for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
        set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
        set rCli [$dut sendCliCommand "show service id $thisRedirectVprnId base | match \"Oper State\" "]
        # Admin State       : Up                  Oper State        : Up
        if {[regexp {.*Oper State[ ]+:[ ]+([A-Za-z]+).*} $rCli match vprnOperState]} {
          if {$vprnOperState == "Up"} {
            incr nbrRedirectVprnOperStateUp
          }
        }
      }
      if {$nbrRedirectVprnOperStateUp == $nbrRedirectVprn} {
        log_msg INFO "All redirectVprn are Up ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn)"
        log_msg INFO "" ; log_msg INFO "Display some interesting info for the redirect vprn's" ; log_msg INFO ""
        for {set vCnt 0} {$vCnt < $nbrRedirectVprn} {incr vCnt} {
          set thisRedirectVprnId [expr $redirectVprnId + $vCnt]
          set rCli [$dut sendCliCommand "show service id $thisRedirectVprnId all"] ; log_msg INFO "$rCli"
        }
        set rCli [$dut sendCliCommand "show router tunnel-table"] ; log_msg INFO "$rCli"
        if {$redirectVprnTunnelEncap == "rsvp"} {
          set rCli [$dut sendCliCommand "show router mpls lsp"] ; log_msg INFO "$rCli"
        }
        if {$redirectVprnTunnelMethod == "sdp"} {
          set rCli [$dut sendCliCommand "show service sdp detail"] ; log_msg INFO "$rCli"
        }
        break
      } else {
        if {$rCnt == $option(maxRetryCnt)} {
          log_msg ERROR "Not all redirectVprn ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn) are Up after $option(maxRetryCnt) retries" ; set Result FAIL
        } else {
          log_msg INFO "Waiting $option(interRetryTimeSec) sec ($rCnt/$option(maxRetryCnt)) till all redirectVprn ($nbrRedirectVprnOperStateUp / $nbrRedirectVprn) are Up ..." ; after [expr $option(interRetryTimeSec) * 100]
        }
      }
    }
#    if {! [testFailed] && $Result == "OK"} {
#      set mySubtest "Precondition: Waiting 5 secs and check that traffic flows from $dut1 to $dut6" ; after 5000
#      log_msg INFO "$mySubtest"
#      if {[checkTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs 5]} {
#        log_msg INFO "Traffic from $dut1 to $dut6 ok"
#      } else {
#        log_msg ERROR "Traffic from $dut1 to $dut6 nok" ; set Result FAIL
#      }
#      subtest "$mySubtest"
#    }

    # apply filters on $dut2
    cliCne $dut2 "/environment no create"
    foreach filterIpType "ip ipv6" {
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId2 action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId3 action forward"]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId4 action forward"]; log_msg INFO $rCli
    }

    log_msg INFO "$dut2: Apply ingress filter (ip/ipv6) $cntPktsViaFilter_filterId (on itf $dut1 => $dut2)"
    set vprnCnt 1
    foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
        if {$itfType_dut1dut2 == "spoke"} {
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        } else {
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
          set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        }
    }

#    if {! [testFailed] && $Result == "OK"} {
#      if {$enableFlowspecBeforeFlowroutesAreInjected} {
        # skip traffic check
#      } else {
#        set mySubtest "Check that traffic still flows from $dut1 to $dut6, because ingress action forward router is not yet applied"
#        log_msg INFO "$mySubtest"
#        if {[checkTrafficFlows $dut1 $dut6 $cntPktsViaFilter_filterId -trafficDurationSecs 5]} {
#          log_msg INFO "Traffic from $dut1 to $dut6 ok"
#        } else {
#          log_msg ERROR "Traffic from $dut1 to $dut6 nok" ; set Result FAIL
#        }
#        subtest "$mySubtest"
#      }
#    }
    if {! [testFailed] && $Result == "OK"} {
      if {$addDefFilterInLastVprnAfterFlowroutesAreInjected} {
        log_msg INFO "$dut2: Apply ingress filter (ip/ipv6) $cntPktsViaFilter_filterId (on itf $dut1 => $dut2)"
        set vprnCnt 1
        foreach {thisVprnId thisNbrFlowroutesPerVprn thisActionListPerVprn} $vprnIdList {
          if {$vprnCnt == $nbrVprns} {
            if {$itfType_dut1dut2 == "spoke"} {
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] spoke-sdp $dataip(sap.$thisVprnId.$dut2.$dataip(id.$dut1)) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
            } else {
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
              set rCli [$dut2 sendCliCommand "configure service vprn $thisVprnId interface to_[set dut1][set thisVprnId] sap $dataip(sap.$thisVprnId.$dut2.$dut1) ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
            }
          }
          incr vprnCnt
        }
      }
    }
    # configure filter $cntPktsViaFilter_filterId in Base router
    if {$addFlowroutesInBase} {
        set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_[set dut1][set baseDot1qTag] ingress filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO $rCli
    }

    # configure service name for target VPRN
    log_msg INFO "Configure service name for target VPRN: $firstRedirectVprnId"
    set rCli [$dut2 sendCliCommand "/configure service vprn $firstRedirectVprnId service-name \"Target VPRN 400\""]; log_msg INFO $rCli

    # Configure action forward router for filters on $dut2
    foreach filterIpType "ip ipv6" {
        if { $option(redirectType) == "vrfToGrt" } {
            set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward router Base"]; log_msg INFO $rCli
        } else {
            set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId action forward router $firstRedirectVprnId"]; log_msg INFO $rCli
        }
        set rCli [$dut2 sendCliCommand "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId2 action forward router service-name \"Target VPRN 400\""]; log_msg INFO $rCli
        set rCli [cliCne $dut2 "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId3 action forward router $firstRedirectVprnId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure filter [getVar4 $filterIpType]-filter $cntPktsViaFilter_filterId entry $filterEntryId4 action forward router service-name \"Target VPRN 400\""]; log_msg INFO $rCli
    }

    set rCli [$dut2 sendCliCommand "show filter ip $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
    set rCli [$dut2 sendCliCommand "show filter ipv6 $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"


    if { $option(redirectType) == "grtToVrf" } {
        log_msg INFO "Configure QoS policy and bind it to $dut2 IES SAP"
    } else {
        log_msg INFO "Configure QoS policy and bind it to $dut2 VPRN 2 SAP"
    }
    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "        sap-ingress 2 create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            queue 1 create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            queue 2 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            queue 3 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           queue 4 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           queue 5 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            queue 6 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            queue 7 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           queue 8 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           queue 9 profile-mode create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           queue 11 multipoint create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc af create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 4"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc be create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 2"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc ef create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 7"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc h1 create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 8"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc h2 create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 6"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc l1 create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 5"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc l2 create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "               queue 3"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           fc nc create"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "                queue 9"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "           exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "       exit"]; log_msg INFO $rCli
    set rCli [$dut2 sendCliCommand "   exit"]; log_msg INFO $rCli

    # modify port to IXIA on $dut1 to encap-type dot1q
    set rCli [$dut1 sendCliCommand "exit all"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure port $topoMap(Dut-A,1/1/3) shutdown"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia ingress no filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia ingress no filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia egress no filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia egress no filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia no port"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure port $topoMap(Dut-A,1/1/3) ethernet encap-type dot1q"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia port $topoMap(Dut-A,1/1/3):2"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia ingress filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia ingress filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia egress filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure router interface to_Ixia egress filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
    set rCli [$dut1 sendCliCommand "/configure port $topoMap(Dut-A,1/1/3) no shutdown"]; log_msg INFO $rCli

#interpreter

    # create IES service on $dut2 and $dut1 in case GRT to VRF redirect
    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_Dut-A5 ingress no filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_Dut-A5 ingress no filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_Dut-A5 no port"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router interface to_Dut-A5 shutdown"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "configure router no interface to_Dut-A5"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "    configure service"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        ies 300 customer 1 create"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            interface to_Dut-A5 create"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                address 5.1.2.2/24"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                mac 00:00:00:00:00:02"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                ipv6"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    address 3FFE::501:202/120"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                sap $topoMap(Dut-B,1/1/1):5 create"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    ingress"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                        filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                        filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                        qos 2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "    exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "configure router interface to_Dut-B5 no port"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "configure router interface to_Dut-B5 shutdown"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "configure router no interface to_Dut-B5"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "configure port $topoMap(Dut-A,1/1/1) ethernet mode access"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "    configure service"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "        ies 300 customer 1 create"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "            interface to_Dut-B5 create"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                address 5.1.2.1/24"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                mac 00:00:00:00:00:01"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                ipv6"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                    address 3FFE::501:201/120"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                sap $topoMap(Dut-A,1/1/1):5 create"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "    exit"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "/configure router static-route 85.1.5.0/24 next-hop 5.1.2.2"]; log_msg INFO $rCli
        set rCli [$dut1 sendCliCommand "/configure router static-route 3FFE::5501:500/120 next-hop 3FFE::501:202"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 5.1.2.50/32 next-hop 5.1.2.1 fc h2 priority high"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::501:232/128 next-hop 3FFE::501:201 fc h2 priority high"]; log_msg INFO $rCli
  
        # add to VPRN import policy FCs and priority - in order to distribute them via BGP IPv4/v6
#        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "    configure router"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        policy-options"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        begin"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "            policy-statement vprn_importPol_2_4"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                entry 1"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                    action accept"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                        fc ef priority high"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                    exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        commit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "    exit"]; log_msg INFO $rCli
    } elseif { $option(redirectType) == "vrfToVrf" } {
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 sap $topoMap(Dut-B,1/1/1):2 ingress qos 2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.1.2.1 fc h2 priority high"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::201:201 fc h2 priority high"]; log_msg INFO $rCli

        # add to VPRN import policy FCs and priority - in order to distribute them via BGP IPv4/v6
#        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "    configure router"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        policy-options"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        begin"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "            policy-statement vprn_importPol_2_4"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                entry 1"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                    action accept"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                        fc ef priority high"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                    exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        commit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "        exit"]; log_msg INFO $rCli
#        set rCli [$dut2 sendCliCommand "    exit"]; log_msg INFO $rCli
    } elseif { $option(redirectType) == "vrfToGrt" } {
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface to_Dut-A2 sap $topoMap(Dut-B,1/1/1):2 ingress qos 2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.1.2.1 fc h2 priority high"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::201:201 fc h2 priority high"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 85.1.0.0/16 next-hop 5.2.3.3 fc ef priority high"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::5501:0/112 next-hop 3FFE::502:303 fc ef priority high"]; log_msg INFO $rCli
    }
    after 2000
    # reconfigure FC and priority for routes, in order to test random combinations
    set configuredFc_src [lindex $possibleFcTypes [random [llength $possibleFcTypes]]]
    set configuredPriority_src [lindex $possiblePriorities [random [llength $possiblePriorities]]]
    set configuredFc_dst [lindex $possibleFcTypes [random [llength $possibleFcTypes]]]
    set configuredPriority_dst [lindex $possiblePriorities [random [llength $possiblePriorities]]]

    if { $configuredPriority_src == "undefined" } {
        set cmd "fc $configuredFc_src"
    } else {
        set cmd "fc $configuredFc_src priority $configuredPriority_src"
    }
    if { $configuredPriority_dst == "undefined" } {
        set cmd2 "fc $configuredFc_dst"
    } else {
        set cmd2 "fc $configuredFc_dst priority $configuredPriority_dst"
    }
    log_msg INFO "New values for source-based QPPB - FC: $configuredFc_src and priority: $configuredPriority_src"
    log_msg INFO "New values for destination-based QPPB - FC: $configuredFc_dst and priority: $configuredPriority_dst"

    if { $option(redirectType) == "grtToVrf" } {
        set rCli [$dut2 sendCliCommand "/configure router static-route 5.1.2.50/32 next-hop 5.1.2.1 $cmd"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::501:232/128 next-hop 3FFE::501:201 $cmd"]; log_msg INFO $rCli
        after 2000
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "    configure router"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        policy-options"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        begin"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            policy-statement vprn_importPol_2_4"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                entry 1"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    action accept"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                        $cmd2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        commit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "    exit"]; log_msg INFO $rCli
        after 3000
        if { $option(family) == "ipv4"} {
            set srcIp 5.1.2.50; set srcMask 32; set dstIp 85.1.5.1; set dstMask 32
        } else {
            set srcIp 3FFE::501:232; set srcMask 128; set dstIp 3FFE::5501:501; set dstMask 128
        }

        # verify source
        log_msg INFO "Verify configured FC and priority for source route lookup"
        set rCli [$dut2 sendCliCommand "show router route-table qos $option(family)"]; log_msg INFO $rCli
        verifyConfiguredQos $dut2 $option(family) false $srcIp $srcMask $configuredFc_src $configuredPriority_src 
        # verify destination
        log_msg INFO "Verify configured FC and priority for destination route lookup"
        set rCli [$dut2 sendCliCommand "show router 400 route-table qos $option(family)"]; log_msg INFO $rCli
        verifyConfiguredQos $dut2 $option(family) true $dstIp $dstMask $configuredFc_dst $configuredPriority_dst -serviceId 400

    } elseif { $option(redirectType) == "vrfToVrf" } {
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.1.2.1 $cmd"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::201:201 $cmd"]; log_msg INFO $rCli
        after 2000
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "    configure router"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        policy-options"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        begin"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            policy-statement vprn_importPol_2_4"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                entry 1"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    action accept"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                        $cmd2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                    exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        commit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "        exit"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "    exit"]; log_msg INFO $rCli
        after 3000
        if { $option(family) == "ipv4"} {
            set srcIp 2.1.2.50; set srcMask 32; set dstIp 85.1.2.1; set dstMask 32
        } else {
            set srcIp 3FFE::201:232; set srcMask 128; set dstIp 3FFE::5501:201; set dstMask 128
        }

        # verify source
        log_msg INFO "Verify configured FC and priority for source route lookup"
        set rCli [$dut2 sendCliCommand "show router 2 route-table qos $option(family)"]; log_msg INFO $rCli
        verifyConfiguredQos $dut2 $option(family) true $srcIp $srcMask $configuredFc_src $configuredPriority_src -serviceId 2
        # verify destination
        log_msg INFO "Verify configured FC and priority for destination route lookup"
        set rCli [$dut2 sendCliCommand "show router 400 route-table qos $option(family)"]; log_msg INFO $rCli
        verifyConfiguredQos $dut2 $option(family) true $dstIp $dstMask $configuredFc_dst $configuredPriority_dst -serviceId 400

    } elseif { $option(redirectType) == "vrfToGrt" } {
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 2.1.2.50/32 next-hop 2.1.2.1 $cmd"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure service vprn 2 static-route 3FFE::201:232/128 next-hop 3FFE::201:201 $cmd"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 85.1.0.0/16 next-hop 5.2.3.3 $cmd2"]; log_msg INFO $rCli
        set rCli [$dut2 sendCliCommand "/configure router static-route 3FFE::5501:0/112 next-hop 3FFE::502:303 $cmd2"]; log_msg INFO $rCli
        after 3000
        if { $option(family) == "ipv4"} {
            set srcIp 2.1.2.50; set srcMask 32; set dstIp 85.1.0.0; set dstMask 16
        } else {
            set srcIp 3FFE::201:232; set srcMask 128; set dstIp 3FFE::5501:0; set dstMask 112
        }

        # verify source
        log_msg INFO "Verify configured FC and priority for source route lookup"
        set rCli [$dut2 sendCliCommand "show router 2 route-table qos $option(family)"]; log_msg INFO $rCli
        verifyConfiguredQos $dut2 $option(family) true $srcIp $srcMask $configuredFc_src $configuredPriority_src -serviceId 2
        # verify destination
        log_msg INFO "Verify configured FC and priority for destination route lookup"
        set rCli [$dut2 sendCliCommand "show router route-table qos $option(family)"]; log_msg INFO $rCli
        verifyConfiguredQos $dut2 $option(family) false $dstIp $dstMask $configuredFc_dst $configuredPriority_dst
    }

    # enable the qos-route-lookup
    log_msg INFO "Enable the qos-route-lookup"
    foreach lookup "source destination" {

#        set queueTypeList "policer priority profile"
        set queueTypeList "priority profile"
        set profileList "in-profile out-profile undefined"
        set deiFlagList "true false"
        set trueFalseList "true false"
        set priorityList "high low"
        set queueTypeOriginal [lindex $queueTypeList [random [llength $queueTypeList]]]
        set queueTypeNew [lindex $queueTypeList [random [llength $queueTypeList]]]
        set profileOriginal [lindex $profileList [random [llength $profileList]]]
        set profileNew [lindex $profileList [random [llength $profileList]]]
        set deiFlagOriginal [lindex $deiFlagList [random [llength $deiFlagList]]]
        set deiFlagNew [lindex $deiFlagList [random [llength $deiFlagList]]]
        set vlanDE [lindex $trueFalseList [random [llength $trueFalseList]]]
        set priorityFirstStage [lindex $priorityList [random [llength $priorityList]]]

        if { $lookup == "source" } {
            set configPriority $configuredPriority_src
            set configFc $configuredFc_src
        } else {
            set configPriority $configuredPriority_dst
            set configFc $configuredFc_dst
        }

        set dot1pMappedFc $configFc
        while { $dot1pMappedFc == $configFc } {
            set dot1pMappedFc [ lindex $possibleFcTypes [random [llength $possibleFcTypes]] ]
        }
        if { $configFc == "" } {
           set configFcQueue $dot1pMappedFc
        } else {
           set configFcQueue $configFc
        }
        
        set action "-useDifferentFC true -queueTypeOriginal $queueTypeOriginal -queueTypeNew $queueTypeNew -profileOriginal $profileOriginal -profileNew $profileNew -deiFlagOriginal $deiFlagOriginal -deiFlagNew $deiFlagNew -vlanDE $vlanDE -priorityFirstStage $priorityFirstStage -qppbPriority \"$configPriority\""
        set cmdln "-dut $dut2 -sapIngressPolicyId 2 -networkPolicyId 2 -networkQueuePolicyName networkQueue -itfType sap -fcOriginal $dot1pMappedFc -fcNew \"$configFc\" -dot1p 2"

        array set actionArr $action

        log_msg DEBUG "Debug info: $action $cmdln"
        parray actionArr        

        set expectedChangeInQueueNumberIdx [getListIndex $fcToQueueMap(sap) $configFcQueue]
        set expectedChangeInQueueNumber [lindex $fcToQueueMap(sap) [expr $expectedChangeInQueueNumberIdx +1]]
        # config of qos policy parameters
        eval qppb_config_qos_parameters config $cmdln $action
        set rCli [videoCli $dut2 "/configure qos"]
        set qosConfig [videoCli $dut2 "info"]
   
        log_msg INFO "$qosConfig"
        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli

        set packetProfileAndPriority [eval qppb_calculatePacketProfileAndPriorityAtSap $action -fcNew [list $configFc]]

        log_msg INFO "The packet should show following behaviour $packetProfileAndPriority"
        log_msg INFO "We should only see changes in queue/policer $expectedChangeInQueueNumber"
        # collecting reference stats
        set queueNumbersForCollectingStats [eval qppb_createQueueNumbersForCollectingStats -majorItfType sap $cmdln $action]
        if { $actionArr(-vlanDE) == "true" } { set vlanDE 1 } else { set vlanDE 0 }

        if { $vlanDE == 1 } {
            if { $option(redirectType) == "vrfToVrf" || $option(redirectType) == "vrfToGrt" } {
                # configure SAP under VPRN to Ixia port 4
                set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure port $topoMap(Dut-B,1/1/8) ethernet mode hybrid"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure port $topoMap(Dut-B,1/1/8) no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "    configure service vprn 2"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "        interface to_Ixia_4 create"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            address 2.1.9.1/24"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            mac 00:00:00:00:09:01"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            ipv6"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                address 3FFE::201:901/120"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            sap $topoMap(Dut-B,1/1/8):2 create"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                ingress"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                    qos 2"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                    filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                    filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "      exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                set thisDA 00:00:00:00:09:01
            } else {
                set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure port $topoMap(Dut-B,1/1/8) ethernet mode hybrid"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/configure port $topoMap(Dut-B,1/1/8) no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "    configure service"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "        ies 300 customer 1 create"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            interface to_Ixia_4 create"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                address 2.1.9.1/24"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                mac 00:00:00:00:09:01"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                ipv6"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                    address 3FFE::201:901/120"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                sap $topoMap(Dut-B,1/1/8):5 create"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                    ingress"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                        filter ip $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                        filter ipv6 $cntPktsViaFilter_filterId"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                        qos 2"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                    exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "                exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "            exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "        no shutdown"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "        exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "    exit"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                set thisDA 00:00:00:00:09:01
            }    
            if {$sendTraffic_v4} {
                if { $option(redirectType) == "vrfToVrf" } {
                  log_msg INFO "=> handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p \"2 0\" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
                } elseif { $option(redirectType) == "grtToVrf" } {
                  log_msg INFO "=> handlePacket -port $portA(Ixia.$dut2) -dot1q 5 -dot1p \"2 0\" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 5 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 5 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 5.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
                } elseif { $option(redirectType) == "vrfToGrt" } {
                  log_msg INFO "=> handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p \"2 0\" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v4 -numDest 1 -src 2.1.2.50 -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
                }
            }
            if {$sendTraffic_v6} {
                if { $option(redirectType) == "vrfToVrf" } {
                  log_msg INFO "=> handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p \"2 0\" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
                } elseif { $option(redirectType) == "grtToVrf" } {
                 log_msg INFO "=> handlePacket -port $portA(Ixia.$dut2) -dot1q 5 -dot1p \"2 0\" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 5 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 5 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  5.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
                } elseif { $option(redirectType) == "vrfToGrt" } {
                  log_msg INFO "=> handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p \"2 0\" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action $thisHandlePacketAction"
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action create
                  handlePacket -port $portA(Ixia.$dut2) -dot1q 2 -dot1p "2 0" -vlanDE 1 -dst $thisDstPrefix_v6 -numDest 1 -src [ipv4ToIpv6  2.1.2.50] -numSource 1 -damac $thisDA -stream 1 -rate $pktRatePerStream -data $streamData_ISATMS -framesize $pktSize -rawProtocol $rawProtocol -action
                }
            }
        }
        if { $vlanDE == 1 } {
            set lookupInterface "to_Ixia_4"
            set ixiaPort $portA(Ixia.$dut2)
            set sap $topoMap(Dut-B,1/1/8)
        } else {
            if { $option(redirectType) == "grtToVrf" } {
                set lookupInterface "to_Dut-A5"
            } else {
                set lookupInterface "to_Dut-A2"
            }
            set ixiaPort $portA(Ixia.$dut1)
            set sap $topoMap(Dut-B,1/1/1)
        }

        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "Enable the qos-route-lookup $lookup on ies interface"
            if { $option(family) == "ipv4"} {
                set rCli [$dut2 sendCliCommand "/configure service ies 300 interface $lookupInterface qos-route-lookup $lookup"]; log_msg INFO $rCli
            } else {
                set rCli [$dut2 sendCliCommand "/configure service ies 300 interface $lookupInterface ipv6 qos-route-lookup $lookup"]; log_msg INFO $rCli
            }
            log_msg INFO "--------------------------------------"
            log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
            log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
            log_msg INFO "--------------------------------------"

        } elseif { $option(redirectType) == "vrfToVrf" } {
            log_msg INFO "Enable the qos-route-lookup $lookup on vprn interface"
            if { $option(family) == "ipv4"} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface qos-route-lookup $lookup"]; log_msg INFO $rCli
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface ipv6 qos-route-lookup $lookup"]; log_msg INFO $rCli
            }
            log_msg INFO "--------------------------------------"
            log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
            log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
            log_msg INFO "--------------------------------------"

        } elseif { $option(redirectType) == "vrfToGrt" } {
            log_msg INFO "Enable the qos-route-lookup $lookup on vprn interface"
            if { $option(family) == "ipv4"} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface qos-route-lookup $lookup"]; log_msg INFO $rCli
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface ipv6 qos-route-lookup $lookup"]; log_msg INFO $rCli
            }
            log_msg INFO "--------------------------------------"
            log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
            log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
            log_msg INFO "--------------------------------------"
        }

        if { $option(redirectType) == "grtToVrf" } {
            set vlan 5
            set serviceId 300
        } else {
            set vlan 2
            set serviceId 2
        }

# interpreter

        switch -- [lindex $packetProfileAndPriority 0] {
            profile - priority - network {
                set expectedNumberOfDifferences 2
                set rCli [$dut2 sendCliCommand "/clear service statistics sap $sap:$vlan all"]; log_msg INFO $rCli
                set originalStatistics [qppb_collectIngressQueueStats -dut $dut2 -type sap -serviceId $serviceId -port $sap:$vlan -captureIngressQueues "$queueNumbersForCollectingStats"]
                log_msg DEBUG "Original statistics: $originalStatistics"
                log_msg INFO "Clear filter counters"
                if {$option(family) == "ipv4"} {
                    set fTxt "ip"
                } else {
                    set fTxt "ipv6"
                }
                set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                after 1000
                handlePacket -port $ixiaPort -action start ; after 5000
                handlePacket -port $ixiaPort -action stop ; after 2000
                # verify
                set difference [qppb_waitForTwoChangesInStats -dut $dut2 -type sap -serviceId $serviceId -port $sap:$vlan -captureIngressQueues "$queueNumbersForCollectingStats" -originalStatistics $originalStatistics -expectedNumberOfDifferences $expectedNumberOfDifferences -expectedChangeInQueueNumber $expectedChangeInQueueNumber]
                log_msg INFO "Stats difference: $difference"
                # verify redirected traffic
                if { $option(redirectType) == "grtToVrf" } {
                    getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut2 -match "entry 1 dir ingress version $option(family) count !=0" -errorIfNotFound true
                }
                if { $option(redirectType) == "vrfToGrt" } {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                }
                set subtestError [evaluateStatisticsBasedOnPacketBehaviour -difference $difference -queueNumber $expectedChangeInQueueNumber -behaviour "$packetProfileAndPriority" -totalNumberOfQueuesShowingChanges 1]
                if { $subtestError == "ERROR"} {
                    log_msg ERROR "Evaluation of statistics FAILED"
                    log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
                    log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
                    set rCli [$dut2 sendCliCommand "show service id $serviceId sap $sap:$vlan detail"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "info"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                }
                # perform rollback
                log_msg INFO "--------------------------------------"
                log_msg INFO "Perform rollback"
                log_msg INFO "--------------------------------------"
                log_msg INFO "Create rollback checkpoint, remove configuration and restore via rollback revert"
                set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "admin rollback save"] ; log_msg INFO "$rCli"
                #
                after 1000
                saveOrRestore delete -dut $dut2
                after 1000
                # configure rollback-location again because it was removed during saveOrRestore delete
                set rCli [$dut2 sendCliCommand "configure system rollback rollback-location $rollbackLocation/fwdRtrVprnTesting"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "admin rollback revert latest-rb now"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "admin rollback delete latest-rb"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "configure system rollback no rollback-location"] ; log_msg INFO "$rCli"
                log_msg INFO "Waiting 20secs ...." ; after 20000
                if { $option(redirectType) == "grtToVrf" } {
                    log_msg INFO "Verify configured FC and priority for source route lookup"
                    verifyConfiguredQos $dut2 $option(family) false $srcIp $srcMask $configuredFc_src $configuredPriority_src
                    log_msg INFO "Verify configured FC and priority for destination route lookup"
                    verifyConfiguredQos $dut2 $option(family) true $dstIp $dstMask $configuredFc_dst $configuredPriority_dst -serviceId 400
                } elseif { $option(redirectType) == "vrfToVrf" } {
                    log_msg INFO "Verify configured FC and priority for source route lookup"
                    verifyConfiguredQos $dut2 $option(family) true $srcIp $srcMask $configuredFc_src $configuredPriority_src -serviceId 2
                    log_msg INFO "Verify configured FC and priority for destination route lookup"
                    verifyConfiguredQos $dut2 $option(family) true $dstIp $dstMask $configuredFc_dst $configuredPriority_dst -serviceId 400
                } elseif { $option(redirectType) == "vrfToGrt" } {
                    log_msg INFO "Verify configured FC and priority for source route lookup"
                    verifyConfiguredQos $dut2 $option(family) true $srcIp $srcMask $configuredFc_src $configuredPriority_src -serviceId 2
                    log_msg INFO "Verify configured FC and priority for destination route lookup"
                    verifyConfiguredQos $dut2 $option(family) false $dstIp $dstMask $configuredFc_dst $configuredPriority_dst
                }
                log_msg INFO "Clear filter counters"
                if {$option(family) == "ipv4"} {
                    set fTxt "ip"
                } else {
                    set fTxt "ipv6"
                }
                set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                after 1000
                handlePacket -port $ixiaPort -action start ; after 5000
                handlePacket -port $ixiaPort -action stop ; after 2000
                # verify
                set difference [qppb_waitForTwoChangesInStats -dut $dut2 -type sap -serviceId $serviceId -port $sap:$vlan -captureIngressQueues "$queueNumbersForCollectingStats" -originalStatistics $originalStatistics -expectedNumberOfDifferences $expectedNumberOfDifferences -expectedChangeInQueueNumber $expectedChangeInQueueNumber]
                log_msg INFO "Stats difference: $difference"
                # verify redirected traffic
                if { $option(redirectType) == "grtToVrf" } {
                    getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut2 -match "entry 1 dir ingress version $option(family) count !=0" -errorIfNotFound true
                }
                if { $option(redirectType) == "vrfToGrt" } {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                }
                set subtestError [evaluateStatisticsBasedOnPacketBehaviour -difference $difference -queueNumber $expectedChangeInQueueNumber -behaviour "$packetProfileAndPriority" -totalNumberOfQueuesShowingChanges 1]
                if { $subtestError == "ERROR"} {
                    log_msg ERROR "Evaluation of statistics FAILED"
                    log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
                    log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
                    set rCli [$dut2 sendCliCommand "show service id $serviceId sap $sap:$vlan detail"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "info"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                }
                # verify QPPB interaction with GRT leak
                if {$lookup == "destination" && $option(redirectType) != "grtToVrf"} {
                    log_msg INFO "--------------------------------------"
                    log_msg INFO "Verify QPPB interaction with GRT leak (only in case qos-route-lookup destination is enabled)"
                    log_msg INFO "--------------------------------------"
                    set rCli [$dut2 sendCliCommand "/configure service vprn 2 grt-lookup enable-grt"] ; log_msg INFO "$rCli"
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "/clear service statistics sap $sap:$vlan all"]; log_msg INFO $rCli
                    log_msg INFO "Clear filter counters"
                    if {$option(family) == "ipv4"} {
                        set fTxt "ip"
                    } else {
                        set fTxt "ipv6"
                    }
                    set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                    set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                    set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                    after 1000
                    handlePacket -port $ixiaPort -action start ; after 5000
                    handlePacket -port $ixiaPort -action stop ; after 2000
                    # verify
                    set difference [qppb_waitForTwoChangesInStats -dut $dut2 -type sap -serviceId $serviceId -port $sap:$vlan -captureIngressQueues "$queueNumbersForCollectingStats" -originalStatistics $originalStatistics -expectedNumberOfDifferences $expectedNumberOfDifferences -expectedChangeInQueueNumber $expectedChangeInQueueNumber]
                    log_msg INFO "Stats difference: $difference"
                    # verify redirected traffic
                    if { $option(redirectType) == "grtToVrf" } {
                        getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version $option(family) count !=0" -errorIfNotFound true
                    } else {
                        getFilter -print true -dut $dut2 -match "entry 1 dir ingress version $option(family) count !=0" -errorIfNotFound true
                    }
                    if { $option(redirectType) == "vrfToGrt" } {
                        getFilter -print true -dut $dut6 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                    } else {
                        getFilter -print true -dut $dut4 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                    }
                    set subtestError [evaluateStatisticsBasedOnPacketBehaviour -difference $difference -queueNumber $expectedChangeInQueueNumber -behaviour "$packetProfileAndPriority" -totalNumberOfQueuesShowingChanges 1]
                    if { $subtestError == "ERROR"} {
                        log_msg ERROR "Evaluation of statistics FAILED"
                        log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
                        log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
                        set rCli [$dut2 sendCliCommand "show service id $serviceId sap $sap:$vlan detail"]; log_msg INFO $rCli
                        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                        set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
                        set rCli [$dut2 sendCliCommand "info"]; log_msg INFO $rCli
                        set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    }
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 grt-lookup no enable-grt"] ; log_msg INFO "$rCli"
                set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                }
                # verify QPPB interaction with uRPF-check strict|loose|strict-no-ecmp
                set urpfList {strict loose strict-no-ecmp}
                set urpf [lindex $urpfList [random [llength $urpfList]]]
                if { $vlanDE == 1 } {
                    set urpf loose
                }
                log_msg INFO "--------------------------------------"
                log_msg INFO "Verify QPPB interaction with uRPF-check in mode $urpf"
                log_msg INFO "--------------------------------------"
                if {$option(family) == "ipv4"} {
                    set cmd ""
                } else {
                    set cmd "ipv6"
                }
                if {$option(redirectType) == "grtToVrf"} {
                    set rCli [$dut2 sendCliCommand "/configure service ies 300 interface $lookupInterface $cmd urpf-check mode $urpf"] ; log_msg INFO "$rCli"
                } else {
                    set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface $cmd urpf-check mode $urpf"] ; log_msg INFO "$rCli"
                }
                set rCli [$dut2 sendCliCommand "/clear service statistics sap $sap:$vlan all"]; log_msg INFO $rCli
                log_msg INFO "Clear filter counters"
                if {$option(family) == "ipv4"} {
                    set fTxt "ip"
                } else {
                    set fTxt "ipv6"
                }
                set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                after 1000
                handlePacket -port $ixiaPort -action start ; after 5000
                handlePacket -port $ixiaPort -action stop ; after 2000
                # verify
                set difference [qppb_waitForTwoChangesInStats -dut $dut2 -type sap -serviceId $serviceId -port $sap:$vlan -captureIngressQueues "$queueNumbersForCollectingStats" -originalStatistics $originalStatistics -expectedNumberOfDifferences $expectedNumberOfDifferences -expectedChangeInQueueNumber $expectedChangeInQueueNumber]
                log_msg INFO "Stats difference: $difference"
                # verify redirected traffic
                if { $option(redirectType) == "grtToVrf" } {
                    getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut2 -match "entry 1 dir ingress version $option(family) count !=0" -errorIfNotFound true
                }
                if { $option(redirectType) == "vrfToGrt" } {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                }
                set subtestError [evaluateStatisticsBasedOnPacketBehaviour -difference $difference -queueNumber $expectedChangeInQueueNumber -behaviour "$packetProfileAndPriority" -totalNumberOfQueuesShowingChanges 1]
                if { $subtestError == "ERROR"} {
                    log_msg ERROR "Evaluation of statistics FAILED"
                    log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
                    log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
                    set rCli [$dut2 sendCliCommand "show service id $serviceId sap $sap:$vlan detail"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "info"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                }
                if {$option(redirectType) == "grtToVrf"} {
                    set rCli [$dut2 sendCliCommand "/configure service ies 300 interface $lookupInterface $cmd no urpf-check"] ; log_msg INFO "$rCli"
                } else {
                    set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface $cmd no urpf-check"] ; log_msg INFO "$rCli"
                }

            }
            policer {
                set policerIdIdx [getListIndex $fcToQueueMap(sap) "$configFcQueue"]
                set policerId [lindex $fcToQueueMap(sap) [expr $policerIdIdx + 1]]
                # stage 1: offered-priority-no-cir
                set rCli [$dut2 sendCliCommand "/configure qos sap-ingress 2 policer $policerId stat-mode offered-priority-no-cir"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/clear service statistics sap $topoMap(Dut-B,1/1/1):$vlan all"]; log_msg INFO $rCli
                set originalStatistics [qppb_collectIngressQueueStats -dut $dut2 -type sap -serviceId $serviceId -port $topoMap(Dut-B,1/1/1):$vlan -captureIngressQueues "$queueNumbersForCollectingStats"]
                log_msg DEBUG "Original statistics: $originalStatistics"
                log_msg INFO "Clear filter counters"
                if {$option(family) == "ipv4"} {
                    set fTxt "ip"
                } else {
                    set fTxt "ipv6"
                }
                set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                after 1000
                handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                # verify
                set difference [qppb_waitForTwoChangesInStats -dut $dut2 -type sap -serviceId $serviceId -port $topoMap(Dut-B,1/1/1):$vlan -captureIngressQueues "$queueNumbersForCollectingStats" -originalStatistics $originalStatistics]
                log_msg INFO "Stats difference: $difference"
                # verify redirected traffic
                if { $option(redirectType) == "grtToVrf" } {
                    getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut2 -match "entry 1 dir ingress version $option(family) count !=0" -errorIfNotFound true
                }
                if { $option(redirectType) == "vrfToGrt" } {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                }
                set subtestErrorVal1 [evaluateStatisticsBasedOnPacketBehaviour -difference $difference -queueNumber $expectedChangeInQueueNumber -behaviour "$packetProfileAndPriority" -totalNumberOfQueuesShowingChanges 1]
                if { $subtestErrorVal1 == "ERROR"} {
                    log_msg ERROR "Evaluation of statistics FAILED"
                    log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
                    log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
                    set rCli [$dut2 sendCliCommand "show service id $serviceId sap $topoMap(Dut-B,1/1/1):$vlan detail"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "info"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                }
                # stage 2: offered-profile-cir stats mode
                set rCli [$dut2 sendCliCommand "/configure qos sap-ingress 2 policer $policerId stat-mode offered-profile-cir"]; log_msg INFO $rCli
                set rCli [$dut2 sendCliCommand "/clear service statistics sap $topoMap(Dut-B,1/1/1):$vlan all"]; log_msg INFO $rCli
                set originalStatistics [qppb_collectIngressQueueStats -dut $dut2 -type sap -serviceId $serviceId -port $topoMap(Dut-B,1/1/1):$vlan -captureIngressQueues "$queueNumbersForCollectingStats"]
                log_msg DEBUG "Original statistics: $originalStatistics"
                log_msg INFO "Clear filter counters"
                if {$option(family) == "ipv4"} {
                    set fTxt "ip"
                } else {
                    set fTxt "ipv6"
                }
                set rCli [$dut2 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut4 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                set rCli [$dut6 sendCliCommand "clear filter $fTxt $cntPktsViaFilter_filterId"] ; log_msg INFO "$rCli"
                after 1000
                handlePacket -port $portA(Ixia.$dut1) -action start ; after 5000
                handlePacket -port $portA(Ixia.$dut1) -action stop ; after 2000
                # verify
                set difference [qppb_waitForTwoChangesInStats -dut $dut2 -type sap -serviceId $serviceId -port $topoMap(Dut-B,1/1/1):$vlan -captureIngressQueues "$queueNumbersForCollectingStats" -originalStatistics $originalStatistics]
                log_msg INFO "Stats difference: $difference"
                # verify redirected traffic
                if { $option(redirectType) == "grtToVrf" } {
                    getFilter -print true -dut $dut2 -match "entry 65535 dir ingress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut2 -match "entry 1 dir ingress version $option(family) count !=0" -errorIfNotFound true
                }
                if { $option(redirectType) == "vrfToGrt" } {
                    getFilter -print true -dut $dut6 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                } else {
                    getFilter -print true -dut $dut4 -match "entry 1 dir egress version $option(family) count !=0" -errorIfNotFound true
                }
                set subtestErrorVal2  [evaluateStatisticsBasedOnPacketBehaviour -difference $difference -queueNumber $expectedChangeInQueueNumber -behaviour "$packetProfileAndPriority" -totalNumberOfQueuesShowingChanges 1]
                if { $subtestErrorVal2 == "ERROR"} {
                    log_msg ERROR "Evaluation of statistics FAILED"
                    log_msg INFO "Testing redirect: $option(redirectType); lookup: $lookup"
                    log_msg INFO "Dot1p mapped FC: $dot1pMappedFc <-> Qppb mapped FC \"$configFc\" (with prio: \"$configPriority\")"
                    set rCli [$dut2 sendCliCommand "show service id $serviceId sap $topoMap(Dut-B,1/1/1):$vlan detail"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "configure qos"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "info"]; log_msg INFO $rCli
                    set rCli [$dut2 sendCliCommand "exit all"]; log_msg INFO $rCli
                }
                if { $subtestErrorVal1 != "noError" || $subtestErrorVal2 != "noError" } { set subtestError ERROR }    
            }
        }
        if { $option(redirectType) == "grtToVrf" } {
            log_msg INFO "Disable the qos-route-lookup $lookup on ies interface"
            if { $option(family) == "ipv4"} {
                set rCli [$dut2 sendCliCommand "/configure service ies 300 interface $lookupInterface no qos-route-lookup"]; log_msg INFO $rCli
            } else {
                set rCli [$dut2 sendCliCommand "/configure service ies 300 interface $lookupInterface ipv6 no qos-route-lookup"]; log_msg INFO $rCli
            }
        } elseif { $option(redirectType) == "vrfToVrf" } {
            log_msg INFO "Disable the qos-route-lookup $lookup on vprn interface"
            if { $option(family) == "ipv4"} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface no qos-route-lookup"]; log_msg INFO $rCli
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface ipv6 no qos-route-lookup"]; log_msg INFO $rCli
            }
        } elseif { $option(redirectType) == "vrfToGrt" } {
            log_msg INFO "Disable the qos-route-lookup $lookup on vprn interface"
            if { $option(family) == "ipv4"} {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface no qos-route-lookup"]; log_msg INFO $rCli
            } else {
                set rCli [$dut2 sendCliCommand "/configure service vprn 2 interface $lookupInterface ipv6 no qos-route-lookup"]; log_msg INFO $rCli
            }
        }
    }

    if { ($subtestError == "noError") && ($Result == "OK") } {
        log_result PASSED "Test Case $testID PASSED"
    } else {
        log_result FAILED "Test Case $testID FAILED"
    }

    if {$option(deconfig)} {
      saveOrRestore delete
    }

}
