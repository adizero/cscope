/**************************************************************************
*
*   Filename:           smgr_mesg.c
*
*   Author:             Marcelo Mourier
*   Created:            Thu Nov  9 14:28:01 2000
*
*   Description:        Messages sent to the IOMs
*
*
*
***************************************************************************
*
*                 Source Control System Information
*
*   $Id: smgr_mesg.c,v 1.1419 2013/04/18 09:05:05 meulek2 Exp $
*
***************************************************************************
*
*              Copyright (c) 2000-2013 TiMetra Networks, Inc., Alcatel, Alcatel-Lucent
*
**************************************************************************/

#ifdef RCSID
static const char rcsid[] = "$Id: smgr_mesg.c,v 1.1419 2013/04/18 09:05:05 meulek2 Exp $";
#endif

#include <intLib.h>
#include <semLib.h>
#include <stdio.h>
#include <string.h>

#include "agent/agent_api.h"
#include "agent/gen/alcatel_igmp_snooping_mib.h"
#include "agent/gen/timetra_eth_ring_mib.h"
#include "agent/gen/timetra_qos_mib.h"
#include "agent/gen/timetra_serv_mib.h"
#include "agent/sia_esas_sap.h"
#include "agent/sia_esas_serv.h"
#include "agent/sia_qos.h"
#include "atm/atm_api.h"
#include "bb/bb_api.h"
#include "chmgr/chmgr_chassis_api.h"
#include "chmgr/red_api.h"
#include "chmgr/red_mod.h"            // RED_Module_Smgr
#include "cli/cli_custom_env.h"
#include "cli/cli_printf.h"
#include "common/bit_util.h"
#include "common/fc_types.h"
#include "common/format_ip.h"
#include "common/format_mac.h"
#include "common/gen/mod_sm_mesg.h"
#include "common/gen/timos_build_type_beta.h"
#include "common/gen/timos_feature_sub_egr_arl_ovr_hsmda.h"
#include "common/gen/timos_feature_vmm.h"
#include "common/gen/timos_feature_smgr_buffered_download.h"
#include "common/ip_util.h"
#include "common/mac_types.h"
#include "common/mem_info.h"
#include "common/portid.h"
#include "common/str_util.h"
#include "common/vmm.h"
#include "debug/debug.h"
#include "dot1ag/dot1ag_smgr_api.h"
#include "filter/filter_api.h"    // getPortRngVal. 
#include "fr/fr_api.h"
#include "gtp_api/gtp_api.h"
#include "iom_api/iom_filter_msg.h"
#include "iom_api/iom_ip_msg.h"
#include "iom_api/iom_qmda_msg.h"
#include "iom_api/iom_qos_common.h"
#include "iom_api/iom_qos_msg.h"
#include "iom_api/iom_subscriber_msg.h"
#include "iom_api/iom_svc_msg.h"
#include "iom_api/iom_svc_types.h"
#include "l2tp/l2tp_api.h"
#include "mplsng/mpls_lmgr.h"     // MPLS_LMGR_USER_SVCMGR
#include "oam/oam_util.h"
#include "platform/icc_api.h"
#include "platform/sf_api.h"
#include "platform/sf_mapping.h"
#include "pmgr/isaaagrp_api.h"
#include "pmgr/mcr_ring.h"
#include "qos/qos_acc_impl.h"     // SM is a 'friend' of QoS  :)
#include "rchips/qchip_common.h"
#include "svcmgr/cem.h"           // cemRetrieveIOMInfo()
#include "svcmgr/cust.h"
#include "svcmgr/dhcp_snooping.h"
#include "svcmgr/dpi_smgr_impl.h"
#include "svcmgr/dpi_smgr_transit_ip.h"
#include "svcmgr/dpi_smgr_transit_prefix.h"
#include "svcmgr/ies.h"
#include "svcmgr/igmp_snooping.h"
#include "svcmgr/ipipe.h"
#include "svcmgr/mc_endpoint_api.h"
#include "svcmgr/mirror.h"
#include "svcmgr/mrp.h"
#include "svcmgr/msap.h"
#include "svcmgr/pppoe_api.h"
#include "svcmgr/pw_port.h"
#include "svcmgr/qos.h"
#include "svcmgr/sap.h"
#include "svcmgr/sbind.h"
#include "svcmgr/sdp.h"
#include "svcmgr/smgr_api.h"
#include "svcmgr/smgr_dndler.h"
#include "svcmgr/smgr_dndler_api.h"
#include "svcmgr/smgr_impl.h"
#include "svcmgr/smgr_mesg.h"
#include "svcmgr/smgr_mesg_api.h"
#include "svcmgr/smgr_mesg_impl.h"
#include "svcmgr/smgr_msgr.h"
#include "svcmgr/smgr_msgr_api.h"
#include "svcmgr/smgr_red.h"
#include "svcmgr/smgr_srrp_mcring.h"
#include "svcmgr/submgt.h"
#include "svcmgr/submgt_acct.h"
#include "svcmgr/submgt_dpi.h"
#include "svcmgr/submgt_gtp.h"
#include "svcmgr/submgt_impl.h"
#include "svcmgr/submgt_radli.h"
#include "svcmgr/submgt_rtm.h"
#include "svcmgr/submgt_sqo.h"
#include "svcmgr/submgt_util.h"
#include "svcmgr/submgt_v6.h"
#include "svcmgr/subscr_host_tracking_api.h"
#include "svcmgr/tls_fdb.h"
#include "svcmgr/tls_mim.h"
#include "svcmgr/tls_shg.h"
#include "svcmgr/trstp.h"
#include "svcmgr/utils.h"
#include "uss/uss_api.h"
#include "vrrp/vrrp_define.h"     // SRRP_STATE_*


// Due to 106576 the IOM needs more work to deal with ghost SAPs.
// As a temp solution we will continue to download sub hosts.
#define SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub)       \
    (PORT_IS_OPERSTATE_PRESENT((pActSub)->pPortRec))

/* Update stats of data sent to the IOM */
#define SMGR_MESG_UPDATE_NUM_STATS(pIccInfo, Num, PreFlush)     \
    do {                                                        \
        if ((pIccInfo)->pStats) {                               \
            (pIccInfo)->pStats->EntryUpdate += (Num);           \
            (pIccInfo)->pStats->MesgUpdate++;                   \
            if (PreFlush) {                                     \
                (pIccInfo)->pStats->MesgPreFlush++;             \
            }                                                   \
        }                                                       \
    } while (FALSE)

#define SMGR_MESG_UPDATE_STATS(pIccInfo, pIomRequest, PreFlush) \
    SMGR_MESG_UPDATE_NUM_STATS(pIccInfo, (pIomRequest)->NumEntries, PreFlush)
          
/* The order in this enum determines the order items are downloaded */
typedef enum {
    SmgrMsgrEntry_Start = 0,
    SmgrMsgrEntry_DpiIp,
    SmgrMsgrEntry_DpiPrefix,
    SmgrMsgrEntry_SdpBindStats,
    SmgrMsgrEntry_SysWide,
    SmgrMsgrEntry_L2tp,
    SmgrMsgrEntry_Gtp,
    SmgrMsgrEntry_Sdp,
    SmgrMsgrEntry_QosSchedPol,
    SmgrMsgrEntry_QosPolicerCtrlPol,
    SmgrMsgrEntry_QosSapIngPol,
    SmgrMsgrEntry_QosSapIngPolIpFilter,
    SmgrMsgrEntry_QosSapIngPolMacFilter,
    SmgrMsgrEntry_QosSapEgrPol,
    SmgrMsgrEntry_QosSapEgrPolIpFilter,
    SmgrMsgrEntry_QosMss,
    SmgrMsgrEntry_QosMssVsO,
    SmgrMsgrEntry_Emg,
    SmgrMsgrEntry_Svc,
    SmgrMsgrEntry_SvcTls,
    SmgrMsgrEntry_GtpBind,
    SmgrMsgrEntry_L2tpBind,
    SmgrMsgrEntry_SdpBind,
    SmgrMsgrEntry_SdpBindLoopBack,
    SmgrMsgrEntry_Sap,
    SmgrMsgrEntry_SapCfmPrimVlan,
    SmgrMsgrEntry_SapLoopBack,
    SmgrMsgrEntry_TlsFdb,
    SmgrMsgrEntry_TlsFdbQuery,
    SmgrMsgrEntry_MirrorSvcRemote,
    SmgrMsgrEntry_MirrorSvcLocal,
    SmgrMsgrEntry_MfibTls,
    SmgrMsgrEntry_UssCatMap,
    SmgrMsgrEntry_SbmSubProfile,
    SmgrMsgrEntry_SbmSubProfileSchedOvr,
    SmgrMsgrEntry_SbmSubProfilePlcrCtrlOvr,
    SmgrMsgrEntry_SbmSubProfileHsmda2EgrQOvr,
    SmgrMsgrEntry_SbmSLAProfile,
    SmgrMsgrEntry_SbmSLAProfileIngQOvr,
    SmgrMsgrEntry_SbmSLAProfileEgrQOvr,
    SmgrMsgrEntry_SbmSLAProfileIngPlcrOvr,
    SmgrMsgrEntry_SbmSLAProfileEgrPlcrOvr,
    SmgrMsgrEntry_SbmSLAProfileSchedOvr,
    SmgrMsgrEntry_SbmActSub,
    SmgrMsgrEntry_SbmSubSchedOvr,
    SmgrMsgrEntry_SbmSubIesIfGroupIf,
    SmgrMsgrEntry_SbmSubIesIfGroupIfRingNode,
    SmgrMsgrEntry_SbmSubHost,
    SmgrMsgrEntry_SbmPppoeLnsSubHost,
    SmgrMsgrEntry_SapIngSchedPlcyOvr,
    SmgrMsgrEntry_SapEgrSchedPlcyOvr,
    SmgrMsgrEntry_SapIngPlcrCtrlOvr,
    SmgrMsgrEntry_SapEgrPlcrCtrlOvr,
    SmgrMsgrEntry_SapIngQOvr,
    SmgrMsgrEntry_SapEgrQOvr,
    SmgrMsgrEntry_SapIngPlcrOvr,
    SmgrMsgrEntry_SapEgrPlcrOvr,
    SmgrMsgrEntry_SapEgrQmdaQOvr,
    SmgrMsgrEntry_SbmSubQosOvr,
    SmgrMsgrEntry_SapEgrEncapGroup,
    SmgrMsgrEntry_SapEgrEncapMember,
    /* Do NOT just add to the end. Order is important */
} eSmgrMsgr_Entry;

typedef struct VirtSchedEntryInfo {
    tUint32 FrameBasedAccnt;
    tUint32 EntryNum;
} tVirtSchedEntryInfo; 



struct SmgrMsgrEntry SmgrMsgr_DownloadTable[];
tUint32 SmgrMsgr_DownloadTableNumEntries;

/* Maximum number of entries that can be packed in a single
 * ICC request, without causing fragmentation.
 */
PRIVATE int SMMaxNumSvcAddEntriesPerMesg;
PRIVATE int SMMaxNumSvcDelEntriesPerMesg;
PRIVATE int SMMaxNumSvcVirtPortEntriesPerMesg;
PUBLIC  int SMMaxNumSvcTlsFloodEntriesPerMesg;
PRIVATE int SMMaxNumSvcTlsEntriesPerMesg;
PRIVATE int SMMaxNumSapAddEntriesPerMesg;
PRIVATE int SMMaxNumSapDelEntriesPerMesg;
PRIVATE int SMMaxNumSapSwitchEntriesPerMesg;
PRIVATE int SMMaxNumSapStateEntriesPerMesg;
PUBLIC  int SMMaxNumSapMcListPruneAndMvrpEntriesPerMesg;
PRIVATE int SMMaxNumSapCfmPrimVlanEntriesPerMesg;
PRIVATE int SMMaxNumSapLoopBackEntriesPerMesg;
PRIVATE int SMMaxNumTlsMacLrnAgeEntriesPerMesg;
PRIVATE int SMMaxNumTlsMacAddEntriesPerMesg;
PRIVATE int SMMaxNumTlsMacDelEntriesPerMesg;
PUBLIC  int SMMaxNumTlsMacDelDstEntriesPerMesg;
PUBLIC  int SMMaxNumTlsMacDelTlsEntriesPerMesg;
PUBLIC  int SMMaxNumTlsMacDelMimEntriesPerMesg;
PRIVATE int SMMaxNumTlsMacMoveEntriesPerMesg;
PRIVATE int SMMaxNumTlsMacQueryEntriesPerMesg;
PUBLIC  int SMMaxNumTlsMacCallbackEntriesPerMesg;
PRIVATE int SMMaxNumSdpEntriesPerMesg;
PRIVATE int SMMaxNumSdpBindEntriesPerMesg;
PRIVATE int SMMaxNumSdpBindSwitchEntriesPerMesg;
PRIVATE int SMMaxNumSdpBindStateEntriesPerMesg;
PRIVATE int SMMaxNumSdpBindMcListPruneEntriesPerMesg;
PRIVATE int SMMaxNumSdpBindMacLoopBackEntriesPerMesg;
PRIVATE int SMMaxNumSapStatsEntriesPerMesg;
PRIVATE int SMMaxNumSapQueueStatsEntriesPerMesg;
PRIVATE int SMMaxNumEncapGrpQueueStatsEntriesPerMesg;
PRIVATE int SMMaxNumSdpBindStatsEntriesPerMesg;
PRIVATE int SMMaxNumMacQosFilterRuleEntriesPerMesg;
PRIVATE int SMMaxNumIpQosFilterRuleEntriesPerMesg;
PRIVATE int SMMaxNumQosMssEntriesPerMesg;
PRIVATE int SMMaxNumVSOverrideEntriesPerMesg;
PRIVATE int SMMaxNumQueueOverrideEntriesPerMesg;
PRIVATE int SMMaxNumQmdaQueueOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSapEgrEncapGroupEntriesPerMesg;
PRIVATE int SMMaxNumSapEgrEncapMemberEntriesPerMesg;
PRIVATE int SMMaxNumSubscrEntriesPerMesg;
PRIVATE int SMMaxNumSubscrVSOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSubscrHostEntriesPerMesg;
PRIVATE int SMMaxNumSubProfVSOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSubProfPlcrCtrlOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSubProfQueueOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSLAProfQueueOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSLAProfPolicerOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSLAProfVSOverrideEntriesPerMesg;
PRIVATE int SMMaxNumSubQueueStatsEntriesPerMesg;
PRIVATE int SMMaxNumEmgEntriesPerMesg;
PRIVATE int SMMaxNumSubL3RedGroupEntriesPerMesg;
PRIVATE int SMMaxNumSubL3RedInterDestGroupIdEntriesPerMesg;

/* Message buffer and support data used by
 * smgrBatchSdpAddMesg() to batch up SDP_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSdpConfigRequest *pSdpAddReqMesg = NULL;
PRIVATE int NextSdpAddEntry = 0;
PRIVATE tUint32 PrevSdpAddIomBitMask = 0;
PRIVATE SEM_ID SdpAddSemId;

/* Message buffer and support data used by
 * smgrBatchEmgAddMesg() to batch up EMG_ADD
 * requests to the IOM's.
 */
PRIVATE tIomEmgConfigRequest *pEmgAddReqMesg = NULL;    
PRIVATE int NextEmgAddEntry = 0;
PRIVATE tUint32 PrevEmgAddIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchSvcAddMesg() to batch up SVC_ADD,
 * smgrBatchSvcVirtPortStateMesg() to batch up SVC_VIRTUAL_PORT_STATE,
 * smgrBatchSvcTlsFloodUpdateMesg() to batch up SVC_TLS_FLOOD_UPDATE and
 * smgrBatchSvcTlsMesg() to batch up IOM_SVC_TLS_FWDING_UPDATE 
 * requests to the IOM's.
 * The above types of messages are mutually exclusive, 
 * so before starting a batch, the other is flushed.
 */
PRIVATE tIomSvcConfigRequest *pSvcCfgReqMesg = NULL;
PRIVATE tUint32 PrevSvcCfgIomBitMask = 0;
PRIVATE tSmgrDndlerBlockType SvcDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
PRIVATE tSfMcastId *pSvcTlsFwdDndlerCbEvtMsgs = NULL;
PRIVATE tUint32 *pSvcAddDndlerCbEvtMsgs = NULL;
PRIVATE SEM_ID SvcCfgSemId;

/* Message buffer and support data used by
 * smgrBatchSapAddMesg() to batch up SAP_ADD, SAP_STATE and SAP_MCLISTPRUNE_MVRP
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSapAddReqMesg = NULL;
PRIVATE tSmgrDndlerSapBindCbEvtMsgs *pSapAddDndlerCbEvtMsgs = NULL;
PRIVATE tUint32 SapAddOp = 0;
PRIVATE tUint32 PrevSapAddIomBitMask = 0;
PUBLIC SEM_ID SapAddSemId;
PRIVATE tSMGenEventMsg *pSapBatchCallbackEvent = NULL;
PRIVATE tSmgrDndlerBlockType SapDnldBlockType = SMGR_DNDLER_MAY_BLOCK;

/* Message buffer and support data used by
 * smgrBatchSapDelMesg() to batch up SAP_DEL
 * requests to the IOMs */
PRIVATE tSmgrDndlerBlockType SapDelDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
PRIVATE tIomSapSubMixedRequest *pSapDelReqMesg = NULL;
PRIVATE int NextSapDelEntry = 0;
PRIVATE tUint32 PrevSapDelIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchSapSwitchMesg() to batch up SAP_SWITCH
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSapSwitchReqMesg = NULL;
PRIVATE tSmgrDndlerSapBindCbEvtMsgs *pSapSwitchDndlerCbEvtMsgs = NULL;
PRIVATE int NextSapSwitchEntry = 0;
PRIVATE tUint32 PrevSapSwitchIomBitMask = 0;
PRIVATE SEM_ID SapSwitchSemId;

/* Message buffer and support data used to batch up IOM_SAP_CFM_PVLAN
 * requests to the IOMs */
PRIVATE tIomSapSubMixedRequest *pSapCfmPrimVlanReqMesg = NULL;
PRIVATE int NextSapCfmPrimVlanEntry = 0;
PRIVATE tUint32 PrevSapCfmPrimVlanIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchSdpBindMesg() to batch up 
 * SVC_BIND, SDP_BIND_SWITCH, SVC_BIND_STATE and SVC_BIND_MCLISTPRUNE
 * requests to the IOM's.
 */
PRIVATE tIomSvcBindRequest *pSdpBindReqMesg = NULL;
PRIVATE tSmgrDndlerSapBindCbEvtMsgs *pSdpBindDndlerCbEvtMsgs = NULL;
PRIVATE tUint32 PrevSdpBindIomBitMask = 0;
PUBLIC SEM_ID SdpBindSemId;
PRIVATE typeof(vxTicks) FirstSbindBatchTime;   // First msg added to batch
PRIVATE typeof(vxTicks) MaxSbindBatchWaitTime; // Longest any msg waited before flush
PRIVATE tSmgrDndlerBlockType SdpBindDnldBlockType = SMGR_DNDLER_MAY_BLOCK;

/* Extra info about batched SdpBindReqMesgs that is
 * only of interest to the CPM (i.e. we don't want 
 * to send this to the IOMs)
 */
PRIVATE tSdpBndRec **pSdpBindReqShadow;


/* Message buffer and support data used by
 * smgrBatchSdpUnbindMesg() to batch up SVC_UNBIND
 * requests to the IOM's.
 */
PRIVATE tIomSvcBindRequest *pSdpUnbindReqMesg = NULL;     
PRIVATE int NextSdpUnbindEntry = 0;
PRIVATE tUint32 PrevSdpUnbindIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchTlsMacAddMesg() to batch up MAC_ADD
 * requests to the IOM's.
 */
#define SMGR_SEND_TLS_MAC_BATCH_ASYNC FALSE
#if !SMGR_SEND_TLS_MAC_BATCH_ASYNC
PRIVATE tIomTlsMacConfigRequest MacAddReqMesg;
#endif
PRIVATE tIomTlsMacConfigRequest *pMacAddReqMesg = NULL;
PRIVATE tUint32 PrevMacAddIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchTlsMacDelMesg() to batch up MAC_DELETE
 * requests to the IOM's.
 */
PRIVATE tIomTlsMacConfigRequest *pMacDelReqMesg = NULL;     
PRIVATE tUint32 PrevMacDelIomBitMask = 0;

/* Message buffer and support data used to batch up MAC_QUERY requests
 * to IOM */
PRIVATE tIomTlsMacConfigRequest *pTlsMacQueryMsg;
PRIVATE tSlot TlsMacQueryPrevSlotNum;

/* Message buffer and support data used by
 * smgrBatchMssAddMesg() to batch up MSS_ADD
 * requests to the IOM's.
 */
PRIVATE tIomQosMultiServiceSiteRequest *pMssAddReqMesg = NULL;     
PRIVATE int NextMssAddEntry = 0;
PRIVATE tUint32 PrevMssAddIomBitMask = 0;
PRIVATE tSmgrDndlerBlockType MssDnldBlockType = SMGR_DNDLER_MAY_BLOCK;

/* Message buffer pointer and support data used by
 * smgrBatchVSOverrideAddMesg() and smgrBatchPCOverrideAddMesg()
 * to batch up IOM_QOS_OVERRIDE_ADD requests to the IOM's.
 * (The "VS" naming is a throwback to the original Virtual Scheduler
 * overrides, but it now includes arbiters as well)
 */
PRIVATE tIomQosGroupOverrideRequest *pVSOverrideAddReqMesg = NULL;
PRIVATE int NextVSOverrideAddEntry = 0;
PRIVATE tUint32 PrevVSOverrideAddIomBitMask = 0;
PRIVATE  tUint32 VirtSchdOverrideAddCount = 0;
PRIVATE  tUint32 IngressSchedPlcyOverrideAddCount = 0;
PRIVATE  tUint32 EgressSchedPlcyOverrideAddCount = 0;
PRIVATE  tUint32 IngressPlcyCtrlOverrideAddCount = 0;
PRIVATE  tUint32 EgressPlcyCtrlOverrideAddCount = 0;

/* Message buffer pointer and support data used by
 * smgrBatchVSOverrideDelMesg() and smgrBatchPCOverrideDelMesg()
 * to batch up IOM_POLICY_DEL requests to the IOM's.
 * (The "VS" naming is a throwback to the original Virtual Scheduler
 * overrides, but it now includes arbiters as well)
 */
PRIVATE tIomQosGroupOverrideRequest *pVSOverrideDelReqMesg = NULL;
PRIVATE int NextVSOverrideDelEntry = 0;
PRIVATE tUint32 PrevVSOverrideDelIomBitMask = 0;
PRIVATE  tUint32 VirtSchdOverrideDelCount = 0;
PRIVATE  tUint32 IngressSchedPlcyOverrideDelCount = 0;
PRIVATE  tUint32 EgressSchedPlcyOverrideDelCount = 0;
PRIVATE  tUint32 IngressPlcyCtrlOverrideDelCount = 0;
PRIVATE  tUint32 EgressPlcyCtrlOverrideDelCount = 0;

/* Message buffer pointer and support data used by
 * smgrBatchQueue/PolicerOverrideAddMesg() to batch up IOM_QOS_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapQosPolicyOverrideRequest *pSapQosOverrideAddReqMesg = NULL;
PRIVATE int NextSapQosOverrideAddEntry = 0;
PRIVATE tUint32 PrevSapQosOverrideAddIomBitMask = 0;
PRIVATE tUint32 sapIngressQOverrideAddCount = 0;
PRIVATE tUint32 sapEgressQOverrideAddCount = 0;
PRIVATE tUint32 sapIngressPlcrOverrideAddCount = 0;
PRIVATE tUint32 sapEgressPlcrOverrideAddCount = 0;


/* Message buffer pointer and support data used by
 * smgrBatchQueue/PolicerOverrideDelMesg() to batch up IOM_POLICY_DEL
 * requests to the IOM's.
 */
PRIVATE tIomSapQosPolicyOverrideRequest *pSapQosOverrideDelReqMesg = NULL;
PRIVATE int NextSapQosOverrideDelEntry = 0;
PRIVATE tUint32 PrevSapQosOverrideDelIomBitMask = 0;
PRIVATE tUint32 sapIngressQOverrideDelCount = 0;
PRIVATE tUint32 sapEgressQOverrideDelCount = 0;
PRIVATE tUint32 sapIngressPlcrOverrideDelCount = 0;
PRIVATE tUint32 sapEgressPlcrOverrideDelCount = 0;

/* Message buffer pointer and support data used by
 * smgrBatchQmdaQueueOverrideAddMesg() to batch up IOM_QOS_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomQmdaSapQosPolicyOverrideRequest *pQmdaQueueOverrideAddReqMesg = NULL;
PRIVATE int NextQmdaQueueOverrideAddEntry = 0;
PRIVATE tUint32 PrevQmdaQueueOverrideAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchQmdaQueueOverrideDelMesg() to batch up IOM_POLICY_DEL
 * requests to the IOM's.
 */
PRIVATE tIomQmdaSapQosPolicyOverrideRequest *pQmdaQueueOverrideDelReqMesg = NULL;
PRIVATE int NextQmdaQueueOverrideDelEntry = 0;
PRIVATE tUint32 PrevQmdaQueueOverrideDelIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSapEgrEncapGroupAddMesgPriv() to batch up IOM_POLICY_ADD
 * requests to the IOM's.
 */
PRIVATE tIomEncapGroupConfigRequest *pSapEgrEncapGroupAddReqMesg = NULL;
PRIVATE int NextSapEgrEncapGroupAddEntry = 0;
PRIVATE tUint32 PrevSapEgrEncapGroupAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSapEgrEncapGroupDelMesg() to batch up IOM_POLICY_DEL
 * requests to the IOM's.
 */
PRIVATE tIomEncapGroupConfigRequest *pSapEgrEncapGroupDelReqMesg = NULL;
PRIVATE int NextSapEgrEncapGroupDelEntry = 0;
PRIVATE tUint32 PrevSapEgrEncapGroupDelIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSapEgrEncapMemberAddMesgPriv() to batch up
 * IOM_ENCAP_GROUP_MEMBERS_ADD requests to the IOM's.
 */
PRIVATE tIomEncapGroupMembershipRequest *pSapEgrEncapMemberAddReqMesg = NULL;
PRIVATE int NextSapEgrEncapMemberAddEntry = 0;
PRIVATE tUint32 PrevSapEgrEncapMemberAddIomBitMask = 0;
PRIVATE tUint32 PrevSapEgrEncapMemberAddGroupId = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubscriberAddMesg() to batch up SUBSCRIBER_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubscriberAddReqMesg = NULL;
PRIVATE int NextSubscriberAddEntry = 0;
PRIVATE tUint32 PrevSubscriberAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubVSOverrideAddMesg() to batch up SUB_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubVSOverrideAddReqMesg = NULL;
PRIVATE int NextSubVSOverrideAddEntry = 0;
PRIVATE tUint32 PrevSubVSOverrideAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubVSOverrideDelMesg() to batch up SUB_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DEL
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubVSOverrideDelReqMesg = NULL;
PRIVATE int NextSubVSOverrideDelEntry = 0;
PRIVATE tUint32 PrevSubVSOverrideDelIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubscriberHostAddMesg() to batch up SUBSCRIBER_HOST_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubscriberHostAddReqMesg = NULL;
PRIVATE int NextSubscriberHostAddEntry = 0;
PRIVATE tUint32 PrevSubscriberHostAddIomBitMask = 0;
PRIVATE tSmgrDndlerBlockType SubHostAddDnldBlockType = SMGR_DNDLER_MAY_BLOCK;

/* Message buffer pointer and support data used by
 * smgrBatchSubscriberHostDelMesg() to batch up SUBSCRIBER_HOST_DELETE
 * or SUBSCRIBER_HOST_UNBIND requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubscriberHostDelReqMesg = NULL;
PRIVATE int NextSubscriberHostDelEntry = 0;
PRIVATE eSapSubOp SubscriberHostDelOp = 0;
PRIVATE tUint32 PrevSubscriberHostDelIomBitMask = 0;
PRIVATE tSmgrDndlerBlockType SubHostDelDnldBlockType = SMGR_DNDLER_MAY_BLOCK;

/* Message buffer pointer and support data used by
 * smgrBatchSubProfVSOverrideAddMesg() to batch up SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubProfVSOverrideAddReqMesg = NULL;
PRIVATE int NextSubProfVSOverrideAddEntry = 0;
PRIVATE tUint32 PrevSubProfVSOverrideAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubProfVSOverrideDelMesg() to batch up SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubProfVSOverrideDelReqMesg = NULL;
PRIVATE int NextSubProfVSOverrideDelEntry = 0;
PRIVATE tUint32 PrevSubProfVSOverrideDelIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubProfPlcrCtrlOverrideAddMesg() to batch up SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubProfPlcrCtrlOverrideAddReqMesg = NULL;
PRIVATE int NextSubProfPlcrCtrlOverrideAddEntry = 0;
PRIVATE tUint32 PrevSubProfPlcrCtrlOverrideAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubProfPlcrCtrlOverrideDelMesg() to batch up SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubProfPlcrCtrlOverrideDelReqMesg = NULL;
PRIVATE int NextSubProfPlcrCtrlOverrideDelEntry = 0;
PRIVATE tUint32 PrevSubProfPlcrCtrlOverrideDelIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubProfHsmda2EgrQueueOverrideAddMesg() to batch up SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD
 * requests to the IOM's (HSMDA2).
 */
PRIVATE tIomSapSubMixedRequest *pSubProfHsmda2EgrQueueOverrideAddReqMesg = NULL;
PRIVATE int NextSubProfHsmda2EgrQueueOverrideAddEntry = 0;
PRIVATE tUint32 PrevSubProfHsmda2EgrQueueOverrideAddIomBitMask = 0;
/* Variables to keep track of the Sub profile Hsmda2 Egr Qos Q Override Add entry count */
PRIVATE tUint32 SubProfileHsmda2EgressQosQAddCnt = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubProfHsmda2EgrQueueOverrideDelMesg() to batch up SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE
 * requests to the IOM's (HSMDA2).
 */
PRIVATE tIomSapSubMixedRequest *pSubProfHsmda2EgrQueueOverrideDelReqMesg = NULL;
PRIVATE int NextSubProfHsmda2EgrQueueOverrideDelEntry = 0;
PRIVATE tUint32 PrevSubProfHsmda2EgrQueueOverrideDelIomBitMask = 0;
/* Variables to keep track of the Sub profile Hsmda2 Egr Qos Q Override Delete entry count */
PRIVATE tUint32 SubProfileHsmda2EgressQosQDeleteCnt = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSLAProfQueueOverrideAddMesg() to batch up SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSLAProfQueueOverrideAddReqMesg = NULL;
PRIVATE int NextSLAProfQueueOverrideAddEntry = 0;
PRIVATE tUint32 PrevSLAProfQueueOverrideAddIomBitMask = 0;
/* Variables to keep track of the SLA profile Qos Q Override Add entry count */
PRIVATE tUint32 SLAProfileIngressQosQAddCnt = 0;
PRIVATE tUint32 SLAProfileEgressQosQAddCnt = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSLAProfQueueOverrideDelMesg() to batch up SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSLAProfQueueOverrideDelReqMesg = NULL;
PRIVATE int NextSLAProfQueueOverrideDelEntry = 0;
PRIVATE tUint32 PrevSLAProfQueueOverrideDelIomBitMask = 0;
/* Variables to keep track of the SLA profile Qos Q Override Delete entry count */
PRIVATE tUint32 SLAProfileIngressQosQDeleteCnt = 0;
PRIVATE tUint32 SLAProfileEgressQosQDeleteCnt = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSLAProfPolicerOverrideAddMesg() to batch up SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSLAProfPolicerOverrideAddReqMesg = NULL;
PRIVATE int NextSLAProfPolicerOverrideAddEntry = 0;
PRIVATE tUint32 PrevSLAProfPolicerOverrideAddIomBitMask = 0;
/* Variables to keep track of the SLA profile Qos Policer Override Add entry count */
PRIVATE tUint32 SLAProfileIngressQosPlcrAddCnt = 0;
PRIVATE tUint32 SLAProfileEgressQosPlcrAddCnt = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSLAProfPolicerOverrideDelMesg() to batch up SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSLAProfPolicerOverrideDelReqMesg = NULL;
PRIVATE int NextSLAProfPolicerOverrideDelEntry = 0;
PRIVATE tUint32 PrevSLAProfPolicerOverrideDelIomBitMask = 0;
/* Variables to keep track of the SLA profile Qos Policer Override Delete entry count */
PRIVATE tUint32 SLAProfileIngressQosPlcrDeleteCnt = 0;
PRIVATE tUint32 SLAProfileEgressQosPlcrDeleteCnt = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSLAProfVSOverrideAddMesg() to batch up SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSLAProfVSOverrideAddReqMesg = NULL;
PRIVATE int NextSLAProfVSOverrideAddEntry = 0;
PRIVATE tUint32 PrevSLAProfVSOverrideAddIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSLAProfVSOverrideDelMesg() to batch up SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE
 * requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSLAProfVSOverrideDelReqMesg = NULL;
PRIVATE int NextSLAProfVSOverrideDelEntry = 0;
PRIVATE tUint32 PrevSLAProfVSOverrideDelIomBitMask = 0;

/* Message buffer pointer and support data used by
 * smgrBatchSubL3RedGroupMesg() to batch up IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD
 * or IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE requests to the IOM's.
 */
PRIVATE tIomSapSubMixedRequest *pSubL3RedGroupRequest = NULL;
PRIVATE eSapSubOp SubL3RedGroupOp = 0;
PRIVATE tUint32 PrevSubL3RedGroupIomBitMask = 0;
PRIVATE SEM_ID SubL3RedGroupSemId;

/* Message buffer and support data used by
 * smgrBatchMcRingRingnodeAddMesg() to batch up 
 * IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD requests
 * to the IOMs
 */
PRIVATE tIomSapSubMixedRequest *pSubL3RedInterDestGroupReqMesg = NULL;
PRIVATE int NextSubL3RedInterDestGroupAddEntry = 0;
PRIVATE tUint32 PrevSubL3RedInterDestGroupIdIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchSapIngQosPolMacRuleAddMesg() to batch up IOM_MAC_RULE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomQosSapIngressMacFilterRuleRequest *pQosSapIngMacFilterAddReqMesg = NULL;     
PRIVATE int NextQosSapIngMacFilterAddEntry = 0;
PRIVATE tUint32 PrevQosSapIngMacFilterIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchSapIngQosPolIpRuleAddMesg() to batch up IOM_IP_RULE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomQosSapIpFilterRuleRequest *pQosSapIngIpFilterAddReqMesg = NULL;     
PRIVATE int NextQosSapIngIpFilterAddEntry = 0;
PRIVATE tUint32 PrevQosSapIngIpFilterIomBitMask = 0;

/* Message buffer and support data used by
 * smgrBatchSapEgrQosPolIpRuleAddMesg() to batch up IOM_IP_RULE_ADD
 * requests to the IOM's.
 */
PRIVATE tIomQosSapIpFilterRuleRequest *pQosSapEgrIpFilterAddReqMesg = NULL;     
PRIVATE int NextQosSapEgrIpFilterAddEntry = 0;
PRIVATE tUint32 PrevQosSapEgrIpFilterIomBitMask = 0;

/* Semaphore to synchronize config task and SMGR dndler for synchronous ICC
 * calls for TLS MAC QUERY */
PRIVATE SEM_ID IccSyncTlsMacQuery;

/******************************************************************************/
/* Forward function declarations */

tStatus smgrMesgOkCmp(const void *pLastKey, tUint32 IomOp, void *p);
tStatus smgrMesgSdpCmp(const void *pLastKey, tUint32 IomOp, const tSdpRec *pSdp);
tStatus smgrMesgQosSchedPolCmp(const void *pLastKey, tUint32 IomOp,
                               const tQosSchedPolRec *pPol);
tStatus smgrMesgQosPolicerCtrlPolCmp(const void *pLastKey, tUint32 IomOp,
                                     const tQosPolicerCtrlPolRec *pPol);
tStatus smgrMesgQosSapIngPolCmp(const void *pLastKey, tUint32 IomOp,
                                const tSapIngQosPolRec *pPol);
tStatus smgrMesgQosSapIngPolMacFilterCmp(const void *pLastKey,tUint32 IomOp,const tSapIngQosPolRec *pPol, int ruleNum);
tStatus smgrMesgQosSapIngPolIpFilterCmp(const void *pLastKey,tUint32 IomOp,const tSapIngQosPolRec *pPol, int ruleNum);
tStatus smgrMesgQosSapEgrPolCmp(const void *pLastKey, tUint32 IomOp,
                                const tSapEgrQosPolRec *pPol);
tStatus smgrMesgQosSapEgrPolIpFilterCmp(const void *pLastKey,tUint32 IomOp,const tSapEgrQosPolRec *pPol, const tSapEgrQosPolIpRuleId *pRuleId);
tStatus smgrMesgCustMssCmp(const void *pLastKey, tUint32 IomOp,
                           const tMssRec *pUpdateMss);
tStatus smgrMesgCustMssVsOvCmp(const void *pLastKey, tUint32 IomOp,
                               const tMssRec *pUpdateMss, int Direction,
                               const tQosVSchedOverrideRec *pVSched);
tStatus smgrMesgEmgCmp(const void *pLastKey, tUint32 IomOp, const tTlsEmgRec *pEmg);
tStatus smgrDoFlushEmgAddMesg(tBoolean PreFlush);
tStatus smgrMesgSvcCmp(const void *pLastKey, tUint32 IomOp, const tSvcRec *pSvc);
tStatus smgrMesgSapCmp(const void *pLastKey, tUint32 IomOp, const tSapRec *pSap);
tStatus smgrFlushSapCfmPrimVlanMesg(void);
tStatus smgrDoFlushSapCfmPrimVlanMesg(tBoolean PreFlush);
tStatus smgrMesgSapCfmPrimVlanCmp(const void *pLastKey, tUint32 IomOp, const tSapRec *pSap, tUint32 PrimVlanId);
tStatus smgrMesgSdpBindCmp(const void *pLastKey, tUint32 IomOp,const tSdpBndRec *pSdpBnd);
tStatus smgrMesgIccTlsFdbCmp(const void *pLastKey, tUint32 IomOp, const tTlsFdbRec *pRec);
tStatus smgrMesgIccMirrorSvcRemoteCmp(const void *pLastKey,tUint32 IomOp,const tMirrorRemSrcRec *pRemSrc);
tStatus smgrMesgIccMirrorSvcLocalCmp(const void *pLastKey,tUint32 IomOp,const  tMirrorSrcEntryRec *pLocSrc);
tStatus smgrMesgIccSbmSubProfCmp(const void *pLastKey,tUint32 IomOp,const tSbmSubProf *pSubProf);
tStatus smgrMesgIccSbmSubProfSchedOvrCmp(const void *pLastKey, tUint32 IomOp,const tSbmSubProfSchedOvr *pSubProfSchedOvr);
tStatus smgrMesgIccSbmSubProfPlcrCtrlOvrCmp(const void *pLastKey,tUint32 IomOp,const tSbmSubProfPlcrCtrlOvr *pSubProfPlcrCtrlOvr);
tStatus smgrMesgIccSbmSubProfQOvrCmp(const void *pLastKey,tUint32 IomOp,const tSbmSubProfQueueOvr *pSubProfQOvr);
tStatus smgrMesgIccSbmSubProfHsmda2EgrQOvrCmp(const void *pLastKey,tUint32 IomOp,const tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr);
tStatus smgrMesgIccSbmSLAProfCmp(const void *pLastKey,tUint32 IomOp,const tSbmSLAProf *pSLAProf);
tStatus smgrMesgIccSbmSLAProfQOvrCmp(const void *pLastKey,tUint32 IomOp,const tSbmSLAProfQueueOvr *pSLAProfQOvr);
tStatus smgrMesgIccSbmSLAProfPlcrOvrCmp(const void *pLastKey,tUint32 IomOp,const tSbmSLAProfPolicerOvr *pSLAProfPlcrOvr);
tStatus smgrMesgIccSbmSLAProfSchedOvrCmp(const void *pLastKey, tUint32 IomOp,const tSbmSLAProfSchedOvr *pSLAProfSchedOvr);
tStatus smgrMesgIccSbmActSubCmp(const void *pLastKey,tUint32 IomOp,const tSbmActSub *pActSub);
tStatus smgrMesgIccSbmSubSchedOvrCmp(const void *pLastKey,tUint32 IomOp,const tSbmSubSchedOvr *pSchedOvr);
tStatus smgrMesgIccSbmIesIfGroupIfCmp(const void *pLastKey,tUint32 IomOp,const  tIesIfRec *pIesIf);
tStatus smgrMesgIccSbmIesIfGroupIfRingNodeCmp(const void *pLastKey, tUint32 IomOp,const  tSMMcRingnodeRec *pRingnode);
tStatus smgrMesgIccSbmSubHostCmp(const void *pLastKey, tUint32 IomOp,const  tSbmSubHost *pSubHost);
tStatus smgrMesgIccSbmPppoeLnsSubCmp(const void *pLastKey,tUint32 IomOp,tUint32 lnsClientId);
tStatus smgrMesgIccSapSchedPlcyOvrCmp(const void *pLastKey,tUint32 IomOp,const tQosVSchedOverrideRec *pVSched,const tSapRec *pSap);
tStatus smgrMesgIccSapPlcrCtrlOvrCmp(const void *pLastKey, tUint32 IomOp,const tSapRec *pSap);
tStatus smgrMesgIccSapOvrCmp(const void *pLastKey,tUint32 IomOp,const tSapRec *pSap,tUint32 QosId);
tStatus smgrMesgIccSapEgrEncapGroupCmp(const void *pLastKey,tUint32 IomOp,const tSapRec *pSap, const STRUCT_TNamedItem *pName);
tStatus smgrMesgIccSapSubQosOvrCmp(const void *pLastKey,tUint32 IomOp,const  tSbmSLAProfInst *pSlaProfInst);
tStatus smgrMesgIccUssCatMapCmp(const void *pLastKey,tUint32 IomOp,const  struct tUssCategoryMap *pCatMap);
tStatus smgrMesgIccDpiIpCmp(const void *pLastKey,tUint32 IomOp);
tStatus smgrMesgIccDpiPrefixCmp(const void *pLastKey,tUint32 IomOp);


PRIVATE void smgrInitSdpAddReqEntry(tIomSdpEntry *pEntry, tSdpRec *pSdp);

typedef struct SmgrInitSvcAddReqEntryRetParams {
    tBoolean IomParentMcastIdChgd;
    tUint32  OldIomParentMcastId;
} tSmgrInitSvcAddReqEntryRetParams;
PRIVATE void smgrInitSvcAddReqEntry(tIomSvcEntry *pEntry, tSvcRec *pSvc,
                                    struct SMEventMsg *pCallbackEvent,
                                    tSmgrInitSvcAddReqEntryRetParams *pRetParams,
                                    tBoolean IsCardOnline);
PRIVATE void smgrInitSvcVirtPortStateEntry(tIomSvcPipEntry *pEntry, tSvcRec *pSvc);
PRIVATE void smgrInitSvcTlsFloodUpdateEntry(tIomSvcTlsFloodEntry *pEntry, tSvcRec *pSvc);
PRIVATE void smgrInitSapAddReqEntry(tIomSapEntry *pEntry, tSapRec *pSap, eSapSdpState IomFwdState, 
                                    struct SMEventMsg *pCallbackEvent);
PRIVATE void smgrInitSapSwitchReqEntry(tIomSapSdpSwitchConfig *pEntry, tSapRec *pSap,
                                       tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs);
PRIVATE void smgrInitSapStateEntry(tIomSapCompactEntry *pEntry, tSapRec *pSap,
                                   eSapSdpState IomSapFwdState, struct SMEventMsg *pCallbackEvent);
PRIVATE void smgrInitSapMcListPruneAndMvrpEntry(tIomSapCompactEntry *pEntry, tSapRec *pSap);
PRIVATE void smgrInitSapCfmPrimVlanReqEntry(tIomSapCfmPrimVlanEntry *pEntry, const tSapRec *pSap,
                                            const tDot1agSapPvEntry *pPrimVlanCfg);
PRIVATE void smgrInitSdpBindReqEntry(tIomSvcBindEntry *pEntry, tSdpBndRec *pSdpBnd,
                                     eSapSdpState IomFwdState, struct SMEventMsg *pCallbackEvent,
                                     tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs);
PRIVATE void smgrInitSdpBindSwitchReqEntry(tIomSapSdpSwitchConfig *pEntry, tSdpBndRec *pSdpBnd,
                                           tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs);
PRIVATE void smgrInitSdpBindStateEntry(tIomSvcBindStateEntry*, tSdpBndRec*, eSapSdpState IomFwdState,
                                       struct SMEventMsg *pCallbackEvent);
PRIVATE void smgrInitSdpBindMcListPruneEntry(tIomSvcBindMcListPruneEntry* pEntry, tSdpBndRec* pSdpBnd);
PRIVATE tStatus smgrDoTlsMacDelOpMesg(tTlsObj *pTlsFdb, tTlsFdbRec *pRec, tSdpBndRec *pSdpBnd, tSapRec *pSap,
                                      tBoolean DelStatic, tTlsFdbRequestorType RequestorType,
                                      tSMGenEventMsg **ppCbEvt,
                                      tSMSlot SlotNum,
                                      eTlsMacOp Op, tBatchProcessing *pBatch);
PRIVATE void smgrInitTlsMacAddReqEntry(tIomTlsMacAddEntry *pEntry, tSvcRec *pSvc, tTlsFdbRec *pRec,
                                       tSlot SrcSlotNum, struct SMEventMsg *pCallbackEvent);
PRIVATE void smgrInitTlsMacDelReqEntry(tIomTlsMacDelEntry *pEntry, tSvcRec *pSvc, tTlsFdbRec *pRec);
PRIVATE void smgrInitTlsMacDelDstReqEntry(tIomTlsMacDelDstEntry *pEntry, tSvcRec *pSvc, tSdpBndRec *pSdpBnd, tSapRec* pSap,
                                          tBoolean DelStatic, tTlsFdbRequestorType RequestorType,
                                          tSMGenEventMsg *pCbEvt);
PRIVATE void smgrInitTlsMacDelTlsReqEntry(tIomTlsMacDelTlsEntry *pEntry, tSvcRec *pSvc,
                                          tBoolean DelStatic, tTlsFdbRequestorType RequestorType,
                                          tSMGenEventMsg *pCbEvt);
PRIVATE void smgrInitTlsMacDelMimReqEntry(tIomTlsMacDelMimEntry *pEntry, tSvcRec *pSvc,
                                          tSMGenEventMsg *pCbEvt);
PRIVATE void smgrInitTlsMacMoveReqEntry(tIomTlsMacMoveEntry *pEntry, tSvcRec *pSvc,
                                        tSdpBndRec *pOldSdpBnd,tSdpBndRec *pNewSdpBnd);
PRIVATE void smgrInitTlsMacQueryReqEntry(tIomTlsMacQueryEntry *pEntry, tSvcRec *pSvc, tTlsFdbRec *pRec, tBoolean MultipleIoms);
PRIVATE tFastFldReqBitMap smgrTlsMacDelGetFastFloodRequestorBitMap(tSvcRec *pSvc,
                                                                   tTlsFdbRequestorType RequestorType);
PRIVATE tStatus smgrDoFlushTlsMacAddMesg(tBoolean preFlush);
PRIVATE tStatus smgrDoFlushTlsMacDelMesg(tBoolean preFlush);
PRIVATE void smgrInitMssAddReqEntry(tMultiServiceSite *pEntry, tMssRec *pMss);
PRIVATE tUint16 smgrEncodeSapQueueOverrideFlags(tQueueOverrideRec *pQueue, int Direction);
PRIVATE void smgrEncodeQosVirtSchedEntry(char *Key, void *Value, void *Arg1, void *Arg2);
PRIVATE void smgrEncodeQosPolicerArbiterEntry(char *Key, void *Value, void *Arg1, void *Arg2);
PRIVATE void smgrEncodeSapIngQosPolIpRule(tIpQosFilterRule *pRule,
                                          STRUCT_tSapIngressIPCriteriaEntry *pEntry);
PRIVATE void smgrEncodeSapIngQosPolMacRule(tInt32 macFltrType,
                                           tMacQosFilterRule *pRule,
                                           STRUCT_tSapIngressMacCriteriaEntry *pEntry);
PRIVATE tStatus smgrFlushSapIngQosPolIpRuleAddMesg(void);
PRIVATE tStatus smgrDoFlushSapIngQosPolIpRuleAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrFlushSapIngQosPolMacRuleAddMesg(void);
PRIVATE tStatus smgrDoFlushSapIngQosPolMacRuleAddMesg(tBoolean PreFlush);
PRIVATE void smgrEncodeSapEgrQosPolIpRule(tIpQosFilterRule *pRule,
                                          STRUCT_tSapEgrIPCritEntry *pEntry);
PRIVATE tStatus smgrFlushSapEgrQosPolIpRuleAddMesg();
PRIVATE tStatus smgrDoFlushSapEgrQosPolIpRuleAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSapQosOverrideAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSapQosOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushQmdaQueueOverrideAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushQmdaQueueOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSapEgrEncapGroupAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSapEgrEncapGroupDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSapEgrEncapMemberAddMesg(tBoolean PreFlush);

PRIVATE tStatus smgrSendVSOverrideAddMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo,
                                          tQosVSchedOverrideRec *pVSched);
PRIVATE tStatus smgrBatchVSOverrideAddMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo,
                                           tQosVSchedOverrideRec *pVSched, tBatchProcessing *pBatch);
PRIVATE tStatus smgrDoFlushVSOverrideAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrSendVSOverrideDelMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo);
PRIVATE tStatus smgrBatchVSOverrideDelMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo);
PRIVATE tStatus smgrDoFlushVSOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrSendPCOverrideAddMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo,
                                          tQosPolicerCtrlOverrideRec *pOverride);
PRIVATE tStatus smgrBatchPCOverrideAddMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo,
                                           tQosPolicerCtrlOverrideRec *pOverride,
                                           tBatchProcessing *pBatch);
PRIVATE tStatus smgrSendPCOverrideDelMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo);
PRIVATE tStatus smgrBatchPCOverrideDelMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo);
PRIVATE tStatus smgrDoBatchSdpAddMesg(tSdpRec *pSdp, tUint32 SlotBitmap, tBoolean IsCardOnline);
PRIVATE tStatus smgrDoFlushSdpAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoBatchSvcAddMesg(tSvcRec *pSvc, tUint32 SlotBitmap, tBoolean IsCardOnline);
PRIVATE void smgrCheckFlushSvcCfgMesg(eSvcConfigOp operation, tUint32 IomBitMask);
PRIVATE tStatus smgrDoFlushSvcCfgMesg(tBoolean preFlush);
PRIVATE tStatus smgrDoBatchSvcVirtPortStateMesg(tSvcRec *pSvc);
PRIVATE tStatus smgrDoBatchSvcTlsFloodUpdateMesg(tSvcRec *pSvc);
PRIVATE tStatus smgrDoBatchSapAddMesg(tSapRec *pSap, tUint32 SlotBitmap,
                                      struct SMEventMsg *pCallbackEvent,
                                      fSapBatchCallback Callback, tBoolean IsCardOnline,
                                      tBatchProcessing *pBatch);
PRIVATE tStatus smgrDoFlushSapDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSapAddAndStateMesg(tBoolean preFlush, tBoolean IfNeeded, 
                                              eSapSubOp msgType, tUint32 newIomBitMask);
PRIVATE tStatus smgrDoBatchSapStateMesg(tSapRec *pSap, tSMSlot SlotNum,
                                        tBoolean UseChmgrBitmap,
                                        struct SMEventMsg *pCallbackEvent);
PRIVATE tStatus smgrDoBatchSapStateCommon(tSapRec *pSap, tSMSlot SlotNum,
                                          tBoolean UseChmgrBitmap,
                                          struct SMEventMsg *pCallbackEvent,
                                          fSapBatchCallback Callback);
PRIVATE tStatus smgrDoBatchSapTlsPruneCommon(tSapRec *pSap, tSMSlot SlotNum);
PRIVATE tStatus smgrDoFlushSapSwitchMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoBatchSdpBindMesg(tSdpBndRec *pSdpBnd, tUint32 SlotBitmap, 
                                       struct SMEventMsg *pCallbackEvent,
                                       tBoolean IsCardOnline);
PRIVATE tStatus smgrDoFlushSdpBindMesg(tBoolean preFlush, tBoolean IfNeeded, 
                                       eSdpBindOp msgType, tUint32 newIomBitMask);
PRIVATE tStatus smgrDoBatchSdpBindSwitchMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum);
PRIVATE tStatus smgrDoBatchSdpBindMcListPruneMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum);
PRIVATE tStatus smgrSendSapSubAuditCommon(tSMSlot SlotNum, eSapSubOp Op);

PRIVATE tStatus smgrBatchSapIngQosPolMacRuleAddMesg(tSapIngQosPolRec *pPol, tSapIngQosPolMacRuleRec *pRule,
                                                    tUint32 SlotBitmap, tBoolean IsCardOnline);
PRIVATE tStatus smgrBatchSapIngQosPolIpRuleAddMesg(tSapIngQosPolRec *pPol, tSapIngQosPolIpRuleRec *pRule,
                                                   tUint32 SlotBitmap, tBoolean IsCardOnline);
PRIVATE tStatus smgrBatchSapEgrQosPolIpRuleAddMesg(tSapEgrQosPolRec *pPol,tSapEgrQosPolIpRuleRec *pRule,
                                                   tUint32 SlotBitmap, tBoolean IsCardOnline);
PRIVATE tStatus smgrDoFlushMcRingRingnodeAddMesg(tBoolean PreFlush);

const char *smgrMesgIccSdpBindStatsOpToStr(tUint32 OpCode);
PRIVATE const char *smgrMesgIccTlsFdbOpToStr(tUint32 OpCode);
PRIVATE int smgrMesgIccTlsFdbOpMaxEntPerMsg(tUint32 OpCode);
PRIVATE tStatus smgrDoFlushSubscriberAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSubscriberHostAddMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSubscriberHostDelUnbindMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSubProfVSOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSubProfVSOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSubProfPlcrCtrlOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSubProfPlcrCtrlOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSLAProfQueueOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSLAProfQueueOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSLAProfPolicerOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSLAProfPolicerOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSLAProfVSOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSLAProfVSOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSubProfQueueOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSubProfQueueOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSubProfHsmda2EgrQueueOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSubProfHsmda2EgrQueueOverrideDelMesg(tBoolean PreFlush);
PRIVATE tStatus smgrDoFlushSubVSOverrideAddMesg(tBoolean PreFlush);
PRIVATE void smgrDoFlushSubVSOverrideDelMesg(tBoolean PreFlush);

/* Initialize objects needed for Messaging */
PUBLIC tStatus smgrMesgInit(void)
{
    tUint32 entries;

    /* Determine the maximum number of entries that can be packed
     * in a single ICC request, without causing fragmentation.
     */
    SMMaxNumSvcAddEntriesPerMesg = MAX_SVC_ADD_ENTRIES_PER_MSG;
    SMMaxNumSvcDelEntriesPerMesg = MAX_SVC_DEL_ENTRIES_PER_MSG;
    SMMaxNumSvcVirtPortEntriesPerMesg = MAX_SVC_PIP_ENTRIES_PER_MSG;
    SMMaxNumSvcTlsFloodEntriesPerMesg = MAX_SVC_TLS_FLOOD_ENTRIES_PER_MSG;
    SMMaxNumSvcTlsEntriesPerMesg = MAX_SVC_TLS_FWDING_ENTRIES_PER_MSG;
    SMMaxNumSapAddEntriesPerMesg = MAX_SAP_ADD_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSapDelEntriesPerMesg = MAX_SAP_DEL_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSapSwitchEntriesPerMesg = MAX_SAP_SWITCH_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSapStateEntriesPerMesg = MAX_SAP_STATE_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSapMcListPruneAndMvrpEntriesPerMesg = MAX_SAP_MCLISTPRUNE_MVRP_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSapCfmPrimVlanEntriesPerMesg = MAX_SAP_CFM_PVLAN_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSapLoopBackEntriesPerMesg =  MAX_ICC_SAP_MAC_LPBK_ENTRIES_PER_MIXED_MSG;
    SMMaxNumTlsMacLrnAgeEntriesPerMesg = MAX_TLS_MAC_LRN_AGE_ENTRIES_PER_MSG;
    SMMaxNumTlsMacAddEntriesPerMesg = MAX_TLS_MAC_ADD_ENTRIES_PER_MSG;
    SMMaxNumTlsMacDelEntriesPerMesg = MAX_TLS_MAC_DEL_ENTRIES_PER_MSG;
    SMMaxNumTlsMacDelDstEntriesPerMesg = MAX_TLS_MAC_DEL_DST_ENTRIES_PER_MSG;
    SMMaxNumTlsMacDelTlsEntriesPerMesg = MAX_TLS_MAC_DEL_TLS_ENTRIES_PER_MSG;
    SMMaxNumTlsMacDelMimEntriesPerMesg = MAX_TLS_MAC_DEL_MIM_ENTRIES_PER_MSG;
    SMMaxNumTlsMacMoveEntriesPerMesg = MAX_TLS_MAC_MOVE_ENTRIES_PER_MSG;
    SMMaxNumTlsMacQueryEntriesPerMesg = MAX_TLS_MAC_QUERY_ENTRIES_PER_MSG;
    SMMaxNumTlsMacCallbackEntriesPerMesg = MAX_TLS_MAC_CALLBACK_ENTRIES_PER_MSG;
    SMMaxNumSdpEntriesPerMesg = MAX_SDP_ENTRIES_PER_MSG;
    SMMaxNumSdpBindEntriesPerMesg = MAX_SVC_BIND_ENTRIES_PER_MSG;
    SMMaxNumSdpBindSwitchEntriesPerMesg = MAX_SVC_BIND_SWITCH_ENTRIES_PER_MSG;
    SMMaxNumSdpBindStateEntriesPerMesg = MAX_SVC_BIND_STATE_ENTRIES_PER_MSG;
    SMMaxNumSdpBindMcListPruneEntriesPerMesg = MAX_SVC_BIND_MCLISTPRUNE_ENTRIES_PER_MSG;
    SMMaxNumSdpBindMacLoopBackEntriesPerMesg = MAX_SVC_BIND_MAC_LPBK_ENTRIES_PER_MSG;
    SMMaxNumSapStatsEntriesPerMesg = MAX_SAP_STATS_ENTRIES_PER_MSG;
    SMMaxNumSapQueueStatsEntriesPerMesg = MAX_SAP_QUEUE_STATS_ENTRIES_PER_MSG;
    SMMaxNumEncapGrpQueueStatsEntriesPerMesg = MAX_ENCAP_GRP_QUEUE_STATS_ENTRIES_PER_MSG;
    SMMaxNumSdpBindStatsEntriesPerMesg = MAX_SDP_STATS_ENTRIES_PER_MSG;
    SMMaxNumMacQosFilterRuleEntriesPerMesg = MAX_MACQOS_FILTER_RULE_ENTRIES_PER_MSG;
    SMMaxNumIpQosFilterRuleEntriesPerMesg = MAX_IPQOS_FILTER_RULE_ENTRIES_PER_MSG;
    SMMaxNumQosMssEntriesPerMesg = MAX_QOS_SITE_ENTRIES_PER_MSG;
    SMMaxNumVSOverrideEntriesPerMesg = MAX_ICC_QOS_GROUP_OVERRIDES_PER_MSG;
    SMMaxNumQueueOverrideEntriesPerMesg = MAX_ICC_SAP_QOS_POLICY_OVERRIDES_PER_MSG;
    SMMaxNumQmdaQueueOverrideEntriesPerMesg = MAX_QMDA_SAP_QOS_POLICY_OVERRIDES_PER_MSG;
    SMMaxNumSapEgrEncapGroupEntriesPerMesg = MAX_STRUCT_ENCAP_GROUP_CONFIG_ENTRIES_PER_MSG;
    SMMaxNumSapEgrEncapMemberEntriesPerMesg = MAX_STRUCT_ENCAP_GROUP_CONFIG_MEMBERS_PER_MSG;
    SMMaxNumSubscrEntriesPerMesg = MAX_SUBSCR_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSubscrHostEntriesPerMesg = MAX_SUBSCR_HOST_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSubscrVSOverrideEntriesPerMesg
        = SMMaxNumSubProfVSOverrideEntriesPerMesg
        = SMMaxNumSubProfPlcrCtrlOverrideEntriesPerMesg
        = SMMaxNumSLAProfVSOverrideEntriesPerMesg = MAX_SUB_SCHEDULER_POLICY_OVERRIDE_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSubProfQueueOverrideEntriesPerMesg = MAX_SUB_QOS_POLICY_OVERRIDE_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSLAProfQueueOverrideEntriesPerMesg
        = SMMaxNumSLAProfPolicerOverrideEntriesPerMesg = MAX_SLA_QOS_POLICY_OVERRIDE_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSubQueueStatsEntriesPerMesg = MAX_SUB_QUEUE_STATS_ENTRIES_PER_MSG;
    SMMaxNumEmgEntriesPerMesg = MAX_EMG_ENTRIES_PER_MSG;
    SMMaxNumSubL3RedGroupEntriesPerMesg = MAX_SUB_L3_RED_GROUP_ENTRIES_PER_MIXED_MSG;
    SMMaxNumSubL3RedInterDestGroupIdEntriesPerMesg = MAX_SUB_L3_RED_INTER_DEST_GROUP_ENTRIES_PER_MIXED_MSG;
    
    /* Only allow this once */
    if ((pVSOverrideAddReqMesg != NULL) ||
        (pSapQosOverrideAddReqMesg != NULL) ||
        (pQmdaQueueOverrideAddReqMesg != NULL) ||
        (pSapEgrEncapGroupAddReqMesg != NULL) ||
        (pSapEgrEncapMemberAddReqMesg != NULL) ||
        (pVSOverrideDelReqMesg != NULL) ||
        (pSapQosOverrideDelReqMesg != NULL) ||
        (pQmdaQueueOverrideDelReqMesg != NULL) ||
        (pSapEgrEncapGroupDelReqMesg != NULL))
        return FAIL;

    /* Create synchronization semaphore used to serialize access to
     * the SdpAddReqMesg object used to batch up SDP_ADD messages.
     */
    if ((SdpAddSemId = semBCreateX(SEM_Q_PRIORITY, "SdpAddSem", -1)) == NULL) {
        return FAIL;
    }
    
    /* Create synchronization semaphore used to serialize access to
     * the SvcCfgReqMesg object used to batch up SVC_ADD messages.
     */
    if ((SvcCfgSemId = semBCreateX(SEM_Q_PRIORITY, "SvcCfgSem", -1)) == NULL) {
        return FAIL;
    }
    
    /* Create synchronization semaphore used to serialize access to
     * the pSapAddReqMesg object used to batch up SAP_ADD messages.
     */
    if ((SapAddSemId = semBCreateX(SEM_Q_PRIORITY, "SapAddSem", -1)) == NULL) {
        return FAIL;
    }
    
    /* Create synchronization semaphore used to serialize access to
     * the SapSwitchReqMesg object used to batch up SAP_SWITCH messages.
     */
    if ((SapSwitchSemId = semBCreateX(SEM_Q_PRIORITY, "SapSwitchSem", -1)) == NULL) {
        return FAIL;
    }
    
    /* Create synchronization semaphore used to serialize access to
     * the SdpBindReqMesg object used to batch up SDP_BIND messages.
     */
    if ((SdpBindSemId = semBCreateX(SEM_Q_PRIORITY, "SdpBindSem", -1)) == NULL) {
        return FAIL;
    }
    
    /* Create synchronization semaphore used to serialize access to
     * the pSubL3RedGroupRequest object.
     */
    if ((SubL3RedGroupSemId = semBCreateX(SEM_Q_PRIORITY, "SubL3RedGroupSemId", -1)) == NULL) {
        return FAIL;
    }
    
    /* Synchronization semaphore for synchronous TLS MAC QUERY ICC call */
    if ((IccSyncTlsMacQuery = semSCreateX(SEM_Q_PRIORITY, "IccSyncTlsMacQuery", -1)) == NULL) {
        return FAIL;
    }

    /* allocate space for sdpBind shadow sdp pointers */
    entries = MAX(SMMaxNumSdpBindEntriesPerMesg, SMMaxNumSdpBindSwitchEntriesPerMesg);
    entries = MAX(entries, SMMaxNumSdpBindStateEntriesPerMesg);

    if ((pSdpBindReqShadow = 
         SMGR_MEM_CALLOC(entries,sizeof(tSdpBndRec))) == NULL)
        return FAIL;
   
    if (smgrMesgImplInit(SmgrMsgr_DownloadTable, SmgrMsgr_DownloadTableNumEntries) != SUCCESS) {
        return FAIL;
    }
    
    if (smgrDndlerInit() != SUCCESS) {
        return FAIL;
    }
    
    return SUCCESS;
}

/* Once batch processing is done, this needs to be called */
PUBLIC void smgrBatchMesgProcessingDone(tBatchProcessing *pBatch)
{
#define BATCH_CAT_STR(str)  strlcat(Buf, str, sizeof(Buf));

    char Buf[128];
    
    Buf[0] = EOS;

    if (SMGR_BATCH_MESG_ENABLED(pBatch)) {
        if (pBatch->SvcAddSent || pBatch->SvcTlsSent || 
            pBatch->SvcVirtPortStateSent) {
            BATCH_CAT_STR("SvcAdd ");
            smgrFlushSvcAddMesg();
        }
                 
        if (pBatch->SapAddSent || pBatch->SapStateSent) {
            BATCH_CAT_STR("SapAdd ");
            smgrFlushSapAddMesg();
        }
            
        if (pBatch->SapSwitchSent) {
            BATCH_CAT_STR("SapSwitch ");
            smgrFlushSapSwitchMesg();
        }

        if (pBatch->SapCfmPrimVlanSent) {
            BATCH_CAT_STR("SapCfmPrimVlanSent ");
            smgrFlushSapCfmPrimVlanMesg();
        }
            
        if (pBatch->SapDelSent) {
            BATCH_CAT_STR("SapDel ");
            smgrFlushSapDelMesg();
        }
        
        if (pBatch->SdpBndAddSent || pBatch->SdpBndStateSent) {
            BATCH_CAT_STR("SdpBind ");
            smgrFlushSdpBindMesg();
        }
            
        if (pBatch->SdpBndSwitchSent) {
            BATCH_CAT_STR("SdpBindSwitch ");
            smgrFlushSdpBindSwitchMesg();
        }
            
        if (pBatch->SdpAddSent) {
            BATCH_CAT_STR("SdpAdd ");
            smgrFlushSdpAddMesg();
        }
            
        if (pBatch->EmgAddSent) {
            BATCH_CAT_STR("EmgAdd ");
            smgrFlushEmgAddMesg();
        }
            
        if (pBatch->MultSvcSiteAddSent) {
            BATCH_CAT_STR("MultSvcSiteAdd ");
            smgrFlushMultSvcSiteAddMesg();
        }

        if (pBatch->VSOverrideAddSent || pBatch->PCOverrideAddSent) {
            BATCH_CAT_STR("VSOvrAdd ");
            smgrFlushVSOverrideAddMesg();
        }

        if (pBatch->QueueOverrideAddSent || pBatch->SapQosOverrideAddSent) {
            BATCH_CAT_STR("SapQosOvrAdd ");
            smgrFlushSapQosOverrideAddMesg();
        }

        if (pBatch->SapQosOverrideDelSent || pBatch->QueueOverrideDelSent) {
            BATCH_CAT_STR("SapQosOvrDel ");
            smgrFlushSapQosOverrideDelMesg();
        }
            
        if (pBatch->QmdaQueueOverrideAddSent) {
            BATCH_CAT_STR("QmdaQueueOvrAdd ");
            smgrFlushQmdaQueueOverrideAddMesg();
        }

        if (pBatch->QmdaQueueOverrideDelSent) {
            BATCH_CAT_STR("QmdaQueueOvrDel ");
            smgrFlushQmdaQueueOverrideDelMesg();
        }

        if (pBatch->SapEgrEncapGroupAddSent) {
            BATCH_CAT_STR("SapEgrEncapGroupAdd ");
            smgrFlushSapEgrEncapGroupAddMesg();
        }

        if (pBatch->SapEgrEncapGroupDelSent) {
            BATCH_CAT_STR("SapEgrEncapGroupDel ");
            smgrFlushSapEgrEncapGroupDelMesg();
        }
            
        if (pBatch->SapEgrEncapMemberAddSent) {
            BATCH_CAT_STR("SapEgrEncapMemberAdd ");
            smgrFlushSapEgrEncapMemberAddMesg();
        }

        if (pBatch->SubscriberAddSent) {
            BATCH_CAT_STR("SubsAdd ");
            smgrFlushSubscriberAddMesg();
        }

        if (pBatch->SubscriberHostAddSent || pBatch->LnsSubscriberHostAddSent) {
            BATCH_CAT_STR("SubsHostAdd ");
            smgrFlushSubscriberHostAddMesg();
        }

        if (pBatch->SubscriberHostDelUnbindSent) {
            BATCH_CAT_STR("SubsHostDelUnbind ");
            smgrFlushSubscriberHostDelUnbindMesg();
        }

        if (pBatch->SubProfVSOverrideAddSent) {
            BATCH_CAT_STR("SubProfVSOvrAdd ");
            smgrFlushSubProfVSOverrideAddMesg();
        }
            
        if (pBatch->SubProfVSOverrideDelSent) {
            BATCH_CAT_STR("SubProfVSOvrDel ");
            smgrFlushSubProfVSOverrideDelMesg();
        }

        if (pBatch->SubProfPlcrCtrlOverrideAddSent) {
            BATCH_CAT_STR("SubProfPlcrCtrlOvrAdd ");
            smgrFlushSubProfPlcrCtrlOverrideAddMesg();
        }

        if (pBatch->SubProfPlcrCtrlOverrideDelSent) {
            BATCH_CAT_STR("SubProfPlcrCtrlOvrDel ");
            smgrFlushSubProfPlcrCtrlOverrideDelMesg();
        }

        if (pBatch->SubL3RedGroupSent) {
            BATCH_CAT_STR("SubL3RedGroup ");
            smgrFlushSubL3RedGroupMesg(pBatch->SyncIccMsg);
        }

        if (pBatch->SLAProfQueueOverrideAddSent) {
            BATCH_CAT_STR("SLAProfQueueOvrAdd ");
            smgrFlushSLAProfQueueOverrideAddMesg();
        }

        if (pBatch->SLAProfQueueOverrideDelSent) {
            BATCH_CAT_STR("SLAProfQueueOvrDel ");
            smgrFlushSLAProfQueueOverrideDelMesg();
        }
            
        if (pBatch->SLAProfPolicerOverrideAddSent) {
            BATCH_CAT_STR("SLAProfPolicerOvrAdd ");
            smgrFlushSLAProfPolicerOverrideAddMesg();
        }

        if (pBatch->SLAProfPolicerOverrideDelSent) {
            BATCH_CAT_STR("SLAProfPolicerOvrDel ");
            smgrFlushSLAProfPolicerOverrideDelMesg();
        }

        if (pBatch->SLAProfVSOverrideAddSent) {
            BATCH_CAT_STR("SLAProfVSOvrAdd ");
            smgrFlushSLAProfVSOverrideAddMesg();
        }

        if (pBatch->SLAProfVSOverrideDelSent) {
            BATCH_CAT_STR("SLAProfVSOvrDel ");
            smgrFlushSLAProfVSOverrideDelMesg();
        }

        if (pBatch->SubProfHsmda2EgrQueueOverrideAddSent) {
            BATCH_CAT_STR("SubProfHsmda2EgrQueueOvrAdd ");
            smgrFlushSubProfHsmda2EgrQueueOverrideAddMesg();
        }
            
        if (pBatch->SubProfHsmda2EgrQueueOverrideDelSent) {
            BATCH_CAT_STR("SubProfHsmda2EgrQueueOvrDel ");
            smgrFlushSubProfHsmda2EgrQueueOverrideDelMesg();
        }

        if (pBatch->SubVSOverrideAddSent) {
            BATCH_CAT_STR("SubVSOvrAdd ");
            smgrFlushSubVSOverrideAddMesg();
        }

        if (pBatch->SubVSOverrideDelSent) {
            BATCH_CAT_STR("SubVSOvrDel ");
            smgrFlushSubVSOverrideDelMesg();
        }
            
        if (pBatch->McRingRingnodeAddSent) {
            BATCH_CAT_STR("McRingRingnodeAdd ");
            smgrFlushMcRingRingnodeAddMesg();
        }

        if (pBatch->SvcTlsFloodUpdateSent) {
            BATCH_CAT_STR("SvcTlsFloodUpdate ");
            smgrFlushSvcTlsFloodUpdateMesg();
        }
            
        if (pBatch->SapTlsPruneSent) {
            BATCH_CAT_STR("SapTlsPrune ");
            smgrFlushSapTlsPrune();
        }

        if (pBatch->SdpBndTlsPruneSent) {
            BATCH_CAT_STR("SdpBndTlsPrune ");
            smgrFlushSdpBindMesg();
        }
        if (pBatch->TlsMacAddSent) {
            BATCH_CAT_STR("TlsMacAdd ");
            smgrFlushTlsMacAddMesg();
        }

        if (pBatch->TlsMacDelSent) {
            BATCH_CAT_STR("TlsMacDel ");
            smgrFlushTlsMacDelMesg();
        }

        if (Buf[0] != EOS)
            SVCMGR_EVENT(IOM_CALL, "%s", Buf);

        /* Reset *pBatch in case this function is called again */
        ZERO_STRUCT_PTR(pBatch);
        pBatch->Batch = TRUE;
    }
}

/* Callback proc when icc transaction completed */
PRIVATE void smgrIccCleanup(void *pHandle)
{
    tSMEventMsg *pMsg = (tSMEventMsg*) pHandle;
    tSMGenEventMsg *pGenMsg = (tSMGenEventMsg *) pMsg; 

    switch ((int)pMsg->Event) {
    case SME_MSAP:
        if (msapValidateMsg(pHandle) != SUCCESS) {
            goto FreeAndExit;
        }
        break;
    case SME_STP_SET_PORT_STATE_COMPLETED:
    case SME_SAP_BATCH_CALLBACK:
    case SME_FLUSH_MACS_COMPLETE:
    case SME_TLS_MAC_CALLBACK:
    case SME_SDPBIND_WITHDRAW_ING_LABEL_ACK:
    case SME_MIRROR_REM_SRC_ACK:
    case SME_BGP_MH_IOM_OP_COMPLETED:
    case SME_SAP_SDPBIND_L3_CALLBACK:
        break;
    case SME_CALLBACK:
        if (!pGenMsg->u.CallbackEvent.ProcessInSvcMain) {
            smgrProcessCallbackEvent(pMsg);
            goto FreeAndExit;
        }
        break;
    default:
        SVCMGR_ERROR(NOCLASS, "%p Bad Event %d", pMsg, pMsg->Event);
        goto FreeAndExit;
    }
        
    if (smgrEnqueueEventMsg(pMsg) != SUCCESS) {
        goto FreeAndExit;
    }
    return;
    
  FreeAndExit:
    smgrFreeEventMsg(pMsg);
}


/* Send an SDP_ADD message */
PUBLIC tStatus smgrSendSdpAddMesg(tSdpRec *pSdp, tSMSlot SlotNum)
{
    tStatus s;
    tUint32 SlotBitmap=0;
    
    SVCMGR_EVENT(IOM_CALL, "sdp=%u admin=%s oper=%s slot=%d",
                 pSdp->Id,
                 SdpAdminStatusName[pSdp->AdminStatus],
                 SdpOperStatusName[pSdp->OperStatus],
                 SlotNum);

    /* Serialize access to shared state data */
    semTake(SdpAddSemId, WAIT_FOREVER);

    /* If there are any pending SDP_ADD messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    if ((pSdpAddReqMesg) && (pSdpAddReqMesg->NumEntries > 0)) {
        if (smgrDoFlushSdpAddMesg(TRUE) != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "Can't pre-flush batched up messages !");
        }
    }
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    /* Now send the SDP_ADD message */
    if ((s = smgrDoBatchSdpAddMesg(pSdp, SlotBitmap, FALSE)) == SUCCESS) {
        s = smgrDoFlushSdpAddMesg(FALSE);
    }
        
    /* End of critical section */
    semGive(SdpAddSemId);
    
    return s;                                  
}


/* Batch up an SDP_ADD message */
PUBLIC tStatus smgrBatchSdpAddMesgPriv(tSdpRec *pSdp, tUint32 SlotBitmap,
                                       tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "sdp=%u admin=%s oper=%s slotbitmap=%d",
                 pSdp->Id,
                 SdpAdminStatusName[pSdp->AdminStatus],
                 SdpOperStatusName[pSdp->OperStatus],
                 SlotBitmap);

    /* Serialize access to shared state data */
    semTake(SdpAddSemId, WAIT_FOREVER);

    s = smgrDoBatchSdpAddMesg(pSdp, SlotBitmap, IsCardOnline);
        
    /* End of critical section */
    semGive(SdpAddSemId);
    
    if (pBatch && s == OK)
        pBatch->SdpAddSent = TRUE;
    
    return s;    
}


PRIVATE void smgrGetSdpDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                    const tSdpRec *pSdp,
                                    tUint32 IomOp,
                                    tUint32 SlotBitmap,
                                    tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_Sdp,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgSdpCmp,
                          pSdp);
}


/* Batch up an SDP_ADD message. This private function assumes
 * the caller has locked the SdpAddSem.
 */
PRIVATE tStatus smgrDoBatchSdpAddMesg(tSdpRec *pSdp, tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSdpDownloadInfo(&IccInfo, pSdp, IOM_SDP_ADD,
                           SlotBitmap, IsCardOnline);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((pSdpAddReqMesg) && (NextSdpAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevSdpAddIomBitMask))
        smgrDoFlushSdpAddMesg(TRUE);
    
    /* Set the bit mask */
    PrevSdpAddIomBitMask = IccInfo.IomBitMask;
   
    if (!pSdpAddReqMesg) {
        if ((pSdpAddReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_SDP_REQUEST_MSG(SMMaxNumSdpEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }

    /* Add new entry */
    pSdpAddReqMesg->Op = IOM_SDP_ADD;
    pSdpAddReqMesg->NumEntries = NextSdpAddEntry + 1;
    smgrInitSdpAddReqEntry(&pSdpAddReqMesg->Entries[NextSdpAddEntry], pSdp);

    /* If we reached the limit, flush the message */
    if (pSdpAddReqMesg->NumEntries == SMMaxNumSdpEntriesPerMesg) {
        s = smgrDoFlushSdpAddMesg(FALSE);
    } else {
        NextSdpAddEntry++;
    }
    
    return s;    
}


/* Flush batched up SDP_ADD messages */
PUBLIC tStatus smgrFlushSdpAddMesg(void)
{
    tStatus s;
    
    /* Serialize access to shared state data */
    semTake(SdpAddSemId, WAIT_FOREVER);
    
    s =  smgrDoFlushSdpAddMesg(FALSE);
    
    /* End of critical section */
    semGive(SdpAddSemId);
    
    return s;
}


/* Flush batched up SDP_ADD messages. This private function assumes
 * the caller has locked the SdpAddSem.
 */
PRIVATE tStatus smgrDoFlushSdpAddMesg(tBoolean PreFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevSdpAddIomBitMask;
    tStatus s = SUCCESS;

    if (!pSdpAddReqMesg) 
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x", pSdpAddReqMesg->NumEntries, IomBitMask);

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_Sdp,
                               IOM_SDP_ADD);
    
    if (pSdpAddReqMesg->NumEntries > 0) {        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo,pSdpAddReqMesg,PreFlush);
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSdpAddReqMesg->Op, IomBitMask,
                                    pSdpAddReqMesg,
                                    SIZE_SDP_REQUEST_MSG(pSdpAddReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                         IccInfo.IomBitMask);

        /* Start a new batch */
        NextSdpAddEntry = 0;
        smgrFreeClientMsg(pSdpAddReqMesg, s);
        pSdpAddReqMesg = NULL;
    }
    
    return s;
}


/* Send an SDP_DELETE message */
PUBLIC tStatus smgrSendSdpDelMesg(tSdpRec *pSdp)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSdpConfigRequest *pMsg;
    tStatus s = SUCCESS;
    tSmgrDndlerBlockType BlockType = SMGR_DNDLER_BLOCK;
    
    SVCMGR_EVENT(IOM_CALL, "sdp=%u", pSdp->Id);

    if (SDP_IS_ORIGIN_BGP_L2VPN_AUTO(pSdp->CreationOrigin)) {
        /* BGP AD/VPLS/VPWS created SDPs do not have dependencies with other non-SMGR sockets */ 
        BlockType = SMGR_DNDLER_MAY_BLOCK;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSdpDownloadInfo(&IccInfo, pSdp, IOM_SDP_DELETE,
                           ALL_APPLICABLE_IOMS, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
        
    if ((pMsg = SMGR_MESG_MEM_MALLOC(SIZE_SDP_REQUEST_MSG(1))) == NULL) {
        return FAIL;
    }
        
    pMsg->Op = IOM_SDP_DELETE;
    pMsg->NumEntries = 1;

    ZERO_STRUCT(pMsg->Entries[0]);

    pMsg->Entries[0].SdpId = pSdp->Id;
    
    /* Send the message to all the IOMs in the chassis that are
     * currently on-line.
     */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_SDP_REQUEST_MSG(pMsg->NumEntries),
                                NULL, BlockType);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);
    
    return s;
}


/* Send an SDP_AUDIT message */
PUBLIC tStatus smgrSendSdpAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSdpConfigRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "SDP AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSdpDownloadInfo(&IccInfo, NULL, IOM_SDP_AUDIT,
                           SlotBitmap, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
            
    if ((pMsg = SMGR_MESG_MEM_MALLOC(SIZE_SDP_REQUEST_MSG(1))) == NULL)
        return FAIL;
            
    pMsg->Op = IOM_SDP_AUDIT;
    pMsg->NumEntries = 1;
        
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);    
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_SDP_REQUEST_MSG(pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);
                     
    smgrFreeClientMsg(pMsg, s);

    return s;                                  
}

PRIVATE void smgrGetEmgDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                    const tTlsEmgRec *pEmg,
                                    tUint32 IomOp,
                                    tUint32 SlotBitmap,
                                    tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_Emg,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgEmgCmp,
                          pEmg);
}

/* Send an EMG_ADD message */
PUBLIC tStatus smgrSendEmgAddMesg(tTlsEmgRec *pEmg, tBoolean forceRebalance, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomEmgConfigRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0; 
        
    SVCMGR_EVENT(IOM_CALL, "emg=%s slot=%d", pEmg->Name, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
     
    smgrGetEmgDownloadInfo(&IccInfo, pEmg, IOM_EMG_ADD,
                           SlotBitmap, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pMsg = (tIomEmgConfigRequest *)SMGR_MESG_MEM_MALLOC(SIZE_EMG_CONFIG_REQUEST_MSG(1));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }
    
    pMsg->Op = IOM_EMG_ADD;
    pMsg->NumEntries = 1;

    ZERO_STRUCT(pMsg->Entries[0]);

    pMsg->Entries[0].EmgId = pEmg->InstanceId;
    pMsg->Entries[0].ChainLimit = pEmg->ChainLimit;
    pMsg->Entries[0].ForceRebalance = forceRebalance;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo,pMsg,FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_EMG_CONFIG_REQUEST_MSG(pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;                                  
}


/* Batch up an EMG_ADD message */
PUBLIC tStatus smgrBatchEmgAddMesgPriv(tTlsEmgRec *pEmg, tUint32 SlotBitmap, tBoolean IsCardOnline,
                                       tBatchProcessing *pBatch)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "emg=%s slotbitmap=0x%08x", pEmg->Name, SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetEmgDownloadInfo(&IccInfo, pEmg, IOM_EMG_ADD,
                           SlotBitmap, IsCardOnline);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
        
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((pEmgAddReqMesg) && (NextEmgAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevEmgAddIomBitMask))
        smgrDoFlushEmgAddMesg(TRUE);
    
    /* Set the bit mask */
    PrevEmgAddIomBitMask = IccInfo.IomBitMask;

    if (!pEmgAddReqMesg) {
        if ((pEmgAddReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_EMG_CONFIG_REQUEST_MSG(SMMaxNumEmgEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }
    
    /* Add new entry */
    pEmgAddReqMesg->Op = IOM_EMG_ADD;
    pEmgAddReqMesg->NumEntries = NextEmgAddEntry + 1;

    ZERO_STRUCT(pEmgAddReqMesg->Entries[NextEmgAddEntry]);

    pEmgAddReqMesg->Entries[NextEmgAddEntry].EmgId = pEmg->InstanceId;
    pEmgAddReqMesg->Entries[NextEmgAddEntry].ChainLimit = pEmg->ChainLimit;

    /* If we reached the limit, flush the message */
    if (pEmgAddReqMesg->NumEntries == SMMaxNumEmgEntriesPerMesg) {
        s = smgrDoFlushEmgAddMesg(FALSE);
        if (pBatch)
            pBatch->EmgAddSent = FALSE;
    } else {
        NextEmgAddEntry++;
        if (pBatch)
            pBatch->EmgAddSent = TRUE;
    }

    return s;    
}


/* Flush batched up EMG_ADD messages */
PRIVATE tStatus smgrDoFlushEmgAddMesg(tBoolean PreFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevEmgAddIomBitMask;
    tStatus s = SUCCESS;

    if (!pEmgAddReqMesg) 
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                 pEmgAddReqMesg->NumEntries, IomBitMask);
    
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_Emg,
                               IOM_EMG_ADD);
    
    if (pEmgAddReqMesg->NumEntries > 0) {
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pEmgAddReqMesg, PreFlush);    
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pEmgAddReqMesg->Op, IomBitMask,
                                    pEmgAddReqMesg,
                                    SIZE_EMG_CONFIG_REQUEST_MSG(pEmgAddReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        
        /* Start a new batch */
        NextEmgAddEntry = 0;
        smgrFreeClientMsg(pEmgAddReqMesg, s);
        pEmgAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushEmgAddMesg(void)
{
    return smgrDoFlushEmgAddMesg(FALSE);
}

/* Send an EMG_DELETE message */
PUBLIC tStatus smgrSendEmgDelMesg(tTlsEmgRec *pEmg)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomEmgConfigRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "emg=%s", pEmg->Name);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */    
    smgrGetEmgDownloadInfo(&IccInfo, pEmg, IOM_EMG_DELETE,
                           ALL_APPLICABLE_IOMS, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pMsg = (tIomEmgConfigRequest *)SMGR_MESG_MEM_MALLOC(SIZE_EMG_CONFIG_REQUEST_MSG(1));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }
    
    pMsg->Op = IOM_EMG_DELETE;
    pMsg->NumEntries = 1;

    ZERO_STRUCT(pMsg->Entries[0]);

    pMsg->Entries[0].EmgId = pEmg->InstanceId;
    
    /* Send the message to all the IOMs in the chassis that are
     * currently on-line.
     */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);    
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_EMG_CONFIG_REQUEST_MSG(pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;
}


/* Send an EMG_AUDIT message */
PUBLIC tStatus smgrSendEmgAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomEmgConfigRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "EMG AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetEmgDownloadInfo(&IccInfo, NULL, IOM_EMG_AUDIT,
                           SlotBitmap, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pMsg = (tIomEmgConfigRequest *)SMGR_MESG_MEM_MALLOC(SIZE_EMG_CONFIG_REQUEST_MSG(1));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }
    
    pMsg->Op = IOM_EMG_AUDIT;
    pMsg->NumEntries = 1;
    
    /* Send the message to all applicable IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_EMG_CONFIG_REQUEST_MSG(pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "EMG AUDIT failed: %d, for mask=%08x !", s,
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;
}


/* Send a SVC_ADD message */
PUBLIC tStatus smgrSendSvcAddMesg(tSvcRec *pSvc, tSMSlot SlotNum)
{
    tStatus s;
    tUint32 SlotBitmap=0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s slot=%d",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus],
                 SlotNum);
    
    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);
    
    /* If there are any pending SVC_ADD messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    smgrDoFlushSvcCfgMesg(TRUE);
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    /* Now send the SVC_ADD message */
    if ((s = smgrDoBatchSvcAddMesg(pSvc, SlotBitmap, FALSE)) == SUCCESS) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
    }
        
    /* End of critical section */
    semGive(SvcCfgSemId);
    
    return s;                                  
}    


/* Batch up a SVC_ADD message */
PUBLIC tStatus smgrBatchSvcAddMesgPriv(tSvcRec *pSvc, tUint32 SlotBitmap, tBoolean IsCardOnline,
                                       tBatchProcessing *pBatch)
{
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s slotbitmap=0x%08x",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus],
                 SlotBitmap);

    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);

    s = smgrDoBatchSvcAddMesg(pSvc, SlotBitmap, IsCardOnline);
        
    /* End of critical section */
    semGive(SvcCfgSemId);
    
    if (pBatch && s == OK)
        pBatch->SvcAddSent = TRUE;

    return s;
}

PRIVATE void smgrGetSvcDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                    const tSvcRec *pSvc,
                                    tUint32 IomOp,
                                    tUint32 SlotBitmap,
                                    tBoolean IsCardOnline,
                                    tBoolean UseChmgrBitmap)
{

    if (pSvc && pSvc->SvcDeleted && (IomOp != IOM_SVC_DELETE)) {
        SVCMGR_BERROR(IOM_CALL, "svc=%u delete but download requested - Suppressed.",
                      pSvc->Id);
        pIccInfo->IomBitMask = 0;
        return;
    }
    
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          (IomOp == IOM_SVC_TLS_FWDING_UPDATE) ?
                          SmgrMsgrEntry_SvcTls : SmgrMsgrEntry_Svc,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          UseChmgrBitmap,                          
                          smgrMesgSvcCmp,
                          pSvc);
}


/* Send a SVC_ADD message asynchronously, allowing the possibility
 * of a callback after acknowledgement is received from ICC.
 * Caller needs to test if ppCallbackEvent != NULL afterwards and
 * cleanup */
PUBLIC tStatus smgrSendSvcAddMesgWithCallback(tSvcRec *pSvc, tSMSlot SlotNum,
                                              struct SMEventMsg **ppCallbackEvent)
{
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask;
    tIomSvcConfigRequest *pReq;
    tUint32 NumCallbackEvents = 0;
    tSmgrDndlerBlockType BlockingType = SMGR_DNDLER_MAY_BLOCK;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s slot=%d",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus],
                 SlotNum);

    /* I-VPLS svcs at present don't use this function and hence it
     * doesn't handle I-VPLS ParentMcastId changes. If in future
     * I-VPLS starts using this function, handle ParentMcastId changes
     * and remove ASSERT */
    ASSERT_MSG(!IS_IVPLS_SVC(pSvc), "svc=%u type=%u - not supported for i-vpls",
               pSvc->Id,
               pSvc->Type);
    
    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);
    
    /* If there are any pending SVC_ADD messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    smgrDoFlushSvcCfgMesg(TRUE);
   
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);

    smgrGetSvcDownloadInfo(&IccInfo, pSvc, IOM_SVC_ADD, SlotBitmap, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        semGive(SvcCfgSemId);
        return SUCCESS;
    }
        
    /* Set the bit mask */
    IomBitMask = IccInfo.IomBitMask;

    if ((pReq = SMGR_MESG_MEM_MALLOC(SIZE_SVC_REQUEST_MSG(IOM_SVC_ADD, 1))) == NULL) {
        semGive(SvcCfgSemId);
        return FAIL;
    }

    pReq->NumEntries = 1;
    pReq->Op = IOM_SVC_ADD;
    smgrInitSvcAddReqEntry(&pReq->u.Add[0], pSvc, ppCallbackEvent ? *ppCallbackEvent : NULL, NULL, FALSE);

    if (ppCallbackEvent) {
        NumCallbackEvents = *ppCallbackEvent ? 1 : 0;
        *ppCallbackEvent = NULL;
    }
    
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_Svc,
                               pReq->Op);

    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pReq, FALSE); 
    
    /* Buffered download: This message download will be blocking if it's the first time
     * the svc record is being downloaded to these IOMs. This is because ICC messages
     * destined to non-SMGR sockets may depend on the service creation (e.g. Interfaces,
     * IGMP-snooping, MLD-snooping, PIM-snooping, ...) */
    if (BITUTILS_BIT_UNION(pSvc->BlkDndledToIomBM, IomBitMask) != pSvc->BlkDndledToIomBM) {
        BlockingType = SMGR_DNDLER_BLOCK;
        pSvc->BlkDndledToIomBM |= IomBitMask;
    }

    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pReq->Op,
                                      IomBitMask, pReq, 
                                      SIZE_SVC_REQUEST_MSG(pReq->Op, pReq->NumEntries),
                                      NULL, BlockingType, CAST_INT_TO_PTR(void *, NumCallbackEvents),
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSvcCfg);
    if (s != SUCCESS) {
        SVCMGR_EVENT(IOM_CALL, "smgrSendClientCustomMsgToIoms() failed for mask=%08x !",
                     IomBitMask);
    
        /* If sending to IOM fails, ICC will not call smgrIccCleanSendSvcCfg -- call it here */
        smgrIccCleanSendSvcCfg(pReq, CAST_INT_TO_PTR(void*, NumCallbackEvents));
    }

    /* End of critical section */
    semGive(SvcCfgSemId);
    
    return s;                                  
}

/* Cleanup after delivered SVC CFG messages to the IOM Async */
PUBLIC void smgrIccCleanSendSvcCfg(void *pIccMsg, void *pUserData)
{
    tUint32 i;
    tUint32 nCb = 0;
    tUint32 ExpNumCb = CAST_PTR_TO_INT(tUint32, pUserData);
    tIomSvcConfigRequest *pMsg = (tIomSvcConfigRequest *)pIccMsg;
    
    switch(pMsg->Op) {
    case IOM_SVC_ADD:
        if (ExpNumCb) {
            for (i = 0; i < pMsg->NumEntries; i++) {
                if (pMsg->u.Add[i].handle.Cpm) {
                    smgrIccCleanup(pMsg->u.Add[i].handle.Cpm);
                    nCb++;
                }
            }
        }
        break;
    
    case IOM_SVC_DELETE:
    case IOM_SVC_AUDIT:
    case IOM_SVC_ADD_VIRTUAL_PORT_STATE:
    case IOM_SVC_ADD_TLS_FLOOD_UPDATE:
    case IOM_SVC_TLS_FWDING_UPDATE:
    case IOM_SVC_SYS_WIDE_UPDATE:
    default:
        ;
    }

    SVCMGR_EVENT(IOM_CALL, "entries=%u op=%u #cb=%u ExpNumCb=%u",
                 pMsg->NumEntries, pMsg->Op, nCb, ExpNumCb);    
    SMGR_MESG_MEM_FREE(pIccMsg);
}


/* Batch up a SVC_ADD message. This private function assumes
 * the caller has locked the SvcAddSem.
 */
PRIVATE tStatus smgrDoBatchSvcAddMesg(tSvcRec *pSvc, tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tSmgrInitSvcAddReqEntryRetParams RetParams = {0};
    tBoolean AddDndlerCallback = (runtime_feature_smgr_buffered_download &&
                                  IS_IVPLS_SVC(pSvc));

    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s slotbitmap=0x%08x "
                 "AddDndlerCallback %u",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus],
                 SlotBitmap, AddDndlerCallback);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSvcDownloadInfo(&IccInfo, pSvc, IOM_SVC_ADD,
                           SlotBitmap, IsCardOnline, FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "bitmap=0");

        if (!IsCardOnline && /* Update IomParentMcastId only if req is sent to all IOMs */
            IS_IVPLS_SVC(pSvc)) {
            tTlsIVplsObj *pIVplsObj = pSvc->u.Tls->Pbb.pIVplsObj;
            if (pIVplsObj->IomParentMcastId != pIVplsObj->ParentMcastId) {
                if (pIVplsObj->IomParentMcastId) {
                    if (AddDndlerCallback)
                        smgrSvcDecrMidDndled(pIVplsObj->IomParentMcastId);
                    pIVplsObj->IomParentMcastId = 0;
                }
                if (pIVplsObj->ParentMcastId) {
                    pIVplsObj->IomParentMcastId = pIVplsObj->ParentMcastId;
                    if (AddDndlerCallback)
                        smgrSvcIncrMidDndled(pIVplsObj->IomParentMcastId);
                }
            }
        }
        
        return SUCCESS;
    }
        
    smgrCheckFlushSvcCfgMesg(IOM_SVC_ADD, IccInfo.IomBitMask);
    
    /* Set the bit mask */
    PrevSvcCfgIomBitMask = IccInfo.IomBitMask;

    if (!pSvcCfgReqMesg) {
        if ((pSvcCfgReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_REQUEST_MSG(IOM_SVC_ADD, SMMaxNumSvcAddEntriesPerMesg))) == NULL) {
            SVCMGR_INFORM(NOCLASS, "Unable to allocate memory for msg (Svc %u IomBitMask 0x%X)",
                  pSvc->Id, IccInfo.IomBitMask);
            return FAIL;
        }
        pSvcCfgReqMesg->NumEntries = 0;
    }
    
    pSvcCfgReqMesg->Op = IOM_SVC_ADD;
    smgrInitSvcAddReqEntry(&pSvcCfgReqMesg->u.Add[pSvcCfgReqMesg->NumEntries], pSvc, NULL,
                           AddDndlerCallback? &RetParams : NULL, IsCardOnline);
                               
    if (AddDndlerCallback &&
        RetParams.IomParentMcastIdChgd) {
        
        if (RetParams.OldIomParentMcastId != 0) {
            if (pSvcAddDndlerCbEvtMsgs == NULL) { 
                pSvcAddDndlerCbEvtMsgs
                    = SMGR_MESG_MEM_CALLOC(sizeof(*pSvcAddDndlerCbEvtMsgs), SMMaxNumSvcAddEntriesPerMesg);
                if (pSvcAddDndlerCbEvtMsgs == NULL) {
                    SVCMGR_INFORM(NOCLASS, "Unable to allocate memory for array (Svc %u IomBitMask 0x%X)",
                                  pSvc->Id, IccInfo.IomBitMask);
                    return FAIL;
                }
            }
            
            /* Insert old MID in Dndler CB */
            pSvcAddDndlerCbEvtMsgs[pSvcCfgReqMesg->NumEntries] = RetParams.OldIomParentMcastId;
        }
        
        /* Increment count for new MID */
        smgrSvcIncrMidDndled(pSvcCfgReqMesg->u.Add[pSvcCfgReqMesg->NumEntries].u.Tls.IsidPrunedMId);
    }
    
    pSvcCfgReqMesg->NumEntries++;

    if (BITUTILS_BIT_UNION(pSvc->BlkDndledToIomBM, PrevSvcCfgIomBitMask) != pSvc->BlkDndledToIomBM ||
        pSvc->BlkDnldToIom) {
        /* Buffered download: This message download will be blocking if it's the first time
         * the svc record is being downloaded to these IOMs. This is because ICC messages
         * destined to non-SMGR sockets may depend on the service creation (e.g. Interfaces,
         * IGMP-snooping, MLD-snooping, PIM-snooping, ...)
         * If the sender has requested for the message download to be blocking, we'll do so here */
        SvcDnldBlockType = SMGR_DNDLER_BLOCK;
        pSvc->BlkDndledToIomBM |= PrevSvcCfgIomBitMask;
        pSvc->BlkDnldToIom = FALSE;
    }
    
    /* If we reached the limit, flush the message */
    if (pSvcCfgReqMesg->NumEntries == SMMaxNumSvcAddEntriesPerMesg) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
    }

    return s;
}


/* Flush of batched up SvcCfg mesg. */
PUBLIC tStatus smgrFlushSvcAddMesg(void)
{
    tStatus s;

    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);
    
    s =  smgrDoFlushSvcCfgMesg(FALSE);
    
    /* End of critical section */
    semGive(SvcCfgSemId);
    
    return s;
}
 
/* Send a SVC_VIRTUAL_PORT_STATE message */
PUBLIC tStatus smgrSendSvcVirtPortStateMesg(tSvcRec *pSvc)
{
    tStatus s;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus]);
    
    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);

    /* If any pending SVC_ADD or SVC_VIRTUAL_PORT_STATE  messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    smgrDoFlushSvcCfgMesg(TRUE);
    
    /* Now send the SVC_VIRTUAL_PORT_STATE message */
    if ((s = smgrDoBatchSvcVirtPortStateMesg(pSvc)) == SUCCESS) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
    }
        
    /* End of critical section */
    semGive(SvcCfgSemId);
    
    return s;                                  
}    


/* Batch up a SVC_VIRTUAL_PORT_STATE message */
PUBLIC tStatus smgrBatchSvcVirtPortStateMesg(tSvcRec *pSvc, tBatchProcessing *pBatch)
{
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus]);

    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);

    s = smgrDoBatchSvcVirtPortStateMesg(pSvc);
        
    /* End of critical section */
    semGive(SvcCfgSemId);

    if (pBatch && s == OK)
        pBatch->SvcVirtPortStateSent = TRUE;

    return s;
}


/* Batch up a SVC_VIRTUAL_PORT_STATE message. This private function assumes
 * the caller has locked the SvcCfgSemId.
 */
PRIVATE tStatus smgrDoBatchSvcVirtPortStateMesg(tSvcRec *pSvc)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus]);

    if (!IS_IVPLS_SVC(pSvc) || !IS_TLS(pSvc)) {
        SVCMGR_ERROR(IOM_CALL, "svc=%u type=%u",
                     pSvc->Id,
                     pSvc->Type);
        return FAIL;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSvcDownloadInfo(&IccInfo, pSvc, IOM_SVC_ADD_VIRTUAL_PORT_STATE,
                           ALL_APPLICABLE_IOMS, FALSE, TRUE);
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;
    
    smgrCheckFlushSvcCfgMesg(IOM_SVC_ADD_VIRTUAL_PORT_STATE, IccInfo.IomBitMask);
    
    /* Set the bit mask */
    PrevSvcCfgIomBitMask = IccInfo.IomBitMask;

    if (!pSvcCfgReqMesg) {
        if ((pSvcCfgReqMesg = SMGR_MESG_MEM_MALLOC(
                 SIZE_SVC_REQUEST_MSG(IOM_SVC_ADD_VIRTUAL_PORT_STATE,
                                      SMMaxNumSvcVirtPortEntriesPerMesg))) == NULL) {
            return FAIL;
        }
        pSvcCfgReqMesg->NumEntries = 0;
    }

    pSvcCfgReqMesg->Op = IOM_SVC_ADD_VIRTUAL_PORT_STATE;
    smgrInitSvcVirtPortStateEntry(&pSvcCfgReqMesg->u.Pip[pSvcCfgReqMesg->NumEntries], pSvc);
    pSvcCfgReqMesg->NumEntries++;

    /* If we reached the limit, flush the message */
    if (pSvcCfgReqMesg->NumEntries == SMMaxNumSvcVirtPortEntriesPerMesg) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
    } 

    return s;
}

/* Flush of batched up SVC_TLS_FLOOD_UPDATE mesgs. */
PUBLIC tStatus smgrFlushSvcTlsFloodUpdateMesg(void)
{
    return (smgrFlushSvcAddMesg());
}

/* Send a SVC_TLS_FLOOD_UPDATE message */
PUBLIC tStatus smgrSendSvcTlsFloodUpdateMesg(tSvcRec *pSvc)
{
    tStatus s;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u",
                 pSvc->Id,
                 pSvc->Type);
    
    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);

    /* If any pending SVC_ADD or SVC_VIRTUAL_PORT_STATE or
     * SVC_TLS_FLOOD_UPDATE messages batched up (by some other task
     * running concurrently with us) then pre-flush them now to
     * preserve the relative time ordering of messages.
     */
    smgrDoFlushSvcCfgMesg(TRUE);
    
    /* Now send the SVC_TLS_FLOOD_UPDATE message */
    if ((s = smgrDoBatchSvcTlsFloodUpdateMesg(pSvc)) == SUCCESS) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
    }
        
    /* End of critical section */
    semGive(SvcCfgSemId);
    
    return s;                                  
}    

/* Batch up a SVC_TLS_FLOOD_UPDATE message */
PUBLIC tStatus smgrBatchSvcTlsFloodUpdateMesg(tSvcRec *pSvc, tBatchProcessing *pBatch)
{
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u",
                 pSvc->Id,
                 pSvc->Type);

    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);

    s = smgrDoBatchSvcTlsFloodUpdateMesg(pSvc);
        
    /* End of critical section */
    semGive(SvcCfgSemId);
    
    if (pBatch && s == OK)
        pBatch->SvcTlsFloodUpdateSent = TRUE;

    return s;
}


/* Batch up a SVC_TLS_FLOOD_UPDATE message. This private function assumes
 * the caller has locked the SvcCfgSemId.
 */
PRIVATE tStatus smgrDoBatchSvcTlsFloodUpdateMesg(tSvcRec *pSvc)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u",
                 pSvc->Id,
                 pSvc->Type);

    if (!IS_TLS(pSvc)) {
        SVCMGR_ERROR(IOM_CALL, "svc=%u type=%u - not supported",
                     pSvc->Id,
                     pSvc->Type);
        return FAIL;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSvcDownloadInfo(&IccInfo, pSvc, IOM_SVC_ADD_TLS_FLOOD_UPDATE,
                           ALL_APPLICABLE_IOMS, FALSE, FALSE);
    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;
    
    smgrCheckFlushSvcCfgMesg(IOM_SVC_ADD_TLS_FLOOD_UPDATE, IccInfo.IomBitMask);
    
    /* Set the bit mask */
    PrevSvcCfgIomBitMask = IccInfo.IomBitMask;

    if (!pSvcCfgReqMesg) {
        if ((pSvcCfgReqMesg = SMGR_MESG_MEM_MALLOC(
                 SIZE_SVC_REQUEST_MSG(IOM_SVC_ADD_TLS_FLOOD_UPDATE,
                                      SMMaxNumSvcTlsFloodEntriesPerMesg))) == NULL) {
            return FAIL;
        }
        pSvcCfgReqMesg->NumEntries = 0;
    }

    pSvcCfgReqMesg->Op = IOM_SVC_ADD_TLS_FLOOD_UPDATE;
    smgrInitSvcTlsFloodUpdateEntry(&pSvcCfgReqMesg->u.TlsFlood[pSvcCfgReqMesg->NumEntries], pSvc);
    pSvcCfgReqMesg->NumEntries++;
    
    /* If we reached the limit, flush the message */
    if (pSvcCfgReqMesg->NumEntries == SMMaxNumSvcTlsFloodEntriesPerMesg) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
    } 

    return s;
}

/* Check whether flushing of batched up SvcCfg mesg is needed. If so, flush. */
PRIVATE void smgrCheckFlushSvcCfgMesg(eSvcConfigOp operation, tUint32 IomBitMask)
{
    if (!pSvcCfgReqMesg)
        return;

    if (pSvcCfgReqMesg->NumEntries == 0)
        return;

    if ((IomBitMask != PrevSvcCfgIomBitMask) || (operation != pSvcCfgReqMesg->Op))
        smgrDoFlushSvcCfgMesg(TRUE);
}


/* Flush batched up SVC_ADD, SVC_VIRTUAL_PORT_STATE, SVC_TLS_FLOOD_UPDATE messages. 
 * This private function assumes the caller has locked the SvcCfgSem.
 */
PUBLIC tStatus smgrDoFlushSvcCfgMesg(tBoolean preFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevSvcCfgIomBitMask;
    tStatus s = SUCCESS;
    void *pDndlerCbEvtMsgs = NULL;

    if (!pSvcCfgReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "op=%u entries=%u mask=%08x", 
                 pSvcCfgReqMesg->Op, pSvcCfgReqMesg->NumEntries, IomBitMask);

    /* Flush batched MacDelReqMesg before flushing TempFlood Update
     * Mesgs (SvcCfgReqMesg) */
    if (pSvcCfgReqMesg->Op == IOM_SVC_ADD_TLS_FLOOD_UPDATE) {
        smgrDoFlushTlsMacDelMesg(TRUE);
    }
    
    if (pSvcCfgReqMesg->NumEntries > 0) {
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   (pSvcCfgReqMesg->Op == IOM_SVC_TLS_FWDING_UPDATE) ?
                                   SmgrMsgrEntry_SvcTls: SmgrMsgrEntry_Svc,
                                   pSvcCfgReqMesg->Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSvcCfgReqMesg, preFlush);
        
        switch (pSvcCfgReqMesg->Op) {
        case IOM_SVC_ADD:
            pDndlerCbEvtMsgs = pSvcAddDndlerCbEvtMsgs;
            break;
        case IOM_SVC_TLS_FWDING_UPDATE:
            pDndlerCbEvtMsgs = pSvcTlsFwdDndlerCbEvtMsgs;
            break;
        case IOM_SVC_DELETE:
        case IOM_SVC_AUDIT:
        case IOM_SVC_ADD_VIRTUAL_PORT_STATE:
        case IOM_SVC_ADD_TLS_FLOOD_UPDATE:
        case IOM_SVC_SYS_WIDE_UPDATE:
        default: /* Do nothing */
            break;
        }

        /* Buffered download: This message download will be blocking if it's the first time
         * the svc record is being downloaded to these IOMs. This is because ICC messages
         * destined to non-SMGR sockets may depend on the service creation (e.g. Interfaces,
         * IGMP-snooping, MLD-snooping, PIM-snooping, ...) */
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSvcCfgReqMesg->Op, IomBitMask,
                                    pSvcCfgReqMesg,
                                    SIZE_SVC_REQUEST_MSG(pSvcCfgReqMesg->Op, pSvcCfgReqMesg->NumEntries),
                                    pDndlerCbEvtMsgs, SvcDnldBlockType);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                         IccInfo.IomBitMask);

            switch (pSvcCfgReqMesg->Op) {
            case IOM_SVC_ADD:
                smgrDndlerSvcAddCallbackCleanup(pSvcAddDndlerCbEvtMsgs, pSvcCfgReqMesg->NumEntries);
                break;
            case IOM_SVC_TLS_FWDING_UPDATE:
                smgrDndlerSvcTlsCallbackCleanup(pSvcTlsFwdDndlerCbEvtMsgs, pSvcCfgReqMesg->NumEntries);
                break;
            case IOM_SVC_DELETE:
            case IOM_SVC_AUDIT:
            case IOM_SVC_ADD_VIRTUAL_PORT_STATE:
            case IOM_SVC_ADD_TLS_FLOOD_UPDATE:
            case IOM_SVC_SYS_WIDE_UPDATE:
            default: /* Do nothing */
                break;
            }
        }

        /* Start a new batch */
        smgrFreeClientMsg(pSvcCfgReqMesg, s);
        pSvcCfgReqMesg = NULL;
        SvcDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
        pSvcTlsFwdDndlerCbEvtMsgs = NULL;
        pSvcAddDndlerCbEvtMsgs = NULL;
    }
    
    return s;
}


/* Send a SVC_DELETE message */
PUBLIC tStatus smgrSendSvcDelMesg(tSvcRec *pSvc, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo; 
    tIomSvcConfigRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u slot=%d", pSvc->Id, pSvc->Type, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSvcDownloadInfo(&IccInfo, pSvc, IOM_SVC_DELETE,
                           SlotBitmap, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((pMsg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_DEL_REQUEST_MSG(1))) == NULL) {
        return FAIL;
    }
        
    pMsg->Op = IOM_SVC_DELETE;
    pMsg->NumEntries = 1;

    ZERO_STRUCT(pMsg->u.Del[0]);

    pMsg->u.Del[0].SvcId = pSvc->Id;
        
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_SVC_REQUEST_MSG(pMsg->Op, pMsg->NumEntries),
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);
    } else {
        pSvc->SvcDeleted = TRUE;
    }

    smgrFreeClientMsg(pMsg, s);
    
    return s;
}
    

/* Send an SVC_AUDIT message */
PUBLIC tStatus smgrSendSvcAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo; 
    tIomSvcConfigRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "SVC AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSvcDownloadInfo(&IccInfo, NULL, IOM_SVC_AUDIT,
                           SlotBitmap, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((pMsg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_REQUEST_MSG(IOM_SVC_AUDIT, 0))) == NULL)
        return FAIL;
    
    pMsg->Op = IOM_SVC_AUDIT;
    pMsg->NumEntries = 0;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_SVC_REQUEST_MSG(pMsg->Op, pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);
                     
    smgrFreeClientMsg(pMsg, s);

    return s;
}


PRIVATE void smgrInitSvcTlsReqEntry(tIomSvcTlsFwdingEntry *pEntry, tSvcRec *pSvc)
{
    tUint32 shg;
    ZERO_STRUCT_PTR(pEntry);
    pEntry->SvcId = pSvc->Id;
    pEntry->SapSdpMcastId = svcTlsGetMcastId(pSvc);
    pEntry->AllSapTapMap =  pSvc->SapTapBitMask;
    
    for (shg = 1; shg <= MAX_SPLIT_HORIZON_GROUPS_PER_TLS; shg++) {
        pEntry->ShgSapTapMap[shg] = pSvc->u.Tls->TlsShgTapsToReachBitMask[shg];
    }
}

/* Send a IOM_SVC_TLS_FWDING_UPDATE message */
PUBLIC tStatus smgrBatchSvcTlsMesgPriv(tSvcRec *pSvc, tUint32 SlotBitmap, tBoolean IsCardOnline,
                                       tBatchProcessing *pBatch)
{
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    const eSvcConfigOp IomOp = IOM_SVC_TLS_FWDING_UPDATE;
    tSfMcastId SapSdpMcastIdPendDel;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u type=%u admin=%s oper=%s slotbitmap=0x%08x",
                 pSvc->Id,
                 pSvc->Type,
                 SvcAdminStatusName[pSvc->AdminStatus],
                 SvcOperStatusName[pSvc->OperStatus],
                 SlotBitmap);

    if (!IS_TLS(pSvc)) {
        SVCMGR_BERROR(IOM_CALL, "Not VPLS svc=%u type=%u", pSvc->Id, pSvc->Type);
        return s;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSvcDownloadInfo(&IccInfo, pSvc, IomOp,
                           SlotBitmap, IsCardOnline, FALSE);

    /* Serialize access to shared state data */
    semTake(SvcCfgSemId, WAIT_FOREVER);
    
    SapSdpMcastIdPendDel = svcTlsGetMcastIdPendDel(pSvc);
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "bitmap=0");        
        goto Done;
    }

    smgrCheckFlushSvcCfgMesg(IomOp, IccInfo.IomBitMask);
    
    if (!pSvcCfgReqMesg) {
        if ((pSvcCfgReqMesg = SMGR_MESG_MEM_MALLOC(
                 SIZE_SVC_REQUEST_MSG(IomOp,
                                      SMMaxNumSvcTlsEntriesPerMesg))) == NULL) {
            SVCMGR_INFORM(NOCLASS, "Unable to allocate memory for msg (Svc %u IomBitMask 0x%X)",
                          pSvc->Id, IccInfo.IomBitMask);
            s = FAIL;
            goto Done;
        }
        pSvcCfgReqMesg->NumEntries = 0;
    }
    
    /* Set the bit mask */
    PrevSvcCfgIomBitMask = IccInfo.IomBitMask;    

    pSvcCfgReqMesg->Op = IomOp;
    smgrInitSvcTlsReqEntry(&pSvcCfgReqMesg->u.TlsFwding[pSvcCfgReqMesg->NumEntries], pSvc);
    
    if (SapSdpMcastIdPendDel != INVALID_MCID &&
        ! IsCardOnline) {
        /* Attach a Dndler callback so that the old MCID is eventually properly freed */                

        if (pSvcTlsFwdDndlerCbEvtMsgs == NULL) { 
            pSvcTlsFwdDndlerCbEvtMsgs
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSvcTlsFwdDndlerCbEvtMsgs), SMMaxNumSvcTlsEntriesPerMesg);
            if (pSvcTlsFwdDndlerCbEvtMsgs == NULL) {
                SVCMGR_INFORM(NOCLASS, "Unable to allocate memory for array (Svc %u IomBitMask 0x%X)",
                              pSvc->Id, IccInfo.IomBitMask);
                s = FAIL;
                goto Done;
            }
        }
        
        pSvcTlsFwdDndlerCbEvtMsgs[pSvcCfgReqMesg->NumEntries] = SapSdpMcastIdPendDel;                
        pSvc->u.Tls->SapSdpMcastIdPendDel = INVALID_MCID;
    }
    
    pSvcCfgReqMesg->NumEntries++;
    
    /* If we reached the limit, flush the message */
    if (pSvcCfgReqMesg->NumEntries >= SMMaxNumSvcTlsEntriesPerMesg) {
        s = smgrDoFlushSvcCfgMesg(FALSE);
        if (pBatch)
            pBatch->SvcTlsSent = FALSE;
    } else {
        if (pBatch)
            pBatch->SvcTlsSent = TRUE;
    }

    /* End of critical section */
    semGive(SvcCfgSemId);

    return s;
    
    
Done:
    if (SapSdpMcastIdPendDel != INVALID_MCID) {
        mcidFree(pSvc->u.Tls->SapSdpMcastIdPendDel, TRUE);
        pSvc->u.Tls->SapSdpMcastIdPendDel = INVALID_MCID;
    }

    semGive(SvcCfgSemId);

    return s;
}


/* Send download dpi transit ip audit message */
PUBLIC tStatus smgrSendDpiTransitIpAudit(tSMSlot SlotNum, tMdaNum MdaNum)
{
    tIomDpiIpRequest *pMsg = SMGR_MESG_MEM_CALLOC(1, SIZE_DPI_IP_REQUEST_MSG(1));
    if (pMsg == NULL) {
        SVCMGR_ERROR(IOM_CALL, "DPI IP AUDIT MESG alloc failed, slot %u", SlotNum);
        return FAIL;
    }
    
    SVCMGR_EVENT(IOM_CALL, "DPI IP AUDIT MESG, slot %u, mda %u", SlotNum, MdaNum);
    
    pMsg->NumDpiIpEntries = 1;
    
    tDpiIpEntry *pEntry = &pMsg->DpiIpEntries[0];
    pEntry->Op = IOM_DPI_IP_AUDIT_END;
    ZERO_STRUCT(pEntry->DpiSubIpAddr);
    pEntry->DpiSubId = DPI_SMGR_TRANSIT_SUB_INVALID_ID;
    pEntry->DpiMdaNumMask = (1 << MdaNum);
    pEntry->DpiIpPlcyIdx = INVALID_AA_TRANSIT_IP_POLICY_ID;

    tStatus s;
    if ((s = smgrSendDpiIpMesg(SlotNum, pMsg)) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "DPI IP AUDIT END MESG failed, slot=%d, status=%d",
                     SlotNum, s);
    }
    
    SMGR_MESG_MEM_FREE(pMsg);
    
    return s;
}

PRIVATE void smgrGetDpiIpDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                      tUint32 IomOp,
                                      tUint32 SlotBitmap,
                                      tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_DpiIp,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccDpiIpCmp);
}

PUBLIC tStatus smgrSendDpiIpMesg(tSMSlot SlotNum, tIomDpiIpRequest *pMsg)
{
    tUint32 SlotBitmap = 0;
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(IOM_CALL, "DPI IP MESG, slot %u, %u entries from Inactive CPM",
                     SlotNum, pMsg->NumDpiIpEntries);
        return OK;
    }
    
    tSmgrMsgrIccInfo IccInfo;
    int i=0;
    
    SVCMGR_EVENT(IOM_CALL, "DPI IP MESG, slot %u, %u entries",
                 SlotNum, pMsg->NumDpiIpEntries);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    if ((SlotNum == ALL_APPLICABLE_IOMS) || (SlotNum == THIS_SAP_IOMS)) {
        SVCMGR_ERROR(NOCLASS, "Invalid slot");
        return FAIL;
    }
    
    for (i = 0 ; i < pMsg->NumDpiIpEntries; i++) {        
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_DpiIp,
                                   pMsg->DpiIpEntries[i].Op);

        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    }
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetDpiIpDownloadInfo(&IccInfo, // Out
                             IOM_DPI_IP_ADD, /* Use any opcode as a place holder to get the bit map */
                             SlotBitmap,
                             FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "DPI IP MESG, download suppressed for SlotBitmap 0x%x, slot %u, %u entries",
                     SlotBitmap, SlotNum, pMsg->NumDpiIpEntries);
        return SUCCESS;
    }

    /* Send the message to all applicable IOM's */
    tStatus s = smgrSendMesgToIoms(IccInfo.pMsgrEntry->IccSocket, IccInfo.IomBitMask, pMsg,
                                   SIZE_DPI_IP_REQUEST_MSG(pMsg->NumDpiIpEntries));
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "DPI IP MESG failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    }
    return s;
}

/* Send download dpi transit prefix audit message */
PUBLIC tStatus smgrSendDpiTransitPrefixAudit(tSMSlot SlotNum, tMdaNum MdaNum)
{
    tIomDpiFilterRequest *pMsg = SMGR_MESG_MEM_CALLOC(1, SIZE_DPI_FILTER_MSG(1));
    if (pMsg == NULL) {
        SVCMGR_ERROR(IOM_CALL, "DPI PREFIX AUDIT MESG alloc failed, slot %u", SlotNum);
        return FAIL;
    }
    
    SVCMGR_EVENT(IOM_CALL, "DPI PREFIX AUDIT MESG, slot %u, mda %u", SlotNum, MdaNum);
    
    pMsg->Op = IOM_DPI_FILTER_AUDIT;
    pMsg->DpiMdaNumMask = (1 << MdaNum);
    pMsg->FilterId = INVALID_AA_TRANSIT_PREFIX_POLICY_ID;
    pMsg->NumDpiRules = 1;
    
    tStatus s;
    if ((s = smgrSendDpiPrefixMesg(SlotNum, pMsg)) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "DPI PREFIX AUDIT END MESG failed, slot=%d, status=%d",
                     SlotNum, s);
    }
    
    SMGR_MESG_MEM_FREE(pMsg);
    
    return s;
}

PRIVATE void smgrGetDpiPrefixDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                          tUint32           IomOp,
                                          tUint32           SlotBitmap,
                                          tBoolean          IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_DpiPrefix,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccDpiPrefixCmp);
}

PUBLIC tStatus smgrSendDpiPrefixMesg(tSMSlot SlotNum, tIomDpiFilterRequest *pMsg)
{
    tUint32 SlotBitmap = 0;
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(IOM_CALL, "DPI PREFIX MESG, slot %u, op %u, %u rules from Inactive CPM",
                     SlotNum, pMsg->Op, pMsg->NumDpiRules);
        return OK;
    }
    
    tSmgrMsgrIccInfo IccInfo;
    int i=0;
    
    SVCMGR_EVENT(IOM_CALL, "DPI PREFIX MESG, slot %u, op %u, %u rules",
                 SlotNum, pMsg->Op, pMsg->NumDpiRules);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    if ((SlotNum == ALL_APPLICABLE_IOMS) || (SlotNum == THIS_SAP_IOMS)) {
        SVCMGR_ERROR(NOCLASS, "Invalid slot");
        return FAIL;
    }
    
    for (i = 0 ; i < pMsg->NumDpiRules; i++) {        
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_DpiPrefix,
                                   pMsg->Op);

        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    }
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetDpiPrefixDownloadInfo(&IccInfo, // Out
                                 IOM_FILTER_ADD_RULES, /* Use any opcode as a place holder to get the bit map */
                                 SlotBitmap,
                                 FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "DPI PREFIX MESG, download suppressed for SlotBitmap 0x%x, slot %u, Op %u, %u rules",
                     SlotBitmap, SlotNum, pMsg->Op, pMsg->NumDpiRules);
        return SUCCESS;
    }

    /* Send the message to all applicable IOM's */
    tStatus s = smgrSendMesgToIoms(IccInfo.pMsgrEntry->IccSocket, IccInfo.IomBitMask, pMsg,
                                   SIZE_DPI_FILTER_MSG(pMsg->NumDpiRules));
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "DPI PREFIX MESG failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    }
    return s;
}

/* Common proc for both types of sapAdd */
PRIVATE tStatus smgrSendSapAddMesgCommon(tSapRec *pSap, tSMSlot SlotNum,
                                         struct SMEventMsg *pCallbackEvent,
                                         fSapBatchCallback Callback)
{
    tStatus s;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d cb=%p",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum, pCallbackEvent);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    /* If there are any pending SAP_ADD messages batched
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative
     * time ordering of messages.
     */
    if (smgrDoFlushSapAddAndStateMesg(TRUE, FALSE, 0, 0) != SUCCESS) {
        SVCMGR_EVENT(NOCLASS, "Can't pre-flush batched up messages !");
    }
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    /* Now send the SAP_ADD message */
    if ((s = smgrDoBatchSapAddMesg(pSap, SlotBitmap, pCallbackEvent, Callback, FALSE, NULL))
            == SUCCESS) {
        s = smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
    }

    /* End of critical section */
    semGive(SapAddSemId);

    return s;
}


/* Send a SAP_ADD message, used by most protols */
PUBLIC tStatus smgrSendSapAddMesg(tSapRec *pSap, tSMSlot SlotNum,
                                  struct SMEventMsg *pCallbackEvent)
{
    return smgrSendSapAddMesgCommon(pSap, SlotNum, pCallbackEvent, NULL);
}


/* Send a SAP_ADD message, used by most protols */
PUBLIC tStatus smgrSendSapAddCallback(struct SapRec *pSap, tSMSlot SlotNum,
                                      fSapBatchCallback Callback) {
    return smgrSendSapAddMesgCommon(pSap, SlotNum, NULL, Callback);
}

PUBLIC tStatus smgrSendSapAddCallbacks(struct SapRec *pSap, tSMSlot SlotNum,
                                       tSMEventMsg *pCallbackEvent, fSapBatchCallback Callback)
{
    return smgrSendSapAddMesgCommon(pSap, SlotNum, pCallbackEvent, Callback);
}


/* Batch up a SAP_ADD message */
PUBLIC tStatus smgrBatchSapAddMesgPriv(tSapRec *pSap, tUint32 SlotBitmap,
                                       struct SMEventMsg *pCallbackEvent,
                                       tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slotbitmap=0x%08x cb=%p cardonline=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotBitmap, pCallbackEvent,IsCardOnline);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    s = smgrDoBatchSapAddMesg(pSap, SlotBitmap, pCallbackEvent, NULL, IsCardOnline, pBatch);
        
    /* End of critical section */
    semGive(SapAddSemId);

    return s;
}

/* Batch up a SAP_ADD message */
PUBLIC tStatus smgrBatchSapAddCallback(tSapRec *pSap, tSMSlot SlotNum,
                                       tBatchProcessing *pBatch, fSapBatchCallback Callback)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d cb=%p",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum, Callback);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    s = smgrDoBatchSapAddMesg(pSap, SlotBitmap, NULL, Callback, FALSE, pBatch);
        
    /* End of critical section */
    semGive(SapAddSemId);

    return s;
}

PUBLIC tStatus smgrBatchSapAddCallbacks(tSapRec *pSap, tSMSlot SlotNum, tBatchProcessing *pBatch,
                                        tSMEventMsg *pCallbackEvent, fSapBatchCallback Callback)
{
    if (Callback && pCallbackEvent) {
        SVCMGR_ERROR(NOCLASS, "both callback event and function requested for sap=%s",
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        Callback = NULL;
    }

    if (Callback)
        return smgrBatchSapAddCallback(pSap, SlotNum, pBatch, Callback);
    else
        return smgrBatchSapAddMesg(pSap, SlotNum, pCallbackEvent, pBatch);
}

PRIVATE void smgrGetSapDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                    const tSapRec *pSap,
                                    tUint32 IomOp,
                                    tUint32 SlotBitmap,
                                    tBoolean IsCardOnline,
                                    tBoolean IngoreSapPresent,
                                    tBoolean UseChmgrBitmap)
{
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:
        pIccInfo->IomBitMask = smgrGetPortRecIomBitMask(pSap->PortRec);
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
    }

    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             SmgrMsgrEntry_Sap,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             UseChmgrBitmap,                          
                             smgrMesgSapCmp,
                             pSap);
}

/* Get the addr of the element based on the provided index.
 * This assumes that the message contains same-sized elements */
PUBLIC tIomSapSubMixedEntry *smgrSapSubGetMixedEntryAddr(tIomSapSubMixedRequest *pMsg,
                                                         eSapSubOp Op, tUint32 Index)
{
    tUint8 *pByte = (tUint8 *)&pMsg->Entries[0];

    pByte += Index * smgrMesgIccSapSubEntrySize(Op);

    return (tIomSapSubMixedEntry *)pByte;
}

/* Batch up a SAP_ADD message. This private function assumes
 * the caller has locked the SapAddSem.
 */
PRIVATE tStatus smgrDoBatchSapAddMesg(tSapRec *pSap, tUint32 SlotBitmap,
                                      struct SMEventMsg *pCallbackEvent,
                                      fSapBatchCallback Callback,
                                      tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo = {0};
    tStatus s = SUCCESS;
    tUint8 CpmFwdState;
    tUint8 IomFwdState;
    tBoolean UpdtFwdState;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tBoolean MemAllocated = FALSE;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_ADD;
    
    if (Callback && pCallbackEvent) {
        SVCMGR_ERROR(NOCLASS, "both callback event and function requested for sap=%s",
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        Callback = NULL;
    }

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s",
                     pSvc->Id,
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        s = SUCCESS;
        goto Done;
    }

    if (IS_SAP_EP_SUPPORTED(pSvc)) {
        if (! pSap->SapEpObj || ! pSap->SapEpObj->EpRec) {
            SVCMGR_ERROR(NOCLASS, "no endpoint record. sap=%s", smgrFmtSapIdVerboseForDebug(&pSap->SapId));
            s = FAIL;
            goto Done;
        }
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                           SlotBitmap, IsCardOnline, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        /* No need to send to the IOM, but update the CPM state for downstream
         * clients so they are notified if the status has changed.
         */
        SVCMGR_EVENT(IOM_CALL, "bitmap=0");
        s = SUCCESS;
        goto Done;
    }

    /* Check if flushing of queued msgs is needed */
    smgrDoFlushSapAddAndStateMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);

    if (!pSapAddReqMesg) {
        MemAllocated = TRUE;
        /* Alloc max message size */
        pSapAddReqMesg = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSapAddEntriesPerMesg));
        if (!pSapAddReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSapAddReqMesg->NumEntries = 0;
        
        if (runtime_feature_smgr_buffered_download) {
            pSapAddDndlerCbEvtMsgs
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSapAddDndlerCbEvtMsgs), SMMaxNumSapAddEntriesPerMesg);
            if (pSapAddDndlerCbEvtMsgs == NULL) {
                s = FAIL;
                goto Done;
            }
        }
    }
    
    /* Set the bit mask */
    PrevSapAddIomBitMask = IccInfo.IomBitMask;

    if (pSapAddDndlerCbEvtMsgs) {
        pDndlerCbEvtMsgs = &(pSapAddDndlerCbEvtMsgs[pSapAddReqMesg->NumEntries]);
        if (smgrSapBindAddDndlerCallbacks(TRUE, &pSap->SapId, NULL, pSap->InstanceId,
                                          (Callback || pCallbackEvent)? TRUE : FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            s = FAIL;
            goto Done;
        }
    }

    if (Callback) {
        if (!pSapBatchCallbackEvent) {
            pSapBatchCallbackEvent = (tSMGenEventMsg *) smgrAllocEventMsg(SME_SAP_BATCH_CALLBACK);
            if (pSapBatchCallbackEvent) {
                queue_init(&pSapBatchCallbackEvent->u.SapBatchCallback.SapQueue);
                pCallbackEvent = (struct SMEventMsg *)pSapBatchCallbackEvent;
            }
        }
        if (pSapBatchCallbackEvent) {
            if (!queue_isempty(&pSap->SapCallbackLink)) {
                queue_remove(&pSap->SapCallbackLink);
                queue_init(&pSap->SapCallbackLink);
                if (pSap->SapCallback) {
                    if (Callback == pSap->SapCallback) {
                        (*pSap->SapCallback)(pSap, eSapBatchRescheduled);
                    } else {
                        (*pSap->SapCallback)(pSap, eSapBatchRescheduledForDifferentCallback);
                    }
                    pSap->SapCallback = NULL;
                }
            }
            queue_insert_tail(&pSapBatchCallbackEvent->u.SapBatchCallback.SapQueue,
                              &pSap->SapCallbackLink);
            pSap->SapCallback = Callback;
        } else {
            (*Callback)(pSap, eSapBatchNoResources);
        }
    }
    
    if ((SlotBitmap == ALL_APPLICABLE_IOMS) ||
        (SlotBitmap == THIS_SAP_IOMS)) {
        UpdtFwdState = TRUE;
    } else {
        tUint32 OnlineIoms = smgrMsgrGetFullyOnlineIoms(pSmgrIccMsgr);
        if (IsCardOnline) {
            OnlineIoms = BITUTILS_BIT_UNION(OnlineIoms, SlotBitmap);
        }
        OnlineIoms &= pSap->PortRec->IomBitMask;
        UpdtFwdState = (OnlineIoms & IccInfo.IomBitMask)  ? TRUE : FALSE;
    }

    sapGetFwdState(pSap, &CpmFwdState, &IomFwdState);
    if (UpdtFwdState) {
        sapSetFwdState(pSap, CpmFwdState, IomFwdState, pDndlerCbEvtMsgs);
    }

    SapAddOp = Op;
    pElm = smgrSapSubGetMixedEntryAddr(pSapAddReqMesg, Op, pSapAddReqMesg->NumEntries);
    pElm->Op = Op;
    smgrInitSapAddReqEntry(&pElm->Add, pSap, IomFwdState, pCallbackEvent);

    pSapAddReqMesg->NumEntries++;

    if (pSap->BlkDnldToIom) {
        SapDnldBlockType = SMGR_DNDLER_BLOCK;
        pSap->BlkDnldToIom = FALSE;
    }

    /* If we reached the limit, flush the message */
    if (pSapAddReqMesg->NumEntries >= SMMaxNumSapAddEntriesPerMesg) {
        s = smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
        if (pBatch)
            pBatch->SapAddSent = FALSE;
    } else {
        if (pBatch)
            pBatch->SapAddSent = TRUE;    
    }
    
    return s;
    
  Done:
    if (s != SUCCESS ||
        IccInfo.IomBitMask == 0) {
        sapSetFwdState(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);
    }
    
    if (pSap->SapCallback) {
        (*pSap->SapCallback)(pSap,
                             (s != SUCCESS || IccInfo.IomBitMask == 0)? eSapBatchNoResources : eSapBatchExecuted);
        pSap->SapCallback = NULL;
    }

    if (pDndlerCbEvtMsgs)
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);
        
    if (pCallbackEvent)
        smgrIccCleanup(pCallbackEvent);
        
    if (MemAllocated) {
        if (pSapAddReqMesg) {
            SMGR_MESG_MEM_FREE(pSapAddReqMesg);
            pSapAddReqMesg = NULL;
        }
        
        if (pSapAddDndlerCbEvtMsgs) {
            SMGR_MESG_MEM_FREE(pSapAddDndlerCbEvtMsgs);
            pSapAddDndlerCbEvtMsgs = NULL;
        }
    }
        
    return s;
}


/* Flush batched up SAP_ADD messages */
PUBLIC tStatus smgrFlushSapAddMesg(void)
{
    tStatus s;
    
    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);
    
    s =  smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
    
    /* End of critical section */
    semGive(SapAddSemId);
    
    return s;
}


/* Flush batched up SAP_ADD messages. This private function assumes
 * the caller has locked the SapAddSem.
 */
PRIVATE tStatus smgrDoFlushSapAddAndStateMesg(tBoolean     preFlush, 
                                              tBoolean     OnlyIfNeeded,
                                              eSapSubOp    msgType,       // only IfNeeded
                                              tUint32      newIomBitMask) // only IfNeeded
{
    tUint32 NumEntries;
    tStatus s = SUCCESS;
    tUint32 size;
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedEntry *pElm = NULL;

    if (!pSapAddReqMesg || (pSapAddReqMesg->NumEntries == 0))
        return SUCCESS;

    if (OnlyIfNeeded) {
        /* A flush of the previous batch is needed if:
         *   - IOM bitmap is not the same
         *   - msg type is not the same
         */
        if ((PrevSapAddIomBitMask == newIomBitMask) && (msgType == SapAddOp))
            return SUCCESS;  // no need to flush
    }
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_Sap,
                               SapAddOp);

    pSapBatchCallbackEvent = NULL;
    NumEntries = pSapAddReqMesg->NumEntries;
    SVCMGR_EVENT(IOM_CALL, "opcode=%u entries=%u prev mask=%08x curr mask=%08x",
                 SapAddOp, NumEntries, PrevSapAddIomBitMask, newIomBitMask);

    switch (SapAddOp) {
        case IOM_SAP_ADD:
        case IOM_SAP_STATE:
        case IOM_SAP_MCLISTPRUNE_MVRP:
            size = smgrMesgIccSapSubMsgSize(SapAddOp, NumEntries);
            break;
        case IOM_SAP_DELETE:
        case IOM_SAP_AUDIT:
        case IOM_SAP_SWITCH:
        case IOM_SAP_CFM_PVLAN:
        default:
            SVCMGR_ERROR(NOCLASS, "bad opcode %u", SapAddOp);
            return FAIL;
    }

    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pSapAddReqMesg, preFlush);
    pSapAddReqMesg->TotalLength = size;
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, SapAddOp,
                                      PrevSapAddIomBitMask, pSapAddReqMesg, size,
                                      pSapAddDndlerCbEvtMsgs, SapDnldBlockType,
                                      NULL, SMIccCleanSemId,
                                      SapAddOp == IOM_SAP_STATE, 
                                      SapAddOp != IOM_SAP_STATE,
                                      smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        int      i;
        tSapRec *pSap;
        void    *cpmHandle;

        for (i = 0; i < pSapAddReqMesg->NumEntries; i++) {
            pElm = smgrSapSubGetMixedEntryAddr(pSapAddReqMesg, SapAddOp, i);

            switch (SapAddOp) {
                case IOM_SAP_ADD:
                    pSap = pElm->Add.sapRec.Cpm;
                    cpmHandle = pElm->Add.handle.Cpm;
                    if (pSap)
                        sapSetFwdState(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);
                    break;
                case IOM_SAP_STATE:
                    pSap = pElm->State.sapRec.Cpm;
                    cpmHandle = pElm->State.handle.Cpm;
                    /* For state msgs an error will be returned if the iom becomes
                     * unavailable on the moment the update is sent.
                     * The calling procs will report and error if we return fail.
                     * Therefore, return success.
                     */
                    s = SUCCESS;
                    if (pSap)
                        sapSetFwdState(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);
                    break;
                case IOM_SAP_MCLISTPRUNE_MVRP:
                    pSap = pElm->McListPruneAndMvrp.sapRec.Cpm;
                    cpmHandle = pElm->McListPruneAndMvrp.handle.Cpm;
                    break;
                case IOM_SAP_DELETE:
                case IOM_SAP_AUDIT:
                case IOM_SAP_SWITCH:
                case IOM_SAP_CFM_PVLAN:
                default:    // can not occur, just to keep compiler happy
                    pSap = NULL;
                    cpmHandle = NULL;
                    break;
            }
            if (cpmHandle) {
                smgrIccCleanup(cpmHandle);
            }
            if (pSapAddDndlerCbEvtMsgs)
                smgrSapBindFreeDndlerCallbacks(&pSapAddDndlerCbEvtMsgs[i]);
        }
        SVCMGR_EVENT(NOCLASS, "smgrSendClientCustomMsgToIoms() failed for mask=%08x !", 
                     PrevSapAddIomBitMask);

        SMGR_MESG_MEM_FREE(pSapAddReqMesg);
        if (pSapAddDndlerCbEvtMsgs)
            SMGR_MESG_MEM_FREE(pSapAddDndlerCbEvtMsgs);        
    }

    /* Start a new batch */
    pSapAddReqMesg = NULL;
    pSapAddDndlerCbEvtMsgs = NULL;
    
    PrevSapAddIomBitMask = 0;
    SapDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
    SapAddOp = 0;
    
    return s;
}

/* Common proc for SAP_STATE.
 * If the SAP's IOM fwd state did not change, we'll suppress the SAP state
 * download to the IOM */
PRIVATE tStatus smgrSendSapStateMesgCommon(tSapRec *pSap, tSMSlot SlotNum,
                                           tBoolean UseChmgrBitmap,
                                           struct SMEventMsg *pCallbackEvent,
                                           fSapBatchCallback Callback)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d cb=%p",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum, pCallbackEvent);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    /* If there are any pending SAP_ADD ir SAP_STATE messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages */
    if (smgrDoFlushSapAddAndStateMesg(TRUE, FALSE, 0, 0) != SUCCESS) {
        SVCMGR_EVENT(NOCLASS, "Can't pre-flush batched up messages !");
    }

    /* Now send the SAP_STATE message */
    if ((s = smgrDoBatchSapStateCommon(pSap, SlotNum, UseChmgrBitmap,
                                       pCallbackEvent, Callback)) 
            == SUCCESS) {
        s = smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
    }
    
    /* End of critical section */
    semGive(SapAddSemId);
    
    return s;
}

/* Send a single SAP_STATE message.
 * If the SAP's IOM fwd state did not change, we'll suppress the SAP state
 * download to the IOM */
PUBLIC tStatus smgrSendSapStateCallback(struct SapRec *pSap, tSMSlot SlotNum,
                                        tBoolean UseChmgrBitmap,
                                        fSapBatchCallback Callback) {
    return smgrSendSapStateMesgCommon(pSap, SlotNum, UseChmgrBitmap,
                                      NULL, Callback);
}

/* Send a single SAP_STATE message */
PUBLIC tStatus smgrSendSapStateMesg(tSapRec *pSap, tSMSlot SlotNum,
                                    tBoolean UseChmgrBitmap,
                                    struct SMEventMsg *pCallbackEvent)
{
    return smgrSendSapStateMesgCommon(pSap, SlotNum, UseChmgrBitmap, pCallbackEvent, NULL);
}

PUBLIC tStatus smgrSendSapStateCallbacks(tSapRec *pSap, tSMSlot SlotNum, tBoolean UseChmgrBitmap,
                                         tSMEventMsg *pCallbackEvent, fSapBatchCallback Callback)
{
    return smgrSendSapStateMesgCommon(pSap, SlotNum, UseChmgrBitmap, pCallbackEvent, Callback);
}

/* Batch up a SAP_STATE message.
 * If the SAP's IOM fwd state did not change, we'll suppress the SAP state
 * download to the IOM */
PUBLIC tStatus smgrBatchSapStateMesg(tSapRec *pSap, tSMSlot SlotNum,
                                     tBoolean UseChmgrBitmap, tBatchProcessing *pBatch,
                                     struct SMEventMsg *pCallbackEvent)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u slot=%d cb=%p",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SlotNum, pCallbackEvent);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    s = smgrDoBatchSapStateMesg(pSap, SlotNum, UseChmgrBitmap, pCallbackEvent);
        
    /* End of critical section */
    semGive(SapAddSemId);
    
    if (pBatch && s == OK)
        pBatch->SapStateSent = TRUE;

    return s;
}

/* Batch up a SAP_ADD message. This private function assumes
 * the caller has locked the SapAddSem.
 * If the SAP's IOM fwd state did not change, we'll suppress the SAP state
 * download to the IOM */
PRIVATE tStatus smgrDoBatchSapStateMesg(tSapRec *pSap, tSMSlot SlotNum,
                                        tBoolean UseChmgrBitmap,
                                        struct SMEventMsg *pCallbackEvent)
{
    return smgrDoBatchSapStateCommon(pSap, SlotNum, UseChmgrBitmap,
                                     pCallbackEvent, NULL);
}

/* If the SAP's IOM fwd state did not change, we'll suppress the SAP state
 * download to the IOM */
PUBLIC tStatus smgrBatchSapStateCallback(tSapRec *pSap, tSMSlot SlotNum,
                                         tBoolean UseChmgrBitmap, tBatchProcessing *pBatch,
                                         fSapBatchCallback Callback)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d cb=%p",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum, Callback);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    s = smgrDoBatchSapStateCommon(pSap, SlotNum, UseChmgrBitmap,
                                  NULL, Callback);
        
    /* End of critical section */
    semGive(SapAddSemId);
    
    if (pBatch && s == OK)
        pBatch->SapStateSent = TRUE;

    return s;
}

/* If the SAP's IOM fwd state did not change, we'll suppress the SAP state
 * download to the IOM */
PUBLIC tStatus smgrBatchSapStateCallbacks(tSapRec *pSap, tSMSlot SlotNum,
                                          tBoolean UseChmgrBitmap, tBatchProcessing *pBatch,
                                          struct SMEventMsg *pCallbackEvent, fSapBatchCallback Callback)
{
    if (Callback && pCallbackEvent) {
        SVCMGR_ERROR(NOCLASS, "both callback event and function requested for sap=%s",
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        Callback = NULL;
    }

    if (Callback)
        return smgrBatchSapStateCallback(pSap, SlotNum, UseChmgrBitmap, pBatch, Callback);
    else
        return smgrBatchSapStateMesg(pSap, SlotNum, UseChmgrBitmap, pBatch, pCallbackEvent);
}

/* If the SAP's IOM oper status did not change, we'll suppress the SAP state
 * download to the IOM */
PRIVATE tStatus smgrDoBatchSapStateCommon(tSapRec *pSap, tSMSlot SlotNum,
                                          tBoolean UseChmgrBitmap,
                                          struct SMEventMsg *pCallbackEvent,
                                          fSapBatchCallback Callback)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo = {0};
    tStatus  s = SUCCESS;
    tUint8   CpmFwdState;
    tUint8   IomFwdState;
    tUint8   LastIomFwdState;
    tBoolean UpdtFwdState;
    tUint32 SlotBitmap = 0;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tBoolean MemAllocated = FALSE;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_STATE;
    
    if (Callback && pCallbackEvent) {
        SVCMGR_ERROR(NOCLASS, "both callback event and function requested for sap=%s",
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        Callback = NULL;
    }

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s",
                     pSvc->Id,
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        s = SUCCESS;
        goto Done;
    }
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                           SlotBitmap, FALSE, FALSE, UseChmgrBitmap);
    
    if (IccInfo.IomBitMask== 0) {
        /* No need to send to the IOM, but update the CPM state for downstream
         * clients so they are notified if the status has changed.
         */
        SVCMGR_EVENT(IOM_CALL, "bitmap=0");
        s = SUCCESS;
        goto Done;
    }

    /* Calculate the SAP's CPM and IOM fwd state */
    LastIomFwdState = pSap->ActualIomFwdState;
    
    if ((SlotNum == ALL_APPLICABLE_IOMS) ||
        (SlotNum == THIS_SAP_IOMS)) {
        UpdtFwdState = TRUE;
    } else {
        tUint32 OnlineIoms = smgrMsgrGetFullyOnlineIoms(pSmgrIccMsgr);
        OnlineIoms &= pSap->PortRec->IomBitMask;
        UpdtFwdState = (OnlineIoms & IccInfo.IomBitMask) ? TRUE : FALSE;
    }
    
    /* Check if flushing of queued msgs is needed */
    smgrDoFlushSapAddAndStateMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);

    if (!pSapAddReqMesg) {
        MemAllocated = TRUE;
        /* Alloc max message size */
        pSapAddReqMesg = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSapStateEntriesPerMesg));
        if (!pSapAddReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSapAddReqMesg->NumEntries = 0;
                
        if (runtime_feature_smgr_buffered_download) {
            pSapAddDndlerCbEvtMsgs 
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSapAddDndlerCbEvtMsgs), SMMaxNumSapStateEntriesPerMesg);
            if (pSapAddDndlerCbEvtMsgs == NULL) {
                s = FAIL;
                goto Done;
            }
        }
    }
    
    /* Set the bit mask */
    PrevSapAddIomBitMask = IccInfo.IomBitMask;
    
    if (pSapAddDndlerCbEvtMsgs) {
        pDndlerCbEvtMsgs = &(pSapAddDndlerCbEvtMsgs[pSapAddReqMesg->NumEntries]);
        if (smgrSapBindAddDndlerCallbacks(TRUE, &pSap->SapId, NULL, pSap->InstanceId,
                                          (Callback || pCallbackEvent)? TRUE : FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            s = FAIL;
            goto Done;
        }
    }

    sapGetFwdState(pSap, &CpmFwdState, &IomFwdState);
    if (UpdtFwdState) {
        sapSetFwdState(pSap, CpmFwdState, IomFwdState, pDndlerCbEvtMsgs); /* For CPM clients */
    }

    /* If there is no change in the SAP's IOM fwd state, do not download.
     * Note that this suppression is done only in this routine where only
     * SAP state would have been downloaded */
    if (!pCallbackEvent) { /* If there is a CallbackEvent, send to the IOM even if there is no change */
        if (LastIomFwdState == IomFwdState) {
            /* Since we are skipping the download, we need to run the Dndler callbacks */
            smgrDndlerSapBindCallback(pDndlerCbEvtMsgs);

            SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s: SAP's IOM fwd state did not change. Skipping download",
                         pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId));
            s = SUCCESS;
            goto Done;
        }
    }
    
    if (Callback) {
        if (!pSapBatchCallbackEvent) {
            pSapBatchCallbackEvent = (tSMGenEventMsg *) smgrAllocEventMsg(SME_SAP_BATCH_CALLBACK);
            if (pSapBatchCallbackEvent) {
                queue_init(&pSapBatchCallbackEvent->u.SapBatchCallback.SapQueue);
                pCallbackEvent = (struct SMEventMsg *)pSapBatchCallbackEvent;
            }
        }
        if (pSapBatchCallbackEvent) {
            if (!queue_isempty(&pSap->SapCallbackLink)) {
                queue_remove(&pSap->SapCallbackLink);
                queue_init(&pSap->SapCallbackLink);
                if (pSap->SapCallback) {
                    if (Callback == pSap->SapCallback) {
                        (*pSap->SapCallback)(pSap, eSapBatchRescheduled);
                    } else {
                        (*pSap->SapCallback)(pSap, eSapBatchRescheduledForDifferentCallback);
                    }
                    pSap->SapCallback = NULL;
                }
            }
            queue_insert_tail(&pSapBatchCallbackEvent->u.SapBatchCallback.SapQueue,
                              &pSap->SapCallbackLink);
            pSap->SapCallback = Callback;
        } else {
            (*Callback)(pSap, eSapBatchNoResources);
        }
    }

    SapAddOp = Op;
    pElm = smgrSapSubGetMixedEntryAddr(pSapAddReqMesg, Op, pSapAddReqMesg->NumEntries);
    pElm->Op = Op;
    smgrInitSapStateEntry(&pElm->State, pSap, IomFwdState, pCallbackEvent);

    pSapAddReqMesg->NumEntries++;

    /* If we reached the limit, flush the message */
    if (pSapAddReqMesg->NumEntries >= SMMaxNumSapStateEntriesPerMesg) {
        s = smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
    }
    return s;

Done:
    if (s != SUCCESS ||
        IccInfo.IomBitMask == 0) {
        sapSetFwdState(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);
    }
    
    if (pSap->SapCallback) {
        (*pSap->SapCallback)(pSap,
                             (s != SUCCESS || IccInfo.IomBitMask == 0)? eSapBatchNoResources : eSapBatchExecuted);
        pSap->SapCallback = NULL;
    }

    if (pDndlerCbEvtMsgs)
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);
  
    if (pCallbackEvent)
        smgrIccCleanup(pCallbackEvent);
        
    if (MemAllocated) {
        if (pSapAddReqMesg) {
            SMGR_MESG_MEM_FREE(pSapAddReqMesg);
            pSapAddReqMesg = NULL;
        }
        
        if (pSapAddDndlerCbEvtMsgs) {
            SMGR_MESG_MEM_FREE(pSapAddDndlerCbEvtMsgs);
            pSapAddDndlerCbEvtMsgs = NULL;
        }
    }
    
    return s;
}
/* Common proc for SAP_TLS_PRUNE. */
PRIVATE tStatus smgrSendSapTlsPruneMesgCommon(tSapRec *pSap, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    /* If there are any pending SAP_ADD or SAP_STATE or SAP_TLS_PRUNE
     * messages batched up (by some other task running concurrently
     * with us) then pre-flush them now to preserve the relative time
     * ordering of messages */
    if (smgrDoFlushSapAddAndStateMesg(TRUE, FALSE, 0, 0) != SUCCESS) {
        SVCMGR_EVENT(NOCLASS, "Can't pre-flush batched up messages !");
    }

    /* Now send the SAP_TLS_PRUNE message */
    if ((s = smgrDoBatchSapTlsPruneCommon(pSap, SlotNum))
            == SUCCESS) {
        s = smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
    }
    
    /* End of critical section */
    semGive(SapAddSemId);
    
    return s;
}

/* Send a single SAP_TLS_PRUNE message. */
PUBLIC tStatus smgrSendSapTlsPrune(struct SapRec *pSap, tSMSlot SlotNum) {
    return smgrSendSapTlsPruneMesgCommon(pSap, SlotNum);
}

/* Batch up a SAP_TLS_PRUNE message. */
PUBLIC tStatus smgrBatchSapTlsPrune(tSapRec *pSap, tSMSlot SlotNum, tBatchProcessing *pBatch) {
    tSvcRec *pSvc = pSap->SvcRec;
    tStatus s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum);

    /* Serialize access to shared state data */
    semTake(SapAddSemId, WAIT_FOREVER);

    s = smgrDoBatchSapTlsPruneCommon(pSap, SlotNum);
        
    /* End of critical section */
    semGive(SapAddSemId);

    if (pBatch && s == OK)
        pBatch->SapTlsPruneSent = TRUE;

    return s;
}

PRIVATE tStatus smgrDoBatchSapTlsPruneCommon(tSapRec *pSap, tSMSlot SlotNum) {
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus  s = SUCCESS;
    tUint32 SlotBitmap = 0;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_MCLISTPRUNE_MVRP;
    
    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s",
                     pSvc->Id,
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        s = SUCCESS;
        goto Done;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
     SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
     
     smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                            SlotBitmap, FALSE, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "bitmap=0");
        s = SUCCESS;
        goto Done;
    }

    /* Check if flushing of queued msgs is needed */
    smgrDoFlushSapAddAndStateMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);

    if (!pSapAddReqMesg) {
        /* Alloc max message size */
        pSapAddReqMesg = SMGR_MESG_MEM_MALLOC(
                            smgrMesgIccSapSubMsgSize(Op, SMMaxNumSapMcListPruneAndMvrpEntriesPerMesg));
        if (!pSapAddReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSapAddReqMesg->NumEntries = 0;
    }
    
    /* Set the bit mask */
    PrevSapAddIomBitMask = IccInfo.IomBitMask;

    SapAddOp = Op;
    pElm = smgrSapSubGetMixedEntryAddr(pSapAddReqMesg, Op, pSapAddReqMesg->NumEntries);
    pElm->Op = Op;
    smgrInitSapMcListPruneAndMvrpEntry(&pElm->McListPruneAndMvrp, pSap);
                        
    pSapAddReqMesg->NumEntries++;

    /* If we reached the limit, flush the message */
    if (pSapAddReqMesg->NumEntries >= SMMaxNumSapMcListPruneAndMvrpEntriesPerMesg) {
        s = smgrDoFlushSapAddAndStateMesg(FALSE, FALSE, 0, 0);
    }
    return s;

  Done:
    return s;
}

/* Flush batched up SAP_TLS_PRUNE messages */
PUBLIC tStatus smgrFlushSapTlsPrune(void) {
    return smgrFlushSapAddMesg();
}

/* Send a SAP_SWITCH message */
PUBLIC tStatus smgrSendSapSwitchMesg(tSapRec *pSap)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *pMsg = NULL;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tStatus s = SUCCESS;
    const tSMSlot SlotNum = ALL_APPLICABLE_IOMS;
    const eSapSubOp Op = IOM_SAP_SWITCH;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum);

    if (! IS_SAP_EP_SUPPORTED(pSvc))
        return FAIL;
        
    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s",
                     pSvc->Id,
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        return SUCCESS;
    }

    if (! pSap->SapEpObj || ! pSap->SapEpObj->EpRec) {
        SVCMGR_ERROR(NOCLASS, "no endpoint record. sap=%s", smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        return FAIL;
    }
            
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                           SlotNum, FALSE, FALSE, FALSE);
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "bitmap=0");
        s = SUCCESS;
        goto Done;
    }
     
    /* If there are any pending SAP_SWITCH messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    semTake(SapSwitchSemId, WAIT_FOREVER);
    if ((pSapSwitchReqMesg) && (pSapSwitchReqMesg->NumEntries > 0)) {
        if (smgrDoFlushSapSwitchMesg(TRUE) != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "Can't pre-flush batched up messages !");
        }
    }
    semGive(SapSwitchSemId);
    
    if ((pMsg = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, 1))) == NULL) {
        SVCMGR_EVENT(NOCLASS, "No more memory for ICC message");
        s = FAIL;
        goto Done;
    }
    
    if (runtime_feature_smgr_buffered_download) {
        pDndlerCbEvtMsgs = SMGR_MESG_MEM_CALLOC(sizeof(*pDndlerCbEvtMsgs), 1);
        if (pDndlerCbEvtMsgs == NULL) {
            s = FAIL;
            goto Done;
        }
        
        if (smgrSapBindAddDndlerCallbacks(TRUE, &pSap->SapId, NULL, pSap->InstanceId, FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            SVCMGR_EVENT(NOCLASS, "Unable to get memory for message event");
            s = FAIL;
            goto Done;
        }
    }
    
    pMsg->NumEntries = 1;
    
    smgrInitSapSwitchReqEntry(&pMsg->Entries[0].Switch, pSap, pDndlerCbEvtMsgs);
    pMsg->Entries[0].Op = Op;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    pMsg->TotalLength = smgrMesgIccSapSubMsgSize(Op, pMsg->NumEntries);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pMsg, pMsg->TotalLength,
                                pDndlerCbEvtMsgs, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask=%08x !", IccInfo.IomBitMask);
        goto Done;
    }
    
    smgrFreeClientMsg(pMsg, s);
    
    return s;

        
Done:
    if (s != SUCCESS ||
        IccInfo.IomBitMask == 0) {
        sapSetFwdStateWithLock(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);
    }
    
    if (pDndlerCbEvtMsgs != NULL) {
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);
        SMGR_MESG_MEM_FREE(pDndlerCbEvtMsgs);
    }
     
    if (pMsg)
        smgrFreeClientMsg(pMsg, s);

    return s;
}    


/* Batch up a IOM_SAP_SWITCH message */
PUBLIC tStatus smgrBatchSapSwitchMesg(tSapRec *pSap, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const tSlot SlotNum = ALL_APPLICABLE_IOMS;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tBoolean MemAllocated = FALSE;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_SWITCH;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus],
                 SlotNum);
                 
    if (! IS_SAP_EP_SUPPORTED(pSvc))
        return FAIL;

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s",
                     pSvc->Id,
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        return SUCCESS;
    }

    if (! pSap->SapEpObj || ! pSap->SapEpObj->EpRec) {
        SVCMGR_ERROR(NOCLASS, "no endpoint record. sap=%s", smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        return FAIL;
    }
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                           SlotNum, FALSE, FALSE, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    semTake(SapSwitchSemId, WAIT_FOREVER);

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((pSapSwitchReqMesg) && (NextSapSwitchEntry != 0) && (
            IccInfo.IomBitMask != PrevSapSwitchIomBitMask))
        smgrDoFlushSapSwitchMesg(TRUE);
    
    /* Set the bit mask */
    PrevSapSwitchIomBitMask = IccInfo.IomBitMask;

    if (!pSapSwitchReqMesg) {
        MemAllocated = TRUE;
        
        if ((pSapSwitchReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSapSwitchEntriesPerMesg))) == NULL) {
            s = FAIL;
            goto Failed;
        }
        
        if (runtime_feature_smgr_buffered_download) {
            pSapSwitchDndlerCbEvtMsgs
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSapSwitchDndlerCbEvtMsgs), SMMaxNumSapSwitchEntriesPerMesg);
            if (pSapSwitchDndlerCbEvtMsgs == NULL) {
                s = FAIL;
                goto Failed;
            }
        }
    }
    
    if (pSapSwitchDndlerCbEvtMsgs) {
        pDndlerCbEvtMsgs = &(pSapSwitchDndlerCbEvtMsgs[NextSapSwitchEntry]);
        if (smgrSapBindAddDndlerCallbacks(TRUE, &pSap->SapId, NULL, pSap->InstanceId, FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            SVCMGR_EVENT(NOCLASS, "Unable to get memory for message event");
            s = FAIL;
            goto Failed;
        }
    }
    
    pSapSwitchReqMesg->NumEntries = NextSapSwitchEntry + 1;
    
    pElm = smgrSapSubGetMixedEntryAddr(pSapSwitchReqMesg, Op, NextSapSwitchEntry);
    smgrInitSapSwitchReqEntry(&pElm->Switch, pSap, pDndlerCbEvtMsgs);
    pElm->Op = Op;

    /* If we reached the limit, flush the message */
    if (pSapSwitchReqMesg->NumEntries == SMMaxNumSapSwitchEntriesPerMesg) {
        s = smgrDoFlushSapSwitchMesg(FALSE);
        if (pBatch)
            pBatch->SapSwitchSent = FALSE;
    } else {
        NextSapSwitchEntry++;
        if (pBatch)
            pBatch->SapSwitchSent = TRUE;
    }
    
    semGive(SapSwitchSemId);
    
    return s;
    
Failed:    
    if (pDndlerCbEvtMsgs != NULL)
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);

    if (MemAllocated) {
        if (pSapSwitchReqMesg) {
            SMGR_MESG_MEM_FREE(pSapSwitchReqMesg);
            pSapSwitchReqMesg = NULL;
        }
        
        if (pSapSwitchDndlerCbEvtMsgs) {
            SMGR_MESG_MEM_FREE(pSapSwitchDndlerCbEvtMsgs);
            pSapSwitchDndlerCbEvtMsgs = NULL;
        }
    }

    semGive(SapSwitchSemId);
    
    if (s != SUCCESS)
        sapSetFwdStateWithLock(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);

    return s;
}


/* Flush batched up SAP_SWITCH messages */
PUBLIC tStatus smgrFlushSapSwitchMesg(void)
{
    tStatus s;
    
    semTake(SapSwitchSemId, WAIT_FOREVER);
    
    s =  smgrDoFlushSapSwitchMesg(FALSE);
    
    semGive(SapSwitchSemId);
    
    return s;
}


/* Flush batched up SAP_SWITCH messages. This private function assumes
 * the caller has locked the SapSwitchSem.
 */
PRIVATE tStatus smgrDoFlushSapSwitchMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapSwitchIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_SWITCH;

    if (!pSapSwitchReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x", pSapSwitchReqMesg->NumEntries, IomBitMask);
    
    if (pSapSwitchReqMesg->NumEntries > 0) {
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_Sap, Op);
            
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSapSwitchReqMesg, PreFlush);
        pSapSwitchReqMesg->TotalLength = smgrMesgIccSapSubMsgSize(Op, pSapSwitchReqMesg->NumEntries);
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                    IomBitMask, pSapSwitchReqMesg, pSapSwitchReqMesg->TotalLength,
                                    pSapSwitchDndlerCbEvtMsgs, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS) {
            int             i;
            tSapRec        *pSap;
            tSapBindInstId  InstId;

            for (i = 0; i < pSapSwitchReqMesg->NumEntries; i ++) {
                pElm = smgrSapSubGetMixedEntryAddr(pSapSwitchReqMesg, Op, i);

                InstId = pElm->Switch.GlobalInstanceId;
                pSap = sapFindRecByInstId(InstId);
                
                if (pSap)
                    sapSetFwdStateWithLock(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);
                    
                if (pSapSwitchDndlerCbEvtMsgs) 
                    smgrSapBindFreeDndlerCallbacks(&pSapSwitchDndlerCbEvtMsgs[i]);
            }
            SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask=%08x !", IomBitMask);
            
            if (pSapSwitchDndlerCbEvtMsgs)
                SMGR_MESG_MEM_FREE(pSapSwitchDndlerCbEvtMsgs);
        }
        
        /* Start a new batch */
        smgrFreeClientMsg(pSapSwitchReqMesg, s);
        NextSapSwitchEntry = 0;
        pSapSwitchReqMesg = NULL;
        pSapSwitchDndlerCbEvtMsgs = NULL;
    }
    
    return s;
}


/* Send a SAP_DELETE message */
PUBLIC tStatus smgrSendSapDelMesg(tSapRec *pSap, tSMSlot SlotNum)
{           
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    const eSapSubOp Op = IOM_SAP_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SlotNum);

    sapSetFwdStateWithLock(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        return SUCCESS;
    }   

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                           SlotBitmap, FALSE, FALSE, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((pMsg = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    pMsg->NumEntries = 1;
    pMsg->Entries[0].Op = Op;
    pMsg->Entries[0].Del.GlobalInstanceId = pSap->InstanceId;
    pMsg->Entries[0].Del.handle.Cpm = NULL;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    pMsg->TotalLength = smgrMesgIccSapSubMsgSize(Op, pMsg->NumEntries);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pMsg, pMsg->TotalLength,
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);
    }

    smgrFreeClientMsg(pMsg, s);
    
    return s;
}


/* Batch up a SAP_DELETE message */
PUBLIC tStatus smgrBatchSapDelMesg(tSapRec *pSap, tSMSlot SlotNum, tBoolean MakeGhost,
                                   tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId,
                 SlotNum);

    sapSetFwdStateWithLock(pSap, SAP_SDP_STATE_UNKNOWN, SAP_SDP_STATE_UNKNOWN, NULL);

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        return SUCCESS;
    }
        
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum); 
    
    smgrGetSapDownloadInfo(&IccInfo, pSap, Op,
                           SlotBitmap, FALSE, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((pSapDelReqMesg) && (NextSapDelEntry != 0) &&
        (IccInfo.IomBitMask != PrevSapDelIomBitMask))
        smgrDoFlushSapDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask*/
    PrevSapDelIomBitMask = IccInfo.IomBitMask;

    if (!pSapDelReqMesg) {
        if ((pSapDelReqMesg = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSapDelEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }

    pSapDelReqMesg->NumEntries = NextSapDelEntry + 1;

    pElm = smgrSapSubGetMixedEntryAddr(pSapDelReqMesg, Op, NextSapDelEntry);
    pElm->Op = Op;
    ZERO_STRUCT(pElm->Del);
    pElm->Del.GlobalInstanceId = pSap->InstanceId;
    pElm->Del.u.MakeNonLocal = MakeGhost;
    
    /* Deleting a SAP is expensive. Making the making a SAP as
     * ghost can be expensive on the IOM, but we allow more messages containing
     * ghost SAPs to be buffered as non-blocking (up til the socket limit) */
    if (! MakeGhost ||
        ! smgrCanDownloadToIom(ICC_SOCKET_SAP_SUB))
        SapDelDnldBlockType = SMGR_DNDLER_BLOCK;

    /* If we reached the limit, flush the message */
    if (pSapDelReqMesg->NumEntries == SMMaxNumSapDelEntriesPerMesg) {
        s = smgrFlushSapDelMesg();
        if (pBatch)
            pBatch->SapDelSent = FALSE;
    } else {
        NextSapDelEntry++;
        if (pBatch)
            pBatch->SapDelSent = TRUE;
    }

    return s;
}

/* Flush batched up SAP_DELETE messages */
PRIVATE tStatus smgrDoFlushSapDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_SAP_DELETE;

    if (!pSapDelReqMesg) 
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x", pSapDelReqMesg->NumEntries, IomBitMask);
    
    if (pSapDelReqMesg->NumEntries > 0) {
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_Sap, Op);

        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSapDelReqMesg, PreFlush);
        pSapDelReqMesg->TotalLength = smgrMesgIccSapSubMsgSize(Op, pSapDelReqMesg->NumEntries);
        
        /* If in the batch of SAP deletion requests there is a true SAP deletion (non-ghost),
         * we need to block until the message has reached ICC (see SMGR dndler) */
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                    IomBitMask, pSapDelReqMesg, pSapDelReqMesg->TotalLength, NULL,
                                    SapDelDnldBlockType);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                         IomBitMask);
        }

        /* Start a new batch */
        smgrFreeClientMsg(pSapDelReqMesg, s);
        NextSapDelEntry = 0;
        pSapDelReqMesg = NULL;
        SapDelDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSapDelMesg(void)
{
    return smgrDoFlushSapDelMesg(FALSE);
}

/* Cleanup after delivered SAP and sub messages to the IOM Async */
PUBLIC void smgrIccCleanSendSapSub(void *pIccMsg, void *pUserData)
{
    tUint32 i;
    tUint32 nCbAdd = 0;
    tUint32 nCbState = 0;
    tUint32 nCbPrune = 0;
    tUint32 nCbSubHost = 0;
    tIomSapSubMixedRequest *pSapSubMsg = pIccMsg;
    tUint8 *pByte;
    tIomSapSubMixedEntry *pElm;
    
    pByte = (tUint8 *)&pSapSubMsg->Entries[0];
    pElm = &pSapSubMsg->Entries[0];
    i = 0;
    
    while (i < pSapSubMsg->NumEntries) {
        switch (pElm->Op) {
        case IOM_SAP_ADD:
            if (pElm->Add.handle.Cpm) {
                smgrIccCleanup(pElm->Add.handle.Cpm);
                nCbAdd++;
            }
            break;
        case IOM_SAP_STATE:
            if (pElm->State.handle.Cpm) {
                smgrIccCleanup(pElm->State.handle.Cpm);
                nCbState++;
            }
            break;
        case IOM_SAP_MCLISTPRUNE_MVRP:
            if (pElm->McListPruneAndMvrp.handle.Cpm) {
                smgrIccCleanup(pElm->McListPruneAndMvrp.handle.Cpm);
                nCbPrune++;
            }
            break;
        case IOM_ESM_HOST_ADD:
            if (pElm->SubscriberHost.handle.Cpm) {
                sbmPostMsg(pElm->SubscriberHost.handle.Cpm, FALSE);
                nCbSubHost++;
            }
            break;

        case IOM_SAP_DELETE:
        case IOM_SAP_AUDIT:
        case IOM_SAP_SWITCH:
        case IOM_SAP_CFM_PVLAN:
        case IOM_SAP_ISSU1:
        case IOM_SAP_ISSU2:
        case IOM_ESM_SUBSCRIBER_ADD:
        case IOM_ESM_SUBSCRIBER_DELETE:
        case IOM_ESM_SUBSCRIBER_AUDIT:
        case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
        case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
        case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
        case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
        case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
        case IOM_ESM_HOST_DELETE:
        case IOM_ESM_HOST_UNBIND_SAP:
        case IOM_ESM_HOST_AUDIT:
        case IOM_ESM_SUB_PROFILE_ADD:
        case IOM_ESM_SUB_PROFILE_DELETE:
        case IOM_ESM_SUB_PROFILE_AUDIT:
        case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
        case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
        case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
        case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        case IOM_ESM_SLA_PROFILE_ADD:
        case IOM_ESM_SLA_PROFILE_DELETE:
        case IOM_ESM_SLA_PROFILE_AUDIT:
        case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
        case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
        case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
        case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
        case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
        case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
        case IOM_ESM_CATMAP_POLICY_ADD:
        case IOM_ESM_CATMAP_POLICY_DELETE:
        case IOM_ESM_CATMAP_POLICY_AUDIT:
        case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ:
        case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:
        case IOM_ESM_HOST_CAT_WRAPUP_REQ:
        case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
        case IOM_ESM_HOST_CAT_AUDIT_REQ:
        case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
        case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
        default:
            /* Do nothing */
            break;
        }
        
        pByte += smgrMesgIccSapSubEntrySize(pElm->Op);
        pElm = (tIomSapSubMixedEntry *)pByte;
        i++;
    }

    SVCMGR_EVENT(IOM_CALL, "NumEntries=%u nCbAdd=%u nCbState=%u nCbPrune=%u nCbSubHost=%u",
                 pSapSubMsg->NumEntries, nCbAdd, nCbState, nCbPrune, nCbSubHost);
    SMGR_MESG_MEM_FREE(pIccMsg);                        
}

PRIVATE void smgrGetSapCfmPrimVlanDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                               const tSapRec *pSap,
                                               tUint16 PrimVlanId,
                                               tUint32 IomOp,
                                               tUint32 SlotBitmap,
                                               tBoolean IsCardOnline)
{
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:
        pIccInfo->IomBitMask = smgrGetPortRecIomBitMask(pSap->PortRec);
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
        
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }

    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             SmgrMsgrEntry_SapCfmPrimVlan,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,                          
                             smgrMesgSapCfmPrimVlanCmp,
                             pSap,
                             PrimVlanId);
}

/* Batch up a IOM_SAP_CFM_PVLAN message */
PUBLIC tStatus smgrBatchSapCfmPrimVlanMesgPriv(const tSapRec *pSap,
                                                const tDot1agSapPvEntry *pPrimVlanCfg, 
                                                tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                tBatchProcessing *pBatch)
{
    const tSvcRec   *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus          s = SUCCESS;
    tBoolean         MemAllocated = FALSE;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_SAP_CFM_PVLAN;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u vlanId=%u ingLvl=%u egrLvl=%u mipMask=%u",
                 pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId, pPrimVlanCfg->VlanId,
                 pPrimVlanCfg->Dot1agMepIngressLevel, pPrimVlanCfg->Dot1agMepEgressLevel,
                 pPrimVlanCfg->Dot1agMipMask);

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s",
                     pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        return SUCCESS;
    }
    
    /* Determine the set of IOMs that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it... */
    smgrGetSapCfmPrimVlanDownloadInfo(&IccInfo, pSap, pPrimVlanCfg->VlanId,
                                      Op, SlotBitmap,
                                      IsCardOnline);
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IOM bitmask is 0");
        return SUCCESS;
    }

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOMs! */
    if (IccInfo.IomBitMask != PrevSapCfmPrimVlanIomBitMask)
        smgrDoFlushSapCfmPrimVlanMesg(TRUE);

    if (! pSapCfmPrimVlanReqMesg) {        
        if ((pSapCfmPrimVlanReqMesg =
                SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSapCfmPrimVlanEntriesPerMesg))) == NULL) {
            s = FAIL;
            goto Failed;
        }
        
        MemAllocated = TRUE;
    }
    
    /* Set the bit mask */
    PrevSapCfmPrimVlanIomBitMask = IccInfo.IomBitMask;

    pSapCfmPrimVlanReqMesg->NumEntries = NextSapCfmPrimVlanEntry + 1;

    pElm = smgrSapSubGetMixedEntryAddr(pSapCfmPrimVlanReqMesg, Op, NextSapCfmPrimVlanEntry);
    pElm->Op = Op;
    smgrInitSapCfmPrimVlanReqEntry(&pElm->CfmPvlan, pSap, pPrimVlanCfg);

    /* If we reached the limit, flush the message */
    if (pSapCfmPrimVlanReqMesg->NumEntries >= SMMaxNumSapCfmPrimVlanEntriesPerMesg) {
        s = smgrDoFlushSapCfmPrimVlanMesg(FALSE);
        if (pBatch)
            pBatch->SapCfmPrimVlanSent = FALSE;
    } else {
        NextSapCfmPrimVlanEntry++;
        if (pBatch)
            pBatch->SapCfmPrimVlanSent = TRUE;
    }
    
    return s;
    
Failed:
    if (MemAllocated) {
        if (pSapCfmPrimVlanReqMesg) {
            SMGR_MESG_MEM_FREE(pSapCfmPrimVlanReqMesg);
            pSapCfmPrimVlanReqMesg = NULL;
        }
    }

    return s;
}

/* Send a single IOM_SAP_CFM_PVLAN message */
PUBLIC tStatus smgrSendSapCfmPrimVlanMesg(const tSapRec *pSap,
                                          const tDot1agSapPvEntry *pPrimVlanCfg,
                                          tSMSlot SlotNum)
{
    tStatus s;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u vlanId=%u SlotNum=%u",
                 pSap->SvcRec->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId, pPrimVlanCfg->VlanId, SlotNum);

    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    if ((s = smgrBatchSapCfmPrimVlanMesgPriv(pSap, pPrimVlanCfg, SlotBitmap,
                                             FALSE, NULL)) == SUCCESS)
        s = smgrDoFlushSapCfmPrimVlanMesg(FALSE);

    return s;
}

/* Flush batched up IOM_SAP_CFM_PVLAN messages */
PRIVATE tStatus smgrDoFlushSapCfmPrimVlanMesg(tBoolean PreFlush)
{
    tUint32          IomBitMask = PrevSapCfmPrimVlanIomBitMask;
    tStatus          s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_SAP_CFM_PVLAN;

    if (! pSapCfmPrimVlanReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                 pSapCfmPrimVlanReqMesg->NumEntries, IomBitMask);
    
    if (pSapCfmPrimVlanReqMesg->NumEntries > 0) {
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr, SmgrMsgrEntry_SapCfmPrimVlan, Op);
            
        /* Send the message to all applicable IOMs */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSapCfmPrimVlanReqMesg, PreFlush);
        pSapCfmPrimVlanReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSapCfmPrimVlanReqMesg->NumEntries);
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                    IomBitMask, pSapCfmPrimVlanReqMesg, pSapCfmPrimVlanReqMesg->TotalLength,
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask=%08x !", IomBitMask);
        
        /* Start a new batch */
        smgrFreeClientMsg(pSapCfmPrimVlanReqMesg, s);
        NextSapCfmPrimVlanEntry = 0;
        pSapCfmPrimVlanReqMesg = NULL;
    }
    
    return s;
}

PRIVATE tStatus smgrFlushSapCfmPrimVlanMesg(void)
{
    return smgrDoFlushSapCfmPrimVlanMesg(FALSE);
}

/* Send a SAP_AUDIT message */
PUBLIC tStatus smgrSendSapAudit(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_SAP_AUDIT);
}

/* Send a SAP_STATS_READ message */
PUBLIC tStatus smgrSendSapBaseStatsReadMesg(
    tSapRec *pSap, 
    tSapStats *pStats,
    tSapStatsIngressQchip *pStatsIngQ,
    tSapStatsEgressQchip *pStatsEgrQ,
    tBoolean *pHaveSmgrLock)
{
    tIomSapStatsRequest msg;
    tIomSapStatsResponse *rep;
    tIomSapStats *pDst;
    tIomSapStats *pSrc;
    tSMPortInfo SapPortInfo;
    tSapCpmStat CpmStats;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;
    tStatus rc = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        goto Exit;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        goto Exit;

    /* get authentication statistics */
    sapGetAuthenticationStats(pSap,
                              &pStats->AuthenticationPktsDiscarded,
                              &pStats->AuthenticationPktsSuccess);

    /* Get CPM SAP packet stats */
    ZERO_STRUCT(CpmStats);
    sapGetCpmStats(pSap->InstanceId, FALSE, &CpmStats);
    pStats->IngressCPMPackets = CpmStats.Packets;
    pStats->IngressCPMOctets = CpmStats.Octets;
    
    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    msg.Op = IOM_SAP_STATS_READ;
    msg.NumEntries = 1;

    ZERO_STRUCT(msg.Entries[0]);

    msg.Entries[0].SapId = pSap->SapId;
    msg.Entries[0].PortId = INVALID_PORTID;

    /* If we can release the svcmgr lock so we are not blocking */
    if (pHaveSmgrLock && *pHaveSmgrLock) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
        
        if ((pIccTran = iccNewTransaction()) == NULL) {
            rc = FAIL;
            goto Exit;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_STATS_REQUEST_MSG(msg.NumEntries);
        pIccTran->RequestFragments[0].Addr = &msg;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_STATS, s);
            iccFreeTransaction(pIccTran);
            rc = FAIL;
            goto Exit;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            rc = FAIL;
            goto Exit;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgIngressStatsTime = rep->Entries[0].Stats.AvgIngressStatsTime;
            pStats->AvgEgressStatsTime = rep->Entries[0].Stats.AvgEgressStatsTime;
            
            /* Fill up the stats */                
            pDst = &pStats->IomStats;
            pSrc = &rep->Entries[0].Stats.IomStats;

            pDst->IngressPchipDroppedPackets += pSrc->IngressPchipDroppedPackets;
            pDst->IngressPchipDroppedOctets += pSrc->IngressPchipDroppedOctets;
            pDst->IngressPchipOfferedHiPrioPackets += pSrc->IngressPchipOfferedHiPrioPackets;
            pDst->IngressPchipOfferedHiPrioOctets += pSrc->IngressPchipOfferedHiPrioOctets;
            pDst->IngressPchipOfferedLoPrioPackets += pSrc->IngressPchipOfferedLoPrioPackets;
            pDst->IngressPchipOfferedLoPrioOctets += pSrc->IngressPchipOfferedLoPrioOctets;
            pDst->IngressPchipOfferedUncolouredPackets += pSrc->IngressPchipOfferedUncolouredPackets;
            pDst->IngressPchipOfferedUncolouredOctets += pSrc->IngressPchipOfferedUncolouredOctets;
            pDst->IngressPchipOfferedMcastManagedPackets += pSrc->IngressPchipOfferedMcastManagedPackets;
            pDst->IngressPchipOfferedMcastManagedOctets += pSrc->IngressPchipOfferedMcastManagedOctets;
            pDst->IngressQchipDroppedHiPrioPackets += pSrc->IngressQchipDroppedHiPrioPackets;
            pDst->IngressQchipDroppedHiPrioOctets += pSrc->IngressQchipDroppedHiPrioOctets;
            pDst->IngressQchipDroppedLoPrioPackets += pSrc->IngressQchipDroppedLoPrioPackets;
            pDst->IngressQchipDroppedLoPrioOctets += pSrc->IngressQchipDroppedLoPrioOctets;
            pDst->IngressQchipForwardedInProfPackets += pSrc->IngressQchipForwardedInProfPackets;
            pDst->IngressQchipForwardedInProfOctets += pSrc->IngressQchipForwardedInProfOctets;
            pDst->IngressQchipForwardedOutProfPackets += pSrc->IngressQchipForwardedOutProfPackets;
            pDst->IngressQchipForwardedOutProfOctets += pSrc->IngressQchipForwardedOutProfOctets;
            pDst->EgressQchipDroppedInProfPackets += pSrc->EgressQchipDroppedInProfPackets;
            pDst->EgressQchipDroppedInProfOctets += pSrc->EgressQchipDroppedInProfOctets;
            pDst->EgressQchipDroppedOutProfPackets += pSrc->EgressQchipDroppedOutProfPackets;
            pDst->EgressQchipDroppedOutProfOctets += pSrc->EgressQchipDroppedOutProfOctets;
            pDst->EgressQchipForwardedInProfPackets += pSrc->EgressQchipForwardedInProfPackets;
            pDst->EgressQchipForwardedInProfOctets += pSrc->EgressQchipForwardedInProfOctets;
            pDst->EgressQchipForwardedOutProfPackets += pSrc->EgressQchipForwardedOutProfPackets;
            pDst->EgressQchipForwardedOutProfOctets += pSrc->EgressQchipForwardedOutProfOctets;

            /* if requested, split up queue statistics for ingress and/or egress */
            if (pStatsIngQ) {
                tIomSapStatsIngressQchip *pIomStatsIngQ = &(pStatsIngQ->Stats);
                pIomStatsIngQ->IngressQchipDroppedHiPrioPackets    += pSrc->IngressQchipDroppedHiPrioPackets;
                pIomStatsIngQ->IngressQchipDroppedHiPrioOctets     += pSrc->IngressQchipDroppedHiPrioOctets;
                pIomStatsIngQ->IngressQchipDroppedLoPrioPackets    += pSrc->IngressQchipDroppedLoPrioPackets;
                pIomStatsIngQ->IngressQchipDroppedLoPrioOctets     += pSrc->IngressQchipDroppedLoPrioOctets;
                pIomStatsIngQ->IngressQchipForwardedInProfPackets  += pSrc->IngressQchipForwardedInProfPackets;
                pIomStatsIngQ->IngressQchipForwardedInProfOctets   += pSrc->IngressQchipForwardedInProfOctets;
                pIomStatsIngQ->IngressQchipForwardedOutProfPackets += pSrc->IngressQchipForwardedOutProfPackets;
                pIomStatsIngQ->IngressQchipForwardedOutProfOctets  += pSrc->IngressQchipForwardedOutProfOctets;
            }
   
            if (pStatsEgrQ) {
                tIomSapStatsEgressQchip *pIomStatsEgrQ = &(pStatsEgrQ->Stats);
                pIomStatsEgrQ->EgressQchipDroppedInProfPackets    += pSrc->EgressQchipDroppedInProfPackets;
                pIomStatsEgrQ->EgressQchipDroppedInProfOctets     += pSrc->EgressQchipDroppedInProfOctets;
                pIomStatsEgrQ->EgressQchipDroppedOutProfPackets   += pSrc->EgressQchipDroppedOutProfPackets;
                pIomStatsEgrQ->EgressQchipDroppedOutProfOctets    += pSrc->EgressQchipDroppedOutProfOctets;
                pIomStatsEgrQ->EgressQchipForwardedInProfPackets  += pSrc->EgressQchipForwardedInProfPackets;
                pIomStatsEgrQ->EgressQchipForwardedInProfOctets   += pSrc->EgressQchipForwardedInProfOctets;
                pIomStatsEgrQ->EgressQchipForwardedOutProfPackets += pSrc->EgressQchipForwardedOutProfPackets;
                pIomStatsEgrQ->EgressQchipForwardedOutProfOctets  += pSrc->EgressQchipForwardedOutProfOctets;
            }
        }
    
        iccFreeTransaction(pIccTran);
    }
    if (pStatsIngQ) {
        pStatsIngQ->AvgIngressStatsTime = pStats->AvgIngressStatsTime;
    }
    if (pStatsEgrQ) {
        pStatsEgrQ->AvgEgressStatsTime = pStats->AvgEgressStatsTime;
    }
    
  Exit:
    /* If we can release the svcmgr lock */
    if (pHaveSmgrLock && *pHaveSmgrLock) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }    
    return rc;
}    


/* Send a SAP_STATS_RESET message */
PUBLIC tStatus smgrSendSapBaseStatsResetMesg(tSapRec *pSap, tBoolean *pHaveSmgrLock)
{
    tIomSapStatsRequest msg;
    tSMPortInfo SapPortInfo;
    tIccError s;
    tStatus rc = SUCCESS;
    tUint32 IomBitMask;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        goto Exit;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        goto Exit;

    sapResetCpmStat(pSap->InstanceId);
    
    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    IomBitMask = SMOnLineIomBitMask & SapPortInfo.IomPresentBitMask;

    msg.Op = IOM_SAP_STATS_RESET;
    msg.NumEntries = 1;

    ZERO_STRUCT(msg.Entries[0]);

    msg.Entries[0].SapId = pSap->SapId;
    msg.Entries[0].PortId = INVALID_PORTID;

    /* If we can, release the svcmgr lock so we are not blocking */
    if (pHaveSmgrLock && *pHaveSmgrLock) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    if (IomBitMask) {
        s = smgrSendMesgToIoms(ICC_SOCKET_SAP_STATS, IomBitMask, &msg,
                               SIZE_SAP_STATS_REQUEST_MSG(msg.NumEntries));
        if (s != ICC_ERR_NONE) {
            if (s != ICC_ERR_UNREACHABLE) {
                SVCMGR_INFORM(NOCLASS,
                              "smgrSendMesgToIoms() to iom=0x%08x failed with error=%d !",
                              IomBitMask, s);
                rc = FAIL;
            }
        }
    }

  Exit:
    /* If we can release the svcmgr lock */
    if (pHaveSmgrLock && *pHaveSmgrLock) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }    
    return rc;
}    


/* Send a ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSapIngQueueStatsReadMesg(tSapRec *pSap, int QueueId, tAccessIngressQosQueueStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapQueueStatsRequest *req;
    tIomSapQueueStatsResponse *rep;
    tSMPortInfo SapPortInfo;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s queue=%d",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId), QueueId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->PollHardware = 0;
    req->SapQueues[0].SapId = pSap->SapId;
    req->SapQueues[0].PortId = INVALID_PORTID;
    req->SapQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_ING_QUEUE(QueueId);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            sapStatsIngQosPlcyQueueAdd(pStats, &rep->Stats[0].Stats.Ingress);
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}


/* Send a ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSapIngQueueStatsResetMesg(tSapRec *pSap)
{
    tIomSapQueueStatsRequest *req;
    tSMPortInfo SapPortInfo;
    int slotNum;
    int numIngQueues;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8 ingStatIdList[MAX_QOS_STAT_COUNTERS_PER_INGRESS_QOS_POLICY + 3];

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    numIngQueues = qosGetSapIngStatIdList(pSap, ingStatIdList);

    /* Allocate for max number of queues */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(SMMaxNumSapQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    req->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    req->PollHardware = 0;

    numIterations = (numIngQueues / SMMaxNumSapQueueStatsEntriesPerMesg) +
                    ((numIngQueues % SMMaxNumSapQueueStatsEntriesPerMesg) ? 1 : 0 );
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in ingStatIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSapQueueStatsEntriesPerMesg;

        req->NumEntries = MIN(numIngQueues, SMMaxNumSapQueueStatsEntriesPerMesg);
        numIngQueues   -= req->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < req->NumEntries; i++) {
            req->SapQueues[i].SapId = pSap->SapId;
            req->SapQueues[i].PortId = INVALID_PORTID;
            req->SapQueues[i].QosQueueId = MAKE_QOS_QUEUE_ID_ING_QUEUE(ingStatIdList[iterationIndex + i]);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this
             * SAP is not present.
             */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SAP_QUEUE_STATS, slotNum, req,
                                   SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}    

/* Send a ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSapIngPolicerStatsReadMesg(tSapRec *pSap, int PolicerId, tAccessIngressQosPolicerStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapQueueStatsRequest *req;
    tIomSapQueueStatsResponse *rep;
    tIomQosPolicerStats_Generic *pDst;
    tIomQosPolicerStats_Generic *pSrc;
    tSMPortInfo SapPortInfo;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s policer=%d",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId), PolicerId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->PollHardware = 0;
    req->SapQueues[0].SapId = pSap->SapId;
    req->SapQueues[0].PortId = INVALID_PORTID;
    req->SapQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_ING_POLICER(PolicerId);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.IngressPolicer.AvgStatsTime;
            pStats->StatMode = rep->Stats[0].Stats.IngressPolicer.StatMode;

            /* Fill up the stats */   
            pDst = &pStats->IomStats.Generic;
            pSrc = &rep->Stats[0].Stats.IngressPolicer.IomStats.Generic;

            pDst->HighPktsOffered += pSrc->HighPktsOffered;
            pDst->HighPktsDropped += pSrc->HighPktsDropped;
            pDst->LowPktsOffered += pSrc->LowPktsOffered;
            pDst->LowPktsDropped += pSrc->LowPktsDropped;
            pDst->HighOctetsOffered += pSrc->HighOctetsOffered;
            pDst->HighOctetsDropped += pSrc->HighOctetsDropped;
            pDst->LowOctetsOffered += pSrc->LowOctetsOffered;
            pDst->LowOctetsDropped += pSrc->LowOctetsDropped;
            pDst->UncolouredPktsOffered += pSrc->UncolouredPktsOffered;
            pDst->UncolouredOctetsOffered += pSrc->UncolouredOctetsOffered;
            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}


/* Send a ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSapIngPolicerStatsResetMesg(tSapRec *pSap)
{
    tIomSapQueueStatsRequest *req;
    tSMPortInfo SapPortInfo;
    int slotNum;
    int numIngPolicers;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8 ingPolicerIdList[MAX_QOS_POLICERS_PER_ING_QOS_POL];

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    numIngPolicers = qosGetSapIngPolicerIdList(pSap, ingPolicerIdList);

    /* Allocate for max number of queues */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(SMMaxNumSapQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    req->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    req->PollHardware = 0;

    numIterations = (numIngPolicers / SMMaxNumSapQueueStatsEntriesPerMesg) +
                    ((numIngPolicers % SMMaxNumSapQueueStatsEntriesPerMesg) ? 1 : 0 );
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in ingPolicerIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSapQueueStatsEntriesPerMesg;

        req->NumEntries = MIN(numIngPolicers, SMMaxNumSapQueueStatsEntriesPerMesg);
        numIngPolicers -= req->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < req->NumEntries; i++) {
            req->SapQueues[i].SapId = pSap->SapId;
            req->SapQueues[i].PortId = INVALID_PORTID;
            req->SapQueues[i].QosQueueId = MAKE_QOS_QUEUE_ID_ING_POLICER(ingPolicerIdList[iterationIndex + i]);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this
             * SAP is not present.
             */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SAP_QUEUE_STATS, slotNum, req,
                                   SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}    


/* Send a ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSapEgrQueueStatsReadMesg(tSapRec *pSap, int QueueId, tAccessEgressQosQueueStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapQueueStatsRequest *req;
    tIomSapQueueStatsResponse *rep;
    tIomAccessEgressQosQueueStats *pDst;
    tIomAccessEgressQosQueueStats *pSrc;
    tSMPortInfo SapPortInfo;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s queue=%d",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId), QueueId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->PollHardware = 0;
    req->SapQueues[0].SapId = pSap->SapId;
    req->SapQueues[0].PortId = INVALID_PORTID;
    req->SapQueues[0].QosQueueId = QueueId;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.Egress.AvgStatsTime;

            /* Fill up the stats */   
            pDst = &pStats->IomStats;
            pSrc = &rep->Stats[0].Stats.Egress.IomStats;

            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->InProfilePktsDropped += pSrc->InProfilePktsDropped;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->OutOfProfilePktsDropped += pSrc->OutOfProfilePktsDropped;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->InProfileOctetsDropped += pSrc->InProfileOctetsDropped;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
            pDst->OutOfProfileOctetsDropped += pSrc->OutOfProfileOctetsDropped;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}


/* Send a ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSapEgrQueueStatsResetMesg(tSapRec *pSap)
{
    tIomSapQueueStatsRequest *req;
    tSMPortInfo SapPortInfo;
    int slotNum;
    int numEgrQueues;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8  egrStatIdList[MAX_QOS_STAT_COUNTERS_PER_EGRESS_QOS_POLICY];

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    numEgrQueues = qosGetSapEgrStatIdList(pSap, egrStatIdList);

    /* Allocate for max number of queues */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(SMMaxNumSapQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    req->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    req->PollHardware = 0;

    numIterations = (numEgrQueues / SMMaxNumSapQueueStatsEntriesPerMesg) +
                    ((numEgrQueues % SMMaxNumSapQueueStatsEntriesPerMesg) ? 1 : 0 );

    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in egrStatIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSapQueueStatsEntriesPerMesg;

        req->NumEntries = MIN(numEgrQueues, SMMaxNumSapQueueStatsEntriesPerMesg);
        numEgrQueues   -= req->NumEntries; /* Tracking remaining queues */

        for (i = 0; i < req->NumEntries; i++) {
            req->SapQueues[i].SapId = pSap->SapId;
            req->SapQueues[i].PortId = INVALID_PORTID;
            req->SapQueues[i].QosQueueId = egrStatIdList[iterationIndex + i];
        }

        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this
             * SAP is not present.
             */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
                continue;

            smgrSendUnicastIomMesg(ICC_SOCKET_SAP_QUEUE_STATS, slotNum, req,
                                   SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries));
        }
    }

    SMGR_MESG_MEM_FREE(req);

    return SUCCESS;
}


/* Send a ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSapEgrPolicerStatsReadMesg(tSapRec *pSap, int PolicerId, tAccessEgressQosPolicerStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapQueueStatsRequest *req;
    tIomSapQueueStatsResponse *rep;
    tIomQosPolicerStats_Generic *pDst;
    tIomQosPolicerStats_Generic *pSrc;
    tSMPortInfo SapPortInfo;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s policer=%d",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId), PolicerId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->PollHardware = 0;
    req->SapQueues[0].SapId = pSap->SapId;
    req->SapQueues[0].PortId = INVALID_PORTID;
    req->SapQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_EGR_POLICER(PolicerId);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.Egress.AvgStatsTime;
            pStats->StatMode = rep->Stats[0].Stats.EgressPolicer.StatMode;

            /* Fill up the stats */   
            pDst = &pStats->IomStats.Generic;
            pSrc = &rep->Stats[0].Stats.EgressPolicer.IomStats.Generic;

            pDst->HighPktsOffered += pSrc->HighPktsOffered;
            pDst->LowPktsOffered += pSrc->LowPktsOffered;
            pDst->HighOctetsOffered += pSrc->HighOctetsOffered;
            pDst->LowOctetsOffered += pSrc->LowOctetsOffered;
            pDst->UncolouredPktsOffered += pSrc->UncolouredPktsOffered;
            pDst->UncolouredOctetsOffered += pSrc->UncolouredOctetsOffered;
            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->HighPktsDropped += pSrc->HighPktsDropped;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->LowPktsDropped += pSrc->LowPktsDropped;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->HighOctetsDropped += pSrc->HighOctetsDropped;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
            pDst->LowOctetsDropped += pSrc->LowOctetsDropped;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}


/* Send a ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSapEgrPolicerStatsResetMesg(tSapRec *pSap)
{
    tIomSapQueueStatsRequest *req;
    tSMPortInfo SapPortInfo;
    int slotNum;
    int numEgrPolicers;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8  egrPolicerIdList[MAX_QOS_POLICERS_PER_EGR_QOS_POL];

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    numEgrPolicers = qosGetSapEgrPolicerIdList(pSap, egrPolicerIdList);

    /* Allocate for max number of queues */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QUEUE_STATS_REQUEST_MSG(SMMaxNumSapQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    req->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    req->PollHardware = 0;

    numIterations = (numEgrPolicers / SMMaxNumSapQueueStatsEntriesPerMesg) +
                    ((numEgrPolicers % SMMaxNumSapQueueStatsEntriesPerMesg) ? 1 : 0 );

    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in egrStatIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSapQueueStatsEntriesPerMesg;

        req->NumEntries = MIN(numEgrPolicers, SMMaxNumSapQueueStatsEntriesPerMesg);
        numEgrPolicers -= req->NumEntries; /* Tracking remaining queues */

        for (i = 0; i < req->NumEntries; i++) {
            req->SapQueues[i].SapId = pSap->SapId;
            req->SapQueues[i].PortId = INVALID_PORTID;
            req->SapQueues[i].QosQueueId = MAKE_QOS_QUEUE_ID_EGR_POLICER(egrPolicerIdList[iterationIndex + i]);
        }

        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this
             * SAP is not present.
             */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
                continue;

            smgrSendUnicastIomMesg(ICC_SOCKET_SAP_QUEUE_STATS, slotNum, req,
                                   SIZE_SAP_QUEUE_STATS_REQUEST_MSG(req->NumEntries));
        }
    }

    SMGR_MESG_MEM_FREE(req);

    return SUCCESS;
}


/* Send a IOM_SCHEDULER_QOS_STATS_READ_RELATIVE message
 * Note, this function can be called in order to get:
 *   SAP ingress/egress scheduler stats
 *   SAP egress Encap Group scheduler stats (per group or per member)
 */
PUBLIC tStatus smgrSendSapSchedStatsReadMesg(const tSapRec *pSap,
                                             tUint32 EncapGroupId,
                                             tUint32 EncapMemberId,
                                             const char *Sched,
                                             tPortId PortId,
                                             tBoolean Ingress,
                                             tSchedulerQosStats *pStats,
                                             tBoolean *pHaveSmgrLock)
{
    tIomSapSchedulerStatsRequest  *req = NULL;
    tIomSapSchedulerStatsResponse *rep = NULL;

    tIccTransaction *pIccTran = NULL;
    tIccError s;

    tSMPortInfo SapPortInfo;
    tSlot slotNum;
    tSlot minSlotNum, maxSlotNum;
    tUint32 ProcessIomBitMask = 0;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s encapGrpId=%d encapMember=0x%x scheduler=%s port=%s direction=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 EncapGroupId,
                 EncapMemberId,
                 Sched,
                 smgrFmtPortIdVerboseForDebug(PortId),
                 (Ingress) ? "ingress" : "egress");

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /* Create request */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_SCHEDULER_QOS_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    if (EncapGroupId == INVALID_ENCAP_GROUP_ID) {
        req->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_SAP;
        req->SapSchedulers[0].TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
        req->SapSchedulers[0].TypeId.Dir = Ingress ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
        req->SapSchedulers[0].LocId.Sap.SapId = pSap->SapId;
        req->SapSchedulers[0].LocId.Sap.PortId = PortId;
        req->SapSchedulers[0].LocId.Sap.FpId = INVALID_FP_ID; // always for scheduler stats
    } else {
        req->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_ENCAP_GROUP;
        req->SapSchedulers[0].TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
        req->SapSchedulers[0].TypeId.Dir = QOS_DIRECTION_EGRESS;
        req->SapSchedulers[0].LocId.EncapGroup.SapId = pSap->SapId;
        req->SapSchedulers[0].LocId.EncapGroup.EncapGroupId = EncapGroupId;
        req->SapSchedulers[0].LocId.EncapGroup.EncapGroupMember = EncapMemberId;
        req->SapSchedulers[0].LocId.EncapGroup.PortId = PortId;
    }
    strcpyn(req->SapSchedulers[0].ObjId.SchedulerName.Str, sizeof (req->SapSchedulers[0].ObjId.SchedulerName.Str), Sched);

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    /* If a specific member port was specified, query only
     * the IOM where that port resides. Otherwise, query
     * all the IOM's where the SAP is defined.
     */
    if (PortId != INVALID_PORTID) {
        slotNum = GET_SLOT_NUM(PortId);
        IOM_BIT_SET(ProcessIomBitMask, slotNum);
        minSlotNum = slotNum;
        maxSlotNum = minSlotNum;
    } else {
        ProcessIomBitMask = SapPortInfo.IomBitMask;
        minSlotNum = MIN_CHASSIS_SLOT;
        maxSlotNum = MAX_CHASSIS_SLOT;
    }
    
    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = minSlotNum; slotNum <= maxSlotNum; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not defined.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(ProcessIomBitMask, slotNum)) {
            continue;
        }
        
        /* ICC Transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
        
        /* Fill out ICC transaction */       
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
 
        SVCMGR_EVENT(IOM_CALL, "sock=%d slot=%d len=%d", pIccTran->Socket, slotNum, pIccTran->RequestFragments[0].Length);

        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Copy the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.AvgStatsTime;
            
            /* Fill up the stats */   
            pStats->IomStats.PktsForwarded += rep->Stats[0].Stats.IomStats.PktsForwarded;
            pStats->IomStats.OctetsForwarded += rep->Stats[0].Stats.IomStats.OctetsForwarded;
        }

        iccFreeTransaction(pIccTran);
    }

    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}


PUBLIC tStatus smgrSendSapSchedStatsResetMesg(tSapRec *pSap, tSMPortInfo *pSapPortInfo, 
                                              tIomSapSchedulerStatsRequest *req)
{  
    tIccTransaction *pIccTran;
    tIccError s;
    tSlot slotNum;
    tPortId PortId;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s port=%s numEntries=%d", pSap->SvcRec->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 smgrFmtPortIdVerboseForDebug(req->SapSchedulers[0].LocId.Sap.PortId),
                 req->NumEntries);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /*
     * If the SAP is a link mode LAG/CCAG or an APS, then the request has a particular
     * member port we want to clear. Only send a msg to that port's IOM
     */

    if (req->SapSchedulers[0].TypeId.Loc == QOS_SCHEDULER_LOC_ENCAP_GROUP)
        PortId = req->SapSchedulers[0].LocId.EncapGroup.PortId;
    else
        PortId = req->SapSchedulers[0].LocId.Sap.PortId;

    if (PortId == INVALID_PORTID) {
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this
             * SAP is not defined.
             */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(pSapPortInfo->IomBitMask, slotNum)) {
                continue;
            }
            
            if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
                return FAIL;
            }
            
            /* Fill out ICC transaction */
            pIccTran->Slot = slotNum;
            pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
            pIccTran->Priority = ICC_HIGHEST_PRIORITY;
            memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
            
            s = iccSendRequestAsyncS(pIccTran, NULL);
            if (s != ICC_ERR_NONE) {
                iccFreeTransaction(pIccTran);
            }    
            
            /* If the IOM is removed during the transaction, we may
             * get an ICC_ERR_UNREACHABLE that can be safely ignored.
             */
            if (s == ICC_ERR_UNREACHABLE) {
                continue;
            }
            
            /* Check the return code */
            if (s != ICC_ERR_NONE) {
                SVCMGR_ERROR(NOCLASS,
                             "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                             slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
                return FAIL;
            }
        }
    } else {
        slotNum = GET_SLOT_NUM(PortId);

        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            return FAIL;
        }
        
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
        
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
        
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            return SUCCESS;
        }
        
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            return FAIL;
        }
    }
    
    return SUCCESS;
}

/* Send a IOM_SCHEDULER_QOS_STATS_READ_RELATIVE message
 * Note, this function can be called in order to get:
 *   SAP ingress/egress arbiter stats
 */
PUBLIC tStatus smgrSendSapArbitStatsReadMesg(const tSapRec *pSap,
                                             const char *Arbit,
                                             tPortId PortId,   // INVALID_PORTID except for agg sap with per link QoS
                                             tBoolean Ingress, // TRUE on ingress
                                             tSchedulerQosStats *pStats,
                                             tBoolean *pHaveSmgrLock)
{
    tIomSapSchedulerStatsRequest  *req = NULL;
    tIomSapSchedulerStatsResponse *rep = NULL;

    tIccTransaction *pIccTran = NULL;
    tIccError s;

    tSMPortInfo SapPortInfo;
    tSlot slotNum;
    tComplexNum cmplx;
    tComplexNum minCmplx, maxCmplx;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s arbiter=%s port=%s direction=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 Arbit,
                 smgrFmtPortIdVerboseForDebug(PortId),
                 (Ingress) ? "ingress" : "egress");

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /* Create request */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_SCHEDULER_QOS_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_SAP;
    req->SapSchedulers[0].TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    req->SapSchedulers[0].TypeId.Dir = Ingress ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    req->SapSchedulers[0].LocId.Sap.SapId = pSap->SapId;
    req->SapSchedulers[0].LocId.Sap.PortId = PortId;
    req->SapSchedulers[0].LocId.Sap.FpId = INVALID_FP_ID; // may be overwritten below
    strcpyn(req->SapSchedulers[0].ObjId.SchedulerName.Str, sizeof (req->SapSchedulers[0].ObjId.SchedulerName.Str), Arbit);

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    /* If a specific member port was specified, query only
     * the complex where that port resides. Otherwise, query
     * all the complexes where the SAP is defined.
     */
    if (PortId != INVALID_PORTID) {
        minCmplx = sfMapPortIdToComplex(PortId);
        maxCmplx = minCmplx;
    } else {
        minCmplx = MIN_COMPLEX_NUM;
        maxCmplx = MAX_COMPLEX_NUM;
    }

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (cmplx = minCmplx; cmplx <= maxCmplx; cmplx++) {
        /* Skip IOM's that are off-line or where this SAP is not defined. */
        slotNum = sfMapComplexToSlot(cmplx);
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            (SapPortInfo.Count[cmplx] == 0)) {
            continue;
        }
        
        /* ICC Transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
        
        /* Tweak the FpId if necessary
         * whenever PortId != INVALID_PORTID, then FpId should be set to INVALID_FP_ID (initialized above)
         * whenever PortId == INVALID_PORTID, then FpId should be set according to this cmplx in the loop
         */
        if (PortId == INVALID_PORTID)
            req->SapSchedulers[0].LocId.Sap.FpId = sfMapComplexToSlotFpNum(cmplx)-1; // -1 converts FpNum to FpId

        /* Fill out ICC transaction */       
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
 
        SVCMGR_EVENT(IOM_CALL, "sock=%d slot=%d fpId=%d len=%d", pIccTran->Socket, slotNum, req->SapSchedulers[0].LocId.Sap.FpId, pIccTran->RequestFragments[0].Length);

        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Copy the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.AvgStatsTime;
            
            /* Fill up the stats */   
            pStats->IomStats.PktsForwarded += rep->Stats[0].Stats.IomStats.PktsForwarded;
            pStats->IomStats.OctetsForwarded += rep->Stats[0].Stats.IomStats.OctetsForwarded;
        }

        iccFreeTransaction(pIccTran);
    }

    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}

/* Send a IOM_SCHEDULER_QOS_STATS_SET_BASELINE message
 * This function uses the passed in request as a template, but then sprays that request across
 * all applicable Slot/FPs, which is why the request needs to be tweaked for each.
 */
PUBLIC tStatus smgrSendSapArbitStatsResetMesg(tSapRec *pSap, tSMPortInfo *pSapPortInfo, 
                                              tIomSapSchedulerStatsRequest *req)
{  
    tIccTransaction *pIccTran;
    tIccError s;
    tSlot slotNum;
    tPortId PortId;
    tComplexNum cmplx;
    int sched;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s port=%s numEntries=%d", pSap->SvcRec->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 smgrFmtPortIdVerboseForDebug(req->SapSchedulers[0].LocId.Sap.PortId),
                 req->NumEntries);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /*
     * If the SAP is a link mode LAG/CCAG or an APS, then the request has a particular
     * member port we want to clear. Only send a msg to that port's IOM
     */
    PortId = req->SapSchedulers[0].LocId.Sap.PortId;

    if (PortId == INVALID_PORTID) {
        for (cmplx = MIN_COMPLEX_NUM; cmplx <= MAX_COMPLEX_NUM; cmplx++) {
            /* Skip IOM's that are off-line or where this SAP is not defined. */
            slotNum = sfMapComplexToSlot(cmplx);
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                (pSapPortInfo->Count[cmplx] == 0)) {
                continue;
            }

            /* Tweak the FpId for all arbiters in this request
             * whenever PortId == INVALID_PORTID, then FpId should be set according to this cmplx in the loop
             */
            for (sched = 0; sched < req->NumEntries; sched++) {
                req->SapSchedulers[sched].LocId.Sap.FpId = sfMapComplexToSlotFpNum(cmplx)-1; // -1 converts FpNum to FpId
            }

            if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
                return FAIL;
            }

            /* Fill out ICC transaction */
            pIccTran->Slot = slotNum;
            pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
            pIccTran->Priority = ICC_HIGHEST_PRIORITY;
            memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
            
            s = iccSendRequestAsyncS(pIccTran, NULL);
            if (s != ICC_ERR_NONE) {
                iccFreeTransaction(pIccTran);
            }    
            
            /* If the IOM is removed during the transaction, we may
             * get an ICC_ERR_UNREACHABLE that can be safely ignored.
             */
            if (s == ICC_ERR_UNREACHABLE) {
                continue;
            }
            
            /* Check the return code */
            if (s != ICC_ERR_NONE) {
                SVCMGR_ERROR(NOCLASS,
                             "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                             slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
                return FAIL;
            }
        }
    } else {
        slotNum = GET_SLOT_NUM(PortId);

        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            return FAIL;
        }

        /* Tweak the FpId. Since PortId != INVALID_PORTID, make sure FpId is set to INVALID_FP_ID */
        for (sched = 0; sched < req->NumEntries; sched++) {
            req->SapSchedulers[sched].LocId.Sap.FpId = INVALID_FP_ID;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
        
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
        
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            return SUCCESS;
        }
        
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            return FAIL;
        }
    }
    
    return SUCCESS;
}


/* Send a IOM_SCHEDULER_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendCustMssSchedStatsReadMesg(const tMssRec *pMss, const char *Sched, tPortId PortId,
                                                 tBoolean Ingress, tSchedulerQosStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapSchedulerStatsRequest  *req;
    tIomSapSchedulerStatsResponse *rep;
    
    tIccTransaction *pIccTran;
    tIccError s;

    tSMPortInfo SapPortInfo;
    tSlot slotNum;
    tSlot minSlotNum, maxSlotNum;
    tUint32 ProcessIomBitMask = 0;

    SVCMGR_EVENT(IOM_CALL, "cust=%u site=%s scheduler=%s port=%s direction=%s",
                 pMss->CustRec->Id, pMss->Name, Sched,
                 smgrFmtPortIdVerboseForDebug(PortId),
                 (Ingress) ? "ingress" : "egress");

    /* Initialize the response. */
    ZERO_STRUCT_PTR(pStats);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (pMss->Scope == VAL_custMultSvcSiteScope_card)
    {
        /* IOM to be processed */
        slotNum = pMss->Assignment;
        IOM_BIT_SET(ProcessIomBitMask, slotNum);
        minSlotNum = slotNum;
        maxSlotNum = minSlotNum;
    }
    else
    {
        tSMPortRec *pRec;

        /* Get the port record */
        pRec = smgrFindPortRec(pMss->Assignment);
        if (pRec == NULL)
            return SUCCESS;

        /* Get the set of ports where this port is defined */
        smgrGetPortInfo(pRec, &SapPortInfo);

        /* If a specific member port was specified, query only
         * the IOM where that port resides. Otherwise, query
         * all the IOM's where the SAP is defined.
         */
        if (PortId != INVALID_PORTID) {
            slotNum = GET_SLOT_NUM(PortId);
            IOM_BIT_SET(ProcessIomBitMask, slotNum);
            minSlotNum = slotNum;
            maxSlotNum = minSlotNum;
        } else {
            ProcessIomBitMask = SapPortInfo.IomBitMask;
            minSlotNum = MIN_CHASSIS_SLOT;
            maxSlotNum = MAX_CHASSIS_SLOT;
        }
    }

    /* Create request */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(1))) == NULL) {
        return FAIL;
    }
        
    req->Op = IOM_SCHEDULER_QOS_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_SITE;
    req->SapSchedulers[0].TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    req->SapSchedulers[0].TypeId.Dir = Ingress ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(req->SapSchedulers[0].ObjId.SchedulerName.Str, sizeof (req->SapSchedulers[0].ObjId.SchedulerName.Str), Sched);
    req->SapSchedulers[0].LocId.Site.SiteId = pMss->InstanceId;
    req->SapSchedulers[0].LocId.Site.PortId = PortId;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }
    
    for (slotNum = minSlotNum; slotNum <= maxSlotNum; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * MSS is not defined.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(ProcessIomBitMask, slotNum)) {
            continue;
        }

        /* ICC Transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        SVCMGR_EVENT(IOM_CALL, "sock=%d slot=%d len=%d", pIccTran->Socket, slotNum, pIccTran->RequestFragments[0].Length);

        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Copy the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.AvgStatsTime;
            
            /* Fill up the stats */   
            pStats->IomStats.PktsForwarded += rep->Stats[0].Stats.IomStats.PktsForwarded;
            pStats->IomStats.OctetsForwarded += rep->Stats[0].Stats.IomStats.OctetsForwarded;
        }

        iccFreeTransaction(pIccTran);
    }
    
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}


PUBLIC tStatus smgrSendCustMssSchedStatsResetMesg(tMssRec *pMss, tSMPortInfo *pCustMssPortInfo, tIomSapSchedulerStatsRequest *req)
{  
    tIccTransaction *pIccTran;
    tIccError s;

    tUint32 ProcessIomBitMask = 0;
    tSlot   slotNum, slotNumBegin = MIN_CHASSIS_SLOT, slotNumEnd = MAX_CHASSIS_SLOT;

    SVCMGR_EVENT(IOM_CALL, "cust=%u site=%s port=%s num entries=%u", pMss->CustRec->Id,
                 pMss->Name, smgrFmtPortIdVerboseForDebug(req->SapSchedulers[0].LocId.Site.PortId), req->NumEntries);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (pMss->Scope == VAL_custMultSvcSiteScope_card)
    {
        /* IOM to be processed */
        IOM_BIT_SET(ProcessIomBitMask, pMss->Assignment);
        slotNumBegin = slotNumEnd = pMss->Assignment;
    }
    else
    {
        /*
         * If the assignment is a link mode LAG/CCAG or an APS, then the request has a particular
         * member port we want to clear. Only send a msg to that port's IOM
         */

        /* IOM Bit Mask */
        if (req->SapSchedulers[0].LocId.Site.PortId == INVALID_PORTID) {
            ProcessIomBitMask = pCustMssPortInfo->IomBitMask;
        }
        else {
            slotNumBegin = slotNumEnd = GET_SLOT_NUM(req->SapSchedulers[0].LocId.Site.PortId);
            IOM_BIT_SET(ProcessIomBitMask, slotNumBegin);
        }
    }

    for (slotNum = slotNumBegin; slotNum <= slotNumEnd; slotNum++) {

        /* Skip IOM's that are off-line or where this
         * MSS is not defined.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(ProcessIomBitMask, slotNum)) {
            continue;
        }
       
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
        
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            return FAIL;
        }    
    }

    return SUCCESS;
}

/* Send a IOM_SCHEDULER_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendCustMssArbitStatsReadMesg(const tMssRec *pMss, const char *Sched, tPortId PortId,
                                                 tBoolean Ingress, tSchedulerQosStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapSchedulerStatsRequest  *req;
    tIomSapSchedulerStatsResponse *rep;
    
    tIccTransaction *pIccTran;
    tIccError s;

    tSMPortInfo SapPortInfo;
    tSlot slotNum;
    tComplexNum cmplx;
    tComplexNum minCmplx, maxCmplx;

    SVCMGR_EVENT(IOM_CALL, "cust=%u site=%s arbiter=%s port=%s direction=%s",
                 pMss->CustRec->Id, pMss->Name, Sched,
                 smgrFmtPortIdVerboseForDebug(PortId),
                 (Ingress) ? "ingress" : "egress");

    /* Initialize the response. */
    ZERO_STRUCT_PTR(pStats);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (pMss->Scope == VAL_custMultSvcSiteScope_port)
    {
        tSMPortRec *pRec;

        /* Get the port record */
        pRec = smgrFindPortRec(pMss->Assignment);
        if (pRec == NULL)
            return SUCCESS;

        /* Get the set of ports where this port is defined */
        smgrGetPortInfo(pRec, &SapPortInfo);

        /* If a specific member port was specified, query only
         * the complex where that port resides. Otherwise, query
         * all the complexes where the SAP is defined.
         */
        if (PortId != INVALID_PORTID) {
            minCmplx = sfMapPortIdToComplex(PortId);
            maxCmplx = minCmplx;
        } else {
            minCmplx = MIN_COMPLEX_NUM;
            maxCmplx = MAX_COMPLEX_NUM;
        }
    }
    else
    {
        /* card assignment is not supported with policer-control-policies because they
         * are a per-FP resource...one day we may support an FP assignment.
         * For now just fail.
         */
        return FAIL;
    }

    /* Create request */
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(1))) == NULL) {
        return FAIL;
    }
        
    req->Op = IOM_SCHEDULER_QOS_STATS_READ_RELATIVE;
    req->NumEntries = 1;
    req->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_SITE;
    req->SapSchedulers[0].TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    req->SapSchedulers[0].TypeId.Dir = Ingress ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(req->SapSchedulers[0].ObjId.SchedulerName.Str, sizeof (req->SapSchedulers[0].ObjId.SchedulerName.Str), Sched);
    req->SapSchedulers[0].LocId.Site.SiteId = pMss->InstanceId;
    req->SapSchedulers[0].LocId.Site.PortId = PortId;
    
    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (cmplx = minCmplx; cmplx <= maxCmplx; cmplx++) {
        /* Skip IOM's that are off-line or where this MSS is not defined. */
        slotNum = sfMapComplexToSlot(cmplx);
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            (SapPortInfo.Count[cmplx] == 0)) {
            continue;
        }

        /* ICC Transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Tweak the FpId if necessary
         * whenever PortId != INVALID_PORTID, then FpId should be set to INVALID_FP_ID (initialized above)
         * whenever PortId == INVALID_PORTID, then FpId should be set according to this cmplx in the loop
         */
        if (PortId == INVALID_PORTID)
            req->SapSchedulers[0].LocId.Site.FpId = sfMapComplexToSlotFpNum(cmplx)-1; // -1 converts FpNum to FpId

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        SVCMGR_EVENT(IOM_CALL, "sock=%d slot=%d len=%d", pIccTran->Socket, slotNum, pIccTran->RequestFragments[0].Length);

        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Copy the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.AvgStatsTime;
            
            /* Fill up the stats */   
            pStats->IomStats.PktsForwarded += rep->Stats[0].Stats.IomStats.PktsForwarded;
            pStats->IomStats.OctetsForwarded += rep->Stats[0].Stats.IomStats.OctetsForwarded;
        }

        iccFreeTransaction(pIccTran);
    }
    
    SMGR_MESG_MEM_FREE(req);
    
    return SUCCESS;
}

PUBLIC tStatus smgrSendCustMssArbitStatsResetMesg(tMssRec *pMss, tSMPortInfo *pCustMssPortInfo, tIomSapSchedulerStatsRequest *req)
{  
    tIccTransaction *pIccTran;
    tIccError s;

    tSlot   slotNum;
    tComplexNum cmplx;
    tComplexNum minCmplx, maxCmplx;
    tPortId portId = req->SapSchedulers[0].LocId.Site.PortId;
    tFpId fpId;
    int arbit;

    SVCMGR_EVENT(IOM_CALL, "cust=%u site=%s port=%s num entries=%u", pMss->CustRec->Id,
                 pMss->Name, smgrFmtPortIdVerboseForDebug(portId), req->NumEntries);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (pMss->Scope == VAL_custMultSvcSiteScope_port)
    {
        /*
         * If the assignment is a link mode LAG/CCAG or an APS, then the request has a particular
         * member port we want to clear. Only send a msg to that port's IOM
         */

        /* IOM Bit Mask */
        if (portId == INVALID_PORTID) {
            minCmplx = MIN_COMPLEX_NUM;
            maxCmplx = MAX_COMPLEX_NUM;
        }
        else {
            minCmplx = maxCmplx = sfMapPortIdToComplex(portId);
        }
    }
    else
    {
        /* card assignment is not supported with policer-control-policies because they
         * are a per-FP resource...one day we may support an FP assignment.
         * For now just fail.
         */
        return FAIL;
    }

    for (cmplx = minCmplx; cmplx <= maxCmplx; cmplx++) {

        /* Skip IOM's that are off-line or where this MSS is not defined. */
        slotNum = sfMapComplexToSlot(cmplx);
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            (pCustMssPortInfo->Count[cmplx] == 0)) {
            continue;
        }
       
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            return FAIL;
        }

        /* Tweak the FpId for all arbiters in this request
         * whenever PortId == INVALID_PORTID, then FpId should be set according to this cmplx in the loop
         * otherwise, FpId should be set to INVALID_FP_ID
         */
        if (portId == INVALID_PORTID)
            fpId = sfMapComplexToSlotFpNum(cmplx)-1; // -1 converts FpNum to FpId
        else
            fpId = INVALID_FP_ID;
        for (arbit = 0; arbit < req->NumEntries; arbit++) {
            req->SapSchedulers[arbit].LocId.Site.FpId = fpId;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
        
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            return FAIL;
        }    
    }

    return SUCCESS;
}

/* Send a ENCAP_GROUP_STATS_READ message for Encap Grps with !qos-per-member */
PUBLIC tStatus smgrSendSapEgrEncapGrpBaseStatsReadMesg(
                tSapEgrEncapGroupRec *pEgrEncapGroupRec,
                tSapRec *pSap, tUint32 MemberId, 
                tEncapGroupStats *pStats,
                tBoolean *pHaveSmgrLock)
{
    tIomEncapGroupStatsRequest *req = NULL;
    tIomEncapGroupStatsResponse *rep = NULL;
    tIomEncapGroupStats *pDst = NULL;
    tIomEncapGroupStats *pSrc = NULL;
    tSvcRec *pSvc = pSap->SvcRec;
    tSMPortInfo SapPortInfo;
    int slotNum = 0;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d MbrId=%u",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEgrEncapGroupRec->Key.Name.name,
                 pEgrEncapGroupRec->GroupId, MemberId);

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap)) 
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_STATS_REQUEST_MSG(1))) == NULL) 
        return FAIL;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    req->Op = IOM_ENCAP_GROUP_STATS_READ;
    req->NumEntries = 1;

    ZERO_STRUCT(req->Entries[0]);

    req->Entries[0].SapId = pSap->SapId;
    req->Entries[0].EncapGroupId = pEgrEncapGroupRec->GroupId;
    req->Entries[0].EncapGroupMember = MemberId;
    req->Entries[0].PortId = INVALID_PORTID;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_ENCAP_GROUP_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_ENCAP_GROUP_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_ENCAP_GROUP_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgEgressStatsTime = rep->Entries[0].Stats.AvgEgressStatsTime;
            
            /* Fill up the stats */                
            pDst = &pStats->IomStats;
            pSrc = &rep->Entries[0].Stats.IomStats;

            pDst->EgressQchipDroppedInProfPackets += pSrc->EgressQchipDroppedInProfPackets;
            pDst->EgressQchipDroppedInProfOctets += pSrc->EgressQchipDroppedInProfOctets;
            pDst->EgressQchipDroppedOutProfPackets += pSrc->EgressQchipDroppedOutProfPackets;
            pDst->EgressQchipDroppedOutProfOctets += pSrc->EgressQchipDroppedOutProfOctets;
            pDst->EgressQchipForwardedInProfPackets += pSrc->EgressQchipForwardedInProfPackets;
            pDst->EgressQchipForwardedInProfOctets += pSrc->EgressQchipForwardedInProfOctets;
            pDst->EgressQchipForwardedOutProfPackets += pSrc->EgressQchipForwardedOutProfPackets;
            pDst->EgressQchipForwardedOutProfOctets += pSrc->EgressQchipForwardedOutProfOctets;
        }

        iccFreeTransaction(pIccTran);
    }

    SMGR_MESG_MEM_FREE(req);

    return SUCCESS;
}

/* Send a ENCAP_GROUP_STATS_RESET message for Encap Grps with !qos-per-member */
PUBLIC tStatus smgrSendSapEgrEncapGrpBaseStatsResetMesg(
                tSapEgrEncapGroupRec *pEgrEncapGroupRec,
                tSapRec *pSap, tUint32 MemberId)
{
    tIomEncapGroupStatsRequest *req = NULL;
    tSvcRec *pSvc = pSap->SvcRec;
    tSMPortInfo SapPortInfo;
    int slotNum = 0;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d MbrId=%u",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEgrEncapGroupRec->Key.Name.name,
                 pEgrEncapGroupRec->GroupId, MemberId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_ENCAP_GROUP_STATS_RESET;
    req->NumEntries = 1;

    ZERO_STRUCT(req->Entries[0]);

    req->Entries[0].SapId = pSap->SapId;
    req->Entries[0].EncapGroupId = pEgrEncapGroupRec->GroupId;
    req->Entries[0].EncapGroupMember = MemberId;
    req->Entries[0].PortId = INVALID_PORTID;

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
         /* Skip IOM's that are off-line or where this
          * SAP is not present.
          */
         if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
             !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
             continue;
    
         if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_ENCAP_GROUP_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
             SMGR_MESG_MEM_FREE(req);
             return FAIL;
         }
       
         /* Fill out ICC transaction */
         pIccTran->Slot = slotNum;
         pIccTran->Socket = ICC_SOCKET_ENCAP_GROUP_STATS; 
         pIccTran->Priority = ICC_HIGHEST_PRIORITY;
         memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
        
         s = iccSendRequestAsyncS(pIccTran, NULL);
        
         /* Check the return code */
         if (s != ICC_ERR_NONE) {
             if (s != ICC_ERR_UNREACHABLE) {
                 SVCMGR_ERROR(NOCLASS,
                              "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                              slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_STATS, s);
             }
             iccFreeTransaction(pIccTran);
             SMGR_MESG_MEM_FREE(req);
             return FAIL;
         }
    }

    SMGR_MESG_MEM_FREE(req);

    return SUCCESS;
}

/* Send a ENCAP_GROUP_QUEUE_STATS_READ msg for Encap Grp with !qos-per-member */
PUBLIC tStatus smgrSendSapEgrEncapGrpQueueStatsReadMesg(
                tSapEgrEncapGroupRec *pEgrEncapGroupRec,
                tSapRec *pSap, tUint32 MemberId, tUint32 QueueId,
                tAccessEgressQosQueueStats *pStats,
                tBoolean *pHaveSmgrLock)
{
    tIomEncapGrpQueueStatsRequest *req = NULL;
    tIomEncapGrpQueueStatsResponse *rep = NULL;
    tIomAccessEgressQosQueueStats *pDst = NULL;
    tIomAccessEgressQosQueueStats *pSrc = NULL;
    tSvcRec *pSvc = pSap->SvcRec;
    tSMPortInfo SapPortInfo;
    int slotNum = 0;
    tIccTransaction *pIccTran;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d MbrId=%u Queue=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEgrEncapGroupRec->Key.Name.name,
                 pEgrEncapGroupRec->GroupId, MemberId, QueueId);

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GRP_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    req->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    req->NumEntries = 1;

    ZERO_STRUCT(req->Queues[0]);

    req->Queues[0].SapId = pSap->SapId;
    req->Queues[0].EncapGroupId = pEgrEncapGroupRec->GroupId;
    req->Queues[0].EncapGroupMember = MemberId;
    req->Queues[0].PortId = INVALID_PORTID;
    req->Queues[0].QosQueueId = QueueId;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_ENCAP_GROUP_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_ENCAP_GRP_QUEUE_STATS_REQUEST_MSG(req->NumEntries);
        pIccTran->RequestFragments[0].Addr = req;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_ENCAP_GROUP_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(req);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (rep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = rep->Stats[0].Stats.Egress.AvgStatsTime;
            
            /* Fill up the stats */                
            pDst = &pStats->IomStats;
            pSrc = &rep->Stats[0].Stats.Egress.IomStats;

            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->InProfilePktsDropped += pSrc->InProfilePktsDropped;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->OutOfProfilePktsDropped += pSrc->OutOfProfilePktsDropped;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->InProfileOctetsDropped += pSrc->InProfileOctetsDropped;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
            pDst->OutOfProfileOctetsDropped += pSrc->OutOfProfileOctetsDropped;

        }

        iccFreeTransaction(pIccTran);
    }

    SMGR_MESG_MEM_FREE(req);

    return SUCCESS;
}

/* Send a ENCAP_GROUP_QUEUE_STATS_RESET message for Encap Grps with !qos-per-member */
PUBLIC tStatus smgrSendSapEgrEncapGrpQueueStatsResetMesg(
                tSapEgrEncapGroupRec *pEgrEncapGroupRec,
                tSapRec *pSap, tUint32 MemberId, tUint32 QueueId)
{
    tIomEncapGrpQueueStatsRequest *req = NULL;
    tSvcRec *pSvc = pSap->SvcRec;
    tSMPortInfo SapPortInfo;
    int slotNum = 0;
    int numEgrQueues;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8 egrStatIdList[MAX_QOS_STAT_COUNTERS_PER_EGRESS_QOS_POLICY];

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d MbrId=%u QueueId=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEgrEncapGroupRec->Key.Name.name,
                 pEgrEncapGroupRec->GroupId, MemberId, QueueId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    numEgrQueues = qosGetEncapGrpStatIdList(pEgrEncapGroupRec, pSap, egrStatIdList);

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_STATS_REQUEST_MSG(SMMaxNumEncapGrpQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;

    req->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    
    numIterations = (numEgrQueues / SMMaxNumEncapGrpQueueStatsEntriesPerMesg) +
                    ((numEgrQueues % SMMaxNumEncapGrpQueueStatsEntriesPerMesg) ? 1 : 0 );
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in egrStatIdList for this iteration */
        iterationIndex = iteration * SMMaxNumEncapGrpQueueStatsEntriesPerMesg;

        req->NumEntries = MIN(numEgrQueues, SMMaxNumEncapGrpQueueStatsEntriesPerMesg);
        numEgrQueues   -= req->NumEntries; /* Tracking remaining queues */

        for (i = 0; i < req->NumEntries; i++) {

             req->Queues[i].SapId = pSap->SapId;
             req->Queues[i].EncapGroupId = pEgrEncapGroupRec->GroupId;
             req->Queues[i].EncapGroupMember = MemberId;
             req->Queues[i].PortId = INVALID_PORTID;
             req->Queues[i].QosQueueId = egrStatIdList[iterationIndex + i];
        }

             for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
                  /* Skip IOM's that are off-line or where this
                   * SAP is not present.
                   */
             if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                 !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
                 continue;

                 smgrSendUnicastIomMesg(ICC_SOCKET_ENCAP_GROUP_QUEUE_STATS, slotNum, req,
                                        SIZE_ENCAP_GROUP_STATS_REQUEST_MSG(req->NumEntries));
    
             }
    }

    SMGR_MESG_MEM_FREE(req);

    return SUCCESS;
}
    
#ifdef MPLS_DEBUG_LABEL_USAGE
/* Trace programming of IOM with labels */
PRIVATE void smgrSdpBindLabelTrace(tSdpBndRec *pSdpBnd, tUint32 ingVcLbl, tUint32 prevIngVcLbl)
{
    e_MplsLmgrLabelState State = e_MPLS_LMGR_LABEL_STATE_ERROR;
    tSdpBndId SdpBndId;

    if (ingVcLbl != PEND_VC_LABEL) {
        if (ingVcLbl != prevIngVcLbl) {
            // ingress vc label state change
            if (VALID_VC_LABEL(ingVcLbl)) {
                State = e_MPLS_LMGR_LABEL_STATE_PROG_IOM;
            } else if ((ingVcLbl != PEND_VC_LABEL) && (prevIngVcLbl != PEND_VC_LABEL)) {
                State = e_MPLS_LMGR_LABEL_STATE_DEPROG_IOM;
                ingVcLbl = prevIngVcLbl;
            }
        }
    }

    if (State == e_MPLS_LMGR_LABEL_STATE_ERROR) {
        return;
    }

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    MPLS_LMGR_SET_HISTORY((e_MPLS_LMGR_LABEL_HIST_SVC_INFO,
                           ingVcLbl,
                           MPLS_LMGR_USER_SVCMGR,
                           State, 1, NULL,
                           (pSdpBnd->SdpRec->FarEndRec ?
                            pSdpBnd->SdpRec->FarEndRec->IpAddress : 0),
                           SdpBndId.SdpId, SdpBndId.VcId, NULL));
}
#endif

/* Send or batch a SDP_BIND message */
PUBLIC tStatus smgrSelectSdpBindMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum,
                                     tBatchProcessing *pBatch, struct SMEventMsg *pCallbackEvent)
{
    tStatus s;

    if (SMGR_BATCH_MESG_ENABLED(pBatch))
        s = smgrBatchSdpBindMesg(pSdpBnd, SlotNum, pCallbackEvent, pBatch);
    else
        s = smgrSendSdpBindMesg(pSdpBnd, SlotNum, pCallbackEvent);
        
    if (s != SUCCESS) {
        tSdpBndId SdpBndId;
        sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
        SVCMGR_ERROR(NOCLASS, "sdpBind msg faild. svc=%d sdp=%s Batch=%d",
                     pSdpBnd->SvcRec->Id, smgrFmtSdpBndIdForDebug(&SdpBndId),
                     SMGR_BATCH_MESG_ENABLED(pBatch));
    }
        
    return s;
}

/* Send a SDP_BIND message */
PUBLIC tStatus smgrSendSdpBindMesg(
    tSdpBndRec *pSdpBnd, 
    tSMSlot SlotNum,
    struct SMEventMsg *pCallbackEvent)
{           
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s;
    tUint32 SlotBitmap = 0;
    
    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotNum);

#ifdef MPLS_DEBUG_LABEL_USAGE
    if (IS_L2_SVC(pSvc) || IS_IES(pSvc) || IS_MIRROR(pSvc) || IS_VPLS_LITE(pSvc)) {
        /* make a record that the IOMs were informed, even if they weren't because they are offline */
        smgrSdpBindLabelTrace(pSdpBnd, pSdpBnd->OperIngressVcLabel,
                              pSdpBnd->PreviousOperIngressVcLabel);

        /* Now reset the previous, so that this label event doesn't get recorded multiple times */
        SBIND_SAVE_OPER_ING_VC_LABEL(pSdpBnd);
    }        
#endif    
    
    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    /* If there are any pending SDP_BIND messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    if (smgrDoFlushSdpBindMesg(TRUE, FALSE, IOM_SVC_BIND, 0) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "Can't pre-flush batched up messages !");
    }
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
        
    /* Now send the SDP_BIND message */
    if ((s = smgrDoBatchSdpBindMesg(pSdpBnd, SlotBitmap, pCallbackEvent,
                                    FALSE)) == SUCCESS) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, IOM_SVC_BIND, 0);
    }
        
    /* End of critical section */
    semGive(SdpBindSemId);

    return s;    
}


/* Batch up a SDP_BIND message */
PUBLIC tStatus smgrBatchSdpBindMesgPriv(tSdpBndRec *pSdpBnd, tUint32 SlotBitmap,
                                        struct SMEventMsg *pCallbackEvent,
                                        tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slotbitmap=0x%08x",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotBitmap);

#ifdef MPLS_DEBUG_LABEL_USAGE
    if (!IsCardOnline && (IS_L2_SVC(pSvc) || IS_IES(pSvc) || IS_MIRROR(pSvc) || IS_VPLS_LITE(pSvc))) {
        /* make a record that the IOMs were informed, even if they weren't because they are offline */
        smgrSdpBindLabelTrace(pSdpBnd, pSdpBnd->OperIngressVcLabel,
                              pSdpBnd->PreviousOperIngressVcLabel);

        /* Now reset the previous, so that this label event doesn't get recorded multiple times */
        SBIND_SAVE_OPER_ING_VC_LABEL(pSdpBnd);
    }
#endif    
        
    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    s = smgrDoBatchSdpBindMesg(pSdpBnd, SlotBitmap, pCallbackEvent, IsCardOnline);
        
    /* End of critical section */
    semGive(SdpBindSemId);
    
    if (pBatch && s == OK)
        pBatch->SdpBndAddSent = TRUE;

    return s;
}


PRIVATE void smgrGetSdpBindDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                        const tSdpBndRec *pSdpBnd,
                                        tUint32 IomOp,
                                        tUint32 SlotBitmap,
                                        tBoolean IsCardOnline,
                                        tBoolean UseChmgrBitmap)
{
    if (pSdpBnd && pSdpBnd->DoNotDownload) {
        pIccInfo->IomBitMask = 0;
        return;
    }
    
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SdpBind,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          UseChmgrBitmap,
                          smgrMesgSdpBindCmp,
                          pSdpBnd);
}

/* Batch up a SDP_BIND message. This private function assumes
 * the caller has locked the SdpBindSemId.
 */
PRIVATE tStatus smgrDoBatchSdpBindMesg(tSdpBndRec *pSdpBnd,  tUint32 SlotBitmap,
                                       struct SMEventMsg *pCallbackEvent,
                                       tBoolean IsCardOnline)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tUint32 Op = IOM_SVC_BIND;
    tUint8 IomFwdState;
    tBoolean UpdtFwdState;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tBoolean MemAllocated = FALSE;
    
    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slotbitmap=0x%08x",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotBitmap);
                 
    if (IS_INT_EP_REQUIRED(pSvc)) {
        if (! pSdpBnd->SdpEpObj || ! pSdpBnd->SdpEpObj->EpRec) {
            SVCMGR_ERROR(NOCLASS, "no endpoint record. sdp=%s", smgrFmtSdpBndIdForDebug(&SdpBndId));
            s = FAIL;
            goto Done;
        }
    } else if (IS_TLS(pSvc)) {
        if (pSdpBnd->Type == VAL_sdpBindType_spoke && ! pSdpBnd->SdpEpObj) {
            SVCMGR_ERROR(NOCLASS, "no SdpEpObj record. sdp=%s", smgrFmtSdpBndIdForDebug(&SdpBndId));
            s = FAIL;
            goto Done;
        }
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSdpBindDownloadInfo(&IccInfo, pSdpBnd, Op,
                               SlotBitmap, IsCardOnline, FALSE);
    if (IccInfo.IomBitMask == 0) {
        /* No need to send to the IOM, but update the IOM state for downstream
         * clients so they are notified if the status has changed.
         */
        if (IS_PE_EP_SPOKE(pSdpBnd) && ! pSdpBnd->SdpEpObj->TxActive) {
            sdpBindSetBlockTxState(pSdpBnd, TRUE, NULL);
        } else if (pSdpBnd->BlockTxOnPeerFault && ! pSdpBnd->SdpEpObj->TxActive) {
            sdpBindSetBlockTxState(pSdpBnd, TRUE, NULL);
        } else {
            sdpBindSetBlockTxState(pSdpBnd, FALSE, NULL);
        }
        s = SUCCESS;
        goto Done;
    }

    /* Check if flushing of queued msgs is needed */
    smgrDoFlushSdpBindMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);
     
    if (!pSdpBindReqMesg) {
        MemAllocated = TRUE;
        
        /* Alloc max message size */
        pSdpBindReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_BIND_REQUEST_MSG(SMMaxNumSdpBindEntriesPerMesg));
        if (!pSdpBindReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSdpBindReqMesg->NumEntries = 0;
        
        if (runtime_feature_smgr_buffered_download) {
            pSdpBindDndlerCbEvtMsgs
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSdpBindDndlerCbEvtMsgs), SMMaxNumSdpBindEntriesPerMesg);
            if (pSdpBindDndlerCbEvtMsgs == NULL) {
                s = FAIL;
                goto Done;
            }
        }
        
    }
     
    /* Set the bit mask */
    PrevSdpBindIomBitMask = IccInfo.IomBitMask;
    
    if (pSdpBindDndlerCbEvtMsgs) {
        pDndlerCbEvtMsgs = &(pSdpBindDndlerCbEvtMsgs[pSdpBindReqMesg->NumEntries]);
        if (smgrSapBindAddDndlerCallbacks(FALSE, NULL, &SdpBndId, pSdpBnd->InstanceId,
                                          (pCallbackEvent)? TRUE : FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            s = FAIL;
            goto Done;
        }
    }
        
    if (SlotBitmap == ALL_APPLICABLE_IOMS) {
        UpdtFwdState = TRUE;
    } else {
        tUint32 OnlineIoms = smgrMsgrGetFullyOnlineIoms(pSmgrIccMsgr);
        if (IsCardOnline) {
            OnlineIoms = BITUTILS_BIT_UNION(OnlineIoms, SlotBitmap);
        }
        UpdtFwdState = (OnlineIoms == IccInfo.IomBitMask) ? TRUE : FALSE;
    }

    IomFwdState = sdpBindGetFwdPortState(pSdpBnd);
    if (UpdtFwdState){
        sdpBindSetFwdState(pSdpBnd, IomFwdState, pDndlerCbEvtMsgs);
    }

    pSdpBindReqMesg->Op = Op;
    smgrInitSdpBindReqEntry(&pSdpBindReqMesg->u.Entries[pSdpBindReqMesg->NumEntries], 
                            pSdpBnd, IomFwdState, pCallbackEvent, pDndlerCbEvtMsgs);

    if (pSdpBnd->BlkDnldToIom) {
        SdpBindDnldBlockType = SMGR_DNDLER_BLOCK;
        pSdpBnd->BlkDnldToIom = FALSE;
    }

    pSdpBindReqShadow[pSdpBindReqMesg->NumEntries] = pSdpBnd;
    // Save the first batched ICC msg's time
    if (pSdpBindReqMesg->NumEntries == 0)
        FirstSbindBatchTime = vxTicks;
    pSdpBindReqMesg->NumEntries++;
    
    /* If we reached the limit, flush the message */
    if (pSdpBindReqMesg->NumEntries >= SMMaxNumSdpBindEntriesPerMesg) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, pSdpBindReqMesg->Op, IccInfo.IomBitMask);
    }

    return s;

  Done:
    if (s != SUCCESS ||
        IccInfo.IomBitMask == 0) {
        sdpBindSetFwdState(pSdpBnd, SAP_SDP_STATE_UNKNOWN, NULL);
    }
  
    if (pDndlerCbEvtMsgs)
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);
  
    if (pCallbackEvent)
        smgrIccCleanup(pCallbackEvent);
        
    if (MemAllocated) {
        if (pSdpBindReqMesg) {
            SMGR_MESG_MEM_FREE(pSdpBindReqMesg);
            pSdpBindReqMesg = NULL;
        }
        
        if (pSdpBindDndlerCbEvtMsgs) {
            SMGR_MESG_MEM_FREE(pSdpBindDndlerCbEvtMsgs);
            pSdpBindDndlerCbEvtMsgs = NULL;
        }
    }
    return s;
}


/* Flush batched up SDP_BIND messages */
PUBLIC tStatus smgrFlushSdpBindMesg(void)
{
    tStatus s;
    
    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);
    
    s =  smgrDoFlushSdpBindMesg(FALSE, FALSE, IOM_SVC_BIND, 0);
    
    /* End of critical section */
    semGive(SdpBindSemId);

    return s;
}


/* Cleanup after delivered SDP BIND messages to the IOM Async */
PUBLIC void smgrIccCleanSendSdpBind(void *pIccMsg, void *pUserData)
{
    tUint32 i;
    tUint32 nCb = 0;
    tIomSvcBindRequest *pSdpMsg = (tIomSvcBindRequest *)pIccMsg;

    switch(pSdpMsg->Op) {
    case IOM_SVC_BIND:
        for (i = 0; i < pSdpMsg->NumEntries; i++) {
            if (pSdpMsg->u.Entries[i].handle.Cpm) {
                smgrIccCleanup(pSdpMsg->u.Entries[i].handle.Cpm);
                nCb++;
            }
        }
        break;
    case IOM_SVC_BIND_STATE:
        for (i = 0; i < pSdpMsg->NumEntries; i++) {
            if (pSdpMsg->u.States[i].handle.Cpm) {
                smgrIccCleanup(pSdpMsg->u.States[i].handle.Cpm);
                nCb++;
            }
        }
    case IOM_SVC_UNBIND:
    case IOM_SVC_BIND_SWITCH:
    case IOM_SVC_BIND_AUDIT:
    case IOM_SVC_BIND_MCLISTPRUNE:
    case IOM_SVC_BIND_MAC_LPBK:
    default:
        ;
    }

    SVCMGR_EVENT(IOM_CALL, "entries=%u op=%u #cb=%u",
                 pSdpMsg->NumEntries, pSdpMsg->Op, nCb);    
    SMGR_MESG_MEM_FREE(pIccMsg);                        
}


/* Flush batched up SDP_BIND messages. This private function assumes
 * the caller has locked the SdpBindSem.
 */
PRIVATE tStatus smgrDoFlushSdpBindMesg(tBoolean     preFlush, 
                                       tBoolean     IfNeeded,
                                       eSdpBindOp   msgType,       // only IfNeeded 
                                       tUint32      newIomBitMask) // only IfNeeded
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 NumEntries;
    tStatus s = SUCCESS;
    tUint32 size;
    eSdpBindOp Op;

    if (!pSdpBindReqMesg || (pSdpBindReqMesg->NumEntries == 0))
        return SUCCESS;

    if (IfNeeded) {
        /* A flush of the previous batch is needed if:
         *   - IOM bitmap is not the same
         *   - msg type is not the same
         */
        if ((PrevSdpBindIomBitMask == newIomBitMask) && (msgType == pSdpBindReqMesg->Op))
            return SUCCESS;  // no need to flush
    }
    
    Op = pSdpBindReqMesg->Op;
    NumEntries = pSdpBindReqMesg->NumEntries;
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SdpBind, Op);
    
    SVCMGR_EVENT(IOM_CALL, "SDP_BIND entries=%u mask=%08x preFlush=%d IfNeeded=%d msgType=%d", 
                 NumEntries, PrevSdpBindIomBitMask, preFlush, IfNeeded, msgType);

    switch (pSdpBindReqMesg->Op) {
        case IOM_SVC_BIND:
            size = SIZE_SVC_BIND_REQUEST_MSG(NumEntries);
            break;
        case IOM_SVC_BIND_SWITCH:
            size = SIZE_SVC_BIND_SWITCH_REQUEST_MSG(NumEntries);
            break;
        case IOM_SVC_BIND_STATE:
            size = SIZE_SVC_BIND_STATE_MSG(NumEntries);
            break;
        case IOM_SVC_BIND_MCLISTPRUNE:
            size = SIZE_SVC_BIND_MCLISTPRUNE_MSG(NumEntries);
            break;
        case IOM_SVC_UNBIND:
        case IOM_SVC_BIND_AUDIT:
        case IOM_SVC_BIND_MAC_LPBK:
        default:
            SVCMGR_ERROR(NOCLASS, "Bad opcode %u", pSdpBindReqMesg->Op);
            return FAIL;
    }
        
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pSdpBindReqMesg, preFlush);
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSdpBindReqMesg->Op,
                                      PrevSdpBindIomBitMask, pSdpBindReqMesg, size,
                                      pSdpBindDndlerCbEvtMsgs, SdpBindDnldBlockType,
                                      NULL, SMIccCleanSemId,
                                      pSdpBindReqMesg->Op == IOM_SVC_BIND_STATE,
                                      pSdpBindReqMesg->Op != IOM_SVC_BIND_STATE,
                                      smgrIccCleanSendSdpBind);
    if (s != SUCCESS) {
        tSdpBndRec *pSdpBnd;
        int         i;
        tSapBindInstId GlobalInstanceId = SMGR_NULL_SDPBND_INST_ID;
        void       *CpmHandle = NULL;

        for(i=0; i<NumEntries; i++) {
            switch (pSdpBindReqMesg->Op) {
                case IOM_SVC_BIND:
                    GlobalInstanceId = pSdpBindReqMesg->u.Entries[i].GlobalInstanceId;
                    CpmHandle = pSdpBindReqMesg->u.Entries[i].handle.Cpm;
                    break;
                case IOM_SVC_BIND_SWITCH:
                    GlobalInstanceId = pSdpBindReqMesg->u.Switch[i].GlobalInstanceId;
                    CpmHandle = NULL;
                    break;
                case IOM_SVC_BIND_STATE:
                    GlobalInstanceId = pSdpBindReqMesg->u.States[i].GlobalInstanceId;
                    CpmHandle = pSdpBindReqMesg->u.States[i].handle.Cpm;
                    /* For state msgs an error will be returned if the iom becomes
                     * unavailable on the moment the update is sent.
                     * The calling procs will report and error if we return fail.
                     * Therefore, return success.
                     */
                    s = SUCCESS;
                    break;
                case IOM_SVC_BIND_MCLISTPRUNE:
                    GlobalInstanceId = pSdpBindReqMesg->u.McListPrune[i].GlobalInstanceId;
                    CpmHandle = pSdpBindReqMesg->u.McListPrune[i].handle.Cpm;
                    break;
                case IOM_SVC_UNBIND:
                case IOM_SVC_BIND_AUDIT:
                case IOM_SVC_BIND_MAC_LPBK:
                default:
                    CpmHandle = NULL;
                    break;
            }
            pSdpBnd = pSdpBindReqShadow[i];
            if (pSdpBnd &&
                (pSdpBnd->InstanceId == GlobalInstanceId)) {
                sdpBindSetFwdState(pSdpBnd, SAP_SDP_STATE_UNKNOWN, NULL);
            }
            if (CpmHandle) {
                smgrIccCleanup(CpmHandle);
            }
            if (pSdpBindDndlerCbEvtMsgs)
                smgrSapBindFreeDndlerCallbacks(&pSdpBindDndlerCbEvtMsgs[i]);
        }
        SVCMGR_EVENT(NOCLASS, "smgrSendClientCustomMsgToIoms failed for mask=%08x !", 
                        PrevSdpBindIomBitMask);
        
        SMGR_MESG_MEM_FREE(pSdpBindReqMesg);  
        
        if (pSdpBindDndlerCbEvtMsgs)
            SMGR_MESG_MEM_FREE(pSdpBindDndlerCbEvtMsgs);
    } else {
        typeof(vxTicks) ThisBatchWaitTime;

        if (Op == IOM_SVC_BIND) {
            /* Save the max wait time an ICC msg was batched for */
            ThisBatchWaitTime = vxTicks - FirstSbindBatchTime;
            if (ThisBatchWaitTime > MaxSbindBatchWaitTime)
                MaxSbindBatchWaitTime = ThisBatchWaitTime;
        }
    }
        
    /* Start a new batch */
    pSdpBindReqMesg = NULL;    
    pSdpBindDndlerCbEvtMsgs = NULL;        
        
    PrevSdpBindIomBitMask = 0;
    SdpBindDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
        
    return s;
}

/* Batch up a SDP_BIND_STATE message. This private function assumes
 * the caller has locked the SdpBindSemId.
 */
PRIVATE tStatus smgrDoBatchSdpBindStateMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum,
                                            tBoolean UseChmgrBitmap,
                                            struct SMEventMsg *pCallbackEvent)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tUint32 Op = IOM_SVC_BIND_STATE;    
    tUint8 IomFwdState;
    tUint8 LastIomFwdState;
    tBoolean UpdtFwdState;
    tUint32 SlotBitmap = 0;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tBoolean MemAllocated = FALSE;
    
    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SlotNum);
                 
    if (!IS_TLS(pSvc)) {
        SVCMGR_ERROR(NOCLASS, "State update only allowed for TLS. sdp=%s", smgrFmtSdpBndIdForDebug(&SdpBndId));
        s = FAIL;
        goto Done;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSdpBindDownloadInfo(&IccInfo, pSdpBnd, Op,
                               SlotBitmap, FALSE, UseChmgrBitmap);
    
    if (IccInfo.IomBitMask == 0) {
        /* No need to send to the IOM, but update the IOM state for downstream
         * clients so they are notified if the status has changed.
         */
        if (IS_PE_EP_SPOKE(pSdpBnd) && ! pSdpBnd->SdpEpObj->TxActive) {
            sdpBindSetBlockTxState(pSdpBnd, TRUE, NULL);
        } else if (pSdpBnd->BlockTxOnPeerFault && ! pSdpBnd->SdpEpObj->TxActive) {
            sdpBindSetBlockTxState(pSdpBnd, TRUE, NULL);
        } else {
            sdpBindSetBlockTxState(pSdpBnd, FALSE, NULL);
        }
        s = SUCCESS;
        goto Done;
    } 
    
    if (SlotNum == ALL_APPLICABLE_IOMS) {
        UpdtFwdState = TRUE;
    } else {
        tUint32 OnlineIoms = smgrMsgrGetFullyOnlineIoms(pSmgrIccMsgr);        
        UpdtFwdState = (OnlineIoms == IccInfo.IomBitMask) ? TRUE : FALSE;
    }

    LastIomFwdState = pSdpBnd->ActualFwdState;

    /* Check if flushing of queued msgs is needed */
    smgrDoFlushSdpBindMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);
     
    if (!pSdpBindReqMesg) {
        MemAllocated = TRUE;
            
        /* Alloc max message size */
        pSdpBindReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_BIND_STATE_MSG(SMMaxNumSdpBindStateEntriesPerMesg));
        if (!pSdpBindReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSdpBindReqMesg->NumEntries = 0;
        
        if (runtime_feature_smgr_buffered_download) {
            pSdpBindDndlerCbEvtMsgs 
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSdpBindDndlerCbEvtMsgs), SMMaxNumSdpBindStateEntriesPerMesg);
            if (pSdpBindDndlerCbEvtMsgs == NULL) {
                s = FAIL;
                goto Done;
            }
        }
    }
     
    /* Set the bit mask */
    PrevSdpBindIomBitMask = IccInfo.IomBitMask;
    
    if (pSdpBindDndlerCbEvtMsgs) {
        pDndlerCbEvtMsgs = &(pSdpBindDndlerCbEvtMsgs[pSdpBindReqMesg->NumEntries]);
        if (smgrSapBindAddDndlerCallbacks(FALSE, NULL, &SdpBndId, pSdpBnd->InstanceId,
                                          (pCallbackEvent)? TRUE : FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            s = FAIL;
            goto Done;
        }
    }
    
    IomFwdState = sdpBindGetFwdPortState(pSdpBnd);
    if (UpdtFwdState) {
        sdpBindSetFwdState(pSdpBnd, IomFwdState, pDndlerCbEvtMsgs);
    }
    /* If there is no change in the SDP BIND's IOM fwd state, do not download.
     * Note that this suppression is done only in this routine where only
     * SDP BIND state would have been downloaded */
    if (!pCallbackEvent) { /* If there is a CallbackEvent, send to the IOM even if there is no change */
        if (LastIomFwdState == IomFwdState) {
            /* Since we are skipping the download, we need to run the Dndler callbacks */
            smgrDndlerSapBindCallback(pDndlerCbEvtMsgs);

            SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%s: SdpBind's IOM fwd state did not change. Skipping download",
                         pSvc->Id, smgrFmtSdpBndIdForDebug(&SdpBndId));
            s = SUCCESS;
            goto Done;
        }
    }
    
    pSdpBindReqMesg->Op = Op;

    smgrInitSdpBindStateEntry(&pSdpBindReqMesg->u.States[pSdpBindReqMesg->NumEntries], 
                              pSdpBnd, IomFwdState, pCallbackEvent);
    pSdpBindReqShadow[pSdpBindReqMesg->NumEntries] = pSdpBnd;
    pSdpBindReqMesg->NumEntries++;
 
    /* If we reached the limit, flush the message */
    if (pSdpBindReqMesg->NumEntries >= SMMaxNumSdpBindStateEntriesPerMesg) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, pSdpBindReqMesg->Op, IccInfo.IomBitMask);
    }

    return s;

  Done:
    if (s != SUCCESS ||
        IccInfo.IomBitMask == 0) {
        sdpBindSetFwdState(pSdpBnd, SAP_SDP_STATE_UNKNOWN, NULL);
    }
    
    if (pDndlerCbEvtMsgs)
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);
    
    if (pCallbackEvent)
        smgrIccCleanup(pCallbackEvent);
        
    if (MemAllocated) {
        if (pSdpBindReqMesg) {
            SMGR_MESG_MEM_FREE(pSdpBindReqMesg);
            pSdpBindReqMesg = NULL;
        }
        
        if (pSdpBindDndlerCbEvtMsgs) {
            SMGR_MESG_MEM_FREE(pSdpBindDndlerCbEvtMsgs);
            pSdpBindDndlerCbEvtMsgs = NULL;
        }
    }
        
    return s;
}

/* Batch up a SDP_BIND_STATE message */
PUBLIC tStatus smgrBatchSdpBindStateMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum,
                                         tBoolean UseChmgrBitmap, tBatchProcessing *pBatch,
                                         struct SMEventMsg *pCallbackEvent)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotNum);
                 
    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    s = smgrDoBatchSdpBindStateMesg(pSdpBnd, SlotNum, UseChmgrBitmap, pCallbackEvent);
        
    /* End of critical section */
    semGive(SdpBindSemId);

    if (pBatch && s == OK)
        pBatch->SdpBndStateSent = TRUE;

    return s;
}

/* Send a SDP_BIND_STATE message */
PUBLIC tStatus smgrSendSdpBindStateMesg(
    tSdpBndRec *pSdpBnd, 
    tSMSlot SlotNum,
    tBoolean UseChmgrBitmap,
    struct SMEventMsg *pCallbackEvent)
{           
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SlotNum);

    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    /* If there are any pending SDP_BIND or SDP_BIND_STATE messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    if (smgrDoFlushSdpBindMesg(TRUE, FALSE, IOM_SVC_BIND_STATE, 0) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "Can't pre-flush batched up messages !");
    }
    
    /* Now send the SDP_BIND message */
    if ((s = smgrDoBatchSdpBindStateMesg(pSdpBnd, SlotNum,
                                         UseChmgrBitmap, pCallbackEvent)) == SUCCESS) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, IOM_SVC_BIND_STATE, 0);
    }
        
    /* End of critical section */
    semGive(SdpBindSemId);

    return s;    
}

/* Batch up a SDP_BIND_MCLISTPRUNE message. This private function assumes
 * the caller has locked the SdpBindSemId.
 */
PRIVATE tStatus smgrDoBatchSdpBindTlsPruneMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tUint32 Op = IOM_SVC_BIND_MCLISTPRUNE;    
    tUint32 SlotBitmap = 0;
    
    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SlotNum);
                 
    if (!IS_TLS(pSvc)) {
        SVCMGR_ERROR(NOCLASS, "TlsPrune only allowed for TLS. sdp=%s", smgrFmtSdpBndIdForDebug(&SdpBndId));
        s = FAIL;
        goto Done;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSdpBindDownloadInfo(&IccInfo, pSdpBnd, Op,
                               SlotBitmap, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        s = SUCCESS;
        goto Done;
    } 
    
    /* Check if flushing of queued msgs is needed */
    smgrDoFlushSdpBindMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);
     
    if (!pSdpBindReqMesg) {
        /* Alloc max message size */
        pSdpBindReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_BIND_MCLISTPRUNE_MSG(SMMaxNumSdpBindStateEntriesPerMesg));
        if (!pSdpBindReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSdpBindReqMesg->NumEntries = 0;
    }
     
    /* Set the bit mask */
    PrevSdpBindIomBitMask = IccInfo.IomBitMask;
    
    pSdpBindReqMesg->Op = Op;

    smgrInitSdpBindMcListPruneEntry(&pSdpBindReqMesg->u.McListPrune[pSdpBindReqMesg->NumEntries], 
                                    pSdpBnd);
    pSdpBindReqShadow[pSdpBindReqMesg->NumEntries] = pSdpBnd;
    pSdpBindReqMesg->NumEntries++;
 
    /* If we reached the limit, flush the message */
    if (pSdpBindReqMesg->NumEntries >= SMMaxNumSdpBindStateEntriesPerMesg) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, pSdpBindReqMesg->Op, IccInfo.IomBitMask);
    }
  Done:
    return s;
}

/* Batch up a SDP_BIND_MCLISTPRUNE message */
PUBLIC tStatus smgrBatchSdpBindTlsPruneMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum,
                                            tBatchProcessing *pBatch)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SlotNum);
                 
    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    s = smgrDoBatchSdpBindTlsPruneMesg(pSdpBnd, SlotNum);
        
    /* End of critical section */
    semGive(SdpBindSemId);

    if (pBatch && s == OK)
        pBatch->SdpBndStateSent = TRUE;

    return s;
}

/* Send a SDP_BIND_MCLISTPRUNE message */
PUBLIC tStatus smgrSendSdpBindTlsPruneMesg(tSdpBndRec *pSdpBnd, 
                                           tSMSlot SlotNum)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SlotNum);

    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    /* If there are any pending SDP_BIND or SDP_BIND_STATE messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    if (smgrDoFlushSdpBindMesg(TRUE, FALSE, IOM_SVC_BIND_MCLISTPRUNE, 0) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "Can't pre-flush batched up messages !");
    }
    
    /* Now send the SDP_BIND message */
    if ((s = smgrDoBatchSdpBindTlsPruneMesg(pSdpBnd, SlotNum)) == SUCCESS) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, IOM_SVC_BIND_MCLISTPRUNE, 0);
    }
        
    /* End of critical section */
    semGive(SdpBindSemId);

    return s;    
}

/* Send or batch a sdp-bind switch msg */
PUBLIC tStatus smgrSelectSdpBindSwitchMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum,
                                           tBatchProcessing *pBatch)
{
    tStatus rc;
    
    if (SMGR_BATCH_MESG_ENABLED(pBatch)) {
        rc = smgrBatchSdpBindSwitchMesg(pSdpBnd, ALL_APPLICABLE_IOMS, pBatch);
    } else {
        rc = smgrSendSdpBindSwitchMesg(pSdpBnd, ALL_APPLICABLE_IOMS);
    }
    if (rc != SUCCESS) {
        tSdpBndId SdpBndId;
        sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
        SVCMGR_ERROR(NOCLASS, "SdpBindSwitch msg faild. svc=%d sdp=%s Batch=%d",
                     pSdpBnd->SvcRec->Id, smgrFmtSdpBndIdForDebug(&SdpBndId),
                     SMGR_BATCH_MESG_ENABLED(pBatch));
    }
    return rc;
}

/* Send a SDP_BIND_SWITCH message */
PUBLIC tStatus smgrSendSdpBindSwitchMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum)
{           
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s = SUCCESS;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotNum);
                 
#ifdef MPLS_DEBUG_LABEL_USAGE
    /* make a record that the IOMs were informed, even if they weren't because they are offline */
    smgrSdpBindLabelTrace(pSdpBnd, pSdpBnd->OperIngressVcLabel,
                          pSdpBnd->PreviousOperIngressVcLabel);

    /* Now reset the previous, so that this label event doesn't get recorded multiple times */
    SBIND_SAVE_OPER_ING_VC_LABEL(pSdpBnd);
#endif    
    
    /* Serialize access to shared state data */
    semTake(SdpBindSemId, WAIT_FOREVER);

    /* If there are any pending SDP_BIND_SWITCH messages batched 
     * up (by some other task running concurrently with us)
     * then pre-flush them now to preserve the relative 
     * time ordering of messages.
     */
    if (smgrDoFlushSdpBindMesg(TRUE, FALSE, IOM_SVC_BIND_SWITCH, 0) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "Can't pre-flush batched up messages !");
    }
    
    /* Now send the SDP_BIND_SWITCH message */
    if ((s = smgrDoBatchSdpBindSwitchMesg(pSdpBnd, SlotNum)) == SUCCESS) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, IOM_SVC_BIND_SWITCH, 0);
    }
    
    semGive(SdpBindSemId);

    return s;    
}


/* Batch up a IOM_SVC_BIND_SWITCH message */
PUBLIC tStatus smgrBatchSdpBindSwitchMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum, 
                                          tBatchProcessing *pBatch)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tStatus s = SUCCESS;

    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotNum);
                 
    semTake(SdpBindSemId, WAIT_FOREVER);

    s = smgrDoBatchSdpBindSwitchMesg(pSdpBnd, SlotNum);
    
    semGive(SdpBindSemId);
    
    if (pBatch && s == OK)
        pBatch->SdpBndSwitchSent = TRUE;

    return s;
}

/* Batch up a IOM_SVC_BIND_SWITCH message.
 * Assume the caller has locked the SdpBindSemId.
 */
PRIVATE tStatus smgrDoBatchSdpBindSwitchMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum)
{
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tUint32 Op = IOM_SVC_BIND_SWITCH;
    tUint32 SlotBitmap = 0;
    tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs = NULL;
    tBoolean MemAllocated = FALSE;
        
    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u admin=%s oper=%s ingLbl=%u egrLbl=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId, pSdpBnd->InstanceId,
                 SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus],
                 pSdpBnd->OperIngressVcLabel,
                 pSdpBnd->OperEgressVcLabel,
                 SlotNum);
                 
    if (IS_INT_EP_REQUIRED(pSvc)) {
        if (! pSdpBnd->SdpEpObj || ! pSdpBnd->SdpEpObj->EpRec) {
            SVCMGR_ERROR(NOCLASS, "no endpoint record. sdp=%s", smgrFmtSdpBndIdForDebug(&SdpBndId));
            return FAIL;
        }
    } else if (IS_TLS(pSvc)) {
        if (pSdpBnd->Type == VAL_sdpBindType_spoke && ! pSdpBnd->SdpEpObj) {
            SVCMGR_ERROR(NOCLASS, "no SdpEpObj record. sdp=%s", smgrFmtSdpBndIdForDebug(&SdpBndId));
            return FAIL;
        }
    } else
        return FAIL;
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSdpBindDownloadInfo(&IccInfo, pSdpBnd, Op,
                               SlotBitmap, FALSE, FALSE);
    if (IccInfo.IomBitMask == 0) {
        /* No need to send to the IOM, but update the IOM state for downstream
         * clients so they are notified if the status has changed.
         */
        if (IS_PE_EP_SPOKE(pSdpBnd) && ! pSdpBnd->SdpEpObj->TxActive) {
            sdpBindSetBlockTxState(pSdpBnd, TRUE, NULL);
        } else if (pSdpBnd->BlockTxOnPeerFault && ! pSdpBnd->SdpEpObj->TxActive) {
            sdpBindSetBlockTxState(pSdpBnd, TRUE, NULL);
        } else {
            sdpBindSetBlockTxState(pSdpBnd, FALSE, NULL);
        }
        s = SUCCESS;
        goto Done;
    }
        
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
     
    /* Check if flushing of queued sdp-bind msgs is needed */
    smgrDoFlushSdpBindMesg(FALSE, TRUE, Op, IccInfo.IomBitMask);
    
    if (!pSdpBindReqMesg) {
        MemAllocated = TRUE;
        
        /* Alloc max message size */
        pSdpBindReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_BIND_SWITCH_REQUEST_MSG(SMMaxNumSdpBindSwitchEntriesPerMesg));
        if (!pSdpBindReqMesg) {
            s = FAIL;
            goto Done;
        }
        pSdpBindReqMesg->NumEntries = 0;
        
        if (runtime_feature_smgr_buffered_download) {
            pSdpBindDndlerCbEvtMsgs
                = SMGR_MESG_MEM_CALLOC(sizeof(*pSdpBindDndlerCbEvtMsgs), SMMaxNumSdpBindSwitchEntriesPerMesg);
            if (pSdpBindDndlerCbEvtMsgs == NULL) {
                s = FAIL;
                goto Done;
            }
        }
    }
     
    /* Set the bit mask */
    PrevSdpBindIomBitMask = IccInfo.IomBitMask;
    
    if (pSdpBindDndlerCbEvtMsgs) {
        pDndlerCbEvtMsgs = &(pSdpBindDndlerCbEvtMsgs[pSdpBindReqMesg->NumEntries]);
        if (smgrSapBindAddDndlerCallbacks(FALSE, NULL, &SdpBndId, pSdpBnd->InstanceId, FALSE,
                                          pDndlerCbEvtMsgs) != SUCCESS) {
            SVCMGR_EVENT(NOCLASS, "Unable to get memory for message event");
            s = FAIL;
            goto Done;
        }
    }
    
    pSdpBindReqMesg->Op = IOM_SVC_BIND_SWITCH;
    smgrInitSdpBindSwitchReqEntry(&pSdpBindReqMesg->u.Switch[pSdpBindReqMesg->NumEntries],
                                  pSdpBnd, pDndlerCbEvtMsgs);
    pSdpBindReqShadow[pSdpBindReqMesg->NumEntries] = pSdpBnd;
    pSdpBindReqMesg->NumEntries++;

    /* If we reached the limit, flush the message */
    if (pSdpBindReqMesg->NumEntries == SMMaxNumSdpBindSwitchEntriesPerMesg) {
        s = smgrDoFlushSdpBindMesg(FALSE, FALSE, Op, IccInfo.IomBitMask);
    } 

    return s;

  Done:
    if (s != SUCCESS ||
        IccInfo.IomBitMask == 0) {
        sdpBindSetFwdState(pSdpBnd, SAP_SDP_STATE_UNKNOWN, NULL);
    }
    
    if (pDndlerCbEvtMsgs)
        smgrSapBindFreeDndlerCallbacks(pDndlerCbEvtMsgs);

    if (MemAllocated) {
        if (pSdpBindReqMesg) {
            SMGR_MESG_MEM_FREE(pSdpBindReqMesg);
            pSdpBindReqMesg = NULL;
        }
        
        if (pSdpBindDndlerCbEvtMsgs) {
            SMGR_MESG_MEM_FREE(pSdpBindDndlerCbEvtMsgs);
            pSdpBindDndlerCbEvtMsgs = NULL;
        }
    }
    
    return s;
}


/* Flush batched up SDP_SWITCH messages */
PUBLIC tStatus smgrFlushSdpBindSwitchMesg(void)
{
    tStatus s;
    
    semTake(SdpBindSemId, WAIT_FOREVER);
    
    s =  smgrDoFlushSdpBindMesg(FALSE, FALSE, IOM_SVC_BIND_SWITCH, 0);
    
    semGive(SdpBindSemId);

    return s;
}

/* Send a SDP_UNBIND message */
PUBLIC tStatus smgrSendSdpUnbindMesg(tSdpBndRec *pSdpBnd, tSMSlot SlotNum)
{           
    tSdpBndId SdpBndId;
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tIomSvcBindRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 Op = IOM_SVC_UNBIND;
    tUint32 SlotBitmap = 0;
    tSmgrDndlerBlockType BlockType = SMGR_DNDLER_BLOCK;
    
    sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u inst=%u slot=%d",
                 pSvc->Id, SdpBndId.SdpId, SdpBndId.VcId,
                 pSdpBnd->InstanceId, SlotNum);

    if (SDPBND_IS_ORIGIN_BGP_L2VPN_AUTO_BIND(pSdpBnd->CreationOrigin) &&
        ! pSdpBnd->BlkDnldToIom) {
        /* BGP AD/VPLS created bindings do not have dependencies with other non-SMGR sockets */ 
        BlockType = SMGR_DNDLER_MAY_BLOCK;
    }
    
#ifdef MPLS_DEBUG_LABEL_USAGE
    if (IS_L2_SVC(pSvc) || IS_IES(pSvc) || IS_MIRROR(pSvc) || IS_VPLS_LITE(pSvc)) {
        /* make a record that the IOMs were informed, even if they weren't because they are offline */
        if (MplsLmgrDebugLabels == 1)
            smgrSdpBindLabelTrace(pSdpBnd, NULL_VC_LABEL, pSdpBnd->OperIngressVcLabel);
    }
#endif    

    sdpBindSetFwdState(pSdpBnd, SAP_SDP_STATE_UNKNOWN, NULL);
                
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);

    smgrGetSdpBindDownloadInfo(&IccInfo, pSdpBnd, Op,
                               SlotBitmap, FALSE, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((pMsg = SMGR_MESG_MEM_CALLOC(1, SIZE_SVC_BIND_REQUEST_MSG(1))) == NULL) 
        return FAIL;

    pMsg->Op = Op;
    pMsg->NumEntries = 1;
    pMsg->u.Entries[0].SdpId = SdpBndId.SdpId;
    pMsg->u.Entries[0].SvcId = pSvc->Id;
    pMsg->u.Entries[0].GlobalInstanceId = pSdpBnd->InstanceId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op,
                                IccInfo.IomBitMask, pMsg,
                                SIZE_SVC_BIND_REQUEST_MSG(pMsg->NumEntries),
                                NULL, BlockType);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);
    }

    smgrFreeClientMsg(pMsg, s);
    
    pSdpBnd->BlkDnldToIom = FALSE;

    return s;
}

/* Send a SDP_BIND_AUDIT message */
PUBLIC tStatus smgrSendSdpBindAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSvcBindRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "SDP BIND AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */ 
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSdpBindDownloadInfo(&IccInfo, NULL, IOM_SVC_BIND_AUDIT,
                               SlotBitmap, FALSE, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;    

    if ((pMsg = SMGR_MESG_MEM_CALLOC(1, SIZE_SVC_BIND_AUDIT_REQUEST_MSG())) == NULL) {
        SVCMGR_EVENT(NOCLASS, "Unable to obtain memory for SDP binding audit msg"); 
        return FAIL;
    }

    pMsg->Op = IOM_SVC_BIND_AUDIT;
    pMsg->NumEntries = 0;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op,
                                IccInfo.IomBitMask, pMsg,
                                SIZE_SVC_BIND_AUDIT_REQUEST_MSG(), NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;
}

PRIVATE tStatus smgrSendSdpBindStatsReadMesgPriv(tSapBindInstId InstanceId, eSdpStatsOp Op,
                                                 tSdpBindingStats *pStats, tBoolean PmsiBind,
                                                 tSdpBindingL2TPV3Stats *pL2TPV3Stats)
{
    tIomSdpBindingStatsRequest msg;
    tIomSdpBindingStatsResponse *rep;
    tIomSdpBindingStats PmsiBindStats, *pDst = NULL;
    tIomSdpBindingStats *pSrc;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;
    tSmgrMsgrIccInfo IccInfo;

    SVCMGR_EVENT(IOM_CALL, "Sdp Bind InstId %u - %s", InstanceId, smgrMesgIccSdpBindStatsOpToStr(Op));
    
    /* Initialize the Stats */
    ZERO_STRUCT_PTR(pStats);
    ZERO_STRUCT(PmsiBindStats);
    ZERO_STRUCT_PTR(pL2TPV3Stats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    msg.Op = Op;
    msg.NumEntries = 1;
    ZERO_STRUCT(msg.Entries[0]);
    msg.Entries[0] = InstanceId;

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SdpBindStats,
                               msg.Op);    

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or that do not
         * have network ports defined on them.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SMNetIntIomBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL)
            return FAIL;
        
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = IccInfo.pMsgrEntry->IccSocket; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SDP_STATS_REQUEST_MSG(msg.NumEntries);
        pIccTran->RequestFragments[0].Addr = &msg;
        s = iccSendRequest(pIccTran, TRUE);
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
        
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SDP_BINDING_STATS, s);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            return FAIL;
        }
    
        /* Copy the stats into the buffer */
        if (rep->NumEntries > 0) {
            ASSERT_MSG(rep->L2TPV3Resp == (Op == IOM_SDP_STATS_READ_L2TPV3),
                       "L2TPV3Resp %s not expected for Op %s",
                       rep->L2TPV3Resp ? "T":"F", smgrMesgIccSdpBindStatsOpToStr(Op));
            if (rep->L2TPV3Resp) {
                if (rep->Entries[0].u.L2TPV3Stats.SessionMismatch) {
                    pL2TPV3Stats->SessionMismatch = TRUE;
                    iccFreeTransaction(pIccTran);
                    break; /* No need to check other IOMs */
                }
            } else {
                /* Update TimeStamp */
                pStats->AvgStatsTime = rep->Entries[0].u.Stats.AvgStatsTime;
            
                /* Fill up the stats */
                pDst = &pStats->IomStats;
                pSrc = &rep->Entries[0].u.Stats.IomStats;
                
                if (PmsiBind) {
                    // if this is a VPLS PMSI binding representing the root of the p2mp tree,
                    // the stats for this are counted on each IOM on which a leaf exists. 
                    // We don't want to have stats for each leaf or egressing IOM - we simply
                    // want the number of packets going out the p2mp root - so we take
                    // the biggest value returned by an IOM as the statistic
                    if (pSrc->EgressSdpBindingForwardedOctets > PmsiBindStats.EgressSdpBindingForwardedOctets) {
                        PmsiBindStats.EgressSdpBindingForwardedOctets = pSrc->EgressSdpBindingForwardedOctets;
                        PmsiBindStats.EgressSdpBindingForwardedPackets = pSrc->EgressSdpBindingForwardedPackets;
                    }
                } else {
                    pDst->IngressSdpBindingForwardedPackets += pSrc->IngressSdpBindingForwardedPackets;
                    pDst->IngressSdpBindingForwardedOctets += pSrc->IngressSdpBindingForwardedOctets;  // 4M England & NZ IOM's only
                    pDst->IngressSdpBindingDroppedPackets += pSrc->IngressSdpBindingDroppedPackets;
                    pDst->IngressSdpBindingDroppedOctets += pSrc->IngressSdpBindingDroppedOctets;      // 4M England & NZ IOM's only
                    pDst->EgressSdpBindingForwardedPackets += pSrc->EgressSdpBindingForwardedPackets;
                    pDst->EgressSdpBindingForwardedOctets += pSrc->EgressSdpBindingForwardedOctets;
                }
            }
        }    
        iccFreeTransaction(pIccTran);
    }
    if (PmsiBind && pDst) {
        pDst->EgressSdpBindingForwardedPackets += PmsiBindStats.EgressSdpBindingForwardedPackets;
        pDst->EgressSdpBindingForwardedOctets += PmsiBindStats.EgressSdpBindingForwardedOctets;
    }
     
    return SUCCESS;    
}
PRIVATE tStatus smgrSendSdpBindStatsResetMesgPriv(tSapBindInstId InstanceId, eSdpStatsOp Op)
{
    tIomSdpBindingStatsRequest msg;
    tUint32 IomBitMask;
    tIccError s;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "Sdp Bind InstId %u - %s", InstanceId, smgrMesgIccSdpBindStatsOpToStr(Op));
    msg.Op = Op;
    msg.NumEntries = 1;

    ZERO_STRUCT(msg.Entries[0]);

    msg.Entries[0] = InstanceId;

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SdpBindStats,
                               msg.Op);

    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    /* Send the message to all the IOM's that have network ports */
    IomBitMask = SMNetIntIomBitMask;
    if ((s = smgrSendMesgToIoms(IccInfo.pMsgrEntry->IccSocket, IomBitMask,
                                &msg, SIZE_SDP_STATS_REQUEST_MSG(msg.NumEntries))) != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendMesgToIoms() failed for mask=%08x !", IomBitMask);
    }
    
    return s;
}
/* Batch Send a SDP_BIND_STATS_RESET message */
PUBLIC tStatus smgrBatchSdpBindStatsResetMesg(tSapBindInstId *pInstanceId, tUint32 Num)
{
    tIomSdpBindingStatsRequest msg;
    tSmgrMsgrIccInfo IccInfo;
    tIccError s = ICC_ERR_NONE;
    tUint32 i;

    SVCMGR_EVENT(IOM_CALL, "Sdp Bind Num %u", Num);
    msg.Op = IOM_SDP_STATS_RESET;        
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SdpBindStats,
                               msg.Op);

    i = 0;
    while (Num) {
        for (msg.NumEntries = 0;
             (msg.NumEntries < MAX_STRUCT_SDP_STATS_ENTRIES_PER_MSG) && Num;
             msg.NumEntries++, Num--, i++) {
            msg.Entries[msg.NumEntries] = pInstanceId[i];
        }
        if ((s = smgrSendMesgToIoms(IccInfo.pMsgrEntry->IccSocket, SMNetIntIomBitMask,
                                    &msg, SIZE_SDP_STATS_REQUEST_MSG(msg.NumEntries))) != SUCCESS) {
            SVCMGR_INFORM(NOCLASS, "Failed for mask=%08x !", SMNetIntIomBitMask);
        }
    }
    return s;
}

/* Send a SDP_BIND_STATS_READ message */
PUBLIC tStatus smgrSendSdpBindStatsReadMesg(tSapBindInstId InstanceId, tSdpBindingStats *pStats, tBoolean PmsiBind)
{
    tSdpBindingL2TPV3Stats L2TPV3Stats; /* dummy */
    return smgrSendSdpBindStatsReadMesgPriv(InstanceId, IOM_SDP_STATS_READ_RELATIVE,
                                            pStats, PmsiBind, &L2TPV3Stats);
}
/* Send a SDP_BIND_STATS_RESET message */
PUBLIC tStatus smgrSendSdpBindStatsResetMesg(tSapBindInstId InstanceId)
{
    return smgrSendSdpBindStatsResetMesgPriv(InstanceId, IOM_SDP_STATS_RESET);
}
/* Send a SDP_BIND_STATS_READ_L2TPV3 message */
PUBLIC tStatus smgrSendSdpBindStatsL2TPV3ReadMesg(tSapBindInstId InstanceId,
                                                  tSdpBindingL2TPV3Stats *pL2TPV3Stats)
{
    tSdpBindingStats Stats; /* dummy */
    return smgrSendSdpBindStatsReadMesgPriv(InstanceId, IOM_SDP_STATS_READ_L2TPV3,
                                             &Stats, FALSE, pL2TPV3Stats);
}
/* Send a SDP_BIND_STATS_RESET_L2TPV3 message */
PUBLIC tStatus smgrSendSdpBindStatsL2TPV3ResetMesg(tSapBindInstId InstanceId)
{
    return smgrSendSdpBindStatsResetMesgPriv(InstanceId, IOM_SDP_STATS_RESET_L2TPV3);
}

PRIVATE void smgrGetTlsMacDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                       const tTlsFdbRec *pRec,
                                       const tSdpBndRec *pSdpBnd,
                                       const tSapRec *pSap,
                                       tUint32 IomOp,
                                       tUint32 SlotBitmap,
                                       tBoolean IsCardOnline)
{  
    switch (SlotBitmap) {    
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;        
    }
    
    smgrMsgrGetObjIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_TlsFdb,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccTlsFdbCmp,
                          pRec);
}

/* Send a TLS_MAC_ADD message */
PUBLIC tStatus smgrSendTlsMacAddMesg(tTlsObj *pTlsFdb, tTlsFdbRec *pRec, tSMSlot SlotNum,
                                     tSlot SrcSlotNum, struct SMEventMsg **ppCallbackEvent)
{
    tSvcRec *pSvc = pTlsFdb->SvcRec;
    char fmtBuf[FMT_MAC_BUF_SIZE];
    tIomTlsMacConfigRequest *pReq;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 NumCallbackEvents = 0;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u mac=%s slot=%d %s mimIdx=%u", 
                 pSvc->Id, FmtMac(&pRec->MacAddr, fmtBuf, sizeof(fmtBuf)), SlotNum,
                 tlsFdbFmtDestination(pRec), pRec->pMimEntry ? pRec->pMimEntry->DestIdx : 0);
   
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetTlsMacDownloadInfo(&IccInfo, pRec, NULL,pRec->DestInfo.Sap.Rec,IOM_TLS_MAC_ADD,SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((pReq = SMGR_MESG_MEM_MALLOC(SIZE_TLS_MAC_REQUEST_MSG(IOM_TLS_MAC_ADD, 1))) == NULL)
        return FAIL;
    
    /* It might be that Mac Delete is being batched up, 
     * if so, flush delete msg to prevent IOM receive out
     * of sync delete/add message (using the same FdbId).
     */
    if (pMacDelReqMesg) 
        smgrDoFlushTlsMacDelMesg(TRUE);    
        
    if (pMacAddReqMesg) 
        smgrDoFlushTlsMacAddMesg(TRUE);
        
    pReq->Op = IOM_TLS_MAC_ADD;
    pReq->NumEntries = 1;
    
    /* SrcSlotNum is used to indicate to the IOM that if it is a new MAC entry
     * being create and the SrcSlotNum != IOM slot num that it should set the age
     * to infinity
     */
    smgrInitTlsMacAddReqEntry(&pReq->u.Add[0], pSvc, pRec, SrcSlotNum, ppCallbackEvent ? *ppCallbackEvent : NULL);
    if (ppCallbackEvent) {
        NumCallbackEvents = *ppCallbackEvent ? 1 : 0;
        *ppCallbackEvent = NULL;
    }
    
    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pReq, FALSE);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pReq->Op,
                                      IccInfo.IomBitMask, pReq,
                                      SIZE_TLS_MAC_REQUEST_MSG(pReq->Op, pReq->NumEntries),
                                      NULL, SMGR_DNDLER_MAY_BLOCK,
                                      CAST_INT_TO_PTR(void *, NumCallbackEvents), SMIccCleanSemId,
                                      FALSE, TRUE, smgrIccCleanSendTlsMac);
    if (s != SUCCESS) {
        /* If sending to IOM fails, ICC will not call smgrIccCleanSendTlsMac, call it here */
        smgrIccCleanSendTlsMac(pReq, CAST_INT_TO_PTR(void*, NumCallbackEvents));
    }

    /* Ack previous Mac Learn Trans from IOMs */
    tlsFdbIomMacLearnTransSendAcks();
    
    return s;    
}




/* Batch up a TLS_MAC_ADD message */

PUBLIC tStatus smgrBatchTlsMacAddMesgPriv(tTlsObj *pTlsFdb, tTlsFdbRec *pRec, tUint32 SlotBitmap,
                                          tSlot SrcSlotNum, tBoolean IsCardOnline,
                                          tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pTlsFdb->SvcRec;
    char fmtBuf[FMT_MAC_BUF_SIZE];
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "svc=%u mac=%s slotbitmap=0x%08x %s mimIdx=%u cardonline: %d",
                 pSvc->Id, FmtMac(&pRec->MacAddr, fmtBuf, sizeof(fmtBuf)), SlotBitmap,
                 tlsFdbFmtDestination(pRec), pRec->pMimEntry ? pRec->pMimEntry->DestIdx : 0,IsCardOnline);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetTlsMacDownloadInfo(&IccInfo, pRec,NULL,pRec->DestInfo.Sap.Rec,IOM_TLS_MAC_ADD,SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;


    if (pMacDelReqMesg) 
        smgrDoFlushTlsMacDelMesg(TRUE);
    
    if (pMacAddReqMesg) {
        /* If the specified IOM bit mask differs from the previous 
         * one, flush the message and start a new batch so that we
         * don't send messages to the wrong set of IOM's!
         */
        if (IccInfo.IomBitMask != PrevMacAddIomBitMask) {
            smgrDoFlushTlsMacAddMesg(TRUE);
        }
    }

    if (!pMacAddReqMesg) {
        if (SMGR_SEND_TLS_MAC_BATCH_ASYNC || runtime_feature_smgr_buffered_download) {
            /* Alloc max message size */
            pMacAddReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_TLS_MAC_REQUEST_MSG(IOM_TLS_MAC_ADD, SMMaxNumTlsMacAddEntriesPerMesg));
            if (pMacAddReqMesg == NULL) {
                return FAIL;
            }
        } else {
            pMacAddReqMesg = &MacAddReqMesg;
        }
        pMacAddReqMesg->Op = IOM_TLS_MAC_ADD;
        pMacAddReqMesg->NumEntries = 0;

        /* Set the bit mask */
        PrevMacAddIomBitMask = IccInfo.IomBitMask;
    }      
    
    /* SrcSlotNum is used to indicate to the IOM that if it is a new MAC entry
     * being create and the SrcSlotNum != IOM slot num that it should set the age
     * to infinity
     */
    smgrInitTlsMacAddReqEntry(&pMacAddReqMesg->u.Add[pMacAddReqMesg->NumEntries],
                              pSvc, pRec, SrcSlotNum, NULL);

    /* Add new entry */
    pMacAddReqMesg->NumEntries++;        

    /* If we reached the limit, flush the message */
    if (pMacAddReqMesg->NumEntries >= SMMaxNumTlsMacAddEntriesPerMesg) {
        s = smgrDoFlushTlsMacAddMesg(FALSE);
        if (pBatch)
            pBatch->TlsMacAddSent = FALSE;
    } else {
        if (pBatch)
            pBatch->TlsMacAddSent = TRUE;
    }
    return s;
}    

/* Flush batched up TLS_MAC_ADD messages */
PUBLIC tStatus smgrFlushTlsMacAddMesg(void)
{
    return smgrDoFlushTlsMacAddMesg(FALSE);
}
PRIVATE tStatus smgrDoFlushTlsMacAddMesg(tBoolean preFlush)
{
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pMacAddReqMesg || pMacAddReqMesg->NumEntries == 0)
        return s;
    
    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x preFlush %s",
                 pMacAddReqMesg->NumEntries, PrevMacAddIomBitMask, preFlush ? "T":"F");
    
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_TlsFdb,
                               IOM_TLS_MAC_ADD);
    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo,pMacAddReqMesg,preFlush);

    if (SMGR_SEND_TLS_MAC_BATCH_ASYNC || runtime_feature_smgr_buffered_download) {
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMacAddReqMesg->Op,
                                          PrevMacAddIomBitMask, pMacAddReqMesg,
                                          SIZE_TLS_MAC_REQUEST_MSG(pMacAddReqMesg->Op, pMacAddReqMesg->NumEntries),
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendTlsMac);
         if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "smgrSendClientCustomMsgToIoms()  failed for mask=%08x !",
                         PrevMacAddIomBitMask);
            smgrIccCleanSendTlsMac(pMacAddReqMesg, NULL);
         }
    } else {
        /* Send the message to all the specified IOMs */      
        s = smgrSendMesgToIoms(IccInfo.pMsgrEntry->IccSocket, PrevMacAddIomBitMask,
                               pMacAddReqMesg,
                               SIZE_TLS_MAC_REQUEST_MSG(pMacAddReqMesg->Op, pMacAddReqMesg->NumEntries));
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "smgrSendMesgToIoms() failed for mask=%08x !",
                         PrevMacAddIomBitMask);
        }
    }

    /* Start a new batch */
    pMacAddReqMesg = NULL;

    /* Ack previous Mac Learn Trans from IOMs */
    tlsFdbIomMacLearnTransSendAcks();
    
    return s;
}

/* Cleanup after delivered TLS messages to the IOM Async */
PUBLIC void smgrIccCleanSendTlsMac(void *pIccMsg, void *pUserData)
{
    tUint32 i;
    tUint32 nCb = 0;
    tUint32 ExpNumCb = CAST_PTR_TO_INT(tUint32, pUserData);
    tIomTlsMacConfigRequest *pMsg = (tIomTlsMacConfigRequest *)pIccMsg;
    
    switch(pMsg->Op) {
    case IOM_TLS_MAC_ADD:
        if (ExpNumCb) {
            for (i = 0; i < pMsg->NumEntries; i++) {
                if (pMsg->u.Add[i].handle.Cpm) {
                    smgrIccCleanup(pMsg->u.Add[i].handle.Cpm);
                    nCb++;
                }
            }
        }
        break;
    case IOM_TLS_MAC_DELETE_ALL_FOR_DEST:
        for (i = 0; i < pMsg->NumEntries; i++) {
            tlsFdbFlushMacsPendingUpdate(TRUE);
            if (pMsg->u.DelDst[i].handle.Cpm) {
                smgrIccCleanup(pMsg->u.DelDst[i].handle.Cpm);
                nCb++;
            }
        }
        break;
    case IOM_TLS_MAC_DELETE_ALL_FOR_TLS:
        for (i = 0; i < pMsg->NumEntries; i++) {
            tlsFdbFlushMacsPendingUpdate(TRUE);
            if (pMsg->u.DelTls[i].handle.Cpm) {
                smgrIccCleanup(pMsg->u.DelTls[i].handle.Cpm);
                nCb++;
            }
        }
        break;
    case IOM_TLS_MAC_DELETE_ALL_FOR_MIM:
        for (i = 0; i < pMsg->NumEntries; i++) {
            tlsFdbFlushMacsPendingUpdate(TRUE);
            if (pMsg->u.DelMim[i].handle.Cpm) {
                smgrIccCleanup(pMsg->u.DelMim[i].handle.Cpm);
                nCb++;
            }
        }
        break;
    case IOM_TLS_MAC_CALLBACK:
        for (i = 0; i < pMsg->NumEntries; i++) {
            if (pMsg->u.Callback[i].handle.Cpm) {
                smgrIccCleanup(pMsg->u.Callback[i].handle.Cpm);
                nCb++;
            }
        }
        break;
    case IOM_TLS_MAC_LEARN:
    case IOM_TLS_MAC_AGE:
    case IOM_TLS_MAC_DELETE:
    case IOM_TLS_MAC_MOVE_ALL_FOR_DEST:
    case IOM_TLS_MAC_QUERY:
    case IOM_TLS_MAC_AUDIT:
    default:
        ;
    }

    SVCMGR_EVENT(IOM_CALL, "entries=%u op=%s #cb=%u ExpNumCb=%u",
                 pMsg->NumEntries, smgrMesgIccTlsFdbOpToStr(pMsg->Op), nCb, ExpNumCb);
    SMGR_MESG_MEM_FREE(pIccMsg);
}

/* Send a TLS_MAC_DELETE message */
PUBLIC tStatus smgrSendTlsMacDelMesg(tTlsObj *pTlsFdb, tTlsFdbRec *pRec, tSMSlot SlotNum)
{
    char fmtBuf[FMT_MAC_BUF_SIZE];
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u mac=%s slot=%d",
                 pTlsFdb->SvcRec->Id, FmtMac(&pRec->MacAddr, fmtBuf, sizeof(fmtBuf)), SlotNum);

    return smgrDoTlsMacDelOpMesg(pTlsFdb, pRec, NULL, pRec->DestInfo.Sap.Rec,
                                 TRUE, TFRT_UNDEF, /* NA for IOM_TLS_MAC_DELETE */
                                 NULL,
                                 SlotNum,
                                 IOM_TLS_MAC_DELETE, NULL);
}

/* Batch up a TLS_MAC_DELETE message */
PUBLIC tStatus smgrBatchTlsMacDelMesg(tTlsObj *pTlsFdb, tTlsFdbRec *pRec, tSMSlot SlotNum,
                                      tBatchProcessing *pBatch)
{
    char fmtBuf[FMT_MAC_BUF_SIZE];
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u mac=%s slot=%d",
                 pTlsFdb->SvcRec->Id, FmtMac(&pRec->MacAddr, fmtBuf, sizeof(fmtBuf)), SlotNum);
    
    return smgrDoTlsMacDelOpMesg(pTlsFdb, pRec, NULL, pRec->DestInfo.Sap.Rec,
                                 TRUE, TFRT_UNDEF, /* NA for IOM_TLS_MAC_DELETE */
                                 NULL,
                                 SlotNum,
                                 IOM_TLS_MAC_DELETE, pBatch);
}

/* Batch up a TLS_MAC DELETE Op Message */
PRIVATE tStatus smgrDoTlsMacDelOpMesg(tTlsObj *pTlsFdb, tTlsFdbRec *pRec, tSdpBndRec *pSdpBnd, tSapRec *pSap,
                                      tBoolean DelStatic, tTlsFdbRequestorType RequestorType,
                                      tSMGenEventMsg **ppCbEvt,
                                      tSMSlot SlotNum,
                                      eTlsMacOp Op, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pTlsFdb->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tInt32 MaxBatchSize = SMGR_BATCH_MESG_ENABLED(pBatch)? smgrMesgIccTlsFdbOpMaxEntPerMsg(Op) : 1;
    tUint32 SlotBitmap = 0;
    
    ASSERT(MaxBatchSize > 0);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetTlsMacDownloadInfo(&IccInfo, pRec, pSdpBnd, pSap, Op, SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if (pMacAddReqMesg)
        smgrDoFlushTlsMacAddMesg(TRUE);

    if (pMacDelReqMesg) {
        /* If the specified IOM bit mask differs from the previous 
         * one, flush the message and start a new batch so that we
         * don't send messages to the wrong set of IOM's!
         */
        if ((IccInfo.IomBitMask != PrevMacDelIomBitMask) ||
            (pMacDelReqMesg->Op != Op) ||
            (pMacDelReqMesg->NumEntries >= MaxBatchSize)) {
            smgrDoFlushTlsMacDelMesg(TRUE);
        }
    }

    if (!pMacDelReqMesg) {
        pMacDelReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_TLS_MAC_REQUEST_MSG(Op, MaxBatchSize));
        if (pMacDelReqMesg == NULL) {
            return FAIL;
        }
        pMacDelReqMesg->Op = Op;
        pMacDelReqMesg->NumEntries = 0;
        
        /* Set the bit mask */
        PrevMacDelIomBitMask = IccInfo.IomBitMask;        
    }
                
    /* Add new entry */
    switch (Op) {
    case IOM_TLS_MAC_DELETE:
        smgrInitTlsMacDelReqEntry(&pMacDelReqMesg->u.Del[pMacDelReqMesg->NumEntries], pSvc, pRec);
        break;
    case IOM_TLS_MAC_DELETE_ALL_FOR_DEST:
        smgrInitTlsMacDelDstReqEntry(&pMacDelReqMesg->u.DelDst[pMacDelReqMesg->NumEntries], pSvc, pSdpBnd, pSap,
                                     DelStatic, RequestorType, ppCbEvt ? *ppCbEvt : NULL);
        tlsFdbFlushMacsPendingUpdate(FALSE);
        tlsFdbUpdateFlushMacsSentToIOM(pSvc, pSap, pSdpBnd);
        break;
    case IOM_TLS_MAC_DELETE_ALL_FOR_TLS:
        smgrInitTlsMacDelTlsReqEntry(&pMacDelReqMesg->u.DelTls[pMacDelReqMesg->NumEntries], pSvc,
                                     DelStatic, RequestorType,
                                     ppCbEvt ? *ppCbEvt : NULL);
        tlsFdbFlushMacsPendingUpdate(FALSE);
        tlsFdbUpdateFlushMacsSentToIOM(pSvc, NULL, NULL);
        break;
    case IOM_TLS_MAC_DELETE_ALL_FOR_MIM:
        smgrInitTlsMacDelMimReqEntry(&pMacDelReqMesg->u.DelMim[pMacDelReqMesg->NumEntries], pSvc,
                                 ppCbEvt ? *ppCbEvt : NULL);
        tlsFdbFlushMacsPendingUpdate(FALSE);
        tlsFdbUpdateFlushMacsSentToIOM(pSvc, NULL, NULL);
        break;
    case IOM_TLS_MAC_LEARN:
    case IOM_TLS_MAC_ADD:
    case IOM_TLS_MAC_AGE:
    case IOM_TLS_MAC_MOVE_ALL_FOR_DEST:
    case IOM_TLS_MAC_QUERY:
    case IOM_TLS_MAC_CALLBACK:
    case IOM_TLS_MAC_AUDIT:
    default:
        SVCMGR_BERROR(NOCLASS, "Op = %d?!", Op);
        return FAIL;
    }
    if (ppCbEvt) {
        *ppCbEvt = NULL;
    }
    pMacDelReqMesg->NumEntries++;

    /* If we reached the limit, flush the message */
    if (pMacDelReqMesg->NumEntries >= MaxBatchSize) {
        s = smgrDoFlushTlsMacDelMesg(FALSE);
        if (pBatch)
            pBatch->TlsMacDelSent = FALSE;
    } else {
        if (pBatch)
            pBatch->TlsMacDelSent = TRUE;
    }
    
    return s;    
}

/* Flush batched up TLS_MAC_DELETE messages */
PUBLIC tStatus smgrFlushTlsMacDelMesg(void)
{
    return smgrDoFlushTlsMacDelMesg(FALSE);
}
PRIVATE tStatus smgrDoFlushTlsMacDelMesg(tBoolean preFlush)
{
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    PRIVATE tSmgrDndlerBlockType BlockType = SMGR_DNDLER_MAY_BLOCK;
    
    if (!pMacDelReqMesg)
        return s;
    
    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x preFlush %s",
                 pMacDelReqMesg->NumEntries, PrevMacDelIomBitMask, preFlush ? "T":"F");

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_TlsFdb,
                               pMacDelReqMesg->Op);

    /* IOMs may get busy with these operations */
    if (pMacDelReqMesg->Op == IOM_TLS_MAC_DELETE_ALL_FOR_DEST ||
        pMacDelReqMesg->Op == IOM_TLS_MAC_DELETE_ALL_FOR_TLS ||
        pMacDelReqMesg->Op == IOM_TLS_MAC_DELETE_ALL_FOR_MIM) {
        if (! smgrCanDownloadToIom(ICC_SOCKET_TLS_MAC_TABLE))
            BlockType = SMGR_DNDLER_BLOCK;
    }

    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMacDelReqMesg, preFlush);

    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMacDelReqMesg->Op,
                                      PrevMacDelIomBitMask, pMacDelReqMesg,
                                      SIZE_TLS_MAC_REQUEST_MSG(pMacDelReqMesg->Op, pMacDelReqMesg->NumEntries),
                                      NULL, BlockType, NULL, SMIccCleanSemId,
                                      FALSE, TRUE, smgrIccCleanSendTlsMac);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientCustomMsgToIoms() failed for mask=%08x !",
                     PrevMacDelIomBitMask);
        /* If sending to IOMs fail, ICC will not call smgrIccCleanSendTlsMac, call it here */
        smgrIccCleanSendTlsMac(pMacDelReqMesg, NULL);
    }

    /* Start a new batch */
    pMacDelReqMesg = NULL;    
    return s;
}

/* Send a TLS_MAC_DELETE message for a specific SDP Bind or SAP */
PUBLIC void smgrBatchTlsMacDelDestMesg(tTlsObj *pTlsFdb, tSdpBndRec *pSdpBnd,
                                       tSapRec *pSap, tBoolean DelStatic,
                                       tTlsFdbRequestorType RequestorType,
                                       tSMGenEventMsg **ppCbEvt,
                                       tBatchProcessing *pBatch)
{
    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u sap=%s", pTlsFdb->SvcRec->Id,
                 pSdpBnd ? sdpBindGetSdpId(pSdpBnd) : 0, pSdpBnd ? sdpBindGetVcId(pSdpBnd) :0,
                 pSap ? smgrFmtSapIdVerboseForDebug(&pSap->SapId) : "<>");
    
    ASSERT (!pSdpBnd || !pSap);
    
    smgrDoTlsMacDelOpMesg(pTlsFdb, NULL, pSdpBnd, pSap,
                          DelStatic, RequestorType,
                          ppCbEvt,
                          ALL_APPLICABLE_IOMS,
                          IOM_TLS_MAC_DELETE_ALL_FOR_DEST, pBatch);
}

 /* Send a TLS_MAC_DELETE message for all records in the TLS */
PUBLIC void smgrBatchTlsMacDelAllMesg(tTlsObj *pTlsFdb, tBoolean DelStatic,
                                      tTlsFdbRequestorType RequestorType,
                                      tSMGenEventMsg **ppCbEvt, tBatchProcessing *pBatch)
{
    SVCMGR_EVENT(IOM_CALL, "svc=%u", pTlsFdb->SvcRec->Id);

    smgrDoTlsMacDelOpMesg(pTlsFdb, NULL, NULL, NULL,
                          DelStatic, RequestorType,
                          ppCbEvt,
                          ALL_APPLICABLE_IOMS,
                          IOM_TLS_MAC_DELETE_ALL_FOR_TLS, pBatch);
}

/* Send a message to IOM. When IOM processes message, callback function is called.
 * Can be used to indicate that IOMs have processed all TLS MAC ICC messages queued
 * before this one. 
 * If *ppCbEvt != NULL at the end of call, caller needs to execute the callback function */
PUBLIC tStatus smgrTlsMacCallbackMesg(tSMGenEventMsg **ppCbEvt)
{
    tSmgrMsgrIccInfo         IccInfo;
    tSMGenEventMsg          *pGenMsg;
    tIomTlsMacConfigRequest *pRequest = NULL;
    tIomTlsMacCallbackEntry *pEntry;  
    tStatus                  Status = SUCCESS;
        
    if (ppCbEvt == NULL || *ppCbEvt == NULL) {
        SVCMGR_ERROR(NOCLASS, "Callback function is not set");
        return FAIL;
    }
        
    pGenMsg = *ppCbEvt;
    SVCMGR_EVENT(IOM_CALL, "Callback Event=%s",
                 SMEventRecTable[pGenMsg->Hdr.Event].Name);

    /* Determine the set of IOMs that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it... */
    smgrGetTlsMacDownloadInfo(&IccInfo, NULL, NULL, NULL,
                              IOM_TLS_MAC_CALLBACK, ALL_APPLICABLE_IOMS, FALSE);
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(NOCLASS, "IomBitMask is 0");
        return SUCCESS;
    }
        
    if (pMacAddReqMesg) 
        smgrFlushTlsMacAddMesg();

    if (pMacDelReqMesg)
        smgrFlushTlsMacDelMesg();
        
    pRequest = SMGR_MESG_MEM_MALLOC(SIZE_TLS_MAC_REQUEST_MSG(IOM_TLS_MAC_CALLBACK,
                                                             MAX_TLS_MAC_CALLBACK_ENTRIES_PER_MSG));
    if (pRequest == NULL) {
        SVCMGR_ERROR(NOCLASS, "Unable to allocate memory: mask=%08x", IccInfo.IomBitMask);
        return FAIL;
    }
        
    pRequest->Op = IOM_TLS_MAC_CALLBACK;
    pRequest->NumEntries = 1;

    pEntry = &pRequest->u.Callback[0];    
    ZERO_STRUCT_PTR(pEntry);
    pEntry->handle.Cpm = *ppCbEvt;
    *ppCbEvt = NULL;
    
    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pRequest, FALSE);
    
    Status = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pRequest->Op,
                                           IccInfo.IomBitMask, pRequest,
                                           SIZE_TLS_MAC_REQUEST_MSG(pRequest->Op, pRequest->NumEntries),
                                           NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                           FALSE, TRUE, smgrIccCleanSendTlsMac);
    if (Status != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "TLS MAC callback failed: Status=%d for mask=%08x",
                     Status, IccInfo.IomBitMask);
        /* If the message is not sent to the IOMs, ICC will not call smgrIccCleanSendTlsMac, call it here */
        smgrIccCleanSendTlsMac(pRequest, NULL);
    }
    
    return Status;
}

/* Send IOM_TLS_MAC_MOVE_ALL_FOR_DEST message in the TLS */
PUBLIC tStatus smgrSendTlsMacMoveAllMesg(tTlsObj *pTlsFdb,
                                         tSdpBndRec *pOldSdpBnd, tSdpBndRec *pNewSdpBnd)
{
    tSvcRec *pSvc = pTlsFdb->SvcRec;
    tIomTlsMacConfigRequest *pMsg = NULL;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u", pSvc->Id);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetTlsMacDownloadInfo(&IccInfo, NULL,NULL,NULL,
                              IOM_TLS_MAC_MOVE_ALL_FOR_DEST,
                              ALL_APPLICABLE_IOMS, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((pMsg = SMGR_MESG_MEM_CALLOC(1, SIZE_TLS_MAC_MOVE_REQUEST_MSG(1))) == NULL) {
        SVCMGR_EVENT(NOCLASS, "Unable to obtain memory for TLS MAC Move msg"); 
        return FAIL;
    }

    if (pMacDelReqMesg) 
        smgrDoFlushTlsMacDelMesg(TRUE);    
        
    if (pMacAddReqMesg) 
        smgrDoFlushTlsMacAddMesg(TRUE);
    
    pMsg->Op = IOM_TLS_MAC_MOVE_ALL_FOR_DEST;
    pMsg->NumEntries = 1;
    smgrInitTlsMacMoveReqEntry(&pMsg->u.Move[0], pSvc, pOldSdpBnd, pNewSdpBnd);
    
    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);    

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op,
                                IccInfo.IomBitMask, pMsg,
                                SIZE_TLS_MAC_REQUEST_MSG(pMsg->Op, pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask=%08x op=%d!", 
                     IccInfo.IomBitMask, IccInfo.pMsgrEntry->IccSocket);
    }

    smgrFreeClientMsg(pMsg, s);
    
    return s;
}

/* Send a TLS_MAC_DELETE message for all MIM records in the TLS */
PUBLIC void smgrBatchTlsMacDelAllMimMesg(tTlsObj *pTlsFdb,
                                         tSMGenEventMsg **ppCbEvt, tBatchProcessing *pBatch)
{
    SVCMGR_EVENT(IOM_CALL, "svc=%u", pTlsFdb->SvcRec->Id);
    
    smgrDoTlsMacDelOpMesg(pTlsFdb, NULL, NULL, NULL,
                          FALSE, TFRT_UNDEF, /* NA for IOM_TLS_MAC_DELETE_ALL_FOR_MIM */
                          ppCbEvt,
                          ALL_APPLICABLE_IOMS,
                          IOM_TLS_MAC_DELETE_ALL_FOR_MIM, pBatch);
}

PRIVATE void smgrGetTlsMacQueryDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                            const tTlsFdbRec *pRec,
                                            tUint32 IomOp,
                                            tUint32 SlotBitmap,
                                            tBoolean IsCardOnline)
{
   
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_TlsFdbQuery,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccTlsFdbCmp,
                          pRec);
}

/* Send a synchronous TLS_MAC_QUERY AGE ICC message.
 * This may release smgrLock and grab it again, meaning that
 * if an error is returned, svc or FDB record may have been deleted */
PUBLIC tStatus smgrSendTlsMacQueryAgeMesg(tSvcRec *pSvc, tTlsFdbRec *pRec, tUint32 *pAge,
                                          tUint32 IomBitMask, tBoolean MultipleIoms)
{
    tIomTlsMacConfigRequest req;
    tIomTlsMacConfigResponse *rep;
    char fmtBuf[FMT_MAC_BUF_SIZE];
    tSlot SlotNum;
    tIccTransaction *pIccTran = NULL;
    tIccError s;
    tUint32 age;
    tSmgrMsgrIccInfo IccInfo;
    tStatus Status;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u mac=%s IomBitMask 0x%08x",
                 pSvc->Id, FmtMac(&pRec->MacAddr, fmtBuf, sizeof(fmtBuf)), IomBitMask);

    
    smgrGetTlsMacQueryDownloadInfo(&IccInfo,pRec,IOM_TLS_MAC_QUERY,ALL_APPLICABLE_IOMS,FALSE);
    
    IomBitMask &=  IccInfo.IomBitMask;

    age = -1;

    for (SlotNum = MIN_CHASSIS_SLOT; SlotNum <= MAX_CHASSIS_SLOT; SlotNum++) {
        if (!IOM_BIT_TST(IomBitMask, SlotNum)) {
            continue;
        }
        
        /* If the TLS_MAC_QUERY socket is full abort
         * the operation, as otherwise we would block
         * on the ICC send call, causing a deadlock!
         */
         
        if (! smgrCanDownloadToIom(IccInfo.pMsgrEntry->IccSocket)) {
            SVCMGR_EVENT(IOM_CALL, "TLS_MAC_QUERY socket full, dndler's "
                         "buffer full, or dndler's latency too large!");
            goto Fail;
        }
        
        req.Op = IOM_TLS_MAC_QUERY;
        req.NumEntries = 1;
        smgrInitTlsMacQueryReqEntry(&req.u.Query[0], pSvc, pRec, MultipleIoms);
        
        /* Allocate new transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Can't alloc transaction for sock=%d slot=%d !",
                         ICC_SOCKET_TLS_MAC_QUERY, SlotNum);
            *pAge = SIA_TLS_FDB_UNKN_AGE;
            return FAIL;
        }
   
        /* Fill out ICC transaction */
        pIccTran->Slot = SlotNum;
        pIccTran->Socket = IccInfo.pMsgrEntry->IccSocket; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_TLS_MAC_REQUEST_MSG(req.Op, req.NumEntries);
        pIccTran->RequestFragments[0].Addr = (void *) &req;


        SMGR_MESG_UPDATE_STATS(&IccInfo, &req, FALSE);
        
        if (! runtime_feature_smgr_buffered_download) {
            s = iccSendRequest(pIccTran, TRUE);
        } else {
            /* We need to make the synchronous ICC request using the SMGR dndler since
             * there may be related transactions pending in its buffered queue */
            tUint32 TmpIomBitMask = 0;
            
            /* Indicate that stack variables can be accessed from another task */
            PTR_CHCK_VALID_RANGE_SET_IF_ON_STACK(&req, sizeof(req), TRUE);
            PTR_CHCK_VALID_RANGE_SET_IF_ON_STACK(&s, sizeof(s), TRUE);

            IOM_BIT_SET(TmpIomBitMask, pIccTran->Slot);
            Status = smgrDndlerPostBufferedSyncMsg(pIccTran->Socket, req.Op, TmpIomBitMask, &req,
                                                   SIZE_TLS_MAC_REQUEST_MSG(req.Op, req.NumEntries),
                                                   SMGR_DNDLER_DO_NOT_BLOCK,
                                                   &s, pIccTran, IccSyncTlsMacQuery);
            if (Status != SUCCESS) {
                /* Indicate that stack variables can no longer be accessed from another task */
                PTR_CHCK_VALID_RANGE_SET_IF_ON_STACK(&req, sizeof(req), FALSE);
                PTR_CHCK_VALID_RANGE_SET_IF_ON_STACK(&s, sizeof(s), FALSE);

                SVCMGR_EVENT(IOM_CALL, "Unable to send buffered synchronous ICC message");
                goto Fail;
            } else {
                tServId  SvcId = pSvc->Id;
                tUint32  SeqNum = pSvc->SeqNum;
                tSvcRec *pTmpSvc;
                
                /* Release smgrLock so that there's no possibility of deadlock */
                smgrUnlock();
                
                /* Wait until message is processed by SMGR dndler */
                semTake(IccSyncTlsMacQuery, WAIT_FOREVER);
                    
                smgrLock();
                
                /* Indicate that stack variables can no longer be accessed from another task */
                PTR_CHCK_VALID_RANGE_SET_IF_ON_STACK(&req, sizeof(req), FALSE);
                PTR_CHCK_VALID_RANGE_SET_IF_ON_STACK(&s, sizeof(s), FALSE);

                /* Since we temporarily released smgrLock, verify that the TLS and MAC
                 * still exist */
                pTmpSvc = svcFindRecById(SvcId);
                if (pTmpSvc == NULL ||
                    ! IS_TLS(pTmpSvc) ||
                    pTmpSvc->SeqNum != SeqNum ||
                    pSvc != pTmpSvc) {
                    SVCMGR_EVENT(IOM_CALL, "Svc %u has been deleted", SvcId);
                    pSvc = NULL;
                    goto Fail;
                }
                
                if (tlsFdbFindRec(pSvc->u.Tls, &req.u.Query[0].MacAddr) != pRec) {
                    SVCMGR_EVENT(IOM_CALL, "MAC %s has been deleted",
                                 smgrFmtMacAddrForDebug(&req.u.Query[0].MacAddr));
                    pRec = NULL;
                    goto Fail;
                }
                
                /* Variable s contains the ICC send status */
            } 
        }
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            *pAge = SIA_TLS_FDB_UNKN_AGE;
            iccFreeTransaction(pIccTran);
            return SUCCESS;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u failed with error=%d !",
                         SlotNum, pIccTran->TransactionId, s);
            goto Fail;
        }
    
        /* Do some sanity checks */
        if ((rep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            goto Fail;
        }
    
        /* Get the age of this MAC from the response message if it was found */
        if (rep->EntriesProcessed == 1) {
            SVCMGR_EVENT(IOM_CALL, "svc=%u mac=%s - slot %d/0x%08x: age: %u (min. so far %u)",
                         pSvc->Id, FmtMac(&pRec->MacAddr, fmtBuf, sizeof(fmtBuf)),
                         SlotNum, IomBitMask,
                         rep->Entries[0].Age, age);
            if (rep->Entries[0].Age < age)
                age = rep->Entries[0].Age;
        }
        iccFreeTransaction(pIccTran);
    }

    if (age == -1) {
        /* This should only be returned if we learned the MAC on a IOM X within a
         * LAG group consisting of IOM X and Y. Then IOM X goes away leaving us with 
         * no idea of how old the MAC entry is because it was never received on IOM Y.
         */
        age = SIA_TLS_FDB_MAX_AGE;
    }
    
    *pAge = age;
     
    return SUCCESS;

Fail:
    if (pIccTran)
        iccFreeTransaction(pIccTran);

    *pAge = SIA_TLS_FDB_UNKN_AGE;
    return FAIL;
}

PRIVATE tStatus smgrFlushTlsMacQueryMesg(tSmgrMsgrIccInfo *pIccInfo, int RemoteAgeTime, tBoolean PreFlush) {
    tStatus s = SUCCESS;
    tUint32 IomBitMask = 0;
    
    if (!pTlsMacQueryMsg) {
        return SUCCESS;
    }
    
    SVCMGR_EVENT(IOM_CALL, "entries=%d slot=%d", 
                 pTlsMacQueryMsg->NumEntries, TlsMacQueryPrevSlotNum);
    
    SMGR_MESG_UPDATE_STATS(pIccInfo, pTlsMacQueryMsg, PreFlush);

    IOM_BIT_SET(IomBitMask, TlsMacQueryPrevSlotNum);

    if (! smgrCanDownloadToIom(pIccInfo->pMsgrEntry->IccSocket)) {
        /* This message may end up getting blocked */
        SVCMGR_EVENT(IOM_CALL, "Cannot send message to IOM 0x%x because socket %u is full, "
                     "dndler's buffer is full, dndler's latency too large", IomBitMask, pIccInfo->pMsgrEntry->IccSocket);
        s = FAIL;
    } else {
        /* We do not block since we're making a best-effort attempt to send this message */        
        s = smgrSendClientCustomMsgToIoms(pIccInfo->pMsgrEntry->IccSocket, pTlsMacQueryMsg->Op,
                                          IomBitMask, pTlsMacQueryMsg,
                                          SIZE_TLS_MAC_REQUEST_MSG(pTlsMacQueryMsg->Op, pTlsMacQueryMsg->NumEntries),
                                          NULL, SMGR_DNDLER_DO_NOT_BLOCK, CAST_INT_TO_PTR(void *, RemoteAgeTime), SMIccHandSemId,
                                          FALSE, TRUE, NULL);
    }
    
    if (s != SUCCESS) {
        /* Oops! */
        SVCMGR_EVENT(NOCLASS, "smgrSendClientCustomMsgToIoms() failed for %08x !", 
                     TlsMacQueryPrevSlotNum);
        SMGR_MESG_MEM_FREE(pTlsMacQueryMsg);
    }
    
    pTlsMacQueryMsg = NULL;

    return s;
}

PRIVATE tStatus smgrDoTlsMacQueryMesg(tSvcRec *pSvc, tTlsFdbRec *pRec, tSlot slotNum, tBoolean MultipleIoms,
                                      tSmgrMsgrIccInfo *pIccInfo, int RemoteAgeTime,
                                      int MaxBatch)
{
    int BatchSz = MIN(MaxBatch, SMMaxNumTlsMacQueryEntriesPerMesg);
    SVCMGR_EVENT(IOM_CALL, "svc=%u slot=%d", 
                 pSvc->Id, slotNum);

    if (pTlsMacQueryMsg) {
        if ((TlsMacQueryPrevSlotNum != slotNum) ||
            (pTlsMacQueryMsg->NumEntries >= BatchSz)) {
            smgrFlushTlsMacQueryMesg(pIccInfo, RemoteAgeTime, (pTlsMacQueryMsg->NumEntries < BatchSz));
        }
    }
    
    if (!pTlsMacQueryMsg) {
        /* If the TLS_MAC_QUERY socket is full abort the operation, as
         * otherwise we would block on the ICC send call, causing a
         * deadlock!
         */
        if (! smgrCanDownloadToIom(pIccInfo->pMsgrEntry->IccSocket)) {
            SVCMGR_EVENT(IOM_CALL, "TLS_MAC_QUERY socket %d is full, "
                         "dndler's buffer is full, or dndler's latency too large",
                         pIccInfo->pMsgrEntry->IccSocket);
            return FAIL;
        }
        
        if ((pTlsMacQueryMsg = SMGR_MESG_MEM_MALLOC(SIZE_TLS_MAC_REQUEST_MSG(IOM_TLS_MAC_QUERY, BatchSz))) == NULL)
            return FAIL;
        TlsMacQueryPrevSlotNum = slotNum;
        pTlsMacQueryMsg->Op = IOM_TLS_MAC_QUERY;
        pTlsMacQueryMsg->NumEntries = 0;
    }

    /* Add this entry to the message */
    smgrInitTlsMacQueryReqEntry(&pTlsMacQueryMsg->u.Query[pTlsMacQueryMsg->NumEntries], pSvc, pRec, MultipleIoms);
    pTlsMacQueryMsg->NumEntries++;

    /* If we reached the limit, flush the message */
    if (pTlsMacQueryMsg->NumEntries >= BatchSz) {
        return smgrFlushTlsMacQueryMesg(pIccInfo, RemoteAgeTime, FALSE);
    }

    return SUCCESS;
}

/* Send a TLS_MAC_QUERY message */
PUBLIC tStatus smgrSendTlsMacQueryMesg(tSvcRec *pSvc, tRemoteMacVector *pVec)
{
    int slotNum;
    int i, n;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u entries=%u", pSvc->Id, pVec->NumEntries);

    smgrGetTlsMacQueryDownloadInfo(&IccInfo,NULL,IOM_TLS_MAC_QUERY,ALL_APPLICABLE_IOMS,FALSE);
    
    /* For every IOM that has entries in the vector, gather the MAC addresses
     * associated with it and send an asynchronous TLS_MAC_QUERY message to the
     * IOM. The response will be processed asynchronously by tlsFdbIccHandler().
     */    
    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
    
        if (IOM_BIT_TST(pVec->IomBitMask, slotNum) &&
            IOM_BIT_TST(IccInfo.IomBitMask, slotNum)) {
            
            for (i = 0, n = 0; i < pVec->NumEntries; i++) {
                /* Skip entries not associated with this IOM */
                if (!IOM_BIT_TST(pVec->Entry[i].IomBitMask, slotNum))
                    continue;

                /* Add this entry */
                if (smgrDoTlsMacQueryMesg(pSvc, pVec->Entry[i].FdbRec, slotNum, pVec->Entry[i].MultipleIoms,
                                          &IccInfo, pVec->RemoteAgeTime, pVec->NumEntries) != SUCCESS) {
                    return FAIL;
                }
            }
            
        }
    }

    return smgrFlushTlsMacQueryMesg(&IccInfo, pVec->RemoteAgeTime, FALSE);
}

/* Send a TLS_MAC_AUDIT message */
PUBLIC tStatus smgrSendTlsMacAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomTlsMacConfigRequest *pMsg;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "TLS MAC AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetTlsMacDownloadInfo(&IccInfo, NULL,NULL,NULL, IOM_TLS_MAC_AUDIT,SlotBitmap, FALSE);
   
    if (IccInfo.IomBitMask== 0)
        return SUCCESS;
    
    if ((pMsg = SMGR_MESG_MEM_CALLOC(1, SIZE_TLS_MAC_AUDIT_REQUEST_MSG())) == NULL) {
        SVCMGR_EVENT(NOCLASS, "Unable to obtain memory for TLS MAC audit msg"); 
        return FAIL;
    }
    
    pMsg->Op = IOM_TLS_MAC_AUDIT;
    pMsg->NumEntries = 1;

    /* Send the message to all the specified IOMs */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op,
                                IccInfo.IomBitMask, pMsg,
                                SIZE_TLS_MAC_REQUEST_MSG(pMsg->Op, pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "TLS MAC AUDIT failed: %d, for mask=%08x",s, IccInfo.IomBitMask);
    }

    smgrFreeClientMsg(pMsg, s);

    return s;
}

PRIVATE void smgrGetQosSchedPolDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                            const tQosSchedPolRec *pPol,
                                            tUint32 IomOp,
                                            tUint32 SlotBitmap,
                                            Boolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosSchedPol,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,                          
                          smgrMesgQosSchedPolCmp,
                          pPol);
}

/* Send an IOM_SCHED_POLICY_ADD message */
PUBLIC tStatus smgrSendQosSchedPolicyAddMesgPriv(tQosSchedPolRec *pPol,
                                                 tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSchedulerPolicyRequest * msg;
    int SchedulerCount = 0;
    int reqMsgSize = 0;
    tStatus s = SUCCESS;
    tVirtSchedEntryInfo EntryInfo = {0};
    
    SVCMGR_EVENT(IOM_CALL, "pol=%s inst=%u slotbitmap=0x%08x", pPol->Name, pPol->InstanceId, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetQosSchedPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_ADD,SlotBitmap,IsCardOnline);    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    SchedulerCount = avlpCount(&pPol->VSchedTbl);
    reqMsgSize = SIZE_QOS_SCHEDULER_POLICY_REQUEST_MSG(SchedulerCount);
    msg = (tIomQosSchedulerPolicyRequest *) SMGR_MESG_MEM_CALLOC(1, reqMsgSize);
    if (msg == NULL)
    {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Can not alloc mem for sched policy request");
        return FAIL;
    }
    
    msg->Op = IOM_POLICY_ADD;
    msg->Policy.PolicyId = pPol->InstanceId;

    EntryInfo.FrameBasedAccnt = pPol->Entry->tSchedulerPolicyFrameBasedAccnt;
    
    /* Initialize all the virtual schedulers */
    avlpForEach(&pPol->VSchedTbl, smgrEncodeQosVirtSchedEntry,
                AVLP_FORWARD, msg, &EntryInfo);
                
    msg->Policy.NumSchedulers = EntryInfo.EntryNum;

    /* Send the message to all applicable IOM's */

    /* We can send at most MAX_QOS_SCHEDULERS_PER_SCHEDULER_POLICY_MSG
     * schedulers per policy, so it'll just be easier to count stats
     * on a per scheduler level and then use the mesg count for the policy
     */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SchedulerCount, FALSE);

    /* Since policy can be used under port, we need to send a blocking call to
     * ensure that this message makes it to ICC before proceeding */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, msg->Op, IccInfo.IomBitMask,
                                msg, reqMsgSize, NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_SCHEDULER_TABLE, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(msg, s);

    return s;
}


/* Send an IOM_SCHED_POLICY_DELETE message */
PUBLIC tStatus smgrSendQosSchedPolicyDelMesg(tQosSchedPolRec *pPol)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSchedulerPolicyRequest * msg;
    int reqMsgSize = 0;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%s inst=%u", pPol->Name, pPol->InstanceId);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetQosSchedPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_DELETE,
                                   ALL_APPLICABLE_IOMS,FALSE);
                                    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;

    reqMsgSize = SIZE_QOS_SCHEDULER_POLICY_REQUEST_MSG(0);
    msg = (tIomQosSchedulerPolicyRequest *) SMGR_MESG_MEM_CALLOC(1, reqMsgSize);
    if (msg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Can not alloc mem for sched policy request");
        return FAIL;
    }
    
    msg->Op = IOM_POLICY_DELETE;
    msg->Policy.PolicyId = pPol->InstanceId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, msg->Op, IccInfo.IomBitMask,
                                msg, reqMsgSize, NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_SCHEDULER_TABLE, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(msg, s);

    return s;
}


/* Send an IOM_SCHED_POLICY_AUDIT message */
PUBLIC tStatus smgrSendQosSchedPolicyAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSchedulerPolicyRequest *pMsg = NULL;
    int reqMsgSize = 0;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "Scheduler Policy Audit, slot %u", SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetQosSchedPolDownloadInfo(&IccInfo, NULL,IOM_POLICY_AUDIT,
                                   ALL_APPLICABLE_IOMS,FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    reqMsgSize = SIZE_QOS_SCHEDULER_POLICY_REQUEST_MSG(1);
    pMsg = (tIomQosSchedulerPolicyRequest *)SMGR_MESG_MEM_CALLOC(1, reqMsgSize);
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for sched policy request");
        return FAIL;
    }

    pMsg->Op = IOM_POLICY_AUDIT;
    pMsg->Policy.NumSchedulers = 1; /* so the IOM doesn't complain */
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, reqMsgSize, NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "Scheduler Policy Audit failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pMsg, s);

    return s;
}

PRIVATE void smgrGetQosPolicerCtrlPolDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                    const tQosPolicerCtrlPolRec *pPol,
                                    tUint32 IomOp,
                                    tUint32 SlotBitmap,
                                    tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosPolicerCtrlPol,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,                          
                          smgrMesgQosPolicerCtrlPolCmp,
                          pPol);

}

/* Send an IOM_POLICY_ADD message */
PUBLIC tStatus smgrSendQosPolicerCtrlPolAddMesgPriv(tQosPolicerCtrlPolRec *pPol,
                                                    tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosArbiterPolicyRequest *msg;
    tUint32 ArbiterCount = 0;
    int reqMsgSize = 0;
    int i;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "pol=%s inst=%u slotbitmap=0x%08x", pPol->Name, pPol->InstanceId, SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetQosPolicerCtrlPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_ADD,
                                         SlotBitmap,IsCardOnline);
              
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;

    reqMsgSize = SIZE_QOS_ARBITER_POLICY_REQUEST_MSG(avlpCount(&pPol->ArbiterTbl) + 1); // +1 for root arbiter

    msg = (tIomQosArbiterPolicyRequest *) SMGR_MESG_MEM_CALLOC(1, reqMsgSize);
    if (msg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Can not alloc mem for policer ctrl policy request");
        return FAIL;
    }
    msg->Op = IOM_POLICY_ADD;
    msg->Policy.PolicyId = pPol->InstanceId;

    /* Encode Root Policer Attributes */
    msg->Policy.Arbiter[0].InUse = TRUE;
    strcpyn(msg->Policy.Arbiter[0].Name.Str, sizeof(msg->Policy.Arbiter[0].Name.Str), QOS_ROOT_ARBITER_NAME);
    msg->Policy.Arbiter[0].Cfg.IsRoot = TRUE;
    msg->Policy.Arbiter[0].Cfg.Rate = pPol->Entry->tQosPolicerCtrlPolRootMaxRate;
    msg->Policy.Arbiter[0].Cfg.Cfg.Root.Thresholds.MinSeparation = pPol->Entry->tQosPolicerCtrlPolMinMBSSep;
    msg->Policy.Arbiter[0].Cfg.Cfg.Root.ProfilePreference = (pPol->Entry->tQosPolicerCtrlPolProfPref == DEFVAL_tQosPolicerCtrlPolProfPref) ? FALSE : TRUE;
    for (i = 0; i <= MAX_QOS_STRICT_LEVEL; i++) {
        msg->Policy.Arbiter[0].Cfg.Cfg.Root.FixedPBS[i] =
            pPol->Entry->level[i].tQosPolicerLevelFixedMBS == VAL_tQosPolicerLevelFixedMBS_true;
        msg->Policy.Arbiter[0].Cfg.Cfg.Root.Thresholds.PBS[i] = pPol->Entry->level[i].tQosPolicerLevelCumMBS;
    }

    // encode the arbiters
    ArbiterCount++; // +1 for root
    avlpForEach(&pPol->ArbiterTbl, smgrEncodeQosPolicerArbiterEntry,
                AVLP_FORWARD, msg, &ArbiterCount);

    msg->Policy.NumArbiters = ArbiterCount;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, msg->Policy.NumArbiters, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, msg->Op, IccInfo.IomBitMask,
                                msg, reqMsgSize, NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_ARBITER_TABLE, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(msg, s);
    
    return s;
}


/* Send an IOM_POLICY_DELETE message */
PUBLIC tStatus smgrSendQosPolicerCtrlPolDelMesg(tQosPolicerCtrlPolRec *pPol)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosArbiterPolicyRequest *msg;
    int ArbiterCount = 0;  // Zero for deletes
    int reqMsgSize = 0;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%s inst=%u", pPol->Name, pPol->InstanceId);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetQosPolicerCtrlPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_DELETE,
                                         ALL_APPLICABLE_IOMS,FALSE);
                                    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;

    reqMsgSize = SIZE_QOS_ARBITER_POLICY_REQUEST_MSG(ArbiterCount);

    msg = (tIomQosArbiterPolicyRequest *) SMGR_MESG_MEM_CALLOC(1, reqMsgSize);
    if (msg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL,
                           "Can not alloc mem for policer ctrl policy request");
        return FAIL;
    }
    msg->Op = IOM_POLICY_DELETE;
    msg->Policy.PolicyId = pPol->InstanceId;
    msg->Policy.NumArbiters = ArbiterCount;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, msg->Op, IccInfo.IomBitMask,
                                msg, reqMsgSize, NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_ARBITER_TABLE, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(msg, s);

    return s;
}


/* Send an IOM_SCHED_POLICY_AUDIT message */
PUBLIC tStatus smgrSendQosPolicerCtrlPolAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosArbiterPolicyRequest *msg;
    int ArbiterCount = 0;  // Zero for audit
    int reqMsgSize = 0;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "Policer Control Policy Audit, slot %u", SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetQosPolicerCtrlPolDownloadInfo(&IccInfo, NULL,IOM_POLICY_AUDIT,
                                         ALL_APPLICABLE_IOMS,FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    reqMsgSize = SIZE_QOS_ARBITER_POLICY_REQUEST_MSG(ArbiterCount);

    msg = (tIomQosArbiterPolicyRequest *) SMGR_MESG_MEM_CALLOC(1, reqMsgSize);
    if (msg == NULL)
    {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL,
                           "Can not alloc mem for policer ctrl policy request");
        return FAIL;
    }
    msg->Op = IOM_POLICY_AUDIT;
    msg->Policy.NumArbiters = ArbiterCount;


    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, msg->Op, IccInfo.IomBitMask,
                                msg, reqMsgSize, NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "Policer Control Policy Audit failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(msg, s);

    return s;
}

PRIVATE void smgrGetSapIngQosPolDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                             const tSapIngQosPolRec *pPol,
                                             tUint32 IomOp,
                                             tUint32 SlotBitmap,
                                             tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosSapIngPol,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgQosSapIngPolCmp,
                          pPol);
}

PRIVATE void smgrBatchSapIngQosPolMacRuleAddHandler(char *Key, void *Value, void *Arg1, void *Arg2)
{
    tSapIngQosPolMacRuleRec *pRule = Value;
    tUint32 SlotBitmap = AVL_CAST_ARG_TO_INT(tSlot, Arg1);
    tSapIngQosPolRec *pPol = (tSapIngQosPolRec*) Arg2;

    smgrBatchSapIngQosPolMacRuleAddMesg(pPol, pRule,SlotBitmap,FALSE);
    
}    

PRIVATE void smgrBatchSapIngQosPolIpRuleAddHandler(char *Key, void *Value, void *Arg1, void *Arg2)
{
    tSapIngQosPolIpRuleRec *pRule = Value;
    tUint32 SlotBitmap = AVL_CAST_ARG_TO_INT(tSlot, Arg1);
    tSapIngQosPolRec *pPol = (tSapIngQosPolRec*) Arg2;

    smgrBatchSapIngQosPolIpRuleAddMesg(pPol, pRule,SlotBitmap,FALSE);
    
}    

PRIVATE void smgrBatchSapEgrQosPolIpRuleAddHandler(char *Key, void *Value, void *Arg1, void *Arg2)
{
    tSapEgrQosPolIpRuleRec *pRule = Value;
    tUint32 SlotBitmap = AVL_CAST_ARG_TO_INT(tSlot, Arg1);
    tSapEgrQosPolRec *pPol = (tSapEgrQosPolRec*) Arg2;

    smgrBatchSapEgrQosPolIpRuleAddMesg(pPol, pRule,SlotBitmap,FALSE);
    
}  
/* Send an ingress IOM_POLICY_ADD message */
PUBLIC tStatus smgrSendSapIngQosPolicyAddMesgPriv(tSapIngQosPolRec *pPol,
                                                  tBoolean SendAll,
                                                  tUint32 SlotBitmap,
                                                  tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIngressBasePolicyRequest *pTmpMsg = NULL;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "pol=%d all=%d slot=0x%08x", pMsg->PolicyId, SendAll, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapIngQosPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_ADD,SlotBitmap,IsCardOnline);
                                    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;
    
    pMsg->Op = IOM_POLICY_ADD;
    
    if (runtime_feature_smgr_buffered_download) {
        /* For the buffered download to the IOMs, we need to allocate new memory
         * for the buffered message */
        pTmpMsg = (tIomQosSapIngressBasePolicyRequest *)SMGR_MESG_MEM_MALLOC(sizeof(*pTmpMsg));
        if (pTmpMsg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for policy request");
            return FAIL;
        }
        memcpy(pTmpMsg, pMsg, sizeof(*pTmpMsg));
    } else {
        pTmpMsg = pMsg;
    }
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pTmpMsg->Op, IccInfo.IomBitMask,
                                pTmpMsg, sizeof(*pTmpMsg), NULL, SMGR_DNDLER_MAY_BLOCK);
                                
    if (runtime_feature_smgr_buffered_download) {
        smgrFreeClientMsg(pTmpMsg, s);
        pTmpMsg = NULL;
    }
        
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_INGRESS_SAP_BASE_TABLE, IccInfo.IomBitMask);
        return s;
    }     
    
    return s;
}    


/* Send an ingress IOM_POLICY_DELETE message */
PUBLIC tStatus smgrSendSapIngQosPolicyDelMesg(tSapIngQosPolRec *pPol,
                                              tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIngressBasePolicyRequest *pTmpMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d slot=0x%x", pMsg->PolicyId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapIngQosPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_DELETE,SlotBitmap,FALSE);
    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;
    
    pMsg->Op = IOM_POLICY_DELETE;
    
    if (runtime_feature_smgr_buffered_download) {
        /* For the buffered download to the IOMs, we need to allocate new memory
         * for the buffered message */
        pTmpMsg = (tIomQosSapIngressBasePolicyRequest *)SMGR_MESG_MEM_MALLOC(sizeof(*pTmpMsg));
        if (pTmpMsg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for policy request");
            return FAIL;
        }
        memcpy(pTmpMsg, pMsg, sizeof(*pTmpMsg));
    } else {
        pTmpMsg = pMsg;
    }
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);    

    /* This is a blocking call since the sap-ingress policy may contain configuration that are
     * expensive (e.g. ip-/ipv6 criteria that may require CAM programming) */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pTmpMsg->Op, IccInfo.IomBitMask,
                                pTmpMsg, sizeof(*pTmpMsg), NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_INGRESS_SAP_BASE_TABLE, IccInfo.IomBitMask);

    if (runtime_feature_smgr_buffered_download)
        smgrFreeClientMsg(pTmpMsg, s);

    return s;
}


/* Send an ingress IOM_POLICY_AUDIT message */
PUBLIC tStatus smgrSendSapIngQosPolicyAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "Sap Ing Policy Audit, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapIngQosPolDownloadInfo(&IccInfo,NULL,IOM_POLICY_AUDIT,
                                    SlotBitmap, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    pMsg = (tIomQosSapIngressBasePolicyRequest *)SMGR_MESG_MEM_CALLOC(1, sizeof(*pMsg));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for policy request");
        return FAIL;
    }

    pMsg->Op = IOM_POLICY_AUDIT;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);    
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, sizeof(*pMsg), NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "Sap Ing Policy Audit failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pMsg, s);

    return s;
}

PRIVATE void smgrGetSapIngQosPolIpRuleDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                   const tSapIngQosPolRec *pPol,int ruleNum,
                                                   tUint32 IomOp,
                                                   tUint32 SlotBitmap,
                                                   tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosSapIngPolIpFilter,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgQosSapIngPolIpFilterCmp,
                          pPol,ruleNum);
}


/* Send an IOM_IP_RULE_ADD message */
PUBLIC tStatus smgrSendSapIngQosPolIpRuleAddMesg(tSapIngQosPolRec *pPol, 
                                                 tSapIngQosPolIpRuleRec *pRule,
                                                 tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIpFilterRuleRequest *pIpFltrMsg = NULL;
    STRUCT_tSapIngressIPCriteriaEntry *pEntry = pRule->Entry;
    tBoolean isIpv6 = QOS_IS_IPV6INDEX(pEntry->tSapIngressIPCriteriaIndex);
    eQosIpType qosIpType= isIpv6 ? QOS_IPTYPE_IPv6 : QOS_IPTYPE_IP;
    
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d type %s", 
                 QOS_ANYINDEX_2_INDEX(pMsg->PolicyId), 
                 QOS_ANYINDEX_2_INDEX(pRule->Id),
                 qos_IpType_Name[qosIpType]);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
     smgrGetSapIngQosPolIpRuleDownloadInfo(&IccInfo, pPol,pRule->Id,
                                           IOM_IP_RULE_ADD,SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pIpFltrMsg
        = (tIomQosSapIpFilterRuleRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_SAP_IP_FILTER_MSG(1));
    if (pIpFltrMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IP rule");
        return FAIL;
    }
    
    pIpFltrMsg->Op = IOM_IP_RULE_ADD;
    pIpFltrMsg->PolicyId = pMsg->PolicyId;
    pIpFltrMsg->NumIpRules = 1;
    smgrEncodeSapIngQosPolIpRule(&pIpFltrMsg->IpRules[0], pEntry);
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pIpFltrMsg->Op, IccInfo.IomBitMask,
                                pIpFltrMsg,
                                SIZE_QOS_SAP_IP_FILTER_MSG(pIpFltrMsg->NumIpRules),
                                NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_INGRESS_SAP_IP_FILTER_TABLE, IccInfo.IomBitMask );

    smgrFreeClientMsg(pIpFltrMsg, s);

    return s;    
}

/* Flush batched up IOM_IP_RULE_ADD messages */
PRIVATE tStatus smgrDoFlushSapIngQosPolIpRuleAddMesg(tBoolean PreFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevQosSapIngIpFilterIomBitMask;
    tStatus s = SUCCESS;
    
    if (!pQosSapIngIpFilterAddReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x", pQosSapIngIpFilterAddReqMesg->NumIpRules, IomBitMask);

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_QosSapIngPolIpFilter,
                               pQosSapIngIpFilterAddReqMesg->Op);
    
    if (pQosSapIngIpFilterAddReqMesg->NumIpRules > 0) {
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                   pQosSapIngIpFilterAddReqMesg->NumIpRules, PreFlush);
                                   
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pQosSapIngIpFilterAddReqMesg->Op,
                                    IomBitMask, pQosSapIngIpFilterAddReqMesg,
                                    SIZE_QOS_SAP_IP_FILTER_MSG(
                                        pQosSapIngIpFilterAddReqMesg->NumIpRules),
                                    NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextQosSapIngIpFilterAddEntry = 0;
        smgrFreeClientMsg(pQosSapIngIpFilterAddReqMesg, s);
        pQosSapIngIpFilterAddReqMesg = NULL;
    }
    
    return s;
}

PRIVATE tStatus smgrFlushSapIngQosPolIpRuleAddMesg(void)
{
    return smgrDoFlushSapIngQosPolIpRuleAddMesg(FALSE);
}

/* Batch up a IOM_IP_RULE_ADD message */
PRIVATE tStatus smgrBatchSapIngQosPolIpRuleAddMesg(tSapIngQosPolRec *pPol, 
                                                   tSapIngQosPolIpRuleRec *pRule,
                                                   tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    STRUCT_tSapIngressIPCriteriaEntry *pEntry=NULL;
            
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d", pPol->Id, pRule->Id);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapIngQosPolIpRuleDownloadInfo(&IccInfo, pPol,pRule->Id, IOM_IP_RULE_ADD,SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
     
    if ((pQosSapIngIpFilterAddReqMesg) && (((NextQosSapIngIpFilterAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevQosSapIngIpFilterIomBitMask)) ||
        (pQosSapIngIpFilterAddReqMesg->PolicyId != pPol->Id)))
        smgrDoFlushSapIngQosPolIpRuleAddMesg(TRUE);
    
    /* Set the bit mask */
    PrevQosSapIngIpFilterIomBitMask = IccInfo.IomBitMask;

    if (!pQosSapIngIpFilterAddReqMesg) {
        if ((pQosSapIngIpFilterAddReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_QOS_SAP_IP_FILTER_MSG(SMMaxNumIpQosFilterRuleEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }

    /* Add new entry */
    pQosSapIngIpFilterAddReqMesg->Op = IOM_IP_RULE_ADD;
    pQosSapIngIpFilterAddReqMesg->PolicyId = pPol->Id;
    
    pEntry = pRule->Entry;
    smgrEncodeSapIngQosPolIpRule(&pQosSapIngIpFilterAddReqMesg->IpRules[NextQosSapIngIpFilterAddEntry], pEntry);
    
    pQosSapIngIpFilterAddReqMesg->NumIpRules = NextQosSapIngIpFilterAddEntry + 1;

    /* If we reached the limit, flush the message */
    if (pQosSapIngIpFilterAddReqMesg->NumIpRules == SMMaxNumIpQosFilterRuleEntriesPerMesg) {
        s = smgrFlushSapIngQosPolIpRuleAddMesg();
    } else {
        NextQosSapIngIpFilterAddEntry++;
    }

    return s;
}
    

/* Send an IOM_IP_RULE_DELETE message */
PUBLIC tStatus smgrSendSapIngQosPolIpRuleDelMesg(tSapIngQosPolRec *pPol, 
                                                 int RuleNum,
                                                 tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIpFilterRuleRequest *pIpFltrMsg = NULL;
    tStatus s = SUCCESS;
    tBoolean isIpv6 = QOS_IS_IPV6INDEX(RuleNum);
    eQosIpType qosIpType= isIpv6 ? QOS_IPTYPE_IPv6 : QOS_IPTYPE_IP;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d type %s",
                 pMsg->PolicyId, QOS_ANYINDEX_2_INDEX(RuleNum), 
                 qos_IpType_Name[qosIpType]);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapIngQosPolIpRuleDownloadInfo(&IccInfo, pPol,RuleNum,
                                          IOM_IP_RULE_DELETE,SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pIpFltrMsg
        = (tIomQosSapIpFilterRuleRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_SAP_IP_FILTER_MSG(1));
    if (pIpFltrMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IP rule");
        return FAIL;
    }
    
    pIpFltrMsg->Op = IOM_IP_RULE_DELETE;
    pIpFltrMsg->PolicyId = pMsg->PolicyId;
    pIpFltrMsg->NumIpRules = 1;
    pIpFltrMsg->IpRules[0].IsIpv6 = isIpv6;
    pIpFltrMsg->IpRules[0].RuleIndex = QOS_ANYINDEX_2_INDEX(RuleNum);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pIpFltrMsg->Op, IccInfo.IomBitMask,
                                pIpFltrMsg,
                                SIZE_QOS_SAP_IP_FILTER_MSG(pIpFltrMsg->NumIpRules),
                                NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_INGRESS_SAP_IP_FILTER_TABLE, IccInfo.IomBitMask );

    smgrFreeClientMsg(pIpFltrMsg, s);

    return s;    
}

PRIVATE void smgrGetSapIngQosPolMacRuleDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                    const tSapIngQosPolRec *pPol,int ruleNum,
                                                    tUint32 IomOp,
                                                    tUint32 SlotBitmap,
                                                    tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosSapIngPolMacFilter,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgQosSapIngPolMacFilterCmp,
                          pPol,ruleNum);
}

/* Send an IOM_MAC_RULE_ADD message */
PUBLIC tStatus smgrSendSapIngQosPolMacRuleAddMesg(tSapIngQosPolRec *pPol, 
                                                  tSapIngQosPolMacRuleRec *pRule,
                                                  tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIngressMacFilterRuleRequest *pMacFltrMsg;
    STRUCT_tSapIngressMacCriteriaEntry *pEntry = pRule->Entry;
    tStatus s = SUCCESS;
    tInt32  macfltrType = VAL_tSapIngressMacCritType_normal;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d", pMsg->PolicyId, pRule->Id);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapIngQosPolMacRuleDownloadInfo(&IccInfo, pPol,
                                           pRule->Id, IOM_MAC_RULE_ADD,
                                           SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if (pPol && pPol->Entry)
        macfltrType = pPol->Entry->tSapIngressMacCritType;

    pMacFltrMsg 
        = (tIomQosSapIngressMacFilterRuleRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(1));
    if (pMacFltrMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for MAC rule");
        return FAIL;
    }

    pMacFltrMsg->Op = IOM_MAC_RULE_ADD;
    pMacFltrMsg->PolicyId = pMsg->PolicyId;
    pMacFltrMsg->NumMacRules = 1;
    smgrEncodeSapIngQosPolMacRule(macfltrType, &pMacFltrMsg->MacRules[0], pEntry);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMacFltrMsg->Op, IccInfo.IomBitMask,
                                pMacFltrMsg,
                                SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(pMacFltrMsg->NumMacRules),
                                NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_INGRESS_SAP_MAC_FILTER_TABLE, IccInfo.IomBitMask);

    smgrFreeClientMsg(pMacFltrMsg, s);

    return s;    
}

/* Flush batched up IOM_MAC_RULE_ADD messages */
PRIVATE tStatus smgrDoFlushSapIngQosPolMacRuleAddMesg(tBoolean PreFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevQosSapIngMacFilterIomBitMask;
    tStatus s = SUCCESS;
    
    if (!pQosSapIngMacFilterAddReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x", pQosSapIngMacFilterAddReqMesg->NumMacRules,
                 IomBitMask);
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_QosSapIngPolMacFilter,
                               IOM_MAC_RULE_ADD);
    
    if (pQosSapIngMacFilterAddReqMesg->NumMacRules > 0) {
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                   pQosSapIngMacFilterAddReqMesg->NumMacRules,
                                   PreFlush);

        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pQosSapIngMacFilterAddReqMesg->Op,
                                    IomBitMask, pQosSapIngMacFilterAddReqMesg,
                                    SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(
                                        pQosSapIngMacFilterAddReqMesg->NumMacRules),
                                    NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextQosSapIngMacFilterAddEntry = 0;
        smgrFreeClientMsg(pQosSapIngMacFilterAddReqMesg, s);
        pQosSapIngMacFilterAddReqMesg = NULL;
    }

    return s;
}

PRIVATE tStatus smgrFlushSapIngQosPolMacRuleAddMesg(void)
{
    return smgrDoFlushSapIngQosPolMacRuleAddMesg(FALSE);
}

/* Batch up a IOM_MAC_RULE_ADD message */
PRIVATE tStatus smgrBatchSapIngQosPolMacRuleAddMesg(tSapIngQosPolRec *pPol, 
                                                    tSapIngQosPolMacRuleRec *pRule,
                                                    tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    tInt32  macfltrType = VAL_tSapIngressMacCritType_normal;

    STRUCT_tSapIngressMacCriteriaEntry *pEntry=NULL;
            
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d", pPol->Id, pRule->Id);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapIngQosPolMacRuleDownloadInfo(&IccInfo, pPol,pRule->Id, IOM_MAC_RULE_ADD,SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if (pPol && pPol->Entry)
        macfltrType = pPol->Entry->tSapIngressMacCritType;

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
     
    if ((pQosSapIngMacFilterAddReqMesg) && (((NextQosSapIngMacFilterAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevQosSapIngMacFilterIomBitMask)) ||
        (pQosSapIngMacFilterAddReqMesg->PolicyId != pPol->Id)))
        smgrDoFlushSapIngQosPolMacRuleAddMesg(TRUE);
    
    /* Set the bit mask */
    PrevQosSapIngMacFilterIomBitMask = IccInfo.IomBitMask;

    if (!pQosSapIngMacFilterAddReqMesg) {
        if ((pQosSapIngMacFilterAddReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(SMMaxNumMacQosFilterRuleEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }

    /* Add new entry */
    pQosSapIngMacFilterAddReqMesg->Op = IOM_MAC_RULE_ADD;
    pQosSapIngMacFilterAddReqMesg->PolicyId = pPol->Id;
    
    pEntry = pRule->Entry;
    smgrEncodeSapIngQosPolMacRule(macfltrType, &pQosSapIngMacFilterAddReqMesg->MacRules[NextQosSapIngMacFilterAddEntry], pEntry);
    
    pQosSapIngMacFilterAddReqMesg->NumMacRules = NextQosSapIngMacFilterAddEntry + 1;

    /* If we reached the limit, flush the message */
    if (pQosSapIngMacFilterAddReqMesg->NumMacRules == SMMaxNumMacQosFilterRuleEntriesPerMesg) {
        s = smgrFlushSapIngQosPolMacRuleAddMesg();
    } else {
        NextQosSapIngMacFilterAddEntry++;
    }

    return s;
}


/* Send an IOM_MAC_RULE_DELETE message */
PUBLIC tStatus smgrSendSapIngQosPolMacRuleDelMesg(tSapIngQosPolRec *pPol, 
                                                  int RuleNum,
                                                  tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapIngressBasePolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIngressMacFilterRuleRequest *pMacFltrMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d", pMsg->PolicyId, RuleNum);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
   SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapIngQosPolMacRuleDownloadInfo(&IccInfo, pPol,RuleNum,
                                           IOM_MAC_RULE_DELETE,SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pMacFltrMsg
        = (tIomQosSapIngressMacFilterRuleRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(1));
    if (pMacFltrMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for MAC rule");
        return FAIL;
    }
    
    pMacFltrMsg->Op = IOM_MAC_RULE_DELETE;
    pMacFltrMsg->PolicyId = pMsg->PolicyId;
    pMacFltrMsg->NumMacRules = 1;
    pMacFltrMsg->MacRules[0].RuleIndex = RuleNum;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMacFltrMsg->Op, IccInfo.IomBitMask,
                                pMacFltrMsg,
                                SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(pMacFltrMsg->NumMacRules),
                                NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_INGRESS_SAP_MAC_FILTER_TABLE, IccInfo.IomBitMask);

    smgrFreeClientMsg(pMacFltrMsg, s);

    return s;    
}

PRIVATE void smgrGetSapEgrQosPolDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                             const tSapEgrQosPolRec *pPol,
                                             tUint32 IomOp,
                                             tUint32 SlotBitmap,
                                             tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosSapEgrPol,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgQosSapEgrPolCmp,
                          pPol);
}

/* Send an egress IOM_POLICY_ADD message */
PUBLIC tStatus smgrSendSapEgrQosPolicyAddMesgPriv(tSapEgrQosPolRec *pPol,
                                                  tBoolean SendAll,
                                                  tUint32 SlotBitmap,
                                                  tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapEgressPolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapEgressPolicyRequest *pTmpMsg = NULL;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "pol=%d slotbitmap=0x%08x", pMsg->PolicyId, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapEgrQosPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_ADD,
                                    SlotBitmap,IsCardOnline);
                                    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;
    
    pMsg->Op = IOM_POLICY_ADD;
    
    if (runtime_feature_smgr_buffered_download) {
        /* For the buffered download to the IOMs, we need to allocate new memory
         * for the buffered message */
        pTmpMsg = (tIomQosSapEgressPolicyRequest *)SMGR_MESG_MEM_MALLOC(sizeof(*pTmpMsg));
        if (pTmpMsg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for policy request");
            return FAIL;
        }
        memcpy(pTmpMsg, pMsg, sizeof(*pTmpMsg));
    } else {
        pTmpMsg = pMsg;
    }
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pTmpMsg->Op, IccInfo.IomBitMask,
                                pTmpMsg, sizeof(*pTmpMsg), NULL,
                                pPol->BlkDnldToIom? SMGR_DNDLER_BLOCK : SMGR_DNDLER_MAY_BLOCK);

    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_EGRESS_SAP_TABLE, IccInfo.IomBitMask);
                                
    if (runtime_feature_smgr_buffered_download) {
        smgrFreeClientMsg(pTmpMsg, s);
        pTmpMsg = NULL;
    }
    
    pPol->BlkDnldToIom = FALSE;

    return s;    
}    


/* Send an egress IOM_POLICY_DELETE message */
PUBLIC tStatus smgrSendSapEgrQosPolicyDelMesg(tSapEgrQosPolRec *pPol,
                                              tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapEgressPolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapEgressPolicyRequest *pTmpMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d slot=0x%x", pMsg->PolicyId, SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapEgrQosPolDownloadInfo(&IccInfo,pPol,IOM_POLICY_DELETE,
                                    SlotBitmap,FALSE);
                                    
    if (IccInfo.IomBitMask  == 0)
        return SUCCESS;
    
    pMsg->Op = IOM_POLICY_DELETE;
    
    if (runtime_feature_smgr_buffered_download) {
        /* For the buffered download to the IOMs, we need to allocate new memory
         * for the buffered message */
        pTmpMsg = (tIomQosSapEgressPolicyRequest *)SMGR_MESG_MEM_MALLOC(sizeof(*pTmpMsg));
        if (pTmpMsg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for policy request");
            return FAIL;
        }
        memcpy(pTmpMsg, pMsg, sizeof(*pTmpMsg));
    } else {
        pTmpMsg = pMsg;
    }

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    /* This is a blocking call since the sap-egress policy may contain configuration that are
     * destined to non-SVCMGR sockets, e.g. hsmda-queues wrr-policy */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pTmpMsg->Op, IccInfo.IomBitMask,
                                pTmpMsg, sizeof(*pTmpMsg), NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_EGRESS_SAP_TABLE, IccInfo.IomBitMask);

    if (runtime_feature_smgr_buffered_download)
        smgrFreeClientMsg(pTmpMsg, s);
    
    return s;
}


/* Send an egress IOM_POLICY_AUDIT message */
PUBLIC tStatus smgrSendSapEgrQosPolicyAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapEgressPolicyRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;

    SVCMGR_EVENT(IOM_CALL, "Sap Egress Policy Audit, slot %u", SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrQosPolDownloadInfo(&IccInfo, NULL, IOM_POLICY_AUDIT,
                                    SlotBitmap,FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pMsg = (tIomQosSapEgressPolicyRequest *)SMGR_MESG_MEM_CALLOC(1, sizeof(*pMsg));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for policy request");
        return FAIL;
    }
    
    pMsg->Op = IOM_POLICY_AUDIT;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, sizeof(*pMsg), NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "Sap Egress Policy Audit failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pMsg, s);
    
    return s;    
}    

PRIVATE void smgrGetSapEgrQosPolIpRuleDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                   const tSapEgrQosPolRec *pPol,
                                                   const tSapEgrQosPolIpRuleId *pRuleId,
                                                   tUint32 IomOp,
                                                   tUint32 SlotBitmap,
                                                   tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosSapEgrPolIpFilter,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgQosSapEgrPolIpFilterCmp,
                          pPol,pRuleId);
}


/* Send an IOM_IP_RULE_ADD message */
PUBLIC tStatus smgrSendSapEgrQosPolIpRuleAddMesg(tSapEgrQosPolRec *pPol, 
                                                 tSapEgrQosPolIpRuleRec *pRule,
                                                 tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapEgressPolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIpFilterRuleRequest *pIpFltrMsg = NULL;
    STRUCT_tSapEgrIPCritEntry *pEntry = pRule->Entry;
    tBoolean isIpv6 = (pRule->Id.FltrType == VAL_tSapEgrIPCritAddrType_ipv6);
    eQosIpType qosIpType= isIpv6 ? QOS_IPTYPE_IPv6 : QOS_IPTYPE_IP;
    
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d type %s", 
                 pMsg->PolicyId, pRule->Id.EntryId, qos_IpType_Name[qosIpType]);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapEgrQosPolIpRuleDownloadInfo(&IccInfo, pPol,&pRule->Id, IOM_IP_RULE_ADD,SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pIpFltrMsg
        = (tIomQosSapIpFilterRuleRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_SAP_IP_FILTER_MSG(1));
    if (pIpFltrMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IP rule");
        return FAIL;
    }
    
    pIpFltrMsg->Op = IOM_IP_RULE_ADD;
    pIpFltrMsg->PolicyId = pMsg->PolicyId;
    pIpFltrMsg->NumIpRules = 1;
    smgrEncodeSapEgrQosPolIpRule(&pIpFltrMsg->IpRules[0], pEntry);
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pIpFltrMsg->Op, IccInfo.IomBitMask,
                                pIpFltrMsg,
                                SIZE_QOS_SAP_IP_FILTER_MSG(pIpFltrMsg->NumIpRules),
                                NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_EGRESS_SAP_IP_FILTER_TABLE, IccInfo.IomBitMask );

    smgrFreeClientMsg(pIpFltrMsg, s);

    return s;    
}

/* Flush batched up IOM_IP_RULE_ADD messages */
PRIVATE tStatus smgrDoFlushSapEgrQosPolIpRuleAddMesg(tBoolean PreFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevQosSapEgrIpFilterIomBitMask;
    tStatus s = SUCCESS;
    
    if (!pQosSapEgrIpFilterAddReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                 pQosSapEgrIpFilterAddReqMesg->NumIpRules, IomBitMask);
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_QosSapEgrPolIpFilter,
                               pQosSapEgrIpFilterAddReqMesg->Op);
    
    if (pQosSapEgrIpFilterAddReqMesg->NumIpRules > 0) {
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                   pQosSapEgrIpFilterAddReqMesg->NumIpRules,
                                   PreFlush);

        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pQosSapEgrIpFilterAddReqMesg->Op,
                                    IomBitMask, pQosSapEgrIpFilterAddReqMesg,
                                    SIZE_QOS_SAP_IP_FILTER_MSG(
                                        pQosSapEgrIpFilterAddReqMesg->NumIpRules),
                                    NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextQosSapEgrIpFilterAddEntry = 0;
        smgrFreeClientMsg(pQosSapEgrIpFilterAddReqMesg, s);
        pQosSapEgrIpFilterAddReqMesg = NULL;
    }

    return s;
}

PRIVATE tStatus smgrFlushSapEgrQosPolIpRuleAddMesg(void)
{
    return smgrDoFlushSapEgrQosPolIpRuleAddMesg(FALSE);
}

/* Batch up a IOM_IP_RULE_ADD message */
PRIVATE tStatus smgrBatchSapEgrQosPolIpRuleAddMesg(tSapEgrQosPolRec *pPol, 
                                                  tSapEgrQosPolIpRuleRec *pRule,
                                                  tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    STRUCT_tSapEgrIPCritEntry *pEntry=NULL;
            
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule filtertype=%d entryId=%d", pPol->Id,
                 pRule->Id.FltrType,pRule->Id.EntryId);
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapEgrQosPolIpRuleDownloadInfo(&IccInfo, pPol,&pRule->Id,
                                          IOM_IP_RULE_ADD,SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
     
    if ((pQosSapEgrIpFilterAddReqMesg) && (((NextQosSapEgrIpFilterAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevQosSapEgrIpFilterIomBitMask)) ||
        (pQosSapEgrIpFilterAddReqMesg->PolicyId != pPol->Id)))
        smgrDoFlushSapEgrQosPolIpRuleAddMesg(TRUE);
    
    /* Set the bit mask */
    PrevQosSapEgrIpFilterIomBitMask = IccInfo.IomBitMask;

    if (!pQosSapEgrIpFilterAddReqMesg) {
        if ((pQosSapEgrIpFilterAddReqMesg = SMGR_MESG_MEM_MALLOC(
                 SIZE_QOS_SAP_IP_FILTER_MSG(SMMaxNumIpQosFilterRuleEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }

    /* Add new entry */
    pQosSapEgrIpFilterAddReqMesg->Op = IOM_IP_RULE_ADD;
    pQosSapEgrIpFilterAddReqMesg->PolicyId = pPol->Id;
    
    pEntry = pRule->Entry;
    smgrEncodeSapEgrQosPolIpRule(
        &pQosSapEgrIpFilterAddReqMesg->IpRules[NextQosSapEgrIpFilterAddEntry], pEntry);
    
    pQosSapEgrIpFilterAddReqMesg->NumIpRules = NextQosSapEgrIpFilterAddEntry + 1;

    /* If we reached the limit, flush the message */
    if (pQosSapEgrIpFilterAddReqMesg->NumIpRules == SMMaxNumIpQosFilterRuleEntriesPerMesg) {
        s = smgrFlushSapEgrQosPolIpRuleAddMesg();
    } else {
        NextQosSapEgrIpFilterAddEntry++;
    }

    return s;
}
        

/* Send an IOM_IP_RULE_DELETE message */
PUBLIC tStatus smgrSendSapEgrQosPolIpRuleDelMesg(tSapEgrQosPolRec *pPol, 
                                                 tSapEgrQosPolIpRuleId *pRuleId,
                                                 tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosSapEgressPolicyRequest *pMsg = &pPol->IomMsg;
    tIomQosSapIpFilterRuleRequest *pIpFltrMsg = NULL;
    tStatus s = SUCCESS;
    tBoolean isIpv6 = (pRuleId->FltrType == VAL_tSapEgrIPCritAddrType_ipv6);
    eQosIpType qosIpType= isIpv6 ? QOS_IPTYPE_IPv6 : QOS_IPTYPE_IP;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "pol=%d rule=%d type %s", pMsg->PolicyId,
                 pRuleId->EntryId, qos_IpType_Name[qosIpType]);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrQosPolIpRuleDownloadInfo(&IccInfo, pPol,pRuleId, IOM_IP_RULE_DELETE,SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pIpFltrMsg
        = (tIomQosSapIpFilterRuleRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_SAP_IP_FILTER_MSG(1));
    if (pIpFltrMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IP rule");
        return FAIL;
    }
    
    pIpFltrMsg->Op = IOM_IP_RULE_DELETE;
    pIpFltrMsg->PolicyId = pMsg->PolicyId;
    pIpFltrMsg->NumIpRules = 1;
    pIpFltrMsg->IpRules[0].IsIpv6 = isIpv6;
    pIpFltrMsg->IpRules[0].RuleIndex = pRuleId->EntryId;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, pIpFltrMsg->NumIpRules, FALSE);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pIpFltrMsg->Op, IccInfo.IomBitMask,
                                pIpFltrMsg,
                                SIZE_QOS_SAP_IP_FILTER_MSG(pIpFltrMsg->NumIpRules),
                                NULL, SMGR_DNDLER_BLOCK); /* Programming the CAM can take a long time */
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for sock=%d mask=%08x !",
                     ICC_SOCKET_QOS_POLICY_EGRESS_SAP_IP_FILTER_TABLE, IccInfo.IomBitMask);

    smgrFreeClientMsg(pIpFltrMsg, s);

    return s;    
}


PRIVATE void smgrGetMssDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                    const tMssRec *pMss,
                                    tUint32 IomOp,
                                    tUint32 SlotBitmap,
                                    tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosMss,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgCustMssCmp,
                          pMss);
}

/* Send an IOM_MULTI_SERVICE_SITE_ADD message */
PUBLIC tStatus smgrSendMultSvcSiteAddMesg(tMssRec *pMss, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosMultiServiceSiteRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    tBoolean BlockType = SMGR_DNDLER_MAY_BLOCK;
    
    SVCMGR_EVENT(IOM_CALL, "cust=%u mss=%s slot=%d",
                 pMss->CustRec->Id, pMss->Name, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetMssDownloadInfo(&IccInfo, pMss, IOM_POLICY_ADD,
                           SlotBitmap, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    pMsg = (tIomQosMultiServiceSiteRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_MULTI_SERVICE_SITE_MSG(1));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }
    
    pMsg->Op = IOM_POLICY_ADD;
    pMsg->NumSites = 1;
    smgrInitMssAddReqEntry(&pMsg->Sites[0], pMss);
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, pMsg->NumSites, FALSE);
    
    if (pMss->BlkDnldToIom) {
        BlockType = SMGR_DNDLER_BLOCK;
        pMss->BlkDnldToIom = FALSE;
    }

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_QOS_MULTI_SERVICE_SITE_MSG(pMsg->NumSites),
                                NULL, BlockType);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;                                  
}



/* Flush batched up IOM_MULTI_SERVICE_SITE_ADD messages */
PRIVATE tStatus smgrDoFlushMultSvcSiteAddMesg(tBoolean PreFlush)
{
    tSmgrMsgrIccInfo IccInfo;
    tUint32 IomBitMask = PrevMssAddIomBitMask;
    tStatus s = SUCCESS;
    
    if (!pMssAddReqMesg)
        return SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x", pMssAddReqMesg->NumSites, IomBitMask);

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_QosMss,
                               IOM_POLICY_ADD);
    
    if (pMssAddReqMesg->NumSites > 0) {        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, pMssAddReqMesg->NumSites, PreFlush);

        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMssAddReqMesg->Op, IomBitMask,
                                    pMssAddReqMesg, 
                                    SIZE_QOS_MULTI_SERVICE_SITE_MSG(pMssAddReqMesg->NumSites),
                                    NULL, MssDnldBlockType);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextMssAddEntry = 0;
        smgrFreeClientMsg(pMssAddReqMesg, s);
        pMssAddReqMesg = NULL;
        MssDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
    }
    
    return s;
}

/* Batch up a IOM_MULTI_SERVICE_SITE_ADD message */
PUBLIC tStatus smgrBatchMultSvcSiteAddMesgPriv(tMssRec *pMss, tUint32 SlotBitmap, tBoolean IsCardOnline,
                                               tBatchProcessing *pBatch)
{
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "cust=%u mss=%s slotbitmap=0x%08x",
                 pMss->CustRec->Id, pMss->Name, SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetMssDownloadInfo(&IccInfo, pMss, IOM_POLICY_ADD,
                           SlotBitmap, IsCardOnline);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((pMssAddReqMesg) && (NextMssAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevMssAddIomBitMask))
        smgrDoFlushMultSvcSiteAddMesg(TRUE);
    
    /* Set the bit mask */
    PrevMssAddIomBitMask = IccInfo.IomBitMask;

    if (!pMssAddReqMesg) {
        if ((pMssAddReqMesg = SMGR_MESG_MEM_MALLOC(SIZE_QOS_MULTI_SERVICE_SITE_MSG(SMMaxNumQosMssEntriesPerMesg))) == NULL) {
            return FAIL;
        }
    }
    
    /* Add new entry */
    pMssAddReqMesg->Op = IOM_POLICY_ADD;
    pMssAddReqMesg->NumSites = NextMssAddEntry + 1;
    smgrInitMssAddReqEntry(&pMssAddReqMesg->Sites[NextMssAddEntry], pMss);

    if (pMss->BlkDnldToIom) {
        MssDnldBlockType = SMGR_DNDLER_BLOCK;
        pMss->BlkDnldToIom = FALSE;
    }

    /* If we reached the limit, flush the message */
    if (pMssAddReqMesg->NumSites == SMMaxNumQosMssEntriesPerMesg) {
        s = smgrDoFlushMultSvcSiteAddMesg(FALSE);
        if (pBatch)
            pBatch->MultSvcSiteAddSent = FALSE;
    } else {
        NextMssAddEntry++;
        if (pBatch)
            pBatch->MultSvcSiteAddSent = TRUE;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushMultSvcSiteAddMesg(void)
{
    return smgrDoFlushMultSvcSiteAddMesg(FALSE);
}

/* Send an IOM_MULTI_SERVICE_SITE_DELETE message */
PUBLIC tStatus smgrSendMultSvcSiteDelMesg(tMssRec *pMss)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosMultiServiceSiteRequest *pMsg = NULL;
    tStatus s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "cust=%u mss=%s",
                 pMss->CustRec->Id, pMss->Name);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetMssDownloadInfo(&IccInfo, pMss, IOM_POLICY_DELETE,
                           ALL_APPLICABLE_IOMS, FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
         
    pMsg = (tIomQosMultiServiceSiteRequest *)SMGR_MESG_MEM_MALLOC(SIZE_QOS_MULTI_SERVICE_SITE_MSG(1));
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }
    
    pMsg->Op = IOM_POLICY_DELETE;
    pMsg->NumSites = 1;

    ZERO_STRUCT(pMsg->Sites[0]);

    pMsg->Sites[0].SiteId = pMss->InstanceId;

    /* Send the message to all the IOMs in the chassis that are
     * currently on-line.
     */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, pMsg->NumSites, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_QOS_MULTI_SERVICE_SITE_MSG(pMsg->NumSites),
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;
}

PRIVATE tUint16 smgrEncodeSapQueueOverrideFlags(tQueueOverrideRec *pQueue, int Direction)
{
    tUint16   QFlags;

    QFlags  = 0;

    if (Direction == SAP_ING_QOS_QUEUE) {
        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_cbs))
            QFlags |= QOS_ELEMENT_OVERRIDE_CBS;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_cir))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_cirPercent))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR; // we use the same override flag for CIR and CIRPercent

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_cirAdaptRule))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR_RULE;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_mbs))
            QFlags |= QOS_ELEMENT_OVERRIDE_MBS;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_pir))
            QFlags |= QOS_ELEMENT_OVERRIDE_PIR;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_pirPercent))
            QFlags |= QOS_ELEMENT_OVERRIDE_PIR; // we use the same override flag for PIR and PIRPercent

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_pirAdaptRule))
            QFlags |= QOS_ELEMENT_OVERRIDE_PIR_RULE;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_hiPrioOnly))
            QFlags |= QOS_ELEMENT_OVERRIDE_HI_PRIO_ONLY;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_avgOverhead))
            QFlags |= QOS_ELEMENT_OVERRIDE_AVG_OVERHEAD;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_weight))
            QFlags |= QOS_ELEMENT_OVERRIDE_WEIGHT;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_cirWeight))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR_WEIGHT;
    } else {
        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_cbs))
            QFlags |= QOS_ELEMENT_OVERRIDE_CBS;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_cir))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_cirPercent))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR; // we use the same override flag for CIR and CIRPercent

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_cirAdaptRule))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR_RULE;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_mbs))
            QFlags |= QOS_ELEMENT_OVERRIDE_MBS;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_pir))
            QFlags |= QOS_ELEMENT_OVERRIDE_PIR;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_pirPercent))
            QFlags |= QOS_ELEMENT_OVERRIDE_PIR; // we use the same override flag for PIR and PIRPercent

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_pirAdaptRule))
            QFlags |= QOS_ELEMENT_OVERRIDE_PIR_RULE;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_hiPrioOnly))
            QFlags |= QOS_ELEMENT_OVERRIDE_HI_PRIO_ONLY;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_avgOverhead))
            QFlags |= QOS_ELEMENT_OVERRIDE_AVG_OVERHEAD;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_weight))
            QFlags |= QOS_ELEMENT_OVERRIDE_WEIGHT;

        if (TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_cirWeight))
            QFlags |= QOS_ELEMENT_OVERRIDE_CIR_WEIGHT;
    }

    return (QFlags);
}

PRIVATE void smgrGetSapQOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                        const tSapRec *pSap,
                                        const tQueueOverrideRec *pQueue,
                                        int Direction,
                                        tUint32 IomOp,
                                        tUint32 SlotBitmap,
                                        tBoolean IsCardOnline)
{
    int entryNum = 0;
    
    if (!pSap || !pQueue)
        return;
    
    if (Direction == SAP_ING_QOS_QUEUE) {
        entryNum = SmgrMsgrEntry_SapIngQOvr;
    } else if (Direction == SAP_EGR_QOS_QUEUE) {
        entryNum = SmgrMsgrEntry_SapEgrQOvr;
    }
    else
        return;

    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask = pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             entryNum,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgIccSapOvrCmp,
                             pSap,
                             pQueue->QosQueueId);
}
/* Send an ingress/egress QoS queue override add message */
PUBLIC tStatus smgrSendQueueOverrideAddMesg(tSapRec *pSap, int Direction,
                                            tQueueOverrideRec *pQueue, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverrideRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s queue=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QUEUE) ? "ing" : "egr",
                 pQueue->QosQueueId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapQOvrDownloadInfo(&IccInfo, pSap,pQueue,Direction,IOM_QOS_OVERRIDE_ADD,
                               SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_OVERRIDE_ADD;
    req->NumOverrides = 1;
    req->Override[0].SapId = pSap->SapId;
    req->Override[0].Qos.QueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueue->QosQueueId),
                                (Direction == SAP_ING_QOS_QUEUE));
    req->Override[0].Qos.Parms.CBS = (pQueue->CBS > 0) ?
        pQueue->CBS * 1024 : pQueue->CBS; // convert to bytes
    if (Direction == SAP_ING_QOS_QUEUE) {
        req->Override[0].Qos.Parms.IsRatePercent =
            TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_pirPercent);
        req->Override[0].Qos.Parms.IsLocalLimit =
            pSap->IngQosPolRecCfg->IomMsg.QosQueue[MIB_QID_TO_IOM_QID(pQueue->QosQueueId)].Parms.IsLocalLimit;
    } else {
        req->Override[0].Qos.Parms.IsRatePercent =
            TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_pirPercent);
        req->Override[0].Qos.Parms.IsLocalLimit =
            pSap->EgrQosPolRecCfg->IomMsg.QosQueue[MIB_QID_TO_IOM_QID(pQueue->QosQueueId)].IsLocalLimit;
    }
    req->Override[0].Qos.Parms.CIR = pQueue->CIR;
    req->Override[0].Qos.Parms.CIRRule = pQueue->CIRRule;
    req->Override[0].Qos.Parms.MBS = pQueue->MBSBytes;
    req->Override[0].Qos.Parms.PIR = pQueue->PIR;
    req->Override[0].Qos.Parms.PIRRule = pQueue->PIRRule;
    req->Override[0].Qos.Parms.HiPrioOnly = pQueue->HiPrioOnly;
    req->Override[0].Qos.Parms.AvgOverhead = pQueue->AvgOverhead;
    req->Override[0].Qos.Parms.AboveCIRWeight = pQueue->ParentWeight;
    req->Override[0].Qos.Parms.CIRWeight = pQueue->ParentCIRWeight;
    req->Override[0].Qos.Mask = smgrEncodeSapQueueOverrideFlags(pQueue, Direction);
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);
    
    return SUCCESS;
}

/* Batch up an ingress/egress QoS Queue override add message
 * (note that SAP Queue and Policer overrides get bundled in the same msg)
 */
PUBLIC tStatus smgrBatchQueueOverrideAddMesgPriv(tSapRec *pSap, int Direction,
                                                 tQueueOverrideRec *pQueue, tUint32 SlotBitmap,
                                                 tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverride *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s queue=%u slotbitmap=0x%08x",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QUEUE) ? "ing" : "egr",
                 pQueue->QosQueueId, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapQOvrDownloadInfo(&IccInfo, pSap,pQueue,Direction,IOM_QOS_OVERRIDE_ADD,
                               SlotBitmap, IsCardOnline);


    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSapQosOverrideAddEntry != 0) && (IccInfo.IomBitMask != PrevSapQosOverrideAddIomBitMask))
        smgrDoFlushSapQosOverrideAddMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevSapQosOverrideAddIomBitMask = IccInfo.IomBitMask;
    
    if (pSapQosOverrideAddReqMesg == NULL) {
        pSapQosOverrideAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(SMMaxNumQueueOverrideEntriesPerMesg));
        if (pSapQosOverrideAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }

    pSapQosOverrideAddReqMesg->Op = IOM_QOS_OVERRIDE_ADD;
    pSapQosOverrideAddReqMesg->NumOverrides = NextSapQosOverrideAddEntry + 1;

    req = &pSapQosOverrideAddReqMesg->Override[NextSapQosOverrideAddEntry];

    req->SapId = pSap->SapId;
    req->Qos.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueue->QosQueueId), (Direction == SAP_ING_QOS_QUEUE));
    req->Qos.Parms.CBS = (pQueue->CBS > 0) ? pQueue->CBS * 1024 : pQueue->CBS; // convert to bytes
    if (Direction == SAP_ING_QOS_QUEUE) {
        req->Qos.Parms.IsRatePercent = TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapIngQosQOverrideFlags_pirPercent);
        req->Qos.Parms.IsLocalLimit = pSap->IngQosPolRecCfg->IomMsg.QosQueue[MIB_QID_TO_IOM_QID(pQueue->QosQueueId)].Parms.IsLocalLimit;
    } else {
        req->Qos.Parms.IsRatePercent = TST_SNMP_BIT(pQueue->SnmpOverrideMask, VAL_sapEgrQosQOverrideFlags_pirPercent);
        req->Qos.Parms.IsLocalLimit = pSap->EgrQosPolRecCfg->IomMsg.QosQueue[MIB_QID_TO_IOM_QID(pQueue->QosQueueId)].IsLocalLimit;
    }
    req->Qos.Parms.CIR = pQueue->CIR;
    req->Qos.Parms.CIRRule = pQueue->CIRRule;
    req->Qos.Parms.MBS = pQueue->MBSBytes;
    req->Qos.Parms.PIR = pQueue->PIR;
    req->Qos.Parms.PIRRule = pQueue->PIRRule;
    req->Qos.Parms.HiPrioOnly = pQueue->HiPrioOnly;
    req->Qos.Parms.AvgOverhead = pQueue->AvgOverhead;
    req->Qos.Parms.AboveCIRWeight = pQueue->ParentWeight;
    req->Qos.Parms.CIRWeight = pQueue->ParentCIRWeight;
    req->Qos.Mask = smgrEncodeSapQueueOverrideFlags(pQueue, Direction);

    if (Direction == SAP_ING_QOS_QUEUE) {
        sapIngressQOverrideAddCount++;
    } else {
        sapEgressQOverrideAddCount++;
    }
    
    /* If we reached the limit, flush the message */
    if (pSapQosOverrideAddReqMesg->NumOverrides == SMMaxNumQueueOverrideEntriesPerMesg) {
        s = smgrFlushSapQosOverrideAddMesg();
        if (pBatch)
            pBatch->QueueOverrideAddSent = FALSE;
    } else {
        NextSapQosOverrideAddEntry++;
        if (pBatch)
            pBatch->QueueOverrideAddSent = TRUE;
    }    

    return s;
}

/* Batch up an ingress/egress QoS Queue override delete message
 * (note that SAP Queue and Policer overrides get bundled in the same msg)
 */
PUBLIC tStatus smgrBatchQueueOverrideDelMesg(tSapRec *pSap, int Direction,
                                             tQueueOverrideRec *pQueue, tSMSlot SlotNum,
                                             tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverride *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s queue=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QUEUE) ? "ing" : "egr",
                 pQueue->QosQueueId, SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapQOvrDownloadInfo(&IccInfo, pSap,pQueue,Direction,IOM_QOS_OVERRIDE_DELETE,
                               SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSapQosOverrideDelEntry != 0) && (IccInfo.IomBitMask != PrevSapQosOverrideDelIomBitMask))
        smgrDoFlushSapQosOverrideDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevSapQosOverrideDelIomBitMask = IccInfo.IomBitMask;

    if (pSapQosOverrideDelReqMesg == NULL) {
        pSapQosOverrideDelReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(SMMaxNumQueueOverrideEntriesPerMesg));
        if (pSapQosOverrideDelReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }

    pSapQosOverrideDelReqMesg->Op = IOM_QOS_OVERRIDE_DELETE;
    pSapQosOverrideDelReqMesg->NumOverrides = NextSapQosOverrideDelEntry + 1;

    req = &pSapQosOverrideDelReqMesg->Override[NextSapQosOverrideDelEntry];

    req->SapId = pSap->SapId;
    req->Qos.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueue->QosQueueId), (Direction == SAP_ING_QOS_QUEUE));

    if (Direction == SAP_ING_QOS_QUEUE) {       
        sapIngressQOverrideDelCount++;        
    } else {
        sapEgressQOverrideDelCount++;
    }
    
    /* If we reached the limit, flush the message */
    if (pSapQosOverrideDelReqMesg->NumOverrides == SMMaxNumQueueOverrideEntriesPerMesg) {
        s = smgrFlushSapQosOverrideDelMesg();
        if (pBatch)
            pBatch->QueueOverrideDelSent = FALSE;
    } else {
        NextSapQosOverrideDelEntry++;
        if (pBatch)
            pBatch->QueueOverrideDelSent = TRUE;
    }
            
    return s;
}

/* Send an ingress/egress QoS queue override delete message */
PUBLIC tStatus smgrSendQueueOverrideDelMesg(tSapRec *pSap, int Direction, 
                                            tQueueOverrideRec *pQueue, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverrideRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s queue=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QUEUE) ? "ing" : "egr",
                 pQueue->QosQueueId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapQOvrDownloadInfo(&IccInfo, pSap,pQueue,Direction,IOM_QOS_OVERRIDE_DELETE,
                               SlotBitmap, FALSE);


    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_OVERRIDE_DELETE;
    req->NumOverrides = 1;
    req->Override[0].SapId = pSap->SapId;
    req->Override[0].Qos.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueue->QosQueueId), (Direction == SAP_ING_QOS_QUEUE));

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

PRIVATE void smgrGetSapPlcrOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                           const tSapRec *pSap,
                                           const tPolicerOverrideRec *pPolicer,
                                           int Direction,
                                           tUint32 IomOp,
                                           tUint32 SlotBitmap,
                                           tBoolean IsCardOnline)
{
    int entryNum = 0;
        
    if (!pSap || !pPolicer)
        return;
    
    if (Direction == SAP_ING_QOS_POLICER) {
        entryNum = SmgrMsgrEntry_SapIngPlcrOvr;
    } else if (Direction == SAP_EGR_QOS_POLICER) {
        entryNum = SmgrMsgrEntry_SapEgrPlcrOvr;
    }
    else
        return;
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask = pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
        
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             entryNum,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgIccSapOvrCmp,
                             pSap,
                             pPolicer->QosPolicerId);
}

/* Send an ingress/egress QoS Policer override add message */
PUBLIC tStatus smgrSendPolicerOverrideAddMesg(tSapRec *pSap, int Direction,
                                              tPolicerOverrideRec *pPolicer, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverrideRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s P=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_POLICER) ? "ing" : "egr",
                 pPolicer->QosPolicerId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
     
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapPlcrOvrDownloadInfo(&IccInfo, pSap,pPolicer,Direction,IOM_QOS_OVERRIDE_ADD,
                                  SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_OVERRIDE_ADD;
    req->NumOverrides = 1;
    req->Override[0].SapId = pSap->SapId;
    req->Override[0].Qos.QueueId =
        MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicer->QosPolicerId), (Direction == SAP_ING_QOS_POLICER));
    req->Override[0].Qos.Mask = 0;

    if (Direction == SAP_ING_QOS_POLICER) {
        if ((pPolicer->PIR != DEFVAL_sapIngPlcrOvrAdminPIR) ||
            (pPolicer->PIRPercent != DEFVAL_sapIngPlcrOvrAdminPIRPercent))
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
        if ((pPolicer->CIR != DEFVAL_sapIngPlcrOvrAdminCIR) ||
            (pPolicer->CIRPercent != DEFVAL_sapIngPlcrOvrAdminCIRPercent))
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_CIR;
        if (pPolicer->MBS != DEFVAL_sapIngPlcrOvrMBS)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
        if (pPolicer->CBS != DEFVAL_sapIngPlcrOvrCBS)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_CBS;
        if (pPolicer->StatMode != DEFVAL_sapIngPlcrOvrStatMode)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_STAT_MODE;
        if (pPolicer->PacketByteOffset != DEFVAL_sapIngPlcrOvrPktOffset)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_PACKET_BYTE_OFFSET;

        if ((pPolicer->PIRPercent != DEFVAL_sapIngPlcrOvrAdminPIRPercent) ||
            (pPolicer->CIRPercent != DEFVAL_sapIngPlcrOvrAdminCIRPercent))
            req->Override[0].Qos.Parms.IsRatePercent = TRUE;
        else
            req->Override[0].Qos.Parms.IsRatePercent = FALSE;
    } else {
        if ((pPolicer->PIR != DEFVAL_sapEgrPlcrOvrAdminPIR) ||
            (pPolicer->PIRPercent != DEFVAL_sapEgrPlcrOvrAdminPIRPercent))
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
        if ((pPolicer->CIR != DEFVAL_sapEgrPlcrOvrAdminCIR) ||
            (pPolicer->CIRPercent != DEFVAL_sapEgrPlcrOvrAdminCIRPercent))
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_CIR;
        if (pPolicer->MBS != DEFVAL_sapEgrPlcrOvrMBS)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
        if (pPolicer->CBS != DEFVAL_sapEgrPlcrOvrCBS)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_CBS;
        if (pPolicer->StatMode != DEFVAL_sapEgrPlcrOvrStatMode)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_STAT_MODE;
        if (pPolicer->PacketByteOffset != DEFVAL_sapEgrPlcrOvrPktOffset)
            req->Override[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_PACKET_BYTE_OFFSET;

        if ((pPolicer->PIRPercent != DEFVAL_sapEgrPlcrOvrAdminPIRPercent) ||
            (pPolicer->CIRPercent != DEFVAL_sapEgrPlcrOvrAdminCIRPercent))
            req->Override[0].Qos.Parms.IsRatePercent = TRUE;
        else
            req->Override[0].Qos.Parms.IsRatePercent = FALSE;
    }
    req->Override[0].Qos.Parms.IsLocalLimit = req->Override[0].Qos.Parms.IsRatePercent; // always for policers
    if (req->Override[0].Qos.Parms.IsRatePercent) {
        req->Override[0].Qos.Parms.PIR = pPolicer->PIRPercent;
        req->Override[0].Qos.Parms.CIR = pPolicer->CIRPercent;
    } else {
        req->Override[0].Qos.Parms.PIR = pPolicer->PIR;
        req->Override[0].Qos.Parms.CIR = pPolicer->CIR;
    }
    req->Override[0].Qos.Parms.MBS = pPolicer->MBS;
    req->Override[0].Qos.Parms.CBS = pPolicer->CBS;
    req->Override[0].Qos.Parms.PolicerStatMode = (Direction == SAP_ING_QOS_POLICER) ?
        tqm_IngMibPStatModeToIomStatMode(pPolicer->StatMode) :
        tqm_EgrMibPStatModeToIomStatMode(pPolicer->StatMode);
    req->Override[0].Qos.Parms.PacketByteOffset = pPolicer->PacketByteOffset;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up an ingress/egress QoS Policer override add message
 * (note that SAP Queue and Policer overrides get bundled in the same msg)
 */
PUBLIC tStatus smgrBatchPolicerOverrideAddMesgPriv(tSapRec *pSap, int Direction,
                                                   tPolicerOverrideRec *pPolicer, tUint32 SlotBitmap,
                                                   tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverride *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo; 
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s P=%u slotbitmap=0x%08x",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_POLICER) ? "ing" : "egr",
                 pPolicer->QosPolicerId, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapPlcrOvrDownloadInfo(&IccInfo, pSap,pPolicer,Direction,IOM_QOS_OVERRIDE_ADD,
                                  SlotBitmap, IsCardOnline);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSapQosOverrideAddEntry != 0) && (IccInfo.IomBitMask != PrevSapQosOverrideAddIomBitMask))
        smgrDoFlushSapQosOverrideAddMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevSapQosOverrideAddIomBitMask = IccInfo.IomBitMask;
    
    if (pSapQosOverrideAddReqMesg == NULL) {
        pSapQosOverrideAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(SMMaxNumQueueOverrideEntriesPerMesg));
        if (pSapQosOverrideAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }

    pSapQosOverrideAddReqMesg->Op = IOM_QOS_OVERRIDE_ADD;
    pSapQosOverrideAddReqMesg->NumOverrides = NextSapQosOverrideAddEntry + 1;

    req = &pSapQosOverrideAddReqMesg->Override[NextSapQosOverrideAddEntry];

    req->SapId = pSap->SapId;
    req->Qos.QueueId = MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicer->QosPolicerId),
                                                 (Direction == SAP_ING_QOS_POLICER));
    req->Qos.Mask = 0;
    if (Direction == SAP_ING_QOS_POLICER) {
        if ((pPolicer->PIR != DEFVAL_sapIngPlcrOvrAdminPIR) ||
            (pPolicer->PIRPercent != DEFVAL_sapIngPlcrOvrAdminPIRPercent))
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
        if ((pPolicer->CIR != DEFVAL_sapIngPlcrOvrAdminCIR) ||
            (pPolicer->CIRPercent != DEFVAL_sapIngPlcrOvrAdminCIRPercent))
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_CIR;
        if (pPolicer->MBS != DEFVAL_sapIngPlcrOvrMBS)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
        if (pPolicer->CBS != DEFVAL_sapIngPlcrOvrCBS)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_CBS;
        if (pPolicer->StatMode != DEFVAL_sapIngPlcrOvrStatMode)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_STAT_MODE;
        if (pPolicer->PacketByteOffset != DEFVAL_sapIngPlcrOvrPktOffset)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_PACKET_BYTE_OFFSET;

        if ((pPolicer->PIRPercent != DEFVAL_sapIngPlcrOvrAdminPIRPercent) ||
            (pPolicer->CIRPercent != DEFVAL_sapIngPlcrOvrAdminCIRPercent))
            req->Qos.Parms.IsRatePercent = TRUE;
        else
            req->Qos.Parms.IsRatePercent = FALSE;
    } else {
        if ((pPolicer->PIR != DEFVAL_sapEgrPlcrOvrAdminPIR) ||
            (pPolicer->PIRPercent != DEFVAL_sapEgrPlcrOvrAdminPIRPercent))
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
        if ((pPolicer->CIR != DEFVAL_sapEgrPlcrOvrAdminCIR) ||
            (pPolicer->CIRPercent != DEFVAL_sapEgrPlcrOvrAdminCIRPercent))
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_CIR;
        if (pPolicer->MBS != DEFVAL_sapEgrPlcrOvrMBS)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
        if (pPolicer->CBS != DEFVAL_sapEgrPlcrOvrCBS)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_CBS;
        if (pPolicer->StatMode != DEFVAL_sapEgrPlcrOvrStatMode)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_STAT_MODE;
        if (pPolicer->PacketByteOffset != DEFVAL_sapEgrPlcrOvrPktOffset)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_PACKET_BYTE_OFFSET;

        if ((pPolicer->PIRPercent != DEFVAL_sapEgrPlcrOvrAdminPIRPercent) ||
            (pPolicer->CIRPercent != DEFVAL_sapEgrPlcrOvrAdminCIRPercent))
            req->Qos.Parms.IsRatePercent = TRUE;
        else
            req->Qos.Parms.IsRatePercent = FALSE;
    }
    req->Qos.Parms.IsLocalLimit = req->Qos.Parms.IsRatePercent; // always for policers
    if (req->Qos.Parms.IsRatePercent) {
        req->Qos.Parms.PIR = pPolicer->PIRPercent;
        req->Qos.Parms.CIR = pPolicer->CIRPercent;
    } else {
        req->Qos.Parms.PIR = pPolicer->PIR;
        req->Qos.Parms.CIR = pPolicer->CIR;
    }
    req->Qos.Parms.MBS = pPolicer->MBS;
    req->Qos.Parms.CBS = pPolicer->CBS;
    req->Qos.Parms.PolicerStatMode = (Direction == SAP_ING_QOS_POLICER) ?
        tqm_IngMibPStatModeToIomStatMode(pPolicer->StatMode) :
        tqm_EgrMibPStatModeToIomStatMode(pPolicer->StatMode);
    req->Qos.Parms.PacketByteOffset = pPolicer->PacketByteOffset;

    if (Direction == SAP_ING_QOS_POLICER) {
        sapIngressPlcrOverrideAddCount++;
    } else {
        sapEgressPlcrOverrideAddCount++;
    }
    
    /* If we reached the limit, flush the message */
    if (pSapQosOverrideAddReqMesg->NumOverrides == SMMaxNumQueueOverrideEntriesPerMesg) {
        s = smgrFlushSapQosOverrideAddMesg();
        if (pBatch)
            pBatch->SapQosOverrideAddSent = FALSE;
    } else {
        NextSapQosOverrideAddEntry++;
        if (pBatch)
            pBatch->SapQosOverrideAddSent = TRUE;
    }    
    
    return s;
}

/* Batch up an ingress/egress QoS Policer override delete message
 * (note that SAP Queue and Policer overrides get bundled in the same msg)
 */
PUBLIC tStatus smgrBatchPolicerOverrideDelMesg(tSapRec *pSap, int Direction,
                                               tPolicerOverrideRec *pPolicer, tSMSlot SlotNum,
                                               tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverride *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s P=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_POLICER) ? "ing" : "egr",
                 pPolicer->QosPolicerId, SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapPlcrOvrDownloadInfo(&IccInfo, pSap,pPolicer,Direction,IOM_QOS_OVERRIDE_DELETE,
                                  SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSapQosOverrideDelEntry != 0) && (IccInfo.IomBitMask != PrevSapQosOverrideDelIomBitMask))
        smgrDoFlushSapQosOverrideDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevSapQosOverrideDelIomBitMask = IccInfo.IomBitMask;
    
    if (pSapQosOverrideDelReqMesg == NULL) {
        pSapQosOverrideDelReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(SMMaxNumQueueOverrideEntriesPerMesg));
        if (pSapQosOverrideDelReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pSapQosOverrideDelReqMesg->Op = IOM_QOS_OVERRIDE_DELETE;
    pSapQosOverrideDelReqMesg->NumOverrides = NextSapQosOverrideDelEntry + 1;

    req = &pSapQosOverrideDelReqMesg->Override[NextSapQosOverrideDelEntry];

    req->SapId = pSap->SapId;
    req->Qos.QueueId = MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicer->QosPolicerId), (Direction == SAP_ING_QOS_POLICER));

    if (Direction == SAP_ING_QOS_POLICER) {
        sapIngressPlcrOverrideDelCount++;        
    } else {
        sapEgressPlcrOverrideDelCount++;
    }
    
    /* If we reached the limit, flush the message */
    if (pSapQosOverrideDelReqMesg->NumOverrides == SMMaxNumQueueOverrideEntriesPerMesg) {
        s = smgrFlushSapQosOverrideDelMesg();
        if (pBatch)
            pBatch->SapQosOverrideDelSent = FALSE;
    } else {
        NextSapQosOverrideDelEntry++;
        if (pBatch)
            pBatch->SapQosOverrideDelSent = TRUE;
    }
        
    return s;
}

/* Send an ingress/egress QoS Policer override delete message */
PUBLIC tStatus smgrSendPolicerOverrideDelMesg(tSapRec *pSap, int Direction, 
                                              tPolicerOverrideRec *pPolicer, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomSapQosPolicyOverrideRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap=0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s P=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_POLICER) ? "ing" : "egr",
                 pPolicer->QosPolicerId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapPlcrOvrDownloadInfo(&IccInfo, pSap,pPolicer,Direction,IOM_QOS_OVERRIDE_DELETE,
                                  SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_QOS_OVERRIDE_DELETE;
    req->NumOverrides = 1;
    req->Override[0].SapId = pSap->SapId;
    req->Override[0].Qos.QueueId =
        MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicer->QosPolicerId), (Direction == SAP_ING_QOS_POLICER));

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Flush batched up SAP Qos (i.e. Queue or Policer) Override messages */
PRIVATE tStatus smgrDoFlushSapQosOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapQosOverrideAddIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo; 
    
    if (!pSapQosOverrideAddReqMesg)
        return s;
    
   //QOS_QID_POLICER_FLAG
    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u mask=%08x",
                 pSapQosOverrideAddReqMesg->NumOverrides,
                 SMMaxNumQueueOverrideEntriesPerMesg, IomBitMask);

    if (pSapQosOverrideAddReqMesg->NumOverrides > 0) {

        if (sapIngressPlcrOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngPlcrOvr,
                                       pSapQosOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapIngressPlcrOverrideAddCount, PreFlush);
        }
        if (sapEgressPlcrOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrPlcrOvr,
                                       pSapQosOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapEgressPlcrOverrideAddCount, PreFlush);
        }
        if (sapIngressQOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngQOvr,
                                       pSapQosOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapIngressQOverrideAddCount, PreFlush);
        }
        if (sapEgressQOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrQOvr,
                                       pSapQosOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapEgressQOverrideAddCount, PreFlush);
        }
        
        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for Policer/Q ingress/egress overrides, we could use the socket from one of these
        ICC info */
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSapQosOverrideAddReqMesg->Op,
                                    IomBitMask, pSapQosOverrideAddReqMesg,
                                    SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(
                                        pSapQosOverrideAddReqMesg->NumOverrides),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextSapQosOverrideAddEntry = 0;
        sapIngressPlcrOverrideAddCount =0;
        sapEgressPlcrOverrideAddCount = 0;
        sapIngressQOverrideAddCount = 0;
        sapEgressQOverrideAddCount = 0;
        
        smgrFreeClientMsg(pSapQosOverrideAddReqMesg, s);
        pSapQosOverrideAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSapQosOverrideAddMesg(void)
{
    return smgrDoFlushSapQosOverrideAddMesg(FALSE);
}

/* Flush batched up SAP Qos (i.e. Queue or Policer) Override delete messages */
PRIVATE tStatus smgrDoFlushSapQosOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapQosOverrideDelIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo; 

    if (!pSapQosOverrideDelReqMesg)
        return s;
    
    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u mask=%08x",
                 pSapQosOverrideDelReqMesg->NumOverrides,
                 SMMaxNumQueueOverrideEntriesPerMesg, IomBitMask);
    
    if (pSapQosOverrideDelReqMesg->NumOverrides > 0) {
        
        if (sapIngressPlcrOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngPlcrOvr,
                                       pSapQosOverrideDelReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapIngressPlcrOverrideDelCount, PreFlush); 
             
        }
        if (sapEgressPlcrOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrQOvr,
                                       pSapQosOverrideDelReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapEgressPlcrOverrideDelCount, PreFlush);
        }
        if (sapIngressQOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngQOvr,
                                       pSapQosOverrideDelReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapIngressQOverrideDelCount, PreFlush);
        }
        if (sapEgressQOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrQOvr,
                                       pSapQosOverrideDelReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, sapEgressQOverrideDelCount, PreFlush);
        }
        /* Since the ICC socket is same for Policer/Q ingress/egress overrides, we could use the socket from one of these
        ICC info */
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSapQosOverrideDelReqMesg->Op,
                                    IomBitMask, pSapQosOverrideDelReqMesg,
                                    SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(
                                        pSapQosOverrideDelReqMesg->NumOverrides),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextSapQosOverrideDelEntry = 0;
        sapIngressPlcrOverrideDelCount = 0;
        sapEgressPlcrOverrideDelCount = 0;
        sapIngressQOverrideDelCount = 0;
        sapEgressQOverrideDelCount = 0;
        
        smgrFreeClientMsg(pSapQosOverrideDelReqMesg, s);
        pSapQosOverrideDelReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSapQosOverrideDelMesg(void)
{
    return smgrDoFlushSapQosOverrideDelMesg(FALSE);
}

PRIVATE void smgrGetSapQmdaQOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                            const tSapRec *pSap,
                                            const tQmdaQueueOverrideRec *pQmdaQueue,
                                            int Direction,
                                            tUint32 IomOp,
                                            tUint32 SlotBitmap,
                                            tBoolean IsCardOnline)
{
    int entryNum = 0;

    if (!pSap || !pQmdaQueue)
        return;
    
    if (Direction == SAP_EGR_QOS_QMDA_QUEUE) {
        entryNum = SmgrMsgrEntry_SapEgrQmdaQOvr;
    }
    else
        return;

    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask = pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
       
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             entryNum,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgIccSapOvrCmp,
                             pSap,
                             pQmdaQueue->QosQmdaQueueId);
}


/* Send an egress QoS QMDA queue override add message */
PUBLIC tStatus smgrSendQmdaQueueOverrideAddMesg(tSapRec *pSap, int Direction,
                                                tQmdaQueueOverrideRec *pQmdaQueue, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomQmdaSapQosPolicyOverrideRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s QmdaQ=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QMDA_QUEUE) ? "ing" : "egr",
                 pQmdaQueue->QosQmdaQueueId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);  
    smgrGetSapQmdaQOvrDownloadInfo(&IccInfo, pSap,pQmdaQueue,Direction,IOM_QMDA_QOS_POLICY_OVERRIDE_ADD,
                                   SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QMDA_QOS_POLICY_OVERRIDE_ADD;
    req->NumEntries = 1;
    req->Entries[0].SapId = pSap->SapId;
    req->Entries[0].Qos.QueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQmdaQueue->QosQmdaQueueId),
                                (Direction == SAP_ING_QOS_QMDA_QUEUE));
    req->Entries[0].Qos.Mask = 0;

    if (Direction == SAP_ING_QOS_QMDA_QUEUE) {
        return FAIL; // obsolete
    } else {
        if (pQmdaQueue->PIR != DEFVAL_sapEgrQosHsmdaQueueAdminPIR)
            req->Entries[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
        if (strcmp(pQmdaQueue->QmdaSlopePolicy.name, DEFVAL_sapEgrQosHsmdaQueueSlopePolicy) != 0)
            req->Entries[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_SLOPEPOLICY;
        if (pQmdaQueue->WrrWeight != DEFVAL_sapEgrQosHsmdaQueueWrrWeight)
            req->Entries[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_WRR_WEIGHT;
        if (pQmdaQueue->MBS != DEFVAL_sapEgrQosHsmdaQueueMBS)
            req->Entries[0].Qos.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
    }
    req->Entries[0].Qos.Parms.PIR = pQmdaQueue->PIR;
    req->Entries[0].Qos.Parms.CIR = pQmdaQueue->CIR;
    req->Entries[0].Qos.Parms.SlopePolicyId = pQmdaQueue->HsmdaSlopePolicyId;
    req->Entries[0].Qos.Parms.WRRWeight = pQmdaQueue->WrrWeight; // (egress only)
    req->Entries[0].Qos.Parms.MBS = pQmdaQueue->MBS; // (egress only)
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    /* Since policy can be used under port, we need to send a blocking call to
     * ensure that this message makes it to ICC before proceeding */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up an egress QoS QMDA Queue override add message */
PUBLIC tStatus smgrBatchQmdaQueueOverrideAddMesgPriv(tSapRec *pSap, int Direction,
                                                     tQmdaQueueOverrideRec *pQmdaQueue,
                                                     tSMSlot SlotBitmap,tBoolean IsCardOnline,
                                                     tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomQmdaSapQosPolicyOverride *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s QmdaQ=%u slotbitmap=0x%08x",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QMDA_QUEUE) ? "ing" : "egr",
                 pQmdaQueue->QosQmdaQueueId, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapQmdaQOvrDownloadInfo(&IccInfo, pSap, pQmdaQueue,
                                   Direction, IOM_QMDA_QOS_POLICY_OVERRIDE_ADD,
                                   SlotBitmap, IsCardOnline);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextQmdaQueueOverrideAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevQmdaQueueOverrideAddIomBitMask))
        smgrDoFlushQmdaQueueOverrideAddMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevQmdaQueueOverrideAddIomBitMask = IccInfo.IomBitMask;
    
    if (pQmdaQueueOverrideAddReqMesg == NULL) {
        pQmdaQueueOverrideAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(SMMaxNumQmdaQueueOverrideEntriesPerMesg));
        if (pQmdaQueueOverrideAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pQmdaQueueOverrideAddReqMesg->Op = IOM_QMDA_QOS_POLICY_OVERRIDE_ADD;
    pQmdaQueueOverrideAddReqMesg->NumEntries = NextQmdaQueueOverrideAddEntry + 1;

    req = &pQmdaQueueOverrideAddReqMesg->Entries[NextQmdaQueueOverrideAddEntry];

    req->SapId = pSap->SapId;
    req->Qos.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQmdaQueue->QosQmdaQueueId),
                                              (Direction == SAP_ING_QOS_QMDA_QUEUE));
    req->Qos.Mask = 0;
    if (Direction == SAP_ING_QOS_QMDA_QUEUE) {
        return FAIL; // obsolete
    } else {
        if (pQmdaQueue->PIR != DEFVAL_sapEgrQosHsmdaQueueAdminPIR)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
        if (strcmp(pQmdaQueue->QmdaSlopePolicy.name, DEFVAL_sapEgrQosHsmdaQueueSlopePolicy) != 0)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_SLOPEPOLICY;
        if (pQmdaQueue->WrrWeight != DEFVAL_sapEgrQosHsmdaQueueWrrWeight)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_WRR_WEIGHT;
        if (pQmdaQueue->MBS != DEFVAL_sapEgrQosHsmdaQueueMBS)
            req->Qos.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
    }
    req->Qos.Parms.PIR = pQmdaQueue->PIR;
    req->Qos.Parms.CIR = pQmdaQueue->CIR;
    req->Qos.Parms.SlopePolicyId = pQmdaQueue->HsmdaSlopePolicyId;
    req->Qos.Parms.WRRWeight = pQmdaQueue->WrrWeight; // (egress only)
    req->Qos.Parms.MBS = pQmdaQueue->MBS; // (egress only)

    /* If we reached the limit, flush the message */
    if (pQmdaQueueOverrideAddReqMesg->NumEntries == SMMaxNumQmdaQueueOverrideEntriesPerMesg) {
        s = smgrFlushQmdaQueueOverrideAddMesg();
        if (pBatch)
            pBatch->QmdaQueueOverrideAddSent = FALSE;
    } else {
        NextQmdaQueueOverrideAddEntry++;
        if (pBatch)
            pBatch->QmdaQueueOverrideAddSent = TRUE;
    }

    return s;
}

/* Batch up an egress QoS QMDA Queue override delete message */
PUBLIC tStatus smgrBatchQmdaQueueOverrideDelMesg(tSapRec *pSap, int Direction,
                                                 tQmdaQueueOverrideRec *pQmdaQueue, tSMSlot SlotNum,
                                                 tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomQmdaSapQosPolicyOverride *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s QmdaQ=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QMDA_QUEUE) ? "ing" : "egr",
                 pQmdaQueue->QosQmdaQueueId, SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapQmdaQOvrDownloadInfo(&IccInfo, pSap,pQmdaQueue,Direction,
                                   IOM_QMDA_QOS_POLICY_OVERRIDE_DELETE,
                                   SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextQmdaQueueOverrideDelEntry != 0) &&
        (IccInfo.IomBitMask != PrevQmdaQueueOverrideDelIomBitMask))
        smgrDoFlushQmdaQueueOverrideDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevQmdaQueueOverrideDelIomBitMask = IccInfo.IomBitMask;
    
    if (pQmdaQueueOverrideDelReqMesg == NULL) {
        pQmdaQueueOverrideDelReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(SMMaxNumQmdaQueueOverrideEntriesPerMesg));
        if (pQmdaQueueOverrideDelReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pQmdaQueueOverrideDelReqMesg->Op = IOM_QMDA_QOS_POLICY_OVERRIDE_DELETE;
    pQmdaQueueOverrideDelReqMesg->NumEntries = NextQmdaQueueOverrideDelEntry + 1;

    req = &pQmdaQueueOverrideDelReqMesg->Entries[NextQmdaQueueOverrideDelEntry];

    req->SapId = pSap->SapId;
    req->Qos.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQmdaQueue->QosQmdaQueueId),
                                                 (Direction == SAP_ING_QOS_QMDA_QUEUE));

    /* If we reached the limit, flush the message */
    if (pQmdaQueueOverrideDelReqMesg->NumEntries == SMMaxNumQmdaQueueOverrideEntriesPerMesg) {
        s = smgrFlushQmdaQueueOverrideDelMesg();
        if (pBatch)
            pBatch->QmdaQueueOverrideDelSent = FALSE;
    } else {
        NextQmdaQueueOverrideDelEntry++;
        if (pBatch)
            pBatch->QmdaQueueOverrideDelSent = TRUE;
    }
        
    return s;
}

/* Flush batched up QMDA Queue Override messages */
PRIVATE tStatus smgrDoFlushQmdaQueueOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevQmdaQueueOverrideAddIomBitMask;
    tStatus s = SUCCESS;
    int entryNum = 0;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pQmdaQueueOverrideAddReqMesg)
        return s;
        
    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u mask=%08x",
                 pQmdaQueueOverrideAddReqMesg->NumEntries,
                 SMMaxNumQmdaQueueOverrideEntriesPerMesg, IomBitMask);
    
    if (pQmdaQueueOverrideAddReqMesg->NumEntries > 0) {

        if ((pQmdaQueueOverrideAddReqMesg->Entries[0].Qos.QueueId) & QOS_QID_INGRESS_FLAG)
            return s; // obsolete
        else 
            entryNum = SmgrMsgrEntry_SapEgrQmdaQOvr;

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   entryNum,
                                   pQmdaQueueOverrideAddReqMesg->Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, pQmdaQueueOverrideAddReqMesg->NumEntries,
                                   PreFlush);
                                   
        /* Since policy can be used under port, we need to send a blocking call to
         * ensure that this message makes it to ICC before proceeding */
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pQmdaQueueOverrideAddReqMesg->Op,
                                    IomBitMask, pQmdaQueueOverrideAddReqMesg,
                                    SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(
                                        pQmdaQueueOverrideAddReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextQmdaQueueOverrideAddEntry = 0;
        smgrFreeClientMsg(pQmdaQueueOverrideAddReqMesg, s);
        pQmdaQueueOverrideAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushQmdaQueueOverrideAddMesg(void)
{
    return smgrDoFlushQmdaQueueOverrideAddMesg(FALSE);
}
   
/* Flush batched up QMDA Queue Override delete messages */
PRIVATE tStatus smgrDoFlushQmdaQueueOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevQmdaQueueOverrideDelIomBitMask;
    tStatus s = SUCCESS;
    int entryNum = 0;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pQmdaQueueOverrideDelReqMesg)
        return s;
    
    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u mask=%08x",
                 pQmdaQueueOverrideDelReqMesg->NumEntries,
                 SMMaxNumQmdaQueueOverrideEntriesPerMesg, IomBitMask);
    
    if (pQmdaQueueOverrideDelReqMesg->NumEntries > 0) {

        if ((pQmdaQueueOverrideDelReqMesg->Entries[0].Qos.QueueId) & QOS_QID_INGRESS_FLAG)
            return s; // obsolete
        else 
            entryNum = SmgrMsgrEntry_SapEgrQmdaQOvr;

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   entryNum,
                                   pQmdaQueueOverrideDelReqMesg->Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                   pQmdaQueueOverrideDelReqMesg->NumEntries, PreFlush);
                                   
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pQmdaQueueOverrideDelReqMesg->Op,
                                    IomBitMask, pQmdaQueueOverrideDelReqMesg,
                                    SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(
                                        pQmdaQueueOverrideDelReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextQmdaQueueOverrideDelEntry = 0;
        smgrFreeClientMsg(pQmdaQueueOverrideDelReqMesg, s);
        pQmdaQueueOverrideDelReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushQmdaQueueOverrideDelMesg(void)
{
    return smgrDoFlushQmdaQueueOverrideDelMesg(FALSE);
}

/* Send an egress QoS QMDA queue override delete message */
PUBLIC tStatus smgrSendQmdaQueueOverrideDelMesg(tSapRec *pSap, int Direction, 
                                                tQmdaQueueOverrideRec *pQmdaQueue, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tIomQmdaSapQosPolicyOverrideRequest *req;
    tStatus s;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s QmdaQ=%u slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_QOS_QMDA_QUEUE) ? "ing" : "egr",
                 pQmdaQueue->QosQmdaQueueId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapQmdaQOvrDownloadInfo(&IccInfo, pSap,pQmdaQueue,Direction,
                                   IOM_QMDA_QOS_POLICY_OVERRIDE_DELETE,
                                   SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_QMDA_QOS_POLICY_OVERRIDE_DELETE;
    req->NumEntries = 1;
    req->Entries[0].SapId = pSap->SapId;
    req->Entries[0].Qos.QueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQmdaQueue->QosQmdaQueueId),
                                (Direction == SAP_ING_QOS_QMDA_QUEUE));
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

PRIVATE void smgrGetSapEgrEncapGroupDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                 const tSapRec *pSap,
                                                 const tSapEgrEncapGroupRec *pEncapGroup,
                                                 tUint32 IomOp,
                                                 tUint32 SlotBitmap,
                                                 tBoolean IsCardOnline)
{
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:
        if (!pSap || !pEncapGroup)
            return;
        pIccInfo->IomBitMask = pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        if (!pSap || !pEncapGroup)
            return;
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap ? pSap->PortRec->IomBitMask : 0;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             SmgrMsgrEntry_SapEgrEncapGroup,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgIccSapEgrEncapGroupCmp,
                             pSap,
                             pEncapGroup ? &pEncapGroup->Key.Name : NULL);
}


/* Send a SAP Egress Encap Group add message */
PUBLIC tStatus smgrSendSapEgrEncapGroupAddMesg(tSapRec *pSap,
                                               tSapEgrEncapGroupRec *pEncapGroup, tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomEncapGroupConfigRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap=0; 
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrEncapGroupDownloadInfo(&IccInfo, pSap, pEncapGroup,
                                        IOM_ENCAP_GROUP_ADD, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_ENCAP_GROUP_ADD;
    req->NumEntries = 1;
    req->Entries[0].SapId = pSap->SapId;
    req->Entries[0].GroupId = pEncapGroup->GroupId;

    req->Entries[0].EgressQosPolicyId =
        pEncapGroup->QosPolRec ? pEncapGroup->QosPolRec->Id : 0;
    req->Entries[0].EgressSchedulerPolicyId =
        pEncapGroup->QosSchedPolRec ? pEncapGroup->QosSchedPolRec->InstanceId : 0;
    req->Entries[0].EgressAggRateLimit = pEncapGroup->AggRateLimit;
    req->Entries[0].GroupType = IOM_ENCAP_GROUP_TYPE_ISID; // only one type supported
    req->Entries[0].EgressAggRateOnTheWire = (pEncapGroup->EgrFrameBasedAccnt == VAL_sapEgrEncapGrpFrameBasedAccnt_true ? TRUE : FALSE);
    req->Entries[0].QosPerMember =
        (pEncapGroup->QosPerMember == VAL_sapEgrEncapGroupQosPerMember_true);
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_ENCAP_GROUP_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up a SAP Egress Encap Group add message */
PUBLIC tStatus smgrBatchSapEgrEncapGroupAddMesgPriv(tSapRec *pSap,
                                                    tSapEgrEncapGroupRec *pEncapGroup,
                                                    tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                    tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomEncapGroupConfigEntry *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d slotbitmap=0x%08x",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapEgrEncapGroupDownloadInfo(&IccInfo, pSap, pEncapGroup,
                                        IOM_ENCAP_GROUP_ADD, SlotBitmap, IsCardOnline);

    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSapEgrEncapGroupAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevSapEgrEncapGroupAddIomBitMask))
        smgrDoFlushSapEgrEncapGroupAddMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevSapEgrEncapGroupAddIomBitMask = IccInfo.IomBitMask;
    
    if (pSapEgrEncapGroupAddReqMesg == NULL) {
        pSapEgrEncapGroupAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_REQUEST_MSG(SMMaxNumSapEgrEncapGroupEntriesPerMesg));
        if (pSapEgrEncapGroupAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pSapEgrEncapGroupAddReqMesg->Op = IOM_ENCAP_GROUP_ADD;
    pSapEgrEncapGroupAddReqMesg->NumEntries = NextSapEgrEncapGroupAddEntry + 1;

    req = &pSapEgrEncapGroupAddReqMesg->Entries[NextSapEgrEncapGroupAddEntry];

    req->SapId = pSap->SapId;
    req->GroupId = pEncapGroup->GroupId;

    req->EgressQosPolicyId = pEncapGroup->QosPolRec ? pEncapGroup->QosPolRec->Id : 0;
    req->EgressSchedulerPolicyId = pEncapGroup->QosSchedPolRec ?
        pEncapGroup->QosSchedPolRec->InstanceId : 0;
    req->EgressAggRateLimit = pEncapGroup->AggRateLimit;
    req->GroupType = IOM_ENCAP_GROUP_TYPE_ISID; // only one supported
    req->EgressAggRateOnTheWire = 0; // not supported yet
    req->QosPerMember = (pEncapGroup->QosPerMember == VAL_sapEgrEncapGroupQosPerMember_true);

    /* If we reached the limit, flush the message */
    if (pSapEgrEncapGroupAddReqMesg->NumEntries == SMMaxNumSapEgrEncapGroupEntriesPerMesg) {
        s = smgrFlushSapEgrEncapGroupAddMesg();
        if (pBatch)
            pBatch->SapEgrEncapGroupAddSent = FALSE;
    } else {
        NextSapEgrEncapGroupAddEntry++;
        if (pBatch)
            pBatch->SapEgrEncapGroupAddSent = TRUE;
    }
    
    return s;
}

/* Batch up a SAP Egress Encap Group delete message */
PUBLIC tStatus smgrBatchSapEgrEncapGroupDelMesg(tSapRec *pSap,
                                                tSapEgrEncapGroupRec *pEncapGroup,
                                                tSMSlot SlotNum, tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomEncapGroupConfigEntry *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrEncapGroupDownloadInfo(&IccInfo, pSap, pEncapGroup,
                                        IOM_ENCAP_GROUP_ADD, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSapEgrEncapGroupDelEntry != 0) &&
        (IccInfo.IomBitMask != PrevSapEgrEncapGroupDelIomBitMask))
        smgrDoFlushSapEgrEncapGroupDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevSapEgrEncapGroupDelIomBitMask = IccInfo.IomBitMask;
    
    if (pSapEgrEncapGroupDelReqMesg == NULL) {
        pSapEgrEncapGroupDelReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_REQUEST_MSG(SMMaxNumSapEgrEncapGroupEntriesPerMesg));
        if (pSapEgrEncapGroupDelReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }

    pSapEgrEncapGroupDelReqMesg->Op = IOM_ENCAP_GROUP_DELETE;
    pSapEgrEncapGroupDelReqMesg->NumEntries = NextSapEgrEncapGroupDelEntry + 1;

    req = &pSapEgrEncapGroupDelReqMesg->Entries[NextSapEgrEncapGroupDelEntry];

    req->SapId = pSap->SapId;
    req->GroupId = pEncapGroup->GroupId;

    /* If we reached the limit, flush the message */
    if (pSapEgrEncapGroupDelReqMesg->NumEntries == SMMaxNumSapEgrEncapGroupEntriesPerMesg) {
        s = smgrFlushSapEgrEncapGroupDelMesg();
        if (pBatch)
            pBatch->SapEgrEncapGroupDelSent = FALSE;
    } else {
        NextSapEgrEncapGroupDelEntry++;
        if (pBatch)
            pBatch->SapEgrEncapGroupDelSent = TRUE;
    }

    return s;
}

/* Flush batched up SAP Egr Encap Group messages */
PRIVATE tStatus smgrDoFlushSapEgrEncapGroupAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapEgrEncapGroupAddIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pSapEgrEncapGroupAddReqMesg)
        return s;
        
    SVCMGR_EVENT(IOM_CALL, "groups=%u of max=%u mask=%08x",
                 pSapEgrEncapGroupAddReqMesg->NumEntries,
                 SMMaxNumSapEgrEncapGroupEntriesPerMesg, IomBitMask);
    
    if (pSapEgrEncapGroupAddReqMesg->NumEntries > 0) {

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SapEgrEncapGroup,
                                   pSapEgrEncapGroupAddReqMesg->Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                   pSapEgrEncapGroupAddReqMesg->NumEntries, PreFlush);
                                   
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSapEgrEncapGroupAddReqMesg->Op,
                                    IomBitMask, pSapEgrEncapGroupAddReqMesg,
                                     SIZE_ENCAP_GROUP_REQUEST_MSG(
                                        pSapEgrEncapGroupAddReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextSapEgrEncapGroupAddEntry = 0;
        
        smgrFreeClientMsg(pSapEgrEncapGroupAddReqMesg, s);
        pSapEgrEncapGroupAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSapEgrEncapGroupAddMesg(void)
{
    return smgrDoFlushSapEgrEncapGroupAddMesg(FALSE);
}

/* Flush batched up SAP Egr Encap Group delete messages */
PRIVATE tStatus smgrDoFlushSapEgrEncapGroupDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapEgrEncapGroupDelIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pSapEgrEncapGroupDelReqMesg)
        return s;
    
    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u mask=%08x",
                 pSapEgrEncapGroupDelReqMesg->NumEntries,
                 SMMaxNumSapEgrEncapGroupEntriesPerMesg, IomBitMask);
    
    if (pSapEgrEncapGroupDelReqMesg->NumEntries > 0) {

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SapEgrEncapGroup,
                                   pSapEgrEncapGroupDelReqMesg->Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                   pSapEgrEncapGroupDelReqMesg->NumEntries, PreFlush);
                                   
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSapEgrEncapGroupDelReqMesg->Op,
                                    IomBitMask, pSapEgrEncapGroupDelReqMesg,
                                    SIZE_ENCAP_GROUP_REQUEST_MSG(
                                        pSapEgrEncapGroupDelReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextSapEgrEncapGroupDelEntry = 0;
        smgrFreeClientMsg(pSapEgrEncapGroupDelReqMesg, s);
        pSapEgrEncapGroupDelReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSapEgrEncapGroupDelMesg(void)
{
    return smgrDoFlushSapEgrEncapGroupDelMesg(FALSE);
}

/* Send a SAP Egress Encap Group delete message */
PUBLIC tStatus smgrSendSapEgrEncapGroupDelMesg(tSapRec *pSap,
                                               tSapEgrEncapGroupRec *pEncapGroup,
                                               tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tSmgrMsgrIccInfo IccInfo;
    tIomEncapGroupConfigRequest *req;
    tStatus s;
    tUint32 SlotBitmap = 0;
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrEncapGroupDownloadInfo(&IccInfo, pSap,pEncapGroup,
                                        IOM_ENCAP_GROUP_DELETE, SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_ENCAP_GROUP_DELETE;
    req->NumEntries = 1;
    req->Entries[0].SapId = pSap->SapId;
    req->Entries[0].GroupId = pEncapGroup->GroupId;
        
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_ENCAP_GROUP_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Send an ENCAP_GROUP_AUDIT message */
PUBLIC tStatus smgrSendSapEgrEncapGroupAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomEncapGroupConfigRequest *req;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "ENCAP GROUP AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrEncapGroupDownloadInfo(&IccInfo, NULL, NULL,
                                        IOM_ENCAP_GROUP_AUDIT, SlotBitmap, FALSE);
    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "Skipped Audit due to 0 bitmask, slot %u", SlotNum);
        return SUCCESS;
    }
            
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_ENCAP_GROUP_AUDIT;
    req->NumEntries = 1;
        
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_ENCAP_GROUP_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "ENCAP GROUP AUDIT failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return s;
}

PRIVATE void smgrGetSapEgrEncapMemberDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                  const tSapRec *pSap,
                                                  const tSapEgrEncapGroupRec *pEncapGroup,
                                                  tUint32 IomOp,
                                                  tUint32 SlotBitmap,
                                                  tBoolean IsCardOnline)
{
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:
        if (!pSap || !pEncapGroup)
            return;
        pIccInfo->IomBitMask = pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        if (!pSap || !pEncapGroup)
            return;
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap ? pSap->PortRec->IomBitMask : 0;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             SmgrMsgrEntry_SapEgrEncapMember,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgIccSapEgrEncapGroupCmp,
                             pSap,
                             pEncapGroup ? &pEncapGroup->Key.Name : NULL);
}

/* Send a SAP Egress Encap Member add message */
PUBLIC tStatus smgrSendSapEgrEncapMemberAddMesg(tSapRec *pSap,
                                                tSapEgrEncapGroupRec *pEncapGroup,
                                                tEncapGroupMember RangeStart,
                                                tEncapGroupMember RangeEnd,
                                                tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomEncapGroupMembershipRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap = 0; 
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d  Range=%d-%d slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, RangeStart, RangeEnd, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrEncapMemberDownloadInfo(&IccInfo, pSap, pEncapGroup,
                                         IOM_ENCAP_GROUP_MEMBERS_ADD, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_ENCAP_GROUP_MEMBERS_ADD;
    req->NumEntries = 1;
    req->SapId = pSap->SapId;
    req->GroupId = pEncapGroup->GroupId;
    req->RangeStart = RangeStart;
    req->RangeEnd = RangeEnd;

    req->Entries[0].first = RangeStart;
    req->Entries[0].last = RangeEnd;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up a SAP Egress Encap Member add message */
PUBLIC tStatus smgrBatchSapEgrEncapMemberAddMesgPriv(tSapRec *pSap,
                                                     tSapEgrEncapGroupRec *pEncapGroup,
                                                     tEncapGroupMember RangeStart,
                                                     tEncapGroupMember RangeEnd,
                                                     tUint32     SlotBitmap,
                                                     tBoolean IsCardOnline,
                                                     tBatchProcessing *pBatch)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomEncapGroupMemberRange *req;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d  Range=%d-%d slotbitmap=0x%08x",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, RangeStart, RangeEnd, SlotBitmap);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapEgrEncapMemberDownloadInfo(&IccInfo, pSap, pEncapGroup,
                                         IOM_ENCAP_GROUP_MEMBERS_ADD, SlotBitmap, IsCardOnline);

    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }

    /* If the Encap Group Id differs from the previous one,
     * flush the message and start a new batch so that we don't
     * batch Encap Members from different groups in the same message!
     */
    if ((NextSapEgrEncapMemberAddEntry != 0) &&
        (pEncapGroup->GroupId != PrevSapEgrEncapMemberAddGroupId))
        smgrDoFlushSapEgrEncapMemberAddMesg(TRUE);
    
    /* Set the GroupId and IOM bit mask */
    PrevSapEgrEncapMemberAddGroupId = pEncapGroup->GroupId;
    PrevSapEgrEncapMemberAddIomBitMask = IccInfo.IomBitMask;
    
    if (pSapEgrEncapMemberAddReqMesg == NULL) {
        pSapEgrEncapMemberAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(SMMaxNumSapEgrEncapMemberEntriesPerMesg));
        if (pSapEgrEncapMemberAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pSapEgrEncapMemberAddReqMesg->Op = IOM_ENCAP_GROUP_MEMBERS_ADD;
    pSapEgrEncapMemberAddReqMesg->NumEntries = NextSapEgrEncapMemberAddEntry + 1;
    pSapEgrEncapMemberAddReqMesg->SapId = pSap->SapId;
    pSapEgrEncapMemberAddReqMesg->GroupId = pEncapGroup->GroupId;
    if (NextSapEgrEncapMemberAddEntry == 0) {
        pSapEgrEncapMemberAddReqMesg->RangeStart = RangeStart;
        pSapEgrEncapMemberAddReqMesg->RangeEnd = RangeEnd;
    } else {
        if (RangeStart < pSapEgrEncapMemberAddReqMesg->RangeStart)
            pSapEgrEncapMemberAddReqMesg->RangeStart = RangeStart;
        if (RangeEnd > pSapEgrEncapMemberAddReqMesg->RangeEnd)
            pSapEgrEncapMemberAddReqMesg->RangeEnd = RangeEnd;
    }

    req = &pSapEgrEncapMemberAddReqMesg->Entries[NextSapEgrEncapMemberAddEntry];

    req->first = RangeStart;
    req->last = RangeEnd;

    /* If we reached the limit, flush the message */
    if (pSapEgrEncapMemberAddReqMesg->NumEntries == SMMaxNumSapEgrEncapMemberEntriesPerMesg) {
        s = smgrFlushSapEgrEncapMemberAddMesg();
        if (pBatch)
            pBatch->SapEgrEncapMemberAddSent = FALSE;
    } else {
        NextSapEgrEncapMemberAddEntry++;
        if (pBatch)
            pBatch->SapEgrEncapMemberAddSent = TRUE;
    }
        
    return s;
}

/* Flush batched up SAP Egr Encap Member messages */
PRIVATE tStatus smgrDoFlushSapEgrEncapMemberAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSapEgrEncapMemberAddIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pSapEgrEncapMemberAddReqMesg)
        return s;
        
    SVCMGR_EVENT(IOM_CALL, "members=%u of max=%u groupId=%d mask=0x%08x",
                 pSapEgrEncapMemberAddReqMesg->NumEntries,
                 SMMaxNumSapEgrEncapMemberEntriesPerMesg,
                 PrevSapEgrEncapMemberAddGroupId, IomBitMask);
    
    if (pSapEgrEncapMemberAddReqMesg->NumEntries > 0) {

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SapEgrEncapMember,
                                   pSapEgrEncapMemberAddReqMesg->Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSapEgrEncapMemberAddReqMesg, PreFlush);
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pSapEgrEncapMemberAddReqMesg->Op,
                                    IomBitMask, pSapEgrEncapMemberAddReqMesg,
                                    SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(
                                        pSapEgrEncapMemberAddReqMesg->NumEntries),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextSapEgrEncapMemberAddEntry = 0;
        
        smgrFreeClientMsg(pSapEgrEncapMemberAddReqMesg, s);
        pSapEgrEncapMemberAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSapEgrEncapMemberAddMesg(void)
{
    return smgrDoFlushSapEgrEncapMemberAddMesg(FALSE);
}

/* Send a SAP Egress Encap Member Del message */
PUBLIC tStatus smgrSendSapEgrEncapMemberDelMesg(tSapRec *pSap,
                                                tSapEgrEncapGroupRec *pEncapGroup,
                                                tEncapGroupMember RangeStart,
                                                tEncapGroupMember RangeEnd,
                                                tSMSlot SlotNum)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tIomEncapGroupMembershipRequest *req;
    tStatus s;
    tSmgrMsgrIccInfo IccInfo; 
    tUint32 SlotBitmap = 0; 
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s Group=%s GrpId=%d  Range=%d-%d slot=%d",
                 pSvc->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pEncapGroup->Key.Name.name,
                 pEncapGroup->GroupId, RangeStart, RangeEnd, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapEgrEncapMemberDownloadInfo(&IccInfo, pSap, pEncapGroup,
                                         IOM_ENCAP_GROUP_MEMBERS_ADD, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0) {
        SVCMGR_EVENT(IOM_CALL, "IccInfo.IomBitMask = 0 so nothing sent");
        return SUCCESS;
    }

    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(0))) == NULL)
        return FAIL;
        
    req->Op = IOM_ENCAP_GROUP_MEMBERS_ADD;
    req->NumEntries = 0;
    req->SapId = pSap->SapId;
    req->GroupId = pEncapGroup->GroupId;
    req->RangeStart = RangeStart;
    req->RangeEnd = RangeEnd;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, req->Op, IccInfo.IomBitMask,
                                req, SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(req->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

PRIVATE void smgrGetSapSchedPolDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                            const tQosVSchedOverrideRec *pVSched,
                                            const tSapRec *pSap,
                                            int Direction,
                                            tUint32 IomOp,
                                            tUint32 SlotBitmap,
                                            Boolean IsCardOnline)
{

    tUint16 entry_num;

    if (!pSap || !pVSched)
        return;
    
    if (Direction == SAP_ING_SCHED) 
        entry_num = SmgrMsgrEntry_SapIngSchedPlcyOvr;
    else if (Direction == SAP_EGR_SCHED)
        entry_num = SmgrMsgrEntry_SapEgrSchedPlcyOvr;
    else 
        return;

    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask = pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;

        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             entry_num,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,                          
                             smgrMesgIccSapSchedPlcyOvrCmp,
                             pVSched,
                             pSap);
    
}
/* Send an ingress/egress Virtual Scheduler override for a SAP */
PUBLIC tStatus smgrSendSapVSOverrideAddMesgPriv(tSapRec *pSap, int Direction, tQosVSchedOverrideRec *pVSched,
                                                tUint32 SlotBitmap, tBatchProcessing *pBatch, tBoolean IsCardOnline)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tQosSchedulerId SchedulerId;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s scheduler=%s slotbitmap=0x%08x present=0x%x batch=%s caronline=%s",
                 pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_SCHED) ? "ing" : "egr",
                 pVSched->Name.Str, SlotBitmap, pVSched->OverridePresent,
                 SMGR_BATCH_MESG_ENABLED(pBatch)? "true" : "false",IsCardOnline ? "true" : "false");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
  
    smgrGetSapSchedPolDownloadInfo(&IccInfo,pVSched,pSap,Direction,IOM_QOS_OVERRIDE_ADD,SlotBitmap,IsCardOnline); 
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* Construct the SAP specific Scheduler Id */
    SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SAP;
    SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    SchedulerId.TypeId.Dir = (Direction == SAP_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(SchedulerId.ObjId.SchedulerName.Str, sizeof(SchedulerId.ObjId.SchedulerName.Str), pVSched->Name.Str);
    SchedulerId.LocId.Sap.SapId = pSap->SapId;
    SchedulerId.LocId.Sap.PortId = INVALID_PORTID;
    SchedulerId.LocId.Sap.FpId = INVALID_FP_ID;

    if (SMGR_BATCH_MESG_ENABLED(pBatch)) {
        return(smgrBatchVSOverrideAddMesg(&SchedulerId, &IccInfo, pVSched, pBatch));
    } else {
        return(smgrSendVSOverrideAddMesg(&SchedulerId, &IccInfo, pVSched));
    }
}

PRIVATE void smgrGetMssVSODownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                       const tMssRec *pMss, int Direction,
                                       const tQosVSchedOverrideRec *pVSched,
                                       tUint32 IomOp, tUint32 SlotBitmap,
                                       tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_QosMssVsO,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgCustMssVsOvCmp,
                          pMss, Direction, pVSched);
}

/* Send an ingress/egress Virtual Scheduler override for a MSS */
PUBLIC tStatus smgrSendMssVSOverrideAddMesgPriv(tMssRec *pMss, int Direction,
                                                tQosVSchedOverrideRec *pVSched,
                                                tUint32 SlotBitmap, tBatchProcessing *pBatch,
                                                tBoolean IsCardOnline)
{
    tCustRec *pCust = pMss->CustRec;
    tQosSchedulerId SchedulerId;
    tSmgrMsgrIccInfo IccInfo;

    SVCMGR_EVENT(IOM_CALL, "cust=%u mss=%s dir=%s scheduler=%s slotbitmap=0x%08x present=0x%x batch=%s",
                 pCust->Id, pMss->Name,
                 (Direction == CUST_MSS_ING_SCHED) ? "ing" : "egr",
                 pVSched->Name.Str, SlotBitmap, pVSched->OverridePresent,
                 SMGR_BATCH_MESG_ENABLED(pBatch)? "true" : "false");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetMssVSODownloadInfo(&IccInfo, pMss, Direction, pVSched,
                              IOM_QOS_OVERRIDE_ADD, SlotBitmap, IsCardOnline);
                              
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;    
    
    /* Construct the SAP specific Scheduler Id */
    SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SITE;
    SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    SchedulerId.TypeId.Dir = (Direction == CUST_MSS_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(SchedulerId.ObjId.SchedulerName.Str, sizeof(SchedulerId.ObjId.SchedulerName.Str), pVSched->Name.Str);
    SchedulerId.LocId.Site.SiteId = pMss->InstanceId;
    SchedulerId.LocId.Site.PortId = INVALID_PORTID;

    if (SMGR_BATCH_MESG_ENABLED(pBatch)) {
        return(smgrBatchVSOverrideAddMesg(&SchedulerId, &IccInfo, pVSched, pBatch));
    } else {
        return(smgrSendVSOverrideAddMesg(&SchedulerId, &IccInfo, pVSched));
    }
}

/* Initialize the QoS Virtual Scheduler override structure */
PRIVATE void smgrInitVSOverrideAddMesg(tQosSchedulerId *SchedulerId,
                                       tQosVSchedOverrideRec *pVSched,
                                       tIomQosGroupOverride *req)
{
    req->SchedulerId = *SchedulerId;

    /* Fill in MGMT override parameters if they exist (excluding the rate) */
    if (pVSched->OverridePresent & QOS_OVERRIDE_CREATOR_MGMT) {
        req->Parms.Scheduler.CIR = pVSched->CIR;
        req->Parms.Scheduler.CIRIsSumMemberCIRs = pVSched->CIRIsSumMemberCIRs;
        req->OverrideMask = pVSched->OverrideMask;
        /* clear out the rate bit, since it will be set properly later */
        req->OverrideMask &= (~QOS_GROUP_OVERRIDE_RATE);
    }

    /* Resolve the proper rate to send */
    if ((pVSched->OverridePresent & QOS_OVERRIDE_CREATOR_ANCP) &&
        (pVSched->AncpOverrideMask & QOS_GROUP_OVERRIDE_RATE) &&
        (pVSched->OverridePresent & QOS_OVERRIDE_CREATOR_MGMT) &&
        (pVSched->OverrideMask & QOS_GROUP_OVERRIDE_RATE)) {
        /* Send the min of the MGMT and ANCP rates */
        if (pVSched->AncpPIR < pVSched->PIR)
            req->Parms.Scheduler.Rate = pVSched->AncpPIR;
        else
            req->Parms.Scheduler.Rate = pVSched->PIR;
        /* Always set the rate bit in the mask */
        req->OverrideMask |= QOS_GROUP_OVERRIDE_RATE;

    } else if ((pVSched->OverridePresent & QOS_OVERRIDE_CREATOR_ANCP) &&
               (pVSched->AncpOverrideMask & QOS_GROUP_OVERRIDE_RATE)) {
        /* Send the ANCP rate and set the ANCP rate bit in the mask */
        req->Parms.Scheduler.Rate = pVSched->AncpPIR;
        req->OverrideMask |= QOS_GROUP_OVERRIDE_ANCP_RATE;
    } else if ((pVSched->OverridePresent & QOS_OVERRIDE_CREATOR_MGMT) &&
               (pVSched->OverrideMask & QOS_GROUP_OVERRIDE_RATE)) {
        /* Send the MGMT rate and set the rate bit in the mask */
        req->Parms.Scheduler.Rate = pVSched->PIR;
        req->OverrideMask |= QOS_GROUP_OVERRIDE_RATE;
    }

    /* Always fill in the IGMP RateDelta */
    req->IgmpRateDelta = pVSched->IgmpRateDelta;

}

/* Send an ingress/egress QoS Virtual Scheduler override add message */
PRIVATE tStatus smgrSendVSOverrideAddMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo,
                                          tQosVSchedOverrideRec *pVSched)
{
    tIomQosGroupOverrideRequest *req;
    tStatus s;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_OVERRIDE_ADD;
    req->NumOverrides = 1;

    smgrInitVSOverrideAddMesg(SchedulerId, pVSched,
                              &req->Override[0]);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(pIccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(pIccInfo->pMsgrEntry->IccSocket, req->Op, pIccInfo->IomBitMask,
                                req, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", pIccInfo->IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up an ingress/egress QoS Virtual Scheduler override add message */
PRIVATE tStatus smgrBatchVSOverrideAddMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo,
                                           tQosVSchedOverrideRec *pVSched, tBatchProcessing *pBatch)
{
    tIomQosGroupOverride *req;
    tStatus s = SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     * Note that scheduler and arbiter overrides are batched together!
     */
    if ((NextVSOverrideAddEntry != 0) && (pIccInfo->IomBitMask != PrevVSOverrideAddIomBitMask))
        smgrDoFlushVSOverrideAddMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevVSOverrideAddIomBitMask = pIccInfo->IomBitMask;

    if (pVSOverrideAddReqMesg == NULL) {
        pVSOverrideAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(SMMaxNumVSOverrideEntriesPerMesg));
        if (pVSOverrideAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
        
    pVSOverrideAddReqMesg->Op = IOM_QOS_OVERRIDE_ADD;
    pVSOverrideAddReqMesg->NumOverrides = NextVSOverrideAddEntry + 1;

    /* here we build up the override message */
    req = &pVSOverrideAddReqMesg->Override[NextVSOverrideAddEntry];

    smgrInitVSOverrideAddMesg(SchedulerId, pVSched, req);

    if (SchedulerId->TypeId.Loc == QOS_SCHEDULER_LOC_SAP) {

        if (SchedulerId->TypeId.Dir == QOS_DIRECTION_INGRESS) {
            IngressSchedPlcyOverrideAddCount++;
        } else {
            EgressSchedPlcyOverrideAddCount++;
        }
        
    } else if (SchedulerId->TypeId.Loc == QOS_SCHEDULER_LOC_SITE) {
        VirtSchdOverrideAddCount++;
    }
    
    /* If we reached the limit, flush the message */
    if (pVSOverrideAddReqMesg->NumOverrides == SMMaxNumVSOverrideEntriesPerMesg) {
        s = smgrFlushVSOverrideAddMesg();
        if (pBatch)
            pBatch->VSOverrideAddSent = FALSE;
    } else {
        NextVSOverrideAddEntry++;
        if (pBatch)
            pBatch->VSOverrideAddSent = TRUE;
    }
        
    return s;
}

/* Send an ingress/egress Virtual Scheduler override delete for a SAP */
PUBLIC tStatus smgrSendSapVSOverrideDelMesg(tSapRec *pSap, int Direction, tQosVSchedOverrideRec *pVSched,
                                            tSMSlot SlotNum, tBoolean BatchThis)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tQosSchedulerId SchedulerId;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap=0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s scheduler=%s slot=%d batch=%s",
                 pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_SCHED) ? "ing" : "egr",
                 pVSched->Name.Str, SlotNum,
                 BatchThis ? "true" : "false");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapSchedPolDownloadInfo(&IccInfo,pVSched,pSap,Direction,IOM_QOS_OVERRIDE_DELETE,SlotBitmap,FALSE); 
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
   
    /* Construct the SAP specific Scheduler Id */
    SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SAP;
    SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    SchedulerId.TypeId.Dir = (Direction == SAP_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(SchedulerId.ObjId.SchedulerName.Str, sizeof(SchedulerId.ObjId.SchedulerName.Str), pVSched->Name.Str);
    SchedulerId.LocId.Sap.SapId = pSap->SapId;
    SchedulerId.LocId.Sap.PortId = INVALID_PORTID;
    SchedulerId.LocId.Sap.FpId = INVALID_FP_ID;

    if (BatchThis) {
        return(smgrBatchVSOverrideDelMesg(&SchedulerId, &IccInfo));
    } else {
        return(smgrSendVSOverrideDelMesg(&SchedulerId, &IccInfo));
    }
}

/* Send an ingress/egress Virtual Scheduler override delete for a MSS */
PUBLIC tStatus smgrSendMssVSOverrideDelMesg(tMssRec *pMss, int Direction, tQosVSchedOverrideRec *pVSched,
                                            tSMSlot SlotNum, tBoolean BatchThis)
{
    tCustRec *pCust = pMss->CustRec;
    tQosSchedulerId SchedulerId;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "cust=%u mss=%s dir=%s scheduler=%s slot=%d batch=%s",
                 pCust->Id, pMss->Name,
                 (Direction == CUST_MSS_ING_SCHED) ? "ing" : "egr",
                 pVSched->Name.Str, SlotNum,
                 BatchThis ? "true" : "false");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetMssVSODownloadInfo(&IccInfo, pMss, Direction, pVSched,
                              IOM_QOS_OVERRIDE_DELETE, SlotBitmap, FALSE);
                              
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;    
    
    /* Construct the SAP specific Scheduler Id */
    SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SITE;
    SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    SchedulerId.TypeId.Dir = (Direction == CUST_MSS_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(SchedulerId.ObjId.SchedulerName.Str, sizeof(SchedulerId.ObjId.SchedulerName.Str), pVSched->Name.Str);
    SchedulerId.LocId.Site.SiteId = pMss->InstanceId;
    SchedulerId.LocId.Site.PortId = INVALID_PORTID;

    if (BatchThis) {
        return(smgrBatchVSOverrideDelMesg(&SchedulerId, &IccInfo));
    } else {
        return(smgrSendVSOverrideDelMesg(&SchedulerId, &IccInfo));
    }
}

/* Send an ingress/egress QoS Virtual Scheduler override delete message */
PRIVATE tStatus smgrSendVSOverrideDelMesg(tQosSchedulerId *SchedulerId,  tSmgrMsgrIccInfo *pIccInfo)
{
    tIomQosGroupOverrideRequest *req;
    tStatus s;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
    
    
    
    req->Op = IOM_QOS_OVERRIDE_DELETE;
    req->NumOverrides = 1;

    /* copy the scheduler Id */
    req->Override[0].SchedulerId = *SchedulerId;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(pIccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(pIccInfo->pMsgrEntry->IccSocket, req->Op, pIccInfo->IomBitMask,
                                req, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", pIccInfo->IomBitMask);
    
    smgrFreeClientMsg(req, s);
 
    return SUCCESS;
}

/* Batch up an ingress/egress QoS Virtual Scheduler override delete message */
PRIVATE tStatus smgrBatchVSOverrideDelMesg(tQosSchedulerId *SchedulerId, tSmgrMsgrIccInfo *pIccInfo)
{
    tIomQosGroupOverride *req;
    tStatus s = SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     * Note that scheduler and arbiter overrides are batched together!
     */
    if ((NextVSOverrideDelEntry != 0) && (pIccInfo->IomBitMask != PrevVSOverrideDelIomBitMask))
        smgrDoFlushVSOverrideDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevVSOverrideDelIomBitMask = pIccInfo->IomBitMask;
    
    if (pVSOverrideDelReqMesg == NULL) {
        pVSOverrideDelReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(SMMaxNumVSOverrideEntriesPerMesg));
        if (pVSOverrideDelReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pVSOverrideDelReqMesg->Op = IOM_QOS_OVERRIDE_DELETE;
    pVSOverrideDelReqMesg->NumOverrides = NextVSOverrideDelEntry + 1;

    /* copy the scheduler Id */
    req = &pVSOverrideDelReqMesg->Override[NextVSOverrideDelEntry];
    req->SchedulerId = *SchedulerId;

    if (SchedulerId->TypeId.Loc == QOS_SCHEDULER_LOC_SAP) {

        if (SchedulerId->TypeId.Dir == QOS_DIRECTION_INGRESS) {
            IngressSchedPlcyOverrideDelCount++;
        } else {
            EgressSchedPlcyOverrideDelCount++;
        }
        
    } else if (SchedulerId->TypeId.Loc == QOS_SCHEDULER_LOC_SITE) {
        VirtSchdOverrideDelCount++;
    }
    
    /* If we reached the limit, flush the message */
    if (pVSOverrideDelReqMesg->NumOverrides == SMMaxNumVSOverrideEntriesPerMesg) {
        s = smgrFlushVSOverrideDelMesg();
    } else {
        NextVSOverrideDelEntry++;
    }
    return s;
}

/* Flush batched up Scheduler Override messages */
PRIVATE tStatus smgrDoFlushVSOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevVSOverrideAddIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
        
    if (! pVSOverrideAddReqMesg)
        return s;
        
    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u nextVSAddEntry=%u mask=%08x",
                 pVSOverrideAddReqMesg->NumOverrides,
                 SMMaxNumVSOverrideEntriesPerMesg, NextVSOverrideAddEntry, IomBitMask);
                 
    if (pVSOverrideAddReqMesg->NumOverrides > 0) {        
        if (IngressSchedPlcyOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngSchedPlcyOvr,
                                       pVSOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                       IngressSchedPlcyOverrideAddCount, PreFlush);
        }
        if (EgressSchedPlcyOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrSchedPlcyOvr,
                                       pVSOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                       EgressSchedPlcyOverrideAddCount, PreFlush);
        }
        if (VirtSchdOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_QosMssVsO,
                                       pVSOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                       VirtSchdOverrideAddCount, PreFlush);
        }
        if (IngressPlcyCtrlOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngPlcrCtrlOvr,
                                       pVSOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                       IngressPlcyCtrlOverrideAddCount, PreFlush);
        }
        if (EgressPlcyCtrlOverrideAddCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrPlcrCtrlOvr,
                                       pVSOverrideAddReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,
                                       EgressPlcyCtrlOverrideAddCount, PreFlush);
        }
  
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pVSOverrideAddReqMesg->Op,
                                    IomBitMask, pVSOverrideAddReqMesg,
                                    SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(
                                        pVSOverrideAddReqMesg->NumOverrides),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextVSOverrideAddEntry = 0;
        IngressSchedPlcyOverrideAddCount = 0;
        EgressSchedPlcyOverrideAddCount = 0;
        VirtSchdOverrideAddCount = 0;
        IngressPlcyCtrlOverrideAddCount = 0;
        EgressPlcyCtrlOverrideAddCount = 0;

        smgrFreeClientMsg(pVSOverrideAddReqMesg, s);
        pVSOverrideAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushVSOverrideAddMesg(void)
{
    return smgrDoFlushVSOverrideAddMesg(FALSE);
}

/* Flush batched up Scheduler Override delete messages */
PRIVATE tStatus smgrDoFlushVSOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevVSOverrideDelIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    
    if (! pVSOverrideDelReqMesg)
        return s;

    SVCMGR_EVENT(IOM_CALL, "overrides=%u of max=%u nextVSDelEntry=%u mask=%08x",
                 pVSOverrideDelReqMesg->NumOverrides,
                 SMMaxNumVSOverrideEntriesPerMesg, NextVSOverrideDelEntry, IomBitMask);

    if (pVSOverrideDelReqMesg->NumOverrides > 0) {
        if (IngressSchedPlcyOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapIngSchedPlcyOvr,
                                       pVSOverrideDelReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, IngressSchedPlcyOverrideDelCount, PreFlush);
        }
        if (EgressSchedPlcyOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SapEgrSchedPlcyOvr,
                                       pVSOverrideDelReqMesg->Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, EgressSchedPlcyOverrideDelCount, PreFlush);
        }
        if (VirtSchdOverrideDelCount) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_QosMssVsO,
                                       pVSOverrideDelReqMesg->Op);
              SMGR_MESG_UPDATE_NUM_STATS(&IccInfo,VirtSchdOverrideDelCount, PreFlush);
        }
         if (IngressPlcyCtrlOverrideDelCount) {
             smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                        SmgrMsgrEntry_SapIngPlcrCtrlOvr,
                                        pVSOverrideDelReqMesg->Op);
             SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, IngressPlcyCtrlOverrideDelCount, PreFlush);
         }
         if (EgressPlcyCtrlOverrideDelCount) {
             smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                        SmgrMsgrEntry_SapEgrPlcrCtrlOvr,
                                        pVSOverrideDelReqMesg->Op);
             SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, EgressPlcyCtrlOverrideDelCount, PreFlush);
        }

        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pVSOverrideDelReqMesg->Op, IomBitMask,
                                    pVSOverrideDelReqMesg,
                                    SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(
                                        pVSOverrideDelReqMesg->NumOverrides),
                                    NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);

        /* Start a new batch */
        NextVSOverrideDelEntry = 0;
        IngressSchedPlcyOverrideDelCount = 0;
        EgressSchedPlcyOverrideDelCount = 0;
        VirtSchdOverrideDelCount = 0;
        IngressPlcyCtrlOverrideDelCount = 0;
        EgressPlcyCtrlOverrideDelCount = 0;

        smgrFreeClientMsg(pVSOverrideDelReqMesg, s);
        pVSOverrideDelReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushVSOverrideDelMesg(void)
{
    return smgrDoFlushVSOverrideDelMesg(FALSE);
}

PRIVATE void smgrGetSapPlcrCtrlDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                            const tSapRec *pSap,
                                            int Direction,
                                            tUint32 IomOp,
                                            tUint32 SlotBitmap,
                                            Boolean IsCardOnline)
{

    tUint16 entry_num;


    if (!pSap)
        return;
    
    if (Direction == SAP_ING_ARBIT) 
        entry_num = SmgrMsgrEntry_SapIngPlcrCtrlOvr;
    else if (Direction == SAP_EGR_ARBIT)
        entry_num = SmgrMsgrEntry_SapEgrPlcrCtrlOvr;
    else 
        return;
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask =  pSap->PortRec->IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;
        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }
    
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             entry_num,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,                          
                             smgrMesgIccSapPlcrCtrlOvrCmp,
                             pSap);
    
}
PUBLIC tStatus smgrSendSapPCOverrideAddMesgPriv(tSapRec *pSap, int Direction, tQosPolicerCtrlOverrideRec *pOverride,
                                                tUint32 SlotBitmap, tBatchProcessing *pBatch, tBoolean IsCardOnline)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tQosSchedulerId ArbiterId;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s slotbitmap=0x%08x batch=%s",
                 pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_ARBIT) ? "ing" : "egr",
                 SlotBitmap, SMGR_BATCH_MESG_ENABLED(pBatch)? "true" : "false");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
 
    smgrGetSapPlcrCtrlDownloadInfo(&IccInfo,pSap,Direction,IOM_QOS_OVERRIDE_ADD,SlotBitmap,IsCardOnline); 

     if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* Construct the SAP specific Arbiter Id */
    ArbiterId.TypeId.Loc = QOS_SCHEDULER_LOC_SAP;
    ArbiterId.TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    ArbiterId.TypeId.Dir = (Direction == SAP_ING_ARBIT) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(ArbiterId.ObjId.SchedulerName.Str, sizeof(ArbiterId.ObjId.SchedulerName.Str),
            QOS_ROOT_ARBITER_NAME);
    ArbiterId.LocId.Sap.SapId = pSap->SapId;
    ArbiterId.LocId.Sap.PortId = INVALID_PORTID;
    ArbiterId.LocId.Sap.FpId = INVALID_FP_ID;

    if (SMGR_BATCH_MESG_ENABLED(pBatch)) {
        return(smgrBatchPCOverrideAddMesg(&ArbiterId, &IccInfo, pOverride, pBatch));
    } else {
        return(smgrSendPCOverrideAddMesg(&ArbiterId, &IccInfo, pOverride));
    }
}

/* Send an ingress/egress QoS Policer Ctrl override add message */
PRIVATE tStatus smgrSendPCOverrideAddMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo,
                                          tQosPolicerCtrlOverrideRec *pOverride)
{
    tIomQosGroupOverrideRequest *req;
    int l;
    tStatus s;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;

    req->Op = IOM_QOS_OVERRIDE_ADD;
    req->NumOverrides = 1;

    /* Copy the Scheduler Id and fill in the rest */
    req->Override[0].SchedulerId = *ArbiterId;
    req->Override[0].Parms.Arbiter.IsRoot = TRUE;

    /* Fill in the message */
    if (pOverride->MaxRate != DEFVAL_sapIngPlcrCtrlOvrMaxRate) {
        req->Override[0].OverrideMask |= QOS_GROUP_OVERRIDE_RATE;
        req->Override[0].Parms.Arbiter.Rate = pOverride->MaxRate;
    }
    if (pOverride->MinMBSSep != DEFVAL_sapIngPlcrCtrlOvrMinMBSSep) {
        req->Override[0].OverrideMask |= QOS_GROUP_OVERRIDE_MIN_MBS_SEPARATION;
        req->Override[0].Parms.Arbiter.Cfg.Root.Thresholds.MinSeparation = pOverride->MinMBSSep;
    }
    for (l = 0; l < MAX_QOS_STRICT_LEVEL; l++) {
        if (pOverride->Level[l].MBSContribution != DEFVAL_sapIngPlcrCtrlOvrLvlMBS) {
            req->Override[0].OverrideMask |= (QOS_GROUP_OVERRIDE_MBS_CONTRIBUTION_BASE << (l+1));
            req->Override[0].Parms.Arbiter.Cfg.Root.Thresholds.PBS[l+1] = pOverride->Level[l].MBSContribution;
        }
    }
    
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(pIccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(pIccInfo->pMsgrEntry->IccSocket, req->Op, pIccInfo->IomBitMask,
                                req, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", pIccInfo->IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up an ingress/egress QoS Virtual Scheduler override add message */
PRIVATE tStatus smgrBatchPCOverrideAddMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo,
                                           tQosPolicerCtrlOverrideRec *pOverride,
                                           tBatchProcessing *pBatch)
{
    tIomQosGroupOverride *req;
    int l;
    tStatus s = SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     * Note that scheduler and arbiter overrides are batched together!
     */
    if ((NextVSOverrideAddEntry != 0) && (pIccInfo->IomBitMask != PrevVSOverrideAddIomBitMask))
        smgrDoFlushVSOverrideAddMesg(TRUE);

     
    /* Set the slot number and IOM bit mask */
    PrevVSOverrideAddIomBitMask = pIccInfo->IomBitMask;
    
    if (pVSOverrideAddReqMesg == NULL) {
        pVSOverrideAddReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(SMMaxNumVSOverrideEntriesPerMesg));
        if (pVSOverrideAddReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pVSOverrideAddReqMesg->Op = IOM_QOS_OVERRIDE_ADD;
    pVSOverrideAddReqMesg->NumOverrides = NextVSOverrideAddEntry + 1;

    /* here we build up the override message */
    req = &pVSOverrideAddReqMesg->Override[NextVSOverrideAddEntry];

    req->SchedulerId = *ArbiterId;
    req->Parms.Arbiter.IsRoot = TRUE;

    /* Fill in the message */
    if (pOverride->MaxRate != DEFVAL_sapIngPlcrCtrlOvrMaxRate) {
        req->OverrideMask |= QOS_GROUP_OVERRIDE_RATE;
        req->Parms.Arbiter.Rate = pOverride->MaxRate;
    }
    if (pOverride->MinMBSSep != DEFVAL_sapIngPlcrCtrlOvrMinMBSSep) {
        req->OverrideMask |= QOS_GROUP_OVERRIDE_MIN_MBS_SEPARATION;
        req->Parms.Arbiter.Cfg.Root.Thresholds.MinSeparation = pOverride->MinMBSSep;
    }
    for (l = 0; l < MAX_QOS_STRICT_LEVEL; l++) {
        if (pOverride->Level[l].MBSContribution != DEFVAL_sapIngPlcrCtrlOvrLvlMBS) {
            req->OverrideMask |= (QOS_GROUP_OVERRIDE_MBS_CONTRIBUTION_BASE << (l+1));
            req->Parms.Arbiter.Cfg.Root.Thresholds.PBS[l+1] = pOverride->Level[l].MBSContribution;
        }
    }

    if (ArbiterId->TypeId.Dir == QOS_DIRECTION_INGRESS) {
        IngressPlcyCtrlOverrideAddCount++;
    } else {
        EgressPlcyCtrlOverrideAddCount++; 
    }
    
    /* If we reached the limit, flush the message */
    if (pVSOverrideAddReqMesg->NumOverrides == SMMaxNumVSOverrideEntriesPerMesg) {
        s = smgrFlushVSOverrideAddMesg();
        if (pBatch)
            pBatch->PCOverrideAddSent = FALSE;
    } else {
        NextVSOverrideAddEntry++;
        if (pBatch)
            pBatch->PCOverrideAddSent = TRUE;
    }
        
    return s;
}

/* Send an ingress/egress Policer Ctrl override delete for a SAP */
PUBLIC tStatus smgrSendSapPCOverrideDelMesg(tSapRec *pSap, int Direction, tQosPolicerCtrlOverrideRec *pOverride,
                                            tSMSlot SlotNum, tBoolean BatchThis)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tQosSchedulerId ArbiterId;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s dir=%s slot=%d batch=%s",
                 pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 (Direction == SAP_ING_SCHED) ? "ing" : "egr",
                 SlotNum, BatchThis ? "true" : "false");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSapPlcrCtrlDownloadInfo(&IccInfo,pSap,Direction,IOM_QOS_OVERRIDE_DELETE,SlotBitmap,FALSE); 

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* Construct the SAP specific Scheduler Id */
    ArbiterId.TypeId.Loc = QOS_SCHEDULER_LOC_SAP;
    ArbiterId.TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    ArbiterId.TypeId.Dir = (Direction == SAP_ING_ARBIT) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(ArbiterId.ObjId.SchedulerName.Str, sizeof(ArbiterId.ObjId.SchedulerName.Str),
            QOS_ROOT_ARBITER_NAME);
    ArbiterId.LocId.Sap.SapId = pSap->SapId;
    ArbiterId.LocId.Sap.PortId = INVALID_PORTID;
    ArbiterId.LocId.Sap.FpId = INVALID_FP_ID;

    if (BatchThis) {
        return(smgrBatchPCOverrideDelMesg(&ArbiterId, &IccInfo));
    } else {
        return(smgrSendPCOverrideDelMesg(&ArbiterId, &IccInfo));
    }
}

/* Send an ingress/egress QoS Policer Ctrl override delete message */
PRIVATE tStatus smgrSendPCOverrideDelMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo)
{
    tIomQosGroupOverrideRequest *req;
    tStatus s;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    req->Op = IOM_QOS_OVERRIDE_DELETE;
    req->NumOverrides = 1;

    /* copy the arbiter Id */
    req->Override[0].SchedulerId = *ArbiterId;
    req->Override[0].Parms.Arbiter.IsRoot = TRUE;

    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(pIccInfo, req->NumOverrides, FALSE);
    
    s = smgrSendClientMsgToIoms(pIccInfo->pMsgrEntry->IccSocket, req->Op, pIccInfo->IomBitMask,
                                req, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(req->NumOverrides),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", pIccInfo->IomBitMask);
    
    smgrFreeClientMsg(req, s);

    return SUCCESS;
}

/* Batch up an ingress/egress QoS Policer Ctrl override delete message */
PRIVATE tStatus smgrBatchPCOverrideDelMesg(tQosSchedulerId *ArbiterId, tSmgrMsgrIccInfo *pIccInfo)
{
    tIomQosGroupOverride *req;
    tStatus s = SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     * Note that scheduler and arbiter overrides are batched together!
     */
    if ((NextVSOverrideDelEntry != 0) && (pIccInfo->IomBitMask != PrevVSOverrideDelIomBitMask))
        smgrDoFlushVSOverrideDelMesg(TRUE);
    
    /* Set the slot number and IOM bit mask */
    PrevVSOverrideDelIomBitMask = pIccInfo->IomBitMask;
    
    if (pVSOverrideDelReqMesg == NULL) {
        pVSOverrideDelReqMesg =
            SMGR_MESG_MEM_CALLOC(1, SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(SMMaxNumVSOverrideEntriesPerMesg));
        if (pVSOverrideDelReqMesg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
            return FAIL;
        }
    }
    
    pVSOverrideDelReqMesg->Op = IOM_QOS_OVERRIDE_DELETE;
    pVSOverrideDelReqMesg->NumOverrides = NextVSOverrideDelEntry + 1;

    /* copy the scheduler Id */
    req = &pVSOverrideDelReqMesg->Override[NextVSOverrideDelEntry];
    req->SchedulerId = *ArbiterId;
    req->Parms.Arbiter.IsRoot = TRUE;

    if (ArbiterId->TypeId.Dir == QOS_DIRECTION_INGRESS) {
        IngressPlcyCtrlOverrideDelCount++;
    } else {
        EgressPlcyCtrlOverrideDelCount++; 
    }
    
    /* If we reached the limit, flush the message */
    if (pVSOverrideDelReqMesg->NumOverrides == SMMaxNumVSOverrideEntriesPerMesg) {
        s = smgrFlushVSOverrideDelMesg();
    } else {
        NextVSOverrideDelEntry++;
    }
    
    return s;
}

/* Send an ISA-AA mirror source add/delete message to a single IOM with a specific MdaId.
 *
 * ISA-AA mirror src msg is sent to all IOMs that host multiple ISA MDAs in 
 * the ISA-AA group, with the corresp. mdaId. This is different from other 
 * mirror source types, where the same msg content is sent to all relevant IOMs.
 */
PUBLIC tStatus smgrSendMirrorSrcIsaAaMesg(tBoolean Add, tMdaId MdaId, tMirrorSrcEntryRec *pLocSrc, tUint32 IomBitMask)
{
    tIomMirrorSourceConfigRequest *pCfg = NULL;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    char Buf[FMT_LOC_SRC_BUF_SIZE];
    
    if (redIsCardActive() && 
        (MdaId != INVALID_MDA_NUM) &&
        IOM_BIT_TST(IomBitMask, SLOT_FROM_MDAID(MdaId))) {

        pCfg = SMGR_MESG_MEM_CALLOC(1, sizeof(*pCfg));
        if (pCfg == NULL) {
            TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot download svc %u %s (Out of memory)",
                         pLocSrc->SvcRec->Id, mirrorFmtLocSrcId(&pLocSrc->Id, Buf, sizeof(Buf)));
            return FAIL;
        }

        mirrorGetSrcIOMConfig(Add, 0, pLocSrc, pCfg);
        pCfg->u.IsaAaEntry.MdaId = MdaId;

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_MirrorSvcLocal,
                                   pCfg->Op);

        SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pCfg->Op, IomBitMask,
                                    pCfg, sizeof(*pCfg), NULL, SMGR_DNDLER_MAY_BLOCK);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                         IomBitMask);

        smgrFreeClientMsg(pCfg, s);
    }

    return s;
}

PRIVATE void smgrGetMirrorSvcLocalDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                               const tMirrorSrcEntryRec *pLocSrc,
                                               tUint32 IomOp, tUint32 SlotBitmap,
                                               tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_MirrorSvcLocal,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccMirrorSvcLocalCmp,
                          pLocSrc);
}
/* Send a mirror source add/delete message */
PUBLIC tStatus smgrSendMirrorSrcMesgPriv(tBoolean Add, tBoolean Ingress, tMirrorSrcEntryRec *pLocSrc,
                                         tUint32 IomBitMask,tUint32 SlotBitmap, tBoolean IsCardonline)
{
    tIomMirrorSourceConfigRequest *pCfg = NULL;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    char Buf[FMT_LOC_SRC_BUF_SIZE];

    smgrGetMirrorSvcLocalDownloadInfo(&IccInfo, pLocSrc,
                                      Add? IOM_MIRROR_SRC_ADD : IOM_MIRROR_SRC_DELETE,
                                      SlotBitmap, IsCardonline);

    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    pCfg = SMGR_MESG_MEM_CALLOC(1, sizeof(*pCfg));
    if (pCfg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot download svc %u %s (Out of memory)",
                     pLocSrc->SvcRec->Id, mirrorFmtLocSrcId(&pLocSrc->Id, Buf, sizeof(Buf)));
        return FAIL;
    }
    
    /* Get the IOM Configuration */
    mirrorGetSrcIOMConfig(Add, Ingress, pLocSrc, pCfg);
    
    /* Inform IOMs to which the message needs to be sent and are online */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);    
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pCfg->Op, IomBitMask,
                                pCfg, sizeof(*pCfg), NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IomBitMask);

    smgrFreeClientMsg(pCfg, s);

    return s;
}


/* Send a mirror source add message */
PUBLIC tStatus smgrSendMirrorSrcAddMesg(tBoolean Ingress, tMirrorSrcEntryRec *pLocSrc, tUint32 IomBitMask)
{
    if (IomBitMask == 0)
        return SUCCESS;

    return smgrSendMirrorSrcMesg(TRUE, Ingress, pLocSrc, IomBitMask);
}


/* Send a mirror source delete message */
PUBLIC tStatus smgrSendMirrorSrcDelMesg(tBoolean Ingress, tMirrorSrcEntryRec *pLocSrc, tUint32 IomBitMask)
{

    if (IomBitMask == 0)
        return SUCCESS;

    return smgrSendMirrorSrcMesg(FALSE, Ingress, pLocSrc, IomBitMask);
}

PRIVATE void smgrGetMirrorSvcRemoteDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                const tMirrorRemSrcRec *pRemSrc,
                                                tUint32 IomOp, tUint32 SlotBitmap,
                                                tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_MirrorSvcRemote,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccMirrorSvcRemoteCmp,
                          pRemSrc);
}

#ifdef MPLS_DEBUG_LABEL_USAGE
/* Trace programming of IOM with labels */
PRIVATE void smgrMirrorRemSrcLabelTrace(const tMirrorRemSrcRec *pRemSrc, tBoolean Add)
{
    e_MplsLmgrLabelState State = e_MPLS_LMGR_LABEL_STATE_ERROR;
    tUint32 IngVcLbl = pRemSrc->OperIngressVcLabel;
    tUint32 PrevIngVcLbl = pRemSrc->PreviousOperIngressVcLabel;

    if (Add) {
        if (IngVcLbl != PrevIngVcLbl &&
            VALID_VC_LABEL(IngVcLbl)) {
            State = e_MPLS_LMGR_LABEL_STATE_PROG_IOM;
        }
    } else {
        if (VALID_VC_LABEL(PrevIngVcLbl)) {
            State = e_MPLS_LMGR_LABEL_STATE_DEPROG_IOM;
            IngVcLbl = PrevIngVcLbl;
        }
    }

    if (State == e_MPLS_LMGR_LABEL_STATE_ERROR) {
        return;
    }

    MPLS_LMGR_SET_HISTORY((e_MPLS_LMGR_LABEL_HIST_SVC_INFO,
                           IngVcLbl,
                           MPLS_LMGR_USER_MIRROR,
                           State, 1, "RemSrc REQ",
                           (pRemSrc->FarEndRec?
                            pRemSrc->FarEndRec->IpAddress : INADDR_ANY),
                           NULL_SDP_ID, pRemSrc->VcId, NULL));
}
#endif

/* Send a mirror remote source add/delete message */
PUBLIC tStatus smgrSendMirrorRemSrcMesgPriv(tBoolean Add, tMirrorRemSrcRec *pRemSrc,
                                            tUint32 IomBitMask, tUint32 SlotBitmap,
                                            tBoolean IsCardonline, tSMEventMsg *pCallbackEvent)
{
    tIomMirrorSourceConfigRequest *pCfg = NULL;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;

    if (! VALID_VC_LABEL(pRemSrc->OperIngressVcLabel) ||
        (pRemSrc->OperIngressVcLabel == LDP_FEC_MIRROR_DUMMY_LABEL)) {
        SVCMGR_EVENT(NOCLASS, "Operational Label=%d, no message being sent to the IOM", 
                     pRemSrc->OperIngressVcLabel);
        s = SUCCESS;
        goto Done;
    }

    smgrGetMirrorSvcRemoteDownloadInfo(&IccInfo, pRemSrc,
                                       Add? IOM_MIRROR_SRC_ADD : IOM_MIRROR_SRC_DELETE,
                                       SlotBitmap, IsCardonline);

    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0) {
        s = SUCCESS;
        goto Done;
    }
    
    pCfg = SMGR_MESG_MEM_CALLOC(1, sizeof(*pCfg));
    if (pCfg == NULL) {
        SVCMGR_ERROR(NOCLASS, "Label=%d, out of memory", pRemSrc->OperIngressVcLabel);
        s = FAIL;
        goto Done;
    }

    /* Get the IOM Configuration */
    mirrorGetRemSrcIOMConfig(Add, pRemSrc, pCfg);
    pCfg->handle.Cpm = pCallbackEvent;
    
    /* Send the message to the intersection set of all the IOMs in the chassis
     * that are currently on-line and ones where we have to program this entity. */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pCfg->Op,
                                      IomBitMask, pCfg, sizeof(*pCfg),
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                      FALSE, TRUE, smgrIccCleanSendMirrorRemSrc);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientCustomMsgToIoms() failed for mask=%08x !", IomBitMask);
        smgrIccCleanSendMirrorRemSrc(pCfg, NULL);
        return FAIL;
    }  
    
    return SUCCESS;
    
Done:
    if (pCallbackEvent)
        smgrIccCleanup(pCallbackEvent);
    return s;
}

PRIVATE tStatus smgrSendMirrorRemSrcMesgCommon(tBoolean Add,
                                               tMirrorRemSrcRec *pRemSrc, tUint32 IomBitMask,
                                               struct SMEventMsg *pCallbackEvent)
{
    SVCMGR_EVENT(NOCLASS, "IomBitMask=%08x, FarEnd=%d.%d.%d.%d, SvcId=%u Add=%u", 
                 IomBitMask, PRINT_IP(pRemSrc->Addr), pRemSrc->SvcRec->Id, Add);
    
#ifdef MPLS_DEBUG_LABEL_USAGE
    /* make a record that the IOMs were informed, even if they weren't because they are offline */
    smgrMirrorRemSrcLabelTrace(pRemSrc, Add);

    /* Now reset the previous, so that this label event doesn't get recorded multiple times */
    MIRROR_REMSRC_SAVE_OPER_ING_VC_LABEL(pRemSrc);
#endif 
    
    if ((IomBitMask == 0) || (smgrRedAmInactive)) {
        if (pCallbackEvent)
            smgrIccCleanup(pCallbackEvent);
        return SUCCESS;
    }

    return smgrSendMirrorRemSrcMesg(Add, pRemSrc, IomBitMask, pCallbackEvent);
}

/* Send a mirror remote source add message */
PUBLIC tStatus smgrSendMirrorRemSrcAddMesg(tMirrorRemSrcRec *pRemSrc, tUint32 IomBitMask)
{
    return smgrSendMirrorRemSrcMesgCommon(TRUE, pRemSrc, IomBitMask, NULL);
}


/* Send a mirror remote source delete message */
PUBLIC tStatus smgrSendMirrorRemSrcDelMesg(tMirrorRemSrcRec *pRemSrc, tUint32 IomBitMask,
                                           struct SMEventMsg *pCallbackEvent)
{
    return smgrSendMirrorRemSrcMesgCommon(FALSE, pRemSrc, IomBitMask, pCallbackEvent);
}

/* Cleanup after delivered SDP BIND messages to the IOM Async */
PUBLIC void smgrIccCleanSendMirrorRemSrc(void *pIccMsg, void *pUserData)
{
    tIomMirrorSourceConfigRequest *pCfg = pIccMsg;

    switch(pCfg->Op) {
    case IOM_MIRROR_SRC_ADD:
    case IOM_MIRROR_SRC_DELETE:
        if (pCfg->handle.Cpm)
            smgrIccCleanup(pCfg->handle.Cpm);
        break;

    case IOM_MIRROR_SRC_AUDIT:
    default: /* Do nothing */
        break;
    }

    SVCMGR_EVENT(IOM_CALL, "Op=%u", pCfg->Op);
    
    SMGR_MESG_MEM_FREE(pIccMsg);                        
}

/* Send a mirror source audit message */
PUBLIC tStatus smgrSendMirrorSrcAudit(tSMSlot SlotNum)
{
    tIomMirrorSourceConfigRequest *pCfg = NULL;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "Mirror AUDIT, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetMirrorSvcRemoteDownloadInfo(&IccInfo, NULL,
                                       IOM_MIRROR_SRC_AUDIT, SlotBitmap,FALSE);
   
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
        
    pCfg = SMGR_MESG_MEM_CALLOC(1, sizeof(*pCfg));
    if (pCfg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot download audit msg (Out of memory)");
        return FAIL;
    }

    pCfg->Op = IOM_MIRROR_SRC_AUDIT;

    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pCfg->Op,
                                IccInfo.IomBitMask,
                                pCfg, sizeof(*pCfg), NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pCfg, s);

    return s;
}


/* Send an IOM_MULTI_SERVICE_SITE_AUDIT message */
PUBLIC tStatus smgrSendMultSvcSiteAudit(tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomQosMultiServiceSiteRequest *pMsg = NULL;
    int reqMsgSize = 0;
    tStatus s = SUCCESS;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL, "MultiServiceSite Audit, slot %u", SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetMssDownloadInfo(&IccInfo, NULL, IOM_POLICY_AUDIT, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    reqMsgSize = SIZE_QOS_MULTI_SERVICE_SITE_MSG(1);
    pMsg = (tIomQosMultiServiceSiteRequest *)SMGR_MESG_MEM_MALLOC(reqMsgSize);
    if (pMsg == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }

    pMsg->NumSites = 1;
    pMsg->Op = IOM_POLICY_AUDIT;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, pMsg->NumSites, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, reqMsgSize, NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "MultiServiceSite Audit failed: %d, for mask=%08x",
                     s, IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;                                  
}


PRIVATE void smgrInitSubscriberAddEntry(tIomSubscriberConfig *pEntry, tSbmActSub *pSub)
{
    tDpiDivertIndex        DpiDivertIndex;
    struct pppoeLnsBundle *pLnsBundle;

    ZERO_STRUCT_PTR(pEntry);

    pLnsBundle = sbmGetPppoeLnsBundle(pSub);

    pEntry->SubscriberId = pSub->iomId;
    pEntry->SubProfileId = pSub->pSubProf->iomId;

    if (pSub->pSubMss)
        pEntry->SiteId = pSub->pSubMss->InstanceId;

    DpiDivertIndex = sbmGetDpiDivertIndex(pSub);
    if ((pSub->pAppProf) && (pSub->pAppProf->divert) && IS_VALID_DPI_DIVERT_INDEX(DpiDivertIndex))
        pEntry->DpiDivertIndex = DpiDivertIndex;
    else
        pEntry->DpiDivertIndex = NO_DPI_DIVERT_SYS_INDEX;

    if (pSub->useIntDestIdAsSecShaper) {
        strcpyn(pEntry->SecondaryShaperName.Name,
                sizeof(pEntry->SecondaryShaperName.Name),
                pSub->intDestId);
    }

    pEntry->EgressRadiusAggRateLimit = pSub->RadiusEgrAggRateLimit;

    if (NULL != pLnsBundle)
        pEntry->EgressAggRateLimit = pppoeLnsBundleGetAggrRateLimit(pLnsBundle);
    else if (pSub->AncpEgrAggRateLimit != 0)
        /* If ANCP is overriding the Egress agg-rate-limit then send that value */
        pEntry->EgressAggRateLimit = pSub->AncpEgrAggRateLimit;
    else
        pEntry->EgressAggRateLimit = -1;

    /* Fill in the rate delta - if none exist, then this field will be zero */
    pEntry->EgressAggRateLimitDelta = pSub->IgmpEgrAggRateLimitDelta;

    /* Egress aggr-rate-limit override for HSMDA2 subscribers */
    if (runtime_feature_sub_egr_arl_ovr_hsmda) {
        if (IS_HSMDA_V2_PORT(pSub->pPortRec)) {
            tUint32 adjustFactor;

            if (sbmShouldAdjustRate(pSub, pSub->pSubProf, &adjustFactor)) {
                tInt32 rawAggRate;
                tInt32 rawAncpRate = pEntry->EgressAggRateLimit;
                tInt32 rawIgmpRate = pEntry->EgressAggRateLimitDelta;

                if (pEntry->EgressRadiusAggRateLimit == -2) {
                    /* No Radius overwrite, take rate from subProf */
                    rawAggRate = pSub->pSubProf->hsmda2EgrAggRateLimit;
                } else {
                    /* Radius overwrite */
                    rawAggRate = pEntry->EgressRadiusAggRateLimit;
                }

                pEntry->EgressRadiusAggRateLimit = sbmAdjustRate(rawAggRate, adjustFactor);
                pEntry->EgressAggRateLimit = sbmAdjustRate(rawAncpRate, adjustFactor);
                if (rawIgmpRate <= 0) {
                    /* Igmp rate is <= 0. As sbmAdjustRate only adjusts positive rates we invert
                     * the rate first and invert the result again.
                     */
                    pEntry->EgressAggRateLimitDelta = -sbmAdjustRate(-rawIgmpRate, adjustFactor);
                } else {
                    /* Hu? */
                    SVCMGR_WARNING(IOM_CALL, "positive IGMP delta:%u", rawIgmpRate);
                }

                SVCMGR_EVENT(IOM_CALL, "sub=\"%s\" (iomId=%u) expandRatio=%u agg:%d->%d ancp:%d->%d igmp:%d->%d",
                             pSub->subId, pSub->iomId, adjustFactor,
                             rawAggRate,  pEntry->EgressRadiusAggRateLimit,
                             rawAncpRate, pEntry->EgressAggRateLimit,
                             rawIgmpRate, pEntry->EgressAggRateLimitDelta);
            }
        }
    }
}


PRIVATE void smgrGetSbmActSubDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                          const tSbmActSub *pSub,
                                          tUint32 IomOp, tUint32 SlotBitmap,
                                          tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmActSub,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccSbmActSubCmp,
                          pSub);
}

/* Send a SUBSCRIBER_ADD message */
PUBLIC tStatus smgrSendSubscriberAddMesg(tSbmActSub *pSub, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *req;
    tUint32 SlotBitmap = 0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "id=%u subprofid=%u slot=%d",
                 pSub->iomId,
                 pSub->pSubProf->iomId,
                 SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
     SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);   
     smgrGetSbmActSubDownloadInfo(&IccInfo, pSub, Op, SlotBitmap, FALSE);
    
   
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
            
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    smgrInitSubscriberAddEntry(&req->Entries[0].Subscriber, pSub);

    /* flush pending subscr msgs first */
    smgrFlushSubscriberAddMesg();
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IccInfo.IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SUBSCRIBER_ADD message */
PUBLIC tStatus smgrBatchSubscriberAddMesgPriv(tSbmActSub *pSub, tUint32 SlotBitmap,
                                              tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_ADD;

    SVCMGR_EVENT(IOM_CALL, "id=%u subprofid=%u slotbitmap=0x%08x",
                 pSub->iomId,
                 pSub->pSubProf->iomId,
                 SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmActSubDownloadInfo(&IccInfo, pSub, Op, SlotBitmap, IsCardOnline);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubscriberAddEntry != 0) && (IccInfo.IomBitMask != PrevSubscriberAddIomBitMask))
        smgrDoFlushSubscriberAddMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSubscriberAddIomBitMask = IccInfo.IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubscriberAddReqMesg == NULL) {
        if ((pSubscriberAddReqMesg = SMGR_MESG_MEM_MALLOC(
                smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubscrEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubscriberAddReqMesg->NumEntries = NextSubscriberAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubscriberAddReqMesg, Op, NextSubscriberAddEntry);
    pElm->Op = Op;
    smgrInitSubscriberAddEntry(&pElm->Subscriber, pSub);

    /* If we reached the limit, flush the message */
    if (pSubscriberAddReqMesg->NumEntries == SMMaxNumSubscrEntriesPerMesg) {
        smgrFlushSubscriberAddMesg();
        if (pBatch)
            pBatch->SubscriberAddSent = FALSE;
    } else {
        NextSubscriberAddEntry++;
        if (pBatch)
            pBatch->SubscriberAddSent = TRUE;
    }
    
    return SUCCESS;
}


/* Flush batched up SUBSCRIBER_ADD messages */
PRIVATE tStatus smgrDoFlushSubscriberAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubscriberAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_ADD;
       
    if (pSubscriberAddReqMesg && (pSubscriberAddReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubscriberAddReqMesg->NumEntries, IomBitMask);    

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmActSub, Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubscriberAddReqMesg, PreFlush);
        pSubscriberAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubscriberAddReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSubscriberAddReqMesg, 
                                          pSubscriberAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSubscriberAddReqMesg);
        }

        /* Start a new batch */
        NextSubscriberAddEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubscriberAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSubscriberAddMesg(void)
{
    return smgrDoFlushSubscriberAddMesg(FALSE);
}


/* Send a SUBSCRIBER_DELETE message */
PUBLIC tStatus smgrSendSubscriberDelMesg(tSbmActSub *pSub, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *req;
    tUint32 SlotBitmap = 0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "id=%u subprofid=%u slot=%d",
                 pSub->iomId,
                 pSub->pSubProf->iomId,
                 SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmActSubDownloadInfo(&IccInfo, pSub, Op, SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    /* Only the SubscriberId is required for a delete operation. */
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    req->Entries[0].Subscriber.SubscriberId = pSub->iomId;

    /* flush pending adds first */
    smgrFlushSubVSOverrideAddMesg();        
    smgrFlushSubscriberAddMesg();

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IccInfo.IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Send a SUBSCRIBER_AUDIT message */
PUBLIC tStatus smgrSendSubscriberAudit(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_ESM_SUBSCRIBER_AUDIT);
}


PRIVATE void smgrInitSubQosOvrAddEntry(tIomSubQosOverride *pEntry,
                                       tSbmActSub *pSub, tSapId *pSapId,
                                       tSbmSLAProfInst *pSLAProfInst,
                                       tSbmSubQosOvr *pSubQosOvr)
{
    tSbmSubQosOvrQueue *pQueue;
    tSbmSubQosOvrPolicer *pPolicer;
    tBoolean ingress;

    ZERO_STRUCT_PTR(pEntry);

    pEntry->SubscriberId = pSub->iomId;
    pEntry->SapId = *pSapId;
    pEntry->SlaProfileId = pSLAProfInst->pSLAProf->iomId;

    pEntry->IsQmda = IS_SAP_HSMDA(pSLAProfInst->pSap) ? TRUE : FALSE;

    ingress = (pSubQosOvr->direction == QOS_DIRECTION_INGRESS) ? TRUE : FALSE;

    switch (pSubQosOvr->type) {
    case SBM_SUB_QOS_OVR_TYPE_QUEUE:
        pQueue = &pSubQosOvr->u.queue;
        if (pEntry->IsQmda && !ingress)
            pEntry->OverrideParms.QueueId =
                MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQueue->id), ingress);
        else
            pEntry->OverrideParms.QueueId =
                MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueue->id), ingress);
        
        if (pQueue->pir != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
            pEntry->OverrideParms.Parms.PIR = pQueue->pir;
            pEntry->OverrideParms.Parms.PIRRule = QOS_ADAPTATION_RULE_CLOSEST;
        }
        if (pQueue->cir != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_CIR;
            pEntry->OverrideParms.Parms.CIR = pQueue->cir;
            pEntry->OverrideParms.Parms.CIRRule = QOS_ADAPTATION_RULE_CLOSEST;
        }
        if (pQueue->cbs != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_CBS;
            pEntry->OverrideParms.Parms.CBS = pQueue->cbs;
        }
        if (pQueue->mbs != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
            pEntry->OverrideParms.Parms.MBS = pQueue->mbs;
        }
        if (pQueue->wrr_weight != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_WRR_WEIGHT;
            pEntry->OverrideParms.Parms.WRRWeight = pQueue->wrr_weight;
        }
        break;
    case SBM_SUB_QOS_OVR_TYPE_POLICER:
        pPolicer = &pSubQosOvr->u.policer;
        pEntry->OverrideParms.QueueId =
            MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicer->id), ingress);
        if (pPolicer->pir != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_PIR;
            pEntry->OverrideParms.Parms.PIR = pPolicer->pir;
            pEntry->OverrideParms.Parms.PIRRule = QOS_ADAPTATION_RULE_CLOSEST;
        }
        if (pPolicer->cir != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_CIR;
            pEntry->OverrideParms.Parms.CIR = pPolicer->cir;
            pEntry->OverrideParms.Parms.CIRRule = QOS_ADAPTATION_RULE_CLOSEST;
        }
        if (pPolicer->cbs != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_CBS;
            pEntry->OverrideParms.Parms.CBS = pPolicer->cbs;
        }
        if (pPolicer->mbs != -2) {
            pEntry->OverrideParms.Mask |= QOS_ELEMENT_OVERRIDE_MBS;
            pEntry->OverrideParms.Parms.MBS = pPolicer->mbs;
        }
        break;
    case SBM_SUB_QOS_OVR_TYPE_NULL:
    case SBM_SUB_QOS_OVR_TYPE_AGG_RATE_LIMIT:
    case SBM_SUB_QOS_OVR_TYPE_ARBITER:
    case SBM_SUB_QOS_OVR_TYPE_ILLEGAL:
        SVCMGR_ERROR(NOCLASS, "override type %d not supported", pSubQosOvr->type);
        break;
    }
}

PRIVATE void smgrGetSapSubQosOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                        const tSbmSLAProfInst *pSLAProfInst,
                                        tPortId portId,
                                        tUint32 IomOp,
                                        tUint32 SlotBitmap,
                                        tBoolean IsCardOnline)
{

    tUint32 IomBitMask = 0; 

    if (portId != INVALID_PORTID)
        IomBitMask = smgrGetPortIomBitMask(portId);
    
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask = IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;;
        if (IsCardOnline)
            pIccInfo->IomBitMask &= IomBitMask;
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             SmgrMsgrEntry_SbmSubQosOvr,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgIccSapSubQosOvrCmp,
                             pSLAProfInst);
    
}

/* Send a SUBSCRIBER_QOS_OVERRIDE_ADD message */
PRIVATE tStatus smgrSendSubQosOvrAddMesgPriv(tSbmActSub *pSub,
                                             tSbmSLAProfInst *pSLAProfInst,
                                             tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tIomSapSubMixedRequest *req;
    tIomSapSubMixedEntry *pElm = NULL;
    tUint32 EntriesLeft;
    tUint32 EntriesAllocated;
    queue_t qp;
    tSmgrMsgrIccInfo IccInfo;
    tSbmSubQosOvrList *pSqoList;
    tSapId sapId;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD;

    if (sbmGetSubQosOvrList(pSLAProfInst, &pSqoList, &sapId) != SUCCESS)
        return FAIL;
    
    SVCMGR_EVENT(IOM_CALL, "sap=%s slotbitmap=0x%08x",
                 smgrFmtSapIdVerboseForDebug(&sapId),
                 SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapSubQosOvrDownloadInfo(&IccInfo, pSLAProfInst,
                                    sapId.PortId, Op,
                                    SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    /* Determine the number of override entries. If we end up
     * with no entries, then don't bother trying to send it...
     */
    if ((EntriesLeft = sbmSubQosOvrListCount(pSqoList)) == 0)
        return SUCCESS;

    req = NULL;
    EntriesAllocated = 0;
    for (qp = queue_first(pSqoList);
         !queue_atend(pSqoList, qp);
         qp = queue_next(qp)) {
        if (req == NULL) {
            EntriesAllocated = MIN(EntriesLeft, MAX_SUB_QOS_OVERRIDE_ENTRIES_PER_MIXED_MSG);
            if ((req = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op,
                        EntriesAllocated))) == NULL)
                return FAIL;
            req->NumEntries = 0;
        }

        pElm = smgrSapSubGetMixedEntryAddr(req, Op, req->NumEntries);
        pElm->Op = Op;
        smgrInitSubQosOvrAddEntry(&pElm->SubQosOverride, pSub, &sapId,
                                  pSLAProfInst, queue_coerce(qp, tSbmSubQosOvr *));
        req->NumEntries++;
        EntriesLeft--;

        if (req->NumEntries >= EntriesAllocated) {            
            /* Send the message to all applicable IOM's */
            SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
            req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
            
            s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                              IccInfo.IomBitMask, req, req->TotalLength,
                                              NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                              SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
            if (s != SUCCESS) {
                SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
                SMGR_MESG_MEM_FREE(req);
            }

            req = NULL;
        }
    }
   
    return s;
}


PRIVATE void smgrInitSubQosOvrDelEntry(tIomSubQosOverride *pEntry,
                                       tSbmActSub *pSub, tSapId *pSapId, tSbmSLAProfInst *pSLAProfInst, tSbmSubQosOvr *pSubQosOvr)
{
    tSbmSubQosOvrQueue *pQueue;
    tSbmSubQosOvrPolicer *pPolicer;
    tBoolean ingress;

    ZERO_STRUCT_PTR(pEntry);

    pEntry->SubscriberId = pSub->iomId;
    pEntry->SapId = *pSapId;
    pEntry->SlaProfileId = pSLAProfInst->pSLAProf->iomId;

    pEntry->IsQmda = IS_SAP_HSMDA(pSLAProfInst->pSap) ? TRUE : FALSE;

    ingress = (pSubQosOvr->direction == QOS_DIRECTION_INGRESS) ? TRUE : FALSE;

    switch (pSubQosOvr->type) {
    case SBM_SUB_QOS_OVR_TYPE_QUEUE:
        pQueue = &pSubQosOvr->u.queue;
        if (pEntry->IsQmda && !ingress)
            pEntry->OverrideParms.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQueue->id), ingress);
        else
            pEntry->OverrideParms.QueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueue->id), ingress);
        break;
    case SBM_SUB_QOS_OVR_TYPE_POLICER:
        pPolicer = &pSubQosOvr->u.policer;
        pEntry->OverrideParms.QueueId = MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicer->id), ingress);
        break;
    case SBM_SUB_QOS_OVR_TYPE_NULL:
    case SBM_SUB_QOS_OVR_TYPE_AGG_RATE_LIMIT:
    case SBM_SUB_QOS_OVR_TYPE_ARBITER:
    case SBM_SUB_QOS_OVR_TYPE_ILLEGAL:
        SVCMGR_ERROR(NOCLASS, "override type %d not supported", pSubQosOvr->type);
        break;
    }
}


/* Send a SUBSCRIBER_QOS_OVERRIDE_DELETE message */
PRIVATE tStatus smgrSendSubQosOvrDelMesg(tSbmActSub *pSub,
                                         tSbmSLAProfInst *pSLAProfInst, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *req;
    tIomSapSubMixedEntry *pElm = NULL;
    tUint32 EntriesLeft;
    tUint32 EntriesAllocated;
    queue_t qp;
    tSbmSubQosOvrList *pSqoList;
    tSapId sapId;
    tUint32 SlotBitmap=0;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE;

    if (sbmGetSubQosOvrList(pSLAProfInst, &pSqoList, &sapId) != SUCCESS)
        return FAIL;
    
    SVCMGR_EVENT(IOM_CALL, "sap=%s slot=%d",
                 smgrFmtSapIdVerboseForDebug(&sapId),
                 SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    
    smgrGetSapSubQosOvrDownloadInfo(&IccInfo,pSLAProfInst,sapId.PortId,
                                    Op, SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    

    /* Determine the number of override entries. If we end up
     * with no entries, then don't bother trying to send it...
     */
    if ((EntriesLeft = sbmSubQosOvrListCount(pSqoList)) == 0)
        return SUCCESS;

    req = NULL;
    EntriesAllocated = 0;
    for (qp = queue_first(pSqoList);
         !queue_atend(pSqoList, qp);
         qp = queue_next(qp)) {
        if (req == NULL) {
            EntriesAllocated = MIN(EntriesLeft, MAX_SUB_QOS_OVERRIDE_ENTRIES_PER_MIXED_MSG);
            if ((req = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op,
                        EntriesAllocated))) == NULL)
                return FAIL;
            req->NumEntries = 0;
        }

        pElm = smgrSapSubGetMixedEntryAddr(req, Op, req->NumEntries);
        pElm->Op = Op;
        smgrInitSubQosOvrDelEntry(&pElm->SubQosOverride, pSub, &sapId,
                                  pSLAProfInst, queue_coerce(qp, tSbmSubQosOvr *));
        req->NumEntries++;
        EntriesLeft--;

        if (req->NumEntries >= EntriesAllocated) {            
            /* Send the message to all applicable IOM's */
            SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
            req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
            
            s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                              IccInfo.IomBitMask, req, req->TotalLength,
                                              NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                              SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
            if (s != SUCCESS) {
                SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
                SMGR_MESG_MEM_FREE(req);
            }

            req = NULL;
        }
    }

    return s;
}


/* Send a SUBSCRIBER_QOS_OVERRIDE_AUDIT message */
PUBLIC tStatus smgrSendSubQosOvrAudit(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT);
}

PRIVATE void smgrInitSubscriberHostFilters(tIomIpFilter *pHostFilter,
                                           tSbmSubHost  *pSubHost)
{
    tBoolean ipv4 = pSubHost->netAddr.isIPv4;

    ZERO_STRUCT_PTR(pHostFilter);

    if (!pSubHost->pSubscrFltrInfo)
    {
        /* No Filter overrides for this host */
        return;
    }

    /* Radius filter override
     * ----------------------
     */
    if (pSubHost->pSubscrFltrInfo->dataRcvd)
    {
        if (ipv4)
        {
            pHostFilter->EgressIpv4FilterId  = pSubHost->pSubscrFltrInfo->egressIpv4FilterId;
            pHostFilter->IngressIpv4FilterId = pSubHost->pSubscrFltrInfo->ingressIpv4FilterId;
        }
        else
        {
            pHostFilter->EgressIpv6FilterId  = pSubHost->pSubscrFltrInfo->egressIpv6FilterId;
            pHostFilter->IngressIpv6FilterId = pSubHost->pSubscrFltrInfo->ingressIpv6FilterId;
        }
    }

    /* One-Time HTTP Redirect override
     * -------------------------------
     * only for IPv4 supported at this time
     */
    if (ipv4)
    {
        if (pSubHost->pSubscrFltrInfo->otHttpRedirState == sbmOtRedir_active &&
            pSubHost->pSubscrFltrInfo->otHttpRedirIpv4FilterId > 0 &&
            pSubHost->pSubscrFltrInfo->otHttpRedirIpv4FilterId <= 0xFFFF
            && (!pSubHost->pRadiusAcct ||
                !pSubHost->pRadiusAcct->otHttpRedirHostWasRedird))
        {
            pHostFilter->IngressIpv4FilterId = pSubHost->pSubscrFltrInfo->otHttpRedirIpv4FilterId;
        }
    }
}

PRIVATE void smgrInitSubscriberHostAddEntry(tIomSubscriberHostConfig *pEntry,
                                            tSbmSubHost *pSubHost, tSapRec *pSap, struct sbmMsg *pSbmMsg)
{
    char ipBuf[FMT_IP6_BUF_SIZE];
    char macBuf[FMT_MAC_BUF_SIZE];
    tUint32 subscriberId = INVALID_SUBSCRIBER_ID;
    tUint32 slaProfileId = INVALID_SLA_PROFILE_ID;
    tUint32 appProfileId = 0;
    tUint32 pppoeMtu = 0; /* 0 == IPoE, else PPPoE */
    tL2TPSessionId l2tpIngSessionId = 0;
    tL2TPSessionId l2tpEgrSessionId = 0;
    tUint32 l2tpTunnelBindId = 0;
    tBoolean is_l2tp_lac_host = FALSE;
    tSbmAleAdjust aleAdjust = {0};
    tSbmActSub *pActSub = NULL;
    struct pppoeLnsBundle *pLnsBundle = NULL;
    tIesIfRec *pSubItf = NULL;

    ZERO_STRUCT_PTR(pEntry);

    if (pSubHost->pSLAProfInst) {
        pActSub = pSubHost->pSLAProfInst->pActSub;

        if (pSubHost->pSLAProfInst->pSLAProf) {
            slaProfileId = pSubHost->pSLAProfInst->pSLAProf->iomId;
        } else {
            SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        }

        if (pActSub) {
            pLnsBundle = sbmGetPppoeLnsBundle(pActSub);
                subscriberId = pActSub->iomId;
            if ((pActSub->pAppProf) &&
                (pActSub->pAppProf->divert))
                appProfileId = pActSub->pAppProf->iomId;
        } else {
            SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        }

        pppoeMtu = sbmGetSubHostPppoeMtu(pSubHost);
        is_l2tp_lac_host = sbmGetSubHostPppoeLacStitchParams(pSubHost, &l2tpIngSessionId, &l2tpEgrSessionId, &l2tpTunnelBindId);
        if (NULL == pLnsBundle) {
            if (pActSub && pActSub->pSubProf) {
                sbmGetAleAdjust(pSubHost->pSLAProfInst, pActSub->pSubProf, &aleAdjust);
            }
        } else {
            tSbmAccessLoopEncap *pEncap;
            pEncap = pppoeLnsBundleGetAccessLoopEncap(pLnsBundle);
            sbmCalcAleAdjust(pEncap, pSubHost->pSap, &aleAdjust);
            // overwrite to fixed value (ignore ethernet + qinq + PPPoE + FCS)
            // real adjust will be done by MS-ISA
            aleAdjust.byteOffsetAdjust = TRUE;
            aleAdjust.byteOffset = -32;
        }
    }

    if (pSubHost->pSubIesIf)
    {
        /* normal situation, the subitf is already chosen */
        pSubItf = pSubHost->pSubIesIf;
    }
    else
    {
        /* no subitf yet chosen (address doesn't match ?),
         * but in case of a retailer subitf we can still determine what the
         * subitf should be (link wholesaler-group/retailer-subitf is unique)
         */
        tUint32 retailId = sbmGetExpectedRetailSvcId(pSubHost);
        if (retailId)
        {
            pSubItf = iesIfRetailerFindViaSap(pSubHost->pSap, retailId);
            if (pSubItf)
            {
                SVCMGR_EVENT(IOM_CALL,"later, itf %s will become retail subitf for this subhost", pSubItf->Name);
            }
        }
    }

    SVCMGR_EVENT(IOM_CALL, "id=%u ip=%s mac=%s pppoesid=%u sap=%s subid-str=\"%s\" subid=%u slaprofid=%u dpi=%u pppoemtu=%u "
                 "ATMadjust=%s offsetAjust=%s offset=%u forwarding=%u vrf=%u",
                 pSubHost->globalHostId,
                 TIM_NET_ADDR_PRINT(&pSubHost->netAddr, ipBuf, sizeof(ipBuf)),
                 FmtMac(&pSubHost->macAddr, macBuf, sizeof(macBuf)),
                 pSubHost->pppoeSessionId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pActSub ? pActSub->subId : "<n/a>",
                 subscriberId,
                 slaProfileId,
                 appProfileId,
                 pppoeMtu,
                 aleAdjust.atmOverheadAdjust ? "yes" : "no",
                 aleAdjust.byteOffsetAdjust ? "yes" : "no",
                 aleAdjust.byteOffset,
                 pSubHost->isForwarding,
                 pSubItf && pSubItf->PrivateRetailSubnets
                      ? pSubItf->SvcRec->Id : pSap->SvcRec->Id);

    pEntry->GlobalHostId = pSubHost->globalHostId;
    pEntry->SubscriberId = subscriberId;
    pEntry->SlaProfileId = slaProfileId;
    pEntry->CatMapPolicyId = 0;
    if (pSubHost->pSLAProfInst &&
        pSubHost->pSLAProfInst->pCrdCtrlInst)
    {
        pEntry->CatMapPolicyId = 
            ussApiGetCrdCtrlInstCatMapId(pSubHost->pSLAProfInst->pCrdCtrlInst);
    }
    if (pSubItf && pSubItf->PrivateRetailSubnets)
    {
        /* Install in the context of the retailer */
        pEntry->SvcId = pSubItf->SvcRec->Id;
    }
    else
    {
        /* Install in the context of the wholesaler */
        pEntry->SvcId = pSap->SvcRec->Id;
    }
    pEntry->SapId = pSap->SapId;
    if (TIM_NET_ADDR_IS_V4(&pSubHost->netAddr))
    {
        pEntry->IpAddrType = IOM_IP_ADDR_V4;
        pEntry->Ip.Ipv4 = pSubHost->netAddr.u.addr;
        pEntry->IpPrefixLen = 0;
    }
    else
    {
        pEntry->IpAddrType = IOM_IP_ADDR_V6;
        sbmIp6SubHostAddr(pSubHost,
                          &pEntry->Ip.Ipv6,
                          &pEntry->IpPrefixLen);
    }
    pEntry->Mac = pSubHost->macAddr;

    /* Mirror and/or Lawful Intercept */
    if (sbmIsActiveLiSource(pSubHost)) {
        /* Radius LI takes precedence */
        tSbmLiInfo liInfo;
        tUint8     mInstIndex;

        sbmGetRadiusLiInfo(pSubHost, &liInfo, &mInstIndex);

        if (liInfo.direction != sbmLiEgress) {
            /* ingress or both */
            pEntry->IngressMirrorLawfulIntercept = TRUE;
            pEntry->IngressMirrorSvcIndex = mInstIndex;
            pEntry->IngressMirrorFcMask = liInfo.fcMap;
            pEntry->IngressMirrorSourceIndex = sbmGetRadiusLiMirrSrcId(pSubHost);
            pEntry->IngressMirrorInterceptId = liInfo.interceptId;
            pEntry->IngressMirrorSessionId = liInfo.sessionId;
        } else {
            pEntry->IngressMirrorLawfulIntercept = 0;
            pEntry->IngressMirrorSvcIndex = 0;
            pEntry->IngressMirrorFcMask = 0;
            pEntry->IngressMirrorSourceIndex = MIRROR_NULL_INST_ID;
            pEntry->IngressMirrorInterceptId = 0;
            pEntry->IngressMirrorSessionId = 0;
        }

        if (liInfo.direction != sbmLiIngress) {
            /* egress or both */
            pEntry->EgressMirrorLawfulIntercept = TRUE;
            pEntry->EgressMirrorSvcIndex = mInstIndex;
            pEntry->EgressMirrorFcMask = liInfo.fcMap;
            pEntry->EgressMirrorSourceIndex = sbmGetRadiusLiMirrSrcId(pSubHost);
            pEntry->EgressMirrorInterceptId = liInfo.interceptId;
            pEntry->EgressMirrorSessionId = liInfo.sessionId;
        } else {
            pEntry->EgressMirrorLawfulIntercept = 0;
            pEntry->EgressMirrorSvcIndex = 0;
            pEntry->EgressMirrorFcMask = 0;
            pEntry->EgressMirrorSourceIndex = MIRROR_NULL_INST_ID;
            pEntry->EgressMirrorInterceptId = 0;
            pEntry->EgressMirrorSessionId = 0;
        }
    } else {
        /* LI/Mirror via CLI-SNMP/Debug */
        tSbmSubHostMirrorInfo *mirrorInfo = pSubHost->pMirrorInfo;

        if (mirrorInfo)
        {
            pEntry->IngressMirrorLawfulIntercept = mirrorInfo->ingMLawfulIntercept;
            pEntry->IngressMirrorSvcIndex = mirrorInfo->ingMSvcIndex;
            pEntry->IngressMirrorFcMask = (mirrorInfo->ingMFcMask? mirrorInfo->ingMFcMask: 0xFF);
            pEntry->IngressMirrorSourceIndex = mirrorInfo->ingMSourceIndex;
            pEntry->IngressMirrorInterceptId = mirrorInfo->ingMInterceptId;
            pEntry->IngressMirrorSessionId = mirrorInfo->ingMSessionId;

            pEntry->EgressMirrorLawfulIntercept = mirrorInfo->egrMLawfulIntercept;
            pEntry->EgressMirrorSvcIndex = mirrorInfo->egrMSvcIndex;
            pEntry->EgressMirrorFcMask = (mirrorInfo->egrMFcMask? mirrorInfo->egrMFcMask: 0xFF);
            pEntry->EgressMirrorSourceIndex = mirrorInfo->egrMSourceIndex;
            pEntry->EgressMirrorInterceptId = mirrorInfo->egrMInterceptId;
            pEntry->EgressMirrorSessionId = mirrorInfo->egrMSessionId;
        }
        else
        {
            pEntry->IngressMirrorLawfulIntercept = 0;
            pEntry->IngressMirrorSvcIndex = 0;
            pEntry->IngressMirrorFcMask = 0;
            pEntry->IngressMirrorSourceIndex = MIRROR_NULL_INST_ID;
            pEntry->IngressMirrorInterceptId = 0;
            pEntry->IngressMirrorSessionId = 0;

            pEntry->EgressMirrorLawfulIntercept = 0;
            pEntry->EgressMirrorSvcIndex = 0;
            pEntry->EgressMirrorFcMask = 0;
            pEntry->EgressMirrorSourceIndex = MIRROR_NULL_INST_ID;
            pEntry->EgressMirrorInterceptId = 0;
            pEntry->EgressMirrorSessionId = 0;
        }
    }
    
    if (pSubHost->pppoeSessionId == PPPOE_INTERNAL_SESSION_ID_PPP)
        pEntry->PppoeSessionId = 0;
    else
        pEntry->PppoeSessionId = pSubHost->pppoeSessionId;
    pEntry->PppMtu = pppoeMtu;
    pEntry->UseIncipientHostForPppoe = 
        sbmGetSubHostPppoeUseIncipientHost(pSubHost);
    pEntry->UseUnicastDestForMcast = TRUE;

    pEntry->Enabled = pSubHost->isForwarding;
    if (pSubHost->pSLAProfInst &&
        pSubHost->pSLAProfInst->pCrdCtrlInst)
    {
        pEntry->Enabled &= ussApiCCAIsAuthorized(pSubHost->pSLAProfInst->pCrdCtrlInst);
    }

    if ((appProfileId) && IS_VALID_DPI_DIVERT_INDEX(pSubHost->pSLAProfInst->dpiEnabledIndex))
        pEntry->DpiDivertIndex = pSubHost->pSLAProfInst->dpiEnabledIndex;
    else
        pEntry->DpiDivertIndex = NO_DPI_DIVERT_SYS_INDEX;

    tQGroupInstanceId qgid = {pSubHost->egrQGrpTemplateId, 1}; // TODO - dmotz for Sanjeev
    pEntry->PolicerEgressPortQGroup = qgid;
    pEntry->EgressQosVportId = pSubHost->egrVportId;

    if (pSap->PortRec->EncapType == PORT_ENCAP_ATM)
    {
        atmEPRetrieveIOMTDOvrIdxs(pSap->VcHand,
                                  &pEntry->IngressAtmTdOverride, &pEntry->EgressAtmTdOverride);
    }

    pEntry->handle.Cpm = pSbmMsg;

    pEntry->EncapAtmOverheadAdjust = aleAdjust.atmOverheadAdjust;
    pEntry->EncapByteOffsetAdjust = aleAdjust.byteOffsetAdjust;
    pEntry->EncapByteOffset = aleAdjust.byteOffset;
    pEntry->IsV6Bridged = sbmIp6SubHostNeedsND(pSubHost);

    if (is_l2tp_lac_host)
    {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L2TP_LAC;
        pEntry->u.lac_nat.L2TPIngressSessionId = l2tpIngSessionId;
        pEntry->u.lac_nat.L2TPEgressSessionId  = l2tpEgrSessionId;
        pEntry->u.lac_nat.L2TPTunnelBindIndex  = l2tpTunnelBindId;
        pEntry->u.lac_nat.L2TPCarriesIPv4      = TRUE;
        pEntry->u.lac_nat.L2TPCarriesIPv6      = TRUE;
    }
    //We must distinguish between NAT subhosts which uses a 
    //bidirectional L2TP tunnel and GTP subhosts with local breakout
    //that use L2TP upstream and GTP downstream 
    else if (pSubHost->pNatSubHost && !pSubHost->hasGtpUplink)
    {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_NAT;

        bbNatGetSubHostTunnelInfo(pSubHost->pNatSubHost,
                                  &l2tpIngSessionId,
                                  &l2tpEgrSessionId,
                                  &l2tpTunnelBindId);

        pEntry->u.lac_nat.L2TPIngressSessionId = l2tpIngSessionId;
        pEntry->u.lac_nat.L2TPEgressSessionId  = l2tpEgrSessionId;
        pEntry->u.lac_nat.L2TPTunnelBindIndex  = l2tpTunnelBindId;
        pEntry->u.lac_nat.L2TPCarriesIPv4      = TRUE;
    }
    else if (pSubHost->hasGtpUplink)
    {
        tUint32 GTPIngressTEID;
        tUint32 GTPEgressTEID;
        tUint32 GTPTunnelBindId;

        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_GTP;

        sbmGetGtpTunnelInfo(pSubHost,
                            &GTPIngressTEID,
                            &GTPEgressTEID,
                            &GTPTunnelBindId);
        //GTP host with local breakout
        if (pSubHost->pNatSubHost)
        {
            bbNatGetSubHostTunnelInfo(pSubHost->pNatSubHost,
                                      &l2tpIngSessionId,
                                      &l2tpEgrSessionId,
                                      &l2tpTunnelBindId);        
        }

        pEntry->u.gtp.IfIndex = pSap->IesIfRec->PipIfInstanceId;
        pEntry->u.gtp.GTPIngressTEID = GTPIngressTEID;
        pEntry->u.gtp.GTPEgressTEID = GTPEgressTEID;
        pEntry->u.gtp.GTPTunnelBindIndex = GTPTunnelBindId;
        pEntry->u.gtp.L2TPTunnelBindIndex = l2tpTunnelBindId;
    }
    else if (pSap->SvcRec->Type == ST_IES)
    {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L3;
        pEntry->u.l3.IfIndex = pSap->IesIfRec->PipIfInstanceId;
        pEntry->u.l3.RetailSvcId = 0;
        pEntry->InterDestId = sbmRtmGetFirstHostRingnodeInstId(pSubHost);
    }
    else if (pSap->SvcRec->Type == ST_VPRN)
    {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L3;
        pEntry->u.l3.IfIndex = pSap->IesIfRec->PipIfInstanceId;
        pEntry->u.l3.RetailSvcId = pSubHost->pSubIesIf ? pSubHost->pSubIesIf->SvcRec->Id : 0;
        pEntry->InterDestId = sbmRtmGetFirstHostRingnodeInstId(pSubHost);
    }
    else if (pSap->SvcRec->Type == ST_TLS) 
    {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_TLS;
    }
    else
    {
        SVCMGR_ERROR(NOCLASS, "invalid service type %u", pSap->SvcRec->Type);
    }
    pEntry->MlpppSub = ((NULL != pActSub) && (NULL != sbmGetPppoeLnsBundle(pActSub)));

    smgrInitSubscriberHostFilters(&pEntry->HostFilter, pSubHost);

}

PRIVATE void smgrGetSbmSubHostDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                           const tSbmSubHost *pSubHost,
                                           const tSapRec *pSap,
                                           tUint32 IomOp, tUint32 SlotBitmap,
                                           tBoolean IsCardOnline)
{

    tUint32 IomBitMask = 0; 

    if (pSap)
        IomBitMask = pSap->PortRec->IomBitMask;
        
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:        
        pIccInfo->IomBitMask = IomBitMask;
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask =SlotBitmap;
        
    }
    smgrMsgrGetObjIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubHost,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccSbmSubHostCmp,
                          pSubHost);
}

/* Send a SUBSCRIBER_HOST_ADD message */
PUBLIC tStatus smgrSendSubscriberHostAddMesg(tSbmSubHost *pSubHost, tSapRec *pSap,
                                             tSMSlot SlotNum, struct sbmMsg *pSbmMsg)
{
    char ipBuf[FMT_IP6_BUF_SIZE];
    char macBuf[FMT_MAC_BUF_SIZE];
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *req;
    tUint32 SlotBitmap = 0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_HOST_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "ip=%s mac=%s pppoesid=%u sap=%s slot=%d",
                 TIM_NET_ADDR_PRINT(&pSubHost->netAddr, ipBuf, sizeof(ipBuf)),
                 FmtMac(&pSubHost->macAddr, macBuf, sizeof(macBuf)),
                 pSubHost->pppoeSessionId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmSubHostDownloadInfo(&IccInfo, pSubHost,pSap,
                                  Op, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
        
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    smgrInitSubscriberHostAddEntry(&req->Entries[0].SubscriberHost, pSubHost, pSap, pSbmMsg);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IccInfo.IomBitMask, req, req->TotalLength, NULL,
                                      pSubHost->blkDnldToIom? SMGR_DNDLER_BLOCK : SMGR_DNDLER_MAY_BLOCK, 
                                      NULL, SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }
    
    pSubHost->blkDnldToIom = FALSE;
    
    return s;
}


/* Batch up a SUBSCRIBER_HOST_ADD message */
PUBLIC tStatus smgrBatchSubscriberHostAddMesgPriv(tSbmSubHost *pSubHost, tSapRec *pSap,
                                                  tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                  tBatchProcessing *pBatch)
{
    char ipBuf[FMT_IP6_BUF_SIZE];
    char macBuf[FMT_MAC_BUF_SIZE];
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSubscriberHostConfig *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_HOST_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "ip=%s mac=%s pppoesid=%u sap=%s slotbitmap=0x%08x",
                 TIM_NET_ADDR_PRINT(&pSubHost->netAddr, ipBuf, sizeof(ipBuf)),
                 FmtMac(&pSubHost->macAddr, macBuf, sizeof(macBuf)),
                 pSubHost->pppoeSessionId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubHostDownloadInfo(&IccInfo, pSubHost,pSap,
                                  Op, SlotBitmap, IsCardOnline);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubscriberHostAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevSubscriberHostAddIomBitMask))
        smgrDoFlushSubscriberHostAddMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSubscriberHostAddIomBitMask = IccInfo.IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubscriberHostAddReqMesg == NULL) {
        if ((pSubscriberHostAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubscrHostEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubscriberHostAddReqMesg->NumEntries = NextSubscriberHostAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubscriberHostAddReqMesg, Op,
                                       NextSubscriberHostAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubscriberHost;

    smgrInitSubscriberHostAddEntry(pEntry, pSubHost, pSap, NULL);
    
    if (pSubHost->blkDnldToIom) {
        SubHostAddDnldBlockType = SMGR_DNDLER_BLOCK;
        pSubHost->blkDnldToIom = FALSE;
    }
    
    /* If we reached the limit, flush the message */
    if (pSubscriberHostAddReqMesg->NumEntries == SMMaxNumSubscrHostEntriesPerMesg) {
        smgrFlushSubscriberHostAddMesg();
        if (pBatch)
            pBatch->SubscriberHostAddSent = FALSE;
    } else {
        NextSubscriberHostAddEntry++;
        if (pBatch)
            pBatch->SubscriberHostAddSent = TRUE;
    }

    return SUCCESS;
}

/* Flush batched up SUBSCRIBER_HOST_ADD messages */
PRIVATE void smgrDoFlushSubscriberHostAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubscriberHostAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_HOST_ADD;

    if (pSubscriberHostAddReqMesg && (pSubscriberHostAddReqMesg->NumEntries > 0)) {
   
        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubscriberHostAddReqMesg->NumEntries, IomBitMask);
        
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmSubHost, Op);
         
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubscriberHostAddReqMesg, PreFlush);
        pSubscriberHostAddReqMesg->TotalLength
             = smgrMesgIccSapSubMsgSize(Op, pSubscriberHostAddReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSubscriberHostAddReqMesg, 
                                          pSubscriberHostAddReqMesg->TotalLength,
                                          NULL, SubHostAddDnldBlockType, NULL, 
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSubscriberHostAddReqMesg);
        }
        
        /* Start a new batch */
        NextSubscriberHostAddEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubscriberHostAddReqMesg = NULL;
        SubHostAddDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
    }
}

PUBLIC void smgrFlushSubscriberHostAddMesg(void)
{
    smgrDoFlushSubscriberHostAddMesg(FALSE);
}

PRIVATE tStatus smgrFlushSbmSubHostAddMesg (void) 
{
    tStatus s=SUCCESS;
    smgrFlushSubscriberHostAddMesg();
    return s;
}

/* Send a SUBSCRIBER_HOST_DELETE message */
PUBLIC tStatus smgrSendSubscriberHostDelMesg(tSbmSubHost *pSubHost, tSapRec *pSap, tSMSlot SlotNum)
{
    char ipBuf[FMT_IP6_BUF_SIZE];
    char macBuf[FMT_MAC_BUF_SIZE];
    tIomSapSubMixedRequest *req;
    tIomSubscriberHostConfig *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap=0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_HOST_DELETE;
    
    SVCMGR_EVENT(IOM_CALL,
                 "id=%u ip=%s mac=%s pppoesid=%u sap=%s subid=%u slaprofid=%u dpi=F slot=%d",
                 pSubHost->globalHostId,
                 TIM_NET_ADDR_PRINT(&pSubHost->netAddr, ipBuf, sizeof(ipBuf)),
                 FmtMac(&pSubHost->macAddr, macBuf, sizeof(macBuf)),
                 pSubHost->pppoeSessionId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 INVALID_SUBSCRIBER_ID,
                 INVALID_SLA_PROFILE_ID,
                 SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmSubHostDownloadInfo(&IccInfo, pSubHost,pSap,
                                  Op, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
        
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubscriberHost;
    pEntry->GlobalHostId = pSubHost->globalHostId;
    pEntry->SubscriberId = INVALID_SUBSCRIBER_ID; /* N/A */
    pEntry->SlaProfileId = INVALID_SLA_PROFILE_ID; /* N/A */
    pEntry->SvcId = pSap->SvcRec->Id;
    pEntry->SapId = pSap->SapId;
    if (TIM_NET_ADDR_IS_V4(&pSubHost->netAddr)) {
        pEntry->IpAddrType = IOM_IP_ADDR_V4;
        pEntry->Ip.Ipv4 = pSubHost->netAddr.u.addr;
    } else {
        pEntry->IpAddrType = IOM_IP_ADDR_V6;
        pEntry->Ip.Ipv6 = pSubHost->netAddr.u.addr6;
    }
    pEntry->IpPrefixLen = 0;
    pEntry->Mac = pSubHost->macAddr;
    pEntry->IngressMirrorSvcIndex = 0; /* N/A */
    pEntry->EgressMirrorSvcIndex = 0; /* N/A */
    pEntry->IngressMirrorLawfulIntercept = FALSE;
    pEntry->EgressMirrorLawfulIntercept = FALSE;
    if (pSubHost->pppoeSessionId == PPPOE_INTERNAL_SESSION_ID_PPP)
        pEntry->PppoeSessionId = 0;
    else
        pEntry->PppoeSessionId = pSubHost->pppoeSessionId;
    pEntry->UseIncipientHostForPppoe = FALSE;
    pEntry->UseUnicastDestForMcast = TRUE;
    pEntry->Enabled = TRUE;
    pEntry->DpiDivertIndex = NO_DPI_DIVERT_SYS_INDEX;
    pEntry->IngressAtmTdOverride = 0;
    pEntry->EgressAtmTdOverride = 0;
    pEntry->IsV6Bridged = 0; /* N/A */

    smgrInitSubscriberHostFilters(&pEntry->HostFilter, pSubHost);

    if (SBM_IS_LAC_SUBHOST(pSubHost)) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L2TP_LAC;
    } else if (pSubHost->pNatSubHost) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_NAT;
    } else if ((pSap->SvcRec->Type == ST_IES) || (pSap->SvcRec->Type == ST_VPRN)) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L3;
        pEntry->u.l3.IfIndex = pSap->IesIfRec->PipIfInstanceId;
        pEntry->u.l3.RetailSvcId = 0;
    } else if (pSap->SvcRec->Type == ST_TLS) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_TLS;
    } else {
        SVCMGR_ERROR(NOCLASS, "invalid service type %u", pSap->SvcRec->Type);
    }                

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, req, req->TotalLength,
                                NULL, pSubHost->blkDnldToIom? SMGR_DNDLER_BLOCK : SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s);
    pSubHost->blkDnldToIom = FALSE;
    
    return s;
}


/* Batch up a SUBSCRIBER_HOST_DELETE or SUBSCRIBER_HOST_UNBIND_SAP message */
PRIVATE tStatus smgrBatchSubscriberHostDelUnbindMesg(tSbmSubHost *pSubHost, tSapRec *pSap,
                                                     tSMSlot SlotNum, tBoolean Unbind,
                                                     tBatchProcessing *pBatch)
{
    char ipBuf[FMT_IP_BUF_SIZE];
    char macBuf[FMT_MAC_BUF_SIZE];
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSubscriberHostConfig *pEntry;
    const eSapSubOp Op = Unbind ? IOM_ESM_HOST_UNBIND_SAP : IOM_ESM_HOST_DELETE;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap = 0;
    
    SVCMGR_EVENT(IOM_CALL,
                 "id=%u ip=%s mac=%s pppoesid=%u sap=%s subid=%u slaprofid=%u dpi=F slot=%d%s",
                 pSubHost->globalHostId,
                 TIM_NET_ADDR_PRINT(&pSubHost->netAddr, ipBuf, sizeof(ipBuf)),
                 FmtMac(&pSubHost->macAddr, macBuf, sizeof(macBuf)),
                 pSubHost->pppoeSessionId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 INVALID_SUBSCRIBER_ID,
                 INVALID_SLA_PROFILE_ID,
                 SlotNum, Unbind ? "Unbind" : "");

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmSubHostDownloadInfo(&IccInfo, pSubHost,pSap,Op,SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if (((NextSubscriberHostDelEntry != 0) &&
         (IccInfo.IomBitMask != PrevSubscriberHostDelIomBitMask)) ||
        ((pSubscriberHostDelReqMesg) && (pSubscriberHostDelReqMesg->NumEntries) &&
         (Op != SubscriberHostDelOp)))
        smgrDoFlushSubscriberHostDelUnbindMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSubscriberHostDelIomBitMask = IccInfo.IomBitMask;

    if (!pSubscriberHostDelReqMesg) {
        if ((pSubscriberHostDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubscrHostEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubscriberHostDelReqMesg->NumEntries = NextSubscriberHostDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubscriberHostDelReqMesg, Op,
                                       NextSubscriberHostDelEntry);
    SubscriberHostDelOp = Op;
    pElm->Op = Op;
    pEntry = &pElm->SubscriberHost;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->GlobalHostId = pSubHost->globalHostId;
    pEntry->SubscriberId = INVALID_SUBSCRIBER_ID;
    pEntry->SlaProfileId = INVALID_SLA_PROFILE_ID;
    pEntry->SvcId = pSap->SvcRec->Id;
    pEntry->SapId = pSap->SapId;
    if (TIM_NET_ADDR_IS_V4(&pSubHost->netAddr)) {
        pEntry->IpAddrType = IOM_IP_ADDR_V4;
        pEntry->Ip.Ipv4 = pSubHost->netAddr.u.addr;
    } else {
        pEntry->IpAddrType = IOM_IP_ADDR_V6;
        pEntry->Ip.Ipv6 = pSubHost->netAddr.u.addr6;
    }
    pEntry->IpPrefixLen = 0;
    pEntry->Mac = pSubHost->macAddr;
    pEntry->IngressMirrorSvcIndex = 0;
    pEntry->EgressMirrorSvcIndex = 0;
    pEntry->IngressMirrorLawfulIntercept = FALSE;
    pEntry->EgressMirrorLawfulIntercept = FALSE;
    if (pSubHost->pppoeSessionId == PPPOE_INTERNAL_SESSION_ID_PPP)
        pEntry->PppoeSessionId = 0;
    else
        pEntry->PppoeSessionId = pSubHost->pppoeSessionId;
    pEntry->UseIncipientHostForPppoe = FALSE;
    pEntry->UseUnicastDestForMcast = TRUE;
    pEntry->Enabled = TRUE;
    pEntry->DpiDivertIndex = NO_DPI_DIVERT_SYS_INDEX;

    pEntry->IngressAtmTdOverride = 0;
    pEntry->EgressAtmTdOverride = 0;
    pEntry->IsV6Bridged = 0; /* N/A */

    if (SBM_IS_LAC_SUBHOST(pSubHost)) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L2TP_LAC;
    } else if (pSubHost->pNatSubHost) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_NAT;
    } else if ((pSap->SvcRec->Type == ST_IES) || (pSap->SvcRec->Type == ST_VPRN)) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L3;
        pEntry->u.l3.IfIndex = pSap->IesIfRec->PipIfInstanceId;
        pEntry->u.l3.RetailSvcId = 0;
    } else if (pSap->SvcRec->Type == ST_TLS) {
        pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_TLS;
    } else {
        SVCMGR_ERROR(NOCLASS, "invalid service type %u", pSap->SvcRec->Type);
    }

    smgrInitSubscriberHostFilters(&pEntry->HostFilter, pSubHost);
    
    if (pSubHost->blkDnldToIom) {
        SubHostDelDnldBlockType = SMGR_DNDLER_BLOCK;
        pSubHost->blkDnldToIom = FALSE;
    }

    /* If we reached the limit, flush the message */
    if (pSubscriberHostDelReqMesg->NumEntries == SMMaxNumSubscrHostEntriesPerMesg) {
        smgrDoFlushSubscriberHostDelUnbindMesg(FALSE);
        if (pBatch)
            pBatch->SubscriberHostDelUnbindSent = FALSE;
    } else {
        NextSubscriberHostDelEntry++;
        if (pBatch)
            pBatch->SubscriberHostDelUnbindSent = TRUE;
    }

    return SUCCESS;
}


/* Batch up a IOM_SUBSCRIBER_HOST_DEL_SAP message */
PUBLIC tStatus smgrBatchSubscriberHostDelMesg(tSbmSubHost *pSubHost, tSapRec *pSap, tSMSlot SlotNum,
                                              tBatchProcessing *pBatch)
{
    tStatus rc;

    rc = smgrBatchSubscriberHostDelUnbindMesg(pSubHost, pSap, SlotNum, FALSE,
                                              pBatch);

    return rc;
}

/* Batch up a IOM_ESM_HOST_UNBIND_SAP message */
PUBLIC tStatus smgrBatchSubscriberHostUnbindMesg(tSbmSubHost *pSubHost, tSapRec *pSap, tSMSlot SlotNum,
                                                 tBatchProcessing *pBatch)
{
    tStatus rc;

    rc = smgrBatchSubscriberHostDelUnbindMesg(pSubHost, pSap, SlotNum, TRUE,
                                              pBatch);

    return rc;
}

/* Flush batched up SUBSCRIBER_HOST_DELETE messages */
PRIVATE tStatus smgrDoFlushSubscriberHostDelUnbindMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubscriberHostDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
   
    if (!pSubscriberHostDelReqMesg)
        return OK;
    
    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x%s",
                 pSubscriberHostDelReqMesg->NumEntries, IomBitMask,
                 pSubscriberHostDelReqMesg->NumEntries &&
                 (SubscriberHostDelOp == IOM_ESM_HOST_UNBIND_SAP) ?
                 " Unbind" : "");

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SbmSubHost, SubscriberHostDelOp);
    
    if (pSubscriberHostDelReqMesg->NumEntries > 0) {
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubscriberHostDelReqMesg, PreFlush);
        pSubscriberHostDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(SubscriberHostDelOp, pSubscriberHostDelReqMesg->NumEntries);
        
        s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, SubscriberHostDelOp,
                                    IomBitMask, pSubscriberHostDelReqMesg, 
                                    pSubscriberHostDelReqMesg->TotalLength,
                                    NULL, SubHostDelDnldBlockType);
        if (s != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x", IomBitMask);
        
        smgrFreeClientMsg(pSubscriberHostDelReqMesg, s);  

        /* Start a new batch */
        NextSubscriberHostDelEntry = 0;
        pSubscriberHostDelReqMesg = NULL;
        SubHostDelDnldBlockType = SMGR_DNDLER_MAY_BLOCK;
        SubscriberHostDelOp = 0;
    }

    return s;
}

PUBLIC tStatus smgrFlushSubscriberHostDelUnbindMesg(void)
{
    return smgrDoFlushSubscriberHostDelUnbindMesg(FALSE);
}

/* Send a SUBSCRIBER_HOST_AUDIT message */
PUBLIC tStatus smgrSendSubscriberHostAudit(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_ESM_HOST_AUDIT);
}

PRIVATE void smgrGetSbmLnsSubscriberHostDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                     tUint32 lnsClientId,
                                                     tUint32 IomOp, tUint32 SlotBitmap,
                                                     tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmPppoeLnsSubHost,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccSbmPppoeLnsSubCmp,
                          lnsClientId);
}


/* Send an LNS-type SUBSCRIBER_HOST_ADD message */
PUBLIC tStatus smgrSendLnsSubscriberHostAddMesg(tUint32 lnsClientId,tL2TPTunnelId L2tpIngTunnelId,
                                                tL2TPSessionId L2tpIngSessionId,
                                                tUint32 IfIndex, tIpAddr NhAddress,
                                                tSMSlot SlotNum,
                                                struct sbmMsg *pSbmMsg)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *req;
    tIomSubscriberHostConfig *pEntry;
    tUint32 SlotBitmap = 0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_HOST_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "tunnelid=%u sessionid=%u ifindex=%u nhaddr=%u.%u.%u.%u slot=%d",
                 L2tpIngTunnelId,
                 L2tpIngSessionId,
                 IfIndex,
                 PRINT_IP(NhAddress),
                 SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmLnsSubscriberHostDownloadInfo(&IccInfo, lnsClientId, Op, SlotBitmap, FALSE);
   
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubscriberHost;
    pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L2TP_LNS;
    pEntry->u.lns.L2TPIngressTunnelId  = L2tpIngTunnelId;
    pEntry->u.lns.L2TPIngressSessionId = L2tpIngSessionId;
    pEntry->u.lns.L2TPInterfaceIndex   = IfIndex;
    pEntry->u.lns.LNSNexthop           = NhAddress;
    pEntry->Enabled = TRUE;

    pEntry->handle.Cpm = pSbmMsg;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IccInfo.IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up an LNS-type SUBSCRIBER_HOST_ADD message */
PUBLIC tStatus smgrBatchLnsSubscriberHostAddMesgPriv(tUint32 lnsClientId,tL2TPTunnelId L2tpIngTunnelId,
                                                     tL2TPSessionId L2tpIngSessionId,
                                                     tUint32 IfIndex, tIpAddr NhAddress,
                                                     tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                     tBatchProcessing *pBatch)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSubscriberHostConfig *pEntry;
    const eSapSubOp Op = IOM_ESM_HOST_ADD;

    SVCMGR_EVENT(IOM_CALL, "tunnelid=%u sessionid=%u ifindex=%u nhaddr=%u.%u.%u.%u slotbitmap=0x%08x",
                 L2tpIngTunnelId,
                 L2tpIngSessionId,
                 IfIndex,
                 PRINT_IP(NhAddress),
                 SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmLnsSubscriberHostDownloadInfo(&IccInfo, lnsClientId, Op,
                                            SlotBitmap, IsCardOnline);
   
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubscriberHostAddEntry != 0) &&
        (IccInfo.IomBitMask != PrevSubscriberHostAddIomBitMask))
        smgrDoFlushSubscriberHostAddMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSubscriberHostAddIomBitMask = IccInfo.IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubscriberHostAddReqMesg == NULL) {
        if ((pSubscriberHostAddReqMesg =
             SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubscrHostEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubscriberHostAddReqMesg->NumEntries = NextSubscriberHostAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubscriberHostAddReqMesg, Op,
                                       NextSubscriberHostAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubscriberHost;

    ZERO_STRUCT_PTR(pEntry);

    pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L2TP_LNS;
    pEntry->u.lns.L2TPIngressTunnelId  = L2tpIngTunnelId;
    pEntry->u.lns.L2TPIngressSessionId = L2tpIngSessionId;
    pEntry->u.lns.L2TPInterfaceIndex   = IfIndex;
    pEntry->u.lns.LNSNexthop           = NhAddress;
    pEntry->Enabled = TRUE;
    
    /* If we reached the limit, flush the message */
    if (pSubscriberHostAddReqMesg->NumEntries == SMMaxNumSubscrHostEntriesPerMesg) {
        smgrFlushSubscriberHostAddMesg();
        if (pBatch)
            pBatch->LnsSubscriberHostAddSent = FALSE;
    } else {
        NextSubscriberHostAddEntry++;
        if (pBatch)
            pBatch->LnsSubscriberHostAddSent = TRUE;
    }
        
    return SUCCESS;
}


/* Send an LNS-type SUBSCRIBER_HOST_DELETE message */
PUBLIC tStatus smgrSendLnsSubscriberHostDelMesg(tUint32 lnsClientId,tL2TPTunnelId L2tpIngTunnelId,
                                                tL2TPSessionId L2tpIngSessionId,
                                                tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *req;
    tIomSubscriberHostConfig *pEntry;
    tUint32 SlotBitmap=0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_HOST_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "tunnelid=%u sessionid=%u slot=%d",
                 L2tpIngTunnelId,
                 L2tpIngSessionId,
                 SlotNum);
    
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmLnsSubscriberHostDownloadInfo(&IccInfo, lnsClientId,
                                            Op, SlotBitmap, FALSE);
   
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubscriberHost;
    pEntry->HostType = IOM_SUBSCRIBER_HOST_TYPE_L2TP_LNS;
    pEntry->u.lns.L2TPIngressTunnelId  = L2tpIngTunnelId;
    pEntry->u.lns.L2TPIngressSessionId = L2tpIngSessionId;
    
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, req, req->TotalLength,
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(req, s); 

    return s;
}

PRIVATE void smgrGetSbmSubProfDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                           const  tSbmSubProf *pSubProf,
                                           tUint32 IomOp,
                                           tUint32 SlotBitmap,
                                           tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubProfile,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccSbmSubProfCmp,
                          pSubProf);
}

/* Send a SUB_PROFILE_ADD message */
PUBLIC void smgrSendSubProfileAddMesgPriv(tSbmSubProf *pSubProf,
                                          tUint32 SlotBitmap,
                                          tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *pReq = NULL;
    tIomSubProfileConfig *pEntry;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_ADD;

    SVCMGR_EVENT(IOM_CALL, "id=%u slotbitmap=0x%08x", pSubProf->iomId, SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    
    smgrGetSbmSubProfDownloadInfo(&IccInfo,pSubProf,
                                  Op, SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return;
    
    pReq = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1));
    if (pReq == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return;
    }

    pReq->NumEntries = 1;
    pReq->Entries[0].Op = Op;
    pEntry = &pReq->Entries[0].SubProfile;
    pEntry->SubProfileId = pSubProf->iomId;
    if (pSubProf->pIngQosSchedPol)
        pEntry->IngressSchedulerPolicyId = pSubProf->pIngQosSchedPol->InstanceId;
    if (pSubProf->pEgrQosSchedPol)
        pEntry->EgressSchedulerPolicyId = pSubProf->pEgrQosSchedPol->InstanceId;
    if (pSubProf->pIngQosPolicerCtrlPol)
        pEntry->IngressArbiterPolicyId = pSubProf->pIngQosPolicerCtrlPol->InstanceId;
    if (pSubProf->pEgrQosPolicerCtrlPol)
        pEntry->EgressArbiterPolicyId = pSubProf->pEgrQosPolicerCtrlPol->InstanceId;
    pEntry->EgressAggRateLimit = pSubProf->egrAggRateLimit;
    pEntry->EgressAggRateOnTheWire =
        pSubProf->FrameBasedAccounting == VAL_tmnxSubProfFrameBasedAccounting_true ?
        TRUE : FALSE;

    /* HSMDAv2 */
    pEntry->IngressPolicyId = pSubProf->pHsmda2IngQosPol->Id;
    pEntry->EgressPolicyId = pSubProf->pHsmda2EgrQosPol->Id;
    pEntry->IngressQmdaAggRateLimit = -1; // TIMW_TODO - obsolete, this can be killed
    pEntry->EgressQmdaAggRateLimit = pSubProf->hsmda2EgrAggRateLimit;

    pEntry->IngressPacketByteOffset = 0;
    pEntry->OverrideIngressPacketByteOffset = FALSE;

    if (pSubProf->hsmda2EgrPackByteOff != DEFVAL_tmnxSubProfHsmda2EgrPackByteOff) {
        pEntry->EgressPacketByteOffset = pSubProf->hsmda2EgrPackByteOff;
        pEntry->OverrideEgressPacketByteOffset = TRUE;
    } else {
        pEntry->EgressPacketByteOffset = 0;
        pEntry->OverrideEgressPacketByteOffset = FALSE;
    }
    
    pEntry->OverrideEgressWrrPolicyId = pSubProf->hsmda2EgrQosWrrPolicyId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    pReq->TotalLength = smgrMesgIccSapSubMsgSize(Op, pReq->NumEntries);
    
    /* Buffered Download: Blocking call since configuration in profile may be dependent
     * on non-SVCMGR socket */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pReq, pReq->TotalLength,
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pReq, s);
}


/* Send a SUB_PROFILE_DELETE message */
PUBLIC void smgrSendSubProfileDelMesg(tSbmSubProf *pSubProf, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *pReq = NULL;
    tIomSubProfileConfig *pEntry;
    tUint32 SlotBitmap=0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "id=%u slot=%d", pSubProf->iomId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmSubProfDownloadInfo(&IccInfo,pSubProf,
                                  Op, SlotBitmap, FALSE);

    if (IccInfo.IomBitMask == 0)
        return;
    
    pReq = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1));
    if (pReq == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return;
    }
    
    pReq->NumEntries = 1;
    pReq->Entries[0].Op = Op;
    pEntry = &pReq->Entries[0].SubProfile;
    pEntry->SubProfileId = pSubProf->iomId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    pReq->TotalLength = smgrMesgIccSapSubMsgSize(Op, pReq->NumEntries);
    
    /* Buffered Download: Blocking call since configuration in profile may be dependent
     * on non-SVCMGR socket */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pReq, pReq->TotalLength,
                                NULL, SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pReq, s);
}


/* Send a SUB_PROFILE_AUDIT message */
PUBLIC tStatus smgrSendSubProfileAudit(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_ESM_SUB_PROFILE_AUDIT);
}


PRIVATE void smgrGetSbmSubProfSchedOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                   const  tSbmSubProfSchedOvr *pSchedOvr,
                                                   tUint32 IomOp,
                                                   tUint32 SlotBitmap,
                                                   tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubProfileSchedOvr,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSubProfSchedOvrCmp,
                          pSchedOvr);
}

/* Send a SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSubProfVSOverrideAddMesg(tSbmSubProfSchedOvr *pSchedOvr,
                                                tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL,
                 "subprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSubProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
        
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str),
            pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSubProf->iomId;
    pEntry->OverrideMask = QOS_GROUP_OVERRIDE_RATE |
                                   QOS_GROUP_OVERRIDE_CIR  |
                                   QOS_GROUP_OVERRIDE_CIR_IS_SUM_MEMBER_CIRS;
    pEntry->Parms.Scheduler.Rate = pSchedOvr->PIR;
    pEntry->Parms.Scheduler.CIRIsSumMemberCIRs =
        (pSchedOvr->summedCIR == VAL_tmnxSubProfSchedOvrSummedCIR_true) ? TRUE : FALSE;
    pEntry->Parms.Scheduler.CIR = pSchedOvr->CIR;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSubProfVSOverrideAddMesgPriv(tSbmSubProfSchedOvr *pSchedOvr,
                                                     tUint32 IomBitMask,
                                                     tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                     tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL,
                 "subprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSubProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op, SlotBitmap,IsCardOnline);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubProfVSOverrideAddEntry != 0) &&
        (IomBitMask != PrevSubProfVSOverrideAddIomBitMask))
        smgrDoFlushSubProfVSOverrideAddMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSubProfVSOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubProfVSOverrideAddReqMesg == NULL) {
        if ((pSubProfVSOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubProfVSOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubProfVSOverrideAddReqMesg->NumEntries = NextSubProfVSOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubProfVSOverrideAddReqMesg, Op,
                                       NextSubProfVSOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSubProf->iomId;
    pEntry->OverrideMask = QOS_GROUP_OVERRIDE_RATE |
                           QOS_GROUP_OVERRIDE_CIR  |
                           QOS_GROUP_OVERRIDE_CIR_IS_SUM_MEMBER_CIRS;
    pEntry->Parms.Scheduler.Rate = pSchedOvr->PIR;
    pEntry->Parms.Scheduler.CIRIsSumMemberCIRs =
        (pSchedOvr->summedCIR == VAL_tmnxSubProfSchedOvrSummedCIR_true) ? TRUE : FALSE;
    pEntry->Parms.Scheduler.CIR = pSchedOvr->CIR;
    
    /* If we reached the limit, flush the message */
    if (pSubProfVSOverrideAddReqMesg->NumEntries == SMMaxNumSubProfVSOverrideEntriesPerMesg) {
        smgrFlushSubProfVSOverrideAddMesg();
        if (pBatch)
            pBatch->SubProfVSOverrideAddSent = FALSE;
    } else {
        NextSubProfVSOverrideAddEntry++;
        if (pBatch)
            pBatch->SubProfVSOverrideAddSent = TRUE;
    }
        
    return SUCCESS;
}


/* Flush batched up SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSubProfVSOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubProfVSOverrideAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;
    
    if (pSubProfVSOverrideAddReqMesg && (pSubProfVSOverrideAddReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubProfVSOverrideAddReqMesg->NumEntries,
                     IomBitMask);
        
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmSubProfileSchedOvr, Op);
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubProfVSOverrideAddReqMesg, PreFlush);
        pSubProfVSOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubProfVSOverrideAddReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op, IomBitMask,
                                          pSubProfVSOverrideAddReqMesg,
                                          pSubProfVSOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSubProfVSOverrideAddReqMesg);
        }

        /* Start a new batch */
        NextSubProfVSOverrideAddEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubProfVSOverrideAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSubProfVSOverrideAddMesg(void)
{
    return smgrDoFlushSubProfVSOverrideAddMesg(FALSE);
}

/* Send a SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSubProfVSOverrideDelMesg(tSbmSubProfSchedOvr *pSchedOvr,
                                                tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL,
                 "subprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSubProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op,
                                          ALL_APPLICABLE_IOMS,FALSE);
    
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
        
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSubProf->iomId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req,  req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSubProfVSOverrideDelMesg(struct sbmSubProfSchedOvr *pSchedOvr,
                                                 tUint32 IomBitMask, tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSubProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;
    
    if (IomBitMask == 0)
        return SUCCESS; 
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubProfVSOverrideDelEntry != 0) &&
        (IomBitMask != PrevSubProfVSOverrideDelIomBitMask))
        smgrDoFlushSubProfVSOverrideDelMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSubProfVSOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubProfVSOverrideDelReqMesg == NULL) {
        if ((pSubProfVSOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubProfVSOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubProfVSOverrideDelReqMesg->NumEntries = NextSubProfVSOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubProfVSOverrideDelReqMesg, Op,
                                       NextSubProfVSOverrideDelEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSubProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSubProf->iomId;
    
    /* If we reached the limit, flush the message */
    if (pSubProfVSOverrideDelReqMesg->NumEntries ==
        SMMaxNumSubProfVSOverrideEntriesPerMesg) {
        smgrFlushSubProfVSOverrideDelMesg();
        if (pBatch)
            pBatch->SubProfVSOverrideDelSent = FALSE;
    } else {
        NextSubProfVSOverrideDelEntry++;
        if (pBatch)
            pBatch->SubProfVSOverrideDelSent = TRUE;
    }    
    
    return SUCCESS;
}


/* Flush batched up SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSubProfVSOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubProfVSOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;
    
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SbmSubProfileSchedOvr, Op);
    
    if (pSubProfVSOverrideDelReqMesg && (pSubProfVSOverrideDelReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubProfVSOverrideDelReqMesg->NumEntries,
                     IomBitMask);
    
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubProfVSOverrideDelReqMesg, PreFlush);
        pSubProfVSOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubProfVSOverrideDelReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSubProfVSOverrideDelReqMesg,
                                          pSubProfVSOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSubProfVSOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSubProfVSOverrideDelEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubProfVSOverrideDelReqMesg = NULL;
    }
}

PUBLIC void smgrFlushSubProfVSOverrideDelMesg(void)
{
    smgrDoFlushSubProfVSOverrideDelMesg(FALSE);
}

PRIVATE void smgrGetSbmSubProfPlcrCtrlOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                      const  tSbmSubProfPlcrCtrlOvr *pPlcrCtrlOvr,
                                                      tUint32 IomOp,
                                                      tUint32 SlotBitmap,
                                                      tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubProfilePlcrCtrlOvr,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSubProfPlcrCtrlOvrCmp,
                          pPlcrCtrlOvr);
}

/* Send a SUB_PROFILE_POLICER_CONTROL_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSubProfPlcrCtrlOverrideAddMesg(tSbmSubProfPlcrCtrlOvr *pPlcrCtrlOvr,
                                                      tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomQosGroupOverride *pEntry;
    int i;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL,
                 "subprofid=%u direction=%s bitmap=%08x",
                 pPlcrCtrlOvr->pSubProf->iomId,
                 (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ?
                 "ingress" : "egress",
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfPlcrCtrlOvrDownloadInfo(&IccInfo, pPlcrCtrlOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    pEntry->SchedulerId.TypeId.Dir = (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), QOS_ROOT_ARBITER_NAME);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pPlcrCtrlOvr->pSubProf->iomId;
        
    pEntry->Parms.Arbiter.IsRoot = TRUE;
    if (pPlcrCtrlOvr->maxRate != -2) {
        pEntry->OverrideMask |= QOS_GROUP_OVERRIDE_RATE;
        pEntry->Parms.Arbiter.Rate = pPlcrCtrlOvr->maxRate;
    }
    if (pPlcrCtrlOvr->minMBSSep != -2) {
        pEntry->OverrideMask |= QOS_GROUP_OVERRIDE_MIN_MBS_SEPARATION;
        pEntry->Parms.Arbiter.Cfg.Root.Thresholds.MinSeparation = pPlcrCtrlOvr->minMBSSep;
    }
    for (i = 1; i <= MAX_QOS_STRICT_LEVEL; i++) {
        if (pPlcrCtrlOvr->level[i].exists) {
            if (pPlcrCtrlOvr->level[i].cumMBS != -2) {
                pEntry->OverrideMask |= (QOS_GROUP_OVERRIDE_MBS_CONTRIBUTION_BASE << i);
                pEntry->Parms.Arbiter.Cfg.Root.Thresholds.PBS[i] = pPlcrCtrlOvr->level[i].cumMBS;
            }
        }
    }
   
    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);

    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SUB_PROFILE_POLICER_CONTROL_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSubProfPlcrCtrlOverrideAddMesgPriv(tSbmSubProfPlcrCtrlOvr *pPlcrCtrlOvr,
                                                           tUint32 IomBitMask, tUint32 SlotBitmap,
                                                           tBoolean IsCardOnline, tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    int i;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;
     
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u direction=%s bitmap=%08x",
                 pPlcrCtrlOvr->pSubProf->iomId,
                 (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress)?
                 "ingress" : "egress",
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfPlcrCtrlOvrDownloadInfo(&IccInfo, pPlcrCtrlOvr, Op, SlotBitmap, IsCardOnline);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubProfPlcrCtrlOverrideAddEntry != 0) &&
        (IomBitMask != PrevSubProfPlcrCtrlOverrideAddIomBitMask))
        smgrDoFlushSubProfPlcrCtrlOverrideAddMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSubProfPlcrCtrlOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubProfPlcrCtrlOverrideAddReqMesg == NULL) {
        if ((pSubProfPlcrCtrlOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubProfPlcrCtrlOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubProfPlcrCtrlOverrideAddReqMesg->NumEntries = NextSubProfPlcrCtrlOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubProfPlcrCtrlOverrideAddReqMesg, Op,
                                       NextSubProfPlcrCtrlOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    pEntry->SchedulerId.TypeId.Dir = (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), QOS_ROOT_ARBITER_NAME);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pPlcrCtrlOvr->pSubProf->iomId;
    pEntry->Parms.Arbiter.IsRoot = TRUE;
    if (pPlcrCtrlOvr->maxRate != -2) {
        pEntry->OverrideMask |= QOS_GROUP_OVERRIDE_RATE;
        pEntry->Parms.Arbiter.Rate = pPlcrCtrlOvr->maxRate;
    }
    if (pPlcrCtrlOvr->minMBSSep != -2) {
        pEntry->OverrideMask |= QOS_GROUP_OVERRIDE_MIN_MBS_SEPARATION;
        pEntry->Parms.Arbiter.Cfg.Root.Thresholds.MinSeparation = pPlcrCtrlOvr->minMBSSep;
    }
    for (i = 1; i <= MAX_QOS_STRICT_LEVEL; i++) {
        if (pPlcrCtrlOvr->level[i].exists) {
            if (pPlcrCtrlOvr->level[i].cumMBS != -2) {
                pEntry->OverrideMask |= (QOS_GROUP_OVERRIDE_MBS_CONTRIBUTION_BASE << i);
                pEntry->Parms.Arbiter.Cfg.Root.Thresholds.PBS[i] = pPlcrCtrlOvr->level[i].cumMBS;
            }
        }
    }

    /* If we reached the limit, flush the message */
    if (pSubProfPlcrCtrlOverrideAddReqMesg->NumEntries ==
        SMMaxNumSubProfPlcrCtrlOverrideEntriesPerMesg) {
        smgrFlushSubProfPlcrCtrlOverrideAddMesg();
        if (pBatch)
            pBatch->SubProfPlcrCtrlOverrideAddSent = FALSE;
    } else {
        NextSubProfPlcrCtrlOverrideAddEntry++;
        if (pBatch)
            pBatch->SubProfPlcrCtrlOverrideAddSent = TRUE;
    }
    
    return SUCCESS;
}


/* Flush batched up SUB_PROFILE_POLICER_CONTROL_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSubProfPlcrCtrlOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubProfPlcrCtrlOverrideAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;
     
    if (pSubProfPlcrCtrlOverrideAddReqMesg &&
        (pSubProfPlcrCtrlOverrideAddReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubProfPlcrCtrlOverrideAddReqMesg->NumEntries, IomBitMask);
        
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmSubProfilePlcrCtrlOvr, Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubProfPlcrCtrlOverrideAddReqMesg, PreFlush);
        pSubProfPlcrCtrlOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubProfPlcrCtrlOverrideAddReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op, IomBitMask,
                                          pSubProfPlcrCtrlOverrideAddReqMesg,
                                          pSubProfPlcrCtrlOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSubProfPlcrCtrlOverrideAddReqMesg);
        }

        /* Start a new batch */
        NextSubProfPlcrCtrlOverrideAddEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubProfPlcrCtrlOverrideAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSubProfPlcrCtrlOverrideAddMesg(void)
{
    return smgrDoFlushSubProfPlcrCtrlOverrideAddMesg(FALSE);
}

/* Send a SUB_PROFILE_POLICER_CONTROL_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSubProfPlcrCtrlOverrideDelMesg(tSbmSubProfPlcrCtrlOvr *pPlcrCtrlOvr,
                                                      tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u direction=%s bitmap=%08x",
                 pPlcrCtrlOvr->pSubProf->iomId,
                 (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ?
                 "ingress" : "egress",
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfPlcrCtrlOvrDownloadInfo(&IccInfo, pPlcrCtrlOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    pEntry->SchedulerId.TypeId.Dir = (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), QOS_ROOT_ARBITER_NAME);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pPlcrCtrlOvr->pSubProf->iomId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SUB_PROFILE_POLICER_CONTROL_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSubProfPlcrCtrlOverrideDelMesg(tSbmSubProfPlcrCtrlOvr *pPlcrCtrlOvr,
                                                       tUint32 IomBitMask, tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u direction=%s bitmap=%08x",
                 pPlcrCtrlOvr->pSubProf->iomId,
                 (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ?
                 "ingress" : "egress",
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfPlcrCtrlOvrDownloadInfo(&IccInfo, pPlcrCtrlOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;


    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubProfPlcrCtrlOverrideDelEntry != 0) &&
        (IomBitMask != PrevSubProfPlcrCtrlOverrideDelIomBitMask))
        smgrDoFlushSubProfPlcrCtrlOverrideDelMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSubProfPlcrCtrlOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubProfPlcrCtrlOverrideDelReqMesg == NULL) {
        if ((pSubProfPlcrCtrlOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubProfPlcrCtrlOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubProfPlcrCtrlOverrideDelReqMesg->NumEntries = NextSubProfPlcrCtrlOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubProfPlcrCtrlOverrideDelReqMesg, Op,
                                       NextSubProfPlcrCtrlOverrideDelEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUB_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_ARBITER;
    pEntry->SchedulerId.TypeId.Dir = (pPlcrCtrlOvr->direction == VAL_tmnxSubProfPCtrlOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), QOS_ROOT_ARBITER_NAME);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pPlcrCtrlOvr->pSubProf->iomId;

    /* If we reached the limit, flush the message */
    if (pSubProfPlcrCtrlOverrideDelReqMesg->NumEntries == SMMaxNumSubProfPlcrCtrlOverrideEntriesPerMesg) {
        smgrFlushSubProfPlcrCtrlOverrideDelMesg();
        if (pBatch)
            pBatch->SubProfPlcrCtrlOverrideDelSent = FALSE;
    } else {
        NextSubProfPlcrCtrlOverrideDelEntry++;
        if (pBatch)
            pBatch->SubProfPlcrCtrlOverrideDelSent = TRUE;
    }
    
    return SUCCESS;
}


/* Flush batched up SUB_PROFILE_POLICER_CONTROL_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSubProfPlcrCtrlOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubProfPlcrCtrlOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SbmSubProfilePlcrCtrlOvr, Op);
    
    if (pSubProfPlcrCtrlOverrideDelReqMesg &&
        (pSubProfPlcrCtrlOverrideDelReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubProfPlcrCtrlOverrideDelReqMesg->NumEntries, IomBitMask);

        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubProfPlcrCtrlOverrideDelReqMesg, PreFlush);
        pSubProfPlcrCtrlOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubProfPlcrCtrlOverrideDelReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSubProfPlcrCtrlOverrideDelReqMesg,
                                          pSubProfPlcrCtrlOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSubProfPlcrCtrlOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSubProfPlcrCtrlOverrideDelEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubProfPlcrCtrlOverrideDelReqMesg = NULL;
    }
}

PUBLIC void smgrFlushSubProfPlcrCtrlOverrideDelMesg(void)
{
    smgrDoFlushSubProfPlcrCtrlOverrideDelMesg(FALSE);
}

PRIVATE void smgrDoFlushSubL3RedGroupMesg(tBoolean Sync, tBoolean PreFlush)
{
    tStatus rc;
    tUint32 IomBitMask = PrevSubL3RedGroupIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    
    if (!pSubL3RedGroupRequest) {
        return;
    }
    
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SbmSubIesIfGroupIf,
                               SubL3RedGroupOp);
    
    SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x sync=%s op=%s",
                 pSubL3RedGroupRequest->NumEntries, IomBitMask,
                 Sync ? "Y" : "N",
                 (SubL3RedGroupOp ==
                  IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD) ? "Add" : "Del");
    
    SMGR_MESG_UPDATE_STATS(&IccInfo, pSubL3RedGroupRequest, PreFlush);
    pSubL3RedGroupRequest->TotalLength
        = smgrMesgIccSapSubMsgSize(SubL3RedGroupOp, pSubL3RedGroupRequest->NumEntries);

    if (Sync) {
        rc = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, SubL3RedGroupOp,
                                     IomBitMask, pSubL3RedGroupRequest, 
                                     pSubL3RedGroupRequest->TotalLength, NULL,
                                     (SubL3RedGroupOp == IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE)?
                                         SMGR_DNDLER_BLOCK : SMGR_DNDLER_MAY_BLOCK);
        if (rc != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        
        smgrFreeClientMsg(pSubL3RedGroupRequest, rc);
    } else {
        rc = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket,
                                           SubL3RedGroupOp,
                                           IomBitMask, pSubL3RedGroupRequest, 
                                           pSubL3RedGroupRequest->TotalLength, NULL,
                                           (SubL3RedGroupOp == IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE)?
                                               SMGR_DNDLER_BLOCK : SMGR_DNDLER_MAY_BLOCK,
                                           NULL, SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (rc != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSubL3RedGroupRequest);
        }
    }
    
    pSubL3RedGroupRequest = NULL;
    PrevSubL3RedGroupIomBitMask = 0;
    SubL3RedGroupOp = 0;
}

PUBLIC void smgrFlushSubL3RedGroupMesg(tBoolean Sync)
{
    
    semTake(SubL3RedGroupSemId, WAIT_FOREVER);
    smgrDoFlushSubL3RedGroupMesg(Sync, FALSE);
    semGive(SubL3RedGroupSemId);

}

PRIVATE tStatus smgrFlushSubIesIfGroupIfMesg(void)
{
    tStatus s = SUCCESS;
    smgrFlushSubL3RedGroupMesg(TRUE);
    return s;
}

PRIVATE void smgrGetSbmIesIfGroupIfDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                const  tIesIfRec *pIesIf,
                                                tUint32 IomOp,
                                                tUint32 SlotBitmap,
                                                tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubIesIfGroupIf,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccSbmIesIfGroupIfCmp,
                          pIesIf);
}

/* Send an L3_SUBSCRIBER_RED_GROUP_ message */
PUBLIC void smgrBatchSubL3RedGroupMesgPriv(tIesIfRec *pIesIf, tUint32 SlotBitmap,
                                           tBoolean Add, tBoolean Sync, tBoolean IsCardOnline,
                                           tBatchProcessing *pBatch)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSubL3RedGroupConfig *pReqCfg;
    eSapSubOp Op;
    tUint32 GroupIfIndex;
    tUint32 RedIfIndex;
    tUint32 SrrpState;
    tBoolean HasMcring;

    if (!IS_IIT_GROUP_IF(pIesIf)) {
        SVCMGR_ERROR(NOCLASS, "Interface %s is not a group-interface", pIesIf->Name);
        return;
    }

    semTake(SMIesTblSemId, WAIT_FOREVER);
    GroupIfIndex = pIesIf->PipIfInstanceId;
    RedIfIndex = pIesIf->IesIfGrpInfo->RedundantIf ?
        pIesIf->IesIfGrpInfo->RedundantIf->PipIfInstanceId : 0;
    SrrpState = pIesIf->IesIfGrpInfo->SrrpRawState;
    HasMcring = pIesIf->IesIfGrpInfo->HasMcring;
    semGive(SMIesTblSemId);
    
    SVCMGR_EVENT(IOM_CALL, "grpIf=%u redIf=%u slotbitmap=0x%08x add=%u state=%u sync=%u",
                 GroupIfIndex, RedIfIndex, SlotBitmap, Add, SrrpState, Sync);

    Op = Add ? IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD : IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE;
    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmIesIfGroupIfDownloadInfo(&IccInfo,pIesIf,Op,SlotBitmap,IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return;
   
    semTake(SubL3RedGroupSemId, WAIT_FOREVER);
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's! Ditto with operation.
     */
    
    if (pSubL3RedGroupRequest && ((IccInfo.IomBitMask != PrevSubL3RedGroupIomBitMask) ||
                                  (SubL3RedGroupOp != Op))) {
        smgrDoFlushSubL3RedGroupMesg(Sync, TRUE);
    }

    if (!pSubL3RedGroupRequest) {
        if ((pSubL3RedGroupRequest = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op,
                SMMaxNumSubL3RedGroupEntriesPerMesg))) == NULL) {
            semGive(SubL3RedGroupSemId);
            return;
        }
        PrevSubL3RedGroupIomBitMask = IccInfo.IomBitMask;
        pSubL3RedGroupRequest->NumEntries = 0;
    }

    pElm = smgrSapSubGetMixedEntryAddr(pSubL3RedGroupRequest, Op,
                                       pSubL3RedGroupRequest->NumEntries);
    pElm->Op = Op;
    SubL3RedGroupOp = Op;
    pReqCfg = &pElm->SubL3RedGroup;

    ZERO_STRUCT_PTR(pReqCfg);

    pReqCfg->InterfaceIndex = GroupIfIndex;
    switch (SrrpState) {
    case SRRP_STATE_INITIALIZE:
        pReqCfg->SrrpSetting = IP_SRRP_ENABLED_DOWN;
        break;
    case SRRP_STATE_BACKUP_ROUTE:
    case SRRP_STATE_BACKUP_SHUNT:
        pReqCfg->SrrpSetting = IP_SRRP_ENABLED_BACKUP;
        break;
    case SRRP_STATE_PRE_ROUTE:
    case SRRP_STATE_PRE_SHUNT:
        pReqCfg->SrrpSetting = IP_SRRP_ENABLED_PENDING_BACKUP;
        break;
    case SRRP_STATE_PRE_MASTER:
        pReqCfg->SrrpSetting = IP_SRRP_ENABLED_PENDING_MASTER;
        break;
    case SRRP_STATE_MASTER:
        pReqCfg->SrrpSetting = IP_SRRP_ENABLED_MASTER;
        break;
    case SRRP_STATE_DISABLED:
    default:
        pReqCfg->SrrpSetting = IP_SRRP_DISABLED;
        break;
    }
    
    if (RedIfIndex &&
        !((SrrpState == SRRP_STATE_BACKUP_ROUTE) ||
          (SrrpState == SRRP_STATE_PRE_ROUTE))) {
        pReqCfg->SubscriberRedSpokeIfIndex = RedIfIndex;
    }

    pReqCfg->SupportsInterDestId = HasMcring;

    pSubL3RedGroupRequest->NumEntries++;
    if (pSubL3RedGroupRequest->NumEntries >= SMMaxNumSubL3RedGroupEntriesPerMesg) {
        smgrDoFlushSubL3RedGroupMesg(Sync, FALSE);
        if (pBatch) {
            pBatch->SubL3RedGroupSent = FALSE;
            pBatch->SyncIccMsg = FALSE;
        }
    } else {
        if (pBatch) {
            pBatch->SubL3RedGroupSent = TRUE;
            pBatch->SyncIccMsg = Sync; /* Track this for the end-of-batch flush operation */
        }
    }

    semGive(SubL3RedGroupSemId);
}


/* Send an L3_SUBSCRIBER_RED_GROUP_AUDIT message */
PUBLIC tStatus smgrSendSubL3RedGroupAuditMesg(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT);
}

PRIVATE void smgrGetSbmSLAProfDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                           const  tSbmSLAProf *pSLAProf,
                                           tUint32 IomOp,
                                           tUint32 SlotBitmap,
                                           tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSLAProfile,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgIccSbmSLAProfCmp,
                          pSLAProf);
}

/* Send an SLA_PROFILE_ADD message */
PUBLIC void smgrSendSLAProfileAddMesgPriv(tSbmSLAProf *pSLAProf, tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *pReq;
    tIomSlaProfileConfig *pEntry;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_ADD;

    SVCMGR_EVENT(IOM_CALL, "id=%u slotbitmap=0x%08x", pSLAProf->iomId, SlotBitmap);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfDownloadInfo(&IccInfo, pSLAProf, Op, SlotBitmap, IsCardOnline);
    
    if (IccInfo.IomBitMask == 0)
        return;
    
    pReq = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1));
    if (pReq == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return;
    }
    
    pReq->NumEntries = 1;
    pReq->Entries[0].Op = Op;
    pEntry = &pReq->Entries[0].SlaProfile;
    pEntry->SlaProfileId = pSLAProf->iomId;
    pEntry->IngressPolicyId = pSLAProf->pIngQosPol->Id;
    pEntry->EgressPolicyId = pSLAProf->pEgrQosPol->Id;
    if (pSLAProf->pIngSharedQueuePol) {
        pEntry->SharedIngressPolicyId = pSLAProf->pIngSharedQueuePol->Request.PolicyId;
        pEntry->MultipointShared = (pSLAProf->useMpointShared == VAL_tmnxSLAProfIngUseMpointShared_true) ?
                                     TRUE : FALSE;
    }
    if (pSLAProf->pEgrQosSchedPol)
        pEntry->EgressSchedulerPolicyId = pSLAProf->pEgrQosSchedPol->InstanceId;
    pEntry->SlaFilter.IngressIpv4FilterId = pSLAProf->pIngIPFltrId ? pSLAProf->pIngIPFltrId->fltr.tFilterId : 0;
    pEntry->SlaFilter.EgressIpv4FilterId = pSLAProf->pEgrIPFltrId ? pSLAProf->pEgrIPFltrId->fltr.tFilterId : 0;
    pEntry->EgressRemarkingFromSapQos = pSLAProf->EgrRemarkingFromSap;
    pEntry->SlaFilter.IngressIpv6FilterId = pSLAProf->pIngIPv6FltrId ? pSLAProf->pIngIPv6FltrId->fltr.tFilterId : 0;
    pEntry->SlaFilter.EgressIpv6FilterId  = pSLAProf->pEgrIPv6FltrId ? pSLAProf->pEgrIPv6FltrId->fltr.tFilterId : 0;
    pEntry->UseOuterL2tpDscp = pSLAProf->egrUseIngL2tpDscp;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    pReq->TotalLength = smgrMesgIccSapSubMsgSize(Op, pReq->NumEntries);
    
    /* Buffered Download: Blocking call since configuration in profile may be dependent
     * on non-SVCMGR socket */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pReq, pReq->TotalLength, NULL,
                                SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pReq, s);
    pSLAProf->blkDnldToIom = FALSE;
}


/* Send an SLA_PROFILE_DELETE message */
PUBLIC void smgrSendSLAProfileDelMesg(tSbmSLAProf *pSLAProf, tSMSlot SlotNum)
{
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedRequest *pReq;
    tUint32 SlotBitmap=0;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "id=%u slot=%d", pSLAProf->iomId, SlotNum);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);    
    smgrGetSbmSLAProfDownloadInfo(&IccInfo, pSLAProf, Op, SlotBitmap, FALSE);
    
    if (IccInfo.IomBitMask == 0)
        return;
    
    pReq = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1));
    if (pReq == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return;
    }
    
    pReq->NumEntries = 1;
    pReq->Entries[0].Op = Op;
    pReq->Entries[0].SlaProfile.SlaProfileId = pSLAProf->iomId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    pReq->TotalLength = smgrMesgIccSapSubMsgSize(Op, pReq->NumEntries);
    
    /* Buffered Download: Blocking call since configuration in profile may be dependent
     * on non-SVCMGR socket */
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pReq, pReq->TotalLength, NULL,
                                SMGR_DNDLER_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                     IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pReq, s);
    pSLAProf->blkDnldToIom = FALSE;
}


/* Send an SLA_PROFILE_AUDIT message */
PUBLIC tStatus smgrSendSLAProfileAudit(tSMSlot SlotNum)
{
    return smgrSendSapSubAuditCommon(SlotNum, IOM_ESM_SLA_PROFILE_AUDIT);
}

PRIVATE tStatus smgrSendSapSubAuditCommon(tSMSlot SlotNum, eSapSubOp Op)
{
    tSmgrMsgrIccInfo        IccInfo;
    tIomSapSubMixedRequest *pMsg;
    tStatus                 s = SUCCESS;
    tUint32                 SlotBitmap  = 0;

    SVCMGR_EVENT(IOM_CALL, "Op %s(%u) Slot %u",
                 smgrMesgIccSapSubOpToStr(Op), Op, SlotNum);

    /* Determine the set of IOMs that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it... */
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);

    switch (Op) {
    case IOM_SAP_AUDIT:
        smgrGetSapDownloadInfo(&IccInfo, NULL, Op, SlotBitmap, FALSE, FALSE, FALSE);
        break;
    case IOM_ESM_SUBSCRIBER_AUDIT:
        smgrGetSbmActSubDownloadInfo(&IccInfo, NULL, Op, SlotBitmap, FALSE);
        break;
    case IOM_ESM_HOST_AUDIT:
        smgrGetSbmSubHostDownloadInfo(&IccInfo, NULL, NULL, Op, SlotBitmap, FALSE);
        break;
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
        smgrGetSapSubQosOvrDownloadInfo(&IccInfo, NULL, INVALID_PORTID,
                                        Op, SlotBitmap, FALSE);
        break;
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
        smgrGetSbmIesIfGroupIfDownloadInfo(&IccInfo,NULL, Op, SlotBitmap, FALSE);
        break;
    case IOM_ESM_SUB_PROFILE_AUDIT:
        smgrGetSbmSubProfDownloadInfo(&IccInfo, NULL, Op, SlotBitmap, FALSE);
        break;
    case IOM_ESM_SLA_PROFILE_AUDIT:
        smgrGetSbmSLAProfDownloadInfo(&IccInfo, NULL, Op, SlotBitmap, FALSE);
        break;

    case IOM_SAP_ADD:
    case IOM_SAP_DELETE:
    case IOM_SAP_SWITCH:
    case IOM_SAP_STATE:
    case IOM_SAP_MCLISTPRUNE_MVRP:
    case IOM_SAP_CFM_PVLAN:
    case IOM_SAP_ISSU1:
    case IOM_SAP_ISSU2:
    case IOM_ESM_SUBSCRIBER_ADD:
    case IOM_ESM_SUBSCRIBER_DELETE:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
    case IOM_ESM_HOST_ADD:
    case IOM_ESM_HOST_DELETE:
    case IOM_ESM_HOST_UNBIND_SAP:
    case IOM_ESM_SUB_PROFILE_ADD:
    case IOM_ESM_SUB_PROFILE_DELETE:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SLA_PROFILE_ADD:
    case IOM_ESM_SLA_PROFILE_DELETE:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
    case IOM_ESM_CATMAP_POLICY_ADD:
    case IOM_ESM_CATMAP_POLICY_DELETE:
    case IOM_ESM_CATMAP_POLICY_AUDIT:
    case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ:
    case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:
    case IOM_ESM_HOST_CAT_WRAPUP_REQ:
    case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
    case IOM_ESM_HOST_CAT_AUDIT_REQ:
    case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
    case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
    default:
        SVCMGR_ERROR(NOCLASS, "Invalid Op %u", Op);
        break;
    }
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((pMsg = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL) {
        SVCMGR_INFORM(NOCLASS, "Unable to obtain memory for audit msg (Op %u)", Op);
        return FAIL;
    }

    pMsg->NumEntries = 1;
    pMsg->Entries[0].Op = Op;

    /* Send the message to all applicable IOMs */
    SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, 1, FALSE);
    pMsg->TotalLength = smgrMesgIccSapSubMsgSize(Op, pMsg->NumEntries);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                IccInfo.IomBitMask, pMsg, pMsg->TotalLength,
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x (Op %u)",
                     IccInfo.IomBitMask, Op);

    smgrFreeClientMsg(pMsg, s);

    return s;
}

PRIVATE void smgrGetSbmSLAProfQOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                               const  tSbmSLAProfQueueOvr *pQueueOvr,
                                               tUint32 IomOp,
                                               tUint32 SlotBitmap,
                                               tBoolean IsCardOnline,
                                               tBoolean Ingress)
{
   eSmgrMsgr_Entry entry;

   if (Ingress)
       entry = SmgrMsgrEntry_SbmSLAProfileIngQOvr;
   else
       entry = SmgrMsgrEntry_SbmSLAProfileEgrQOvr;
   
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          entry,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSLAProfQOvrCmp,
                          pQueueOvr);
    
}

/* Send an SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSLAProfQueueOverrideAddMesg(tSbmSLAProfQueueOvr *pQueueOvr,
                                                   tBoolean Ingress, tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomSlaProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s queue=%u bitmap=%08x",
                 pQueueOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                      ALL_APPLICABLE_IOMS,FALSE,Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SlaProfileQosPolicyOverride;
    pEntry->SlaProfileId = pQueueOvr->pSLAProf->iomId;
    pEntry->QosQueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueueOvr->qosQueueId), Ingress);
    if (pQueueOvr->PIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PIR;
    if (pQueueOvr->CIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CIR;
    if (pQueueOvr->MBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_MBS;
    if (pQueueOvr->CBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CBS;
    if (pQueueOvr->hiPrioOnly != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_HI_PRIO_ONLY;
    if (pQueueOvr->avgOverhead != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_AVG_OVERHEAD;
    pEntry->Parms.PIR = pQueueOvr->PIR;
    pEntry->Parms.IsRatePercent = FALSE; // not supported
    pEntry->Parms.CIR = pQueueOvr->CIR;
    pEntry->Parms.MBS = pQueueOvr->MBS;
    pEntry->Parms.CBS = (pQueueOvr->CBS > 0) ? pQueueOvr->CBS * 1024 : pQueueOvr->CBS; // convert to bytes
    pEntry->Parms.HiPrioOnly = pQueueOvr->hiPrioOnly;
    pEntry->Parms.AvgOverhead = pQueueOvr->avgOverhead;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up an SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSLAProfQueueOverrideAddMesgPriv(tSbmSLAProfQueueOvr *pQueueOvr,
                                                        tBoolean Ingress, tUint32 IomBitMask,
                                                        tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                        tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSlaProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s queue=%u bitmap=%08x",
                 pQueueOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                      SlotBitmap,IsCardOnline,Ingress);
    IomBitMask &= IccInfo.IomBitMask;


    if (IomBitMask == 0)
        return SUCCESS; 

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSLAProfQueueOverrideAddEntry != 0) &&
        (IomBitMask != PrevSLAProfQueueOverrideAddIomBitMask))
        smgrDoFlushSLAProfQueueOverrideAddMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSLAProfQueueOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSLAProfQueueOverrideAddReqMesg == NULL) {
        if ((pSLAProfQueueOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSLAProfQueueOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSLAProfQueueOverrideAddReqMesg->NumEntries = NextSLAProfQueueOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSLAProfQueueOverrideAddReqMesg, Op,
                                       NextSLAProfQueueOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SlaProfileQosPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SlaProfileId = pQueueOvr->pSLAProf->iomId;
    pEntry->QosQueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueueOvr->qosQueueId), Ingress);
    if (pQueueOvr->PIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PIR;
    if (pQueueOvr->CIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CIR;
    if (pQueueOvr->MBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_MBS;
    if (pQueueOvr->CBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CBS;
    if (pQueueOvr->hiPrioOnly != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_HI_PRIO_ONLY;
    if (pQueueOvr->avgOverhead != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_AVG_OVERHEAD;
    pEntry->Parms.IsRatePercent = FALSE; // not supported
    pEntry->Parms.PIR = pQueueOvr->PIR;
    pEntry->Parms.CIR = pQueueOvr->CIR;
    pEntry->Parms.MBS = pQueueOvr->MBS;
    pEntry->Parms.CBS = (pQueueOvr->CBS > 0) ?
        pQueueOvr->CBS * 1024 : pQueueOvr->CBS; // convert to bytes
    pEntry->Parms.HiPrioOnly = pQueueOvr->hiPrioOnly;
    pEntry->Parms.AvgOverhead = pQueueOvr->avgOverhead;

    if (Ingress)
        SLAProfileIngressQosQAddCnt++;
    else
        SLAProfileEgressQosQAddCnt++;
    
    /* If we reached the limit, flush the message */
    if (pSLAProfQueueOverrideAddReqMesg->NumEntries == SMMaxNumSLAProfQueueOverrideEntriesPerMesg) {
        smgrFlushSLAProfQueueOverrideAddMesg();
        if (pBatch)
            pBatch->SLAProfQueueOverrideAddSent = FALSE;
    } else {
        NextSLAProfQueueOverrideAddEntry++;
        if (pBatch)
            pBatch->SLAProfQueueOverrideAddSent = TRUE;
    }
    
    return SUCCESS;
}


/* Flush batched up SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSLAProfQueueOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSLAProfQueueOverrideAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD;
        
    if (pSLAProfQueueOverrideAddReqMesg &&
        (pSLAProfQueueOverrideAddReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSLAProfQueueOverrideAddReqMesg->NumEntries, IomBitMask);
        if (SLAProfileIngressQosQAddCnt) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSLAProfileIngQOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileIngressQosQAddCnt, PreFlush);
        } 
        if (SLAProfileEgressQosQAddCnt) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSLAProfileEgrQOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileEgressQosQAddCnt, PreFlush);
        }
        pSLAProfQueueOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSLAProfQueueOverrideAddReqMesg->NumEntries);
        
        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for ingress and egress profile we could use the ICC socket either from ingress/egress IccInfo */
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSLAProfQueueOverrideAddReqMesg, 
                                          pSLAProfQueueOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSLAProfQueueOverrideAddReqMesg);
        }    

        /* Start a new batch */
        NextSLAProfQueueOverrideAddEntry = 0;
        SLAProfileIngressQosQAddCnt = 0;
        SLAProfileEgressQosQAddCnt = 0;
        
        /* Since we use the async ICC interface, the message will be freed later on */
        pSLAProfQueueOverrideAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSLAProfQueueOverrideAddMesg(void)
{
    return smgrDoFlushSLAProfQueueOverrideAddMesg(FALSE);
}

/* Send an SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSLAProfQueueOverrideDelMesg(tSbmSLAProfQueueOvr *pQueueOvr,
                                                   tBoolean Ingress, tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
     
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s queue=%u bitpmap=%4X",
                 pQueueOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                      ALL_APPLICABLE_IOMS,FALSE,Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    req->Entries[0].SlaProfileQosPolicyOverride.SlaProfileId = pQueueOvr->pSLAProf->iomId;
    req->Entries[0].SlaProfileQosPolicyOverride.QosQueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueueOvr->qosQueueId), Ingress);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up an SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSLAProfQueueOverrideDelMesg(tSbmSLAProfQueueOvr *pQueueOvr, tBoolean Ingress,
                                                    tUint32 IomBitMask, tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSlaProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s queue=%u bitmap=%08x",
                 pQueueOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                      ALL_APPLICABLE_IOMS,FALSE,Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSLAProfQueueOverrideDelEntry != 0) &&
        (IomBitMask != PrevSLAProfQueueOverrideDelIomBitMask))
        smgrDoFlushSLAProfQueueOverrideDelMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSLAProfQueueOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSLAProfQueueOverrideDelReqMesg == NULL) {
        if ((pSLAProfQueueOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op,
                     SMMaxNumSLAProfQueueOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSLAProfQueueOverrideDelReqMesg->NumEntries = NextSLAProfQueueOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSLAProfQueueOverrideDelReqMesg, Op,
                                       NextSLAProfQueueOverrideDelEntry);
    pElm->Op = Op;
    pEntry = &pElm->SlaProfileQosPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SlaProfileId = pQueueOvr->pSLAProf->iomId;
    pEntry->QosQueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QID_TO_IOM_QID(pQueueOvr->qosQueueId), Ingress);

    if (Ingress)
        SLAProfileIngressQosQDeleteCnt++;
    else
        SLAProfileEgressQosQDeleteCnt++;
    
    /* If we reached the limit, flush the message */
    if (pSLAProfQueueOverrideDelReqMesg->NumEntries == SMMaxNumSLAProfQueueOverrideEntriesPerMesg) {
        smgrFlushSLAProfQueueOverrideDelMesg();
        if (pBatch)
            pBatch->SLAProfQueueOverrideDelSent = FALSE;
    } else {
        NextSLAProfQueueOverrideDelEntry++;
        if (pBatch)
            pBatch->SLAProfQueueOverrideDelSent = TRUE;
    }
    
    return SUCCESS;
}


/* Flush batched up SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSLAProfQueueOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSLAProfQueueOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
    
    if (pSLAProfQueueOverrideDelReqMesg &&
        (pSLAProfQueueOverrideDelReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSLAProfQueueOverrideDelReqMesg->NumEntries, IomBitMask);
        if (SLAProfileIngressQosQDeleteCnt) {
             smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                        SmgrMsgrEntry_SbmSLAProfileIngQOvr, Op);
             SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileIngressQosQDeleteCnt, PreFlush);
        } 
        if (SLAProfileEgressQosQDeleteCnt) {       
             smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                        SmgrMsgrEntry_SbmSLAProfileEgrQOvr, Op);
             SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileEgressQosQDeleteCnt, PreFlush);
        }  
        pSLAProfQueueOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSLAProfQueueOverrideDelReqMesg->NumEntries);

        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for ingress and egress profile we could use the ICC socket either from ingress/egress IccInfo */
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSLAProfQueueOverrideDelReqMesg, 
                                          pSLAProfQueueOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSLAProfQueueOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSLAProfQueueOverrideDelEntry = 0;
        SLAProfileIngressQosQDeleteCnt = 0;
        SLAProfileEgressQosQDeleteCnt = 0;
        
        /* Since we use the async ICC interface, the message will be freed later on */
        pSLAProfQueueOverrideDelReqMesg = NULL;

    }
}

PUBLIC void smgrFlushSLAProfQueueOverrideDelMesg(void)
{
    smgrDoFlushSLAProfQueueOverrideDelMesg(FALSE);
}

PRIVATE void smgrGetSbmSLAProfPlcrOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                  const  tSbmSLAProfPolicerOvr *pPolicerOvr,
                                                  tUint32 IomOp,
                                                  tUint32 SlotBitmap,
                                                  tBoolean IsCardOnline,
                                                  tBoolean Ingress)
{
   eSmgrMsgr_Entry entry;

   if (Ingress)
       entry = SmgrMsgrEntry_SbmSLAProfileIngPlcrOvr;
   else
        entry = SmgrMsgrEntry_SbmSLAProfileEgrPlcrOvr;
   
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          entry,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSLAProfPlcrOvrCmp,
                          pPolicerOvr);
    
}


/* Send an SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSLAProfPolicerOverrideAddMesg(tSbmSLAProfPolicerOvr *pPolicerOvr,
                                                     tBoolean Ingress, tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomSlaProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s policer=%u bitmap=%08x",
                 pPolicerOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pPolicerOvr->qosPolicerId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfPlcrOvrDownloadInfo(&IccInfo, pPolicerOvr, Op,
                                         ALL_APPLICABLE_IOMS,FALSE,Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SlaProfileQosPolicyOverride;
    pEntry->SlaProfileId = pPolicerOvr->pSLAProf->iomId;
    pEntry->QosQueueId =
        MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicerOvr->qosPolicerId), Ingress);
    if (pPolicerOvr->PIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PIR;
    if (pPolicerOvr->CIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CIR;
    if (pPolicerOvr->MBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_MBS;
    if (pPolicerOvr->CBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CBS;
    if (pPolicerOvr->pktOffset != -128)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PACKET_BYTE_OFFSET;
    if (pPolicerOvr->statMode != -1)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_STAT_MODE;
    pEntry->Parms.IsRatePercent = FALSE; // not supported
    pEntry->Parms.PIR = pPolicerOvr->PIR;
    pEntry->Parms.CIR = pPolicerOvr->CIR;
    pEntry->Parms.MBS = pPolicerOvr->MBS;
    pEntry->Parms.CBS = pPolicerOvr->CBS;
    pEntry->Parms.PacketByteOffset = pPolicerOvr->pktOffset;
    pEntry->Parms.PolicerStatMode = Ingress ?
        tqm_IngMibPStatModeToIomStatMode(pPolicerOvr->statMode) :
        tqm_EgrMibPStatModeToIomStatMode(pPolicerOvr->statMode);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up an SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSLAProfPolicerOverrideAddMesgPriv(tSbmSLAProfPolicerOvr *pPolicerOvr,
                                                          tBoolean Ingress, tUint32 IomBitMask,
                                                          tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                          tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSlaProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s policer=%u bitmap=%08x",
                 pPolicerOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pPolicerOvr->qosPolicerId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfPlcrOvrDownloadInfo(&IccInfo, pPolicerOvr, Op,
                                         SlotBitmap,IsCardOnline,Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSLAProfPolicerOverrideAddEntry != 0) &&
        (IomBitMask != PrevSLAProfPolicerOverrideAddIomBitMask))
        smgrDoFlushSLAProfPolicerOverrideAddMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSLAProfPolicerOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSLAProfPolicerOverrideAddReqMesg == NULL) {
        if ((pSLAProfPolicerOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op,
                     SMMaxNumSLAProfPolicerOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSLAProfPolicerOverrideAddReqMesg->NumEntries = NextSLAProfPolicerOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSLAProfPolicerOverrideAddReqMesg, Op,
                                       NextSLAProfPolicerOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SlaProfileQosPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SlaProfileId = pPolicerOvr->pSLAProf->iomId;
    pEntry->QosQueueId = MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicerOvr->qosPolicerId), Ingress);
    if (pPolicerOvr->PIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PIR;
    if (pPolicerOvr->CIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CIR;
    if (pPolicerOvr->MBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_MBS;
    if (pPolicerOvr->CBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_CBS;
    if (pPolicerOvr->pktOffset != -128)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PACKET_BYTE_OFFSET;
    if (pPolicerOvr->statMode != -1)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_STAT_MODE;
    pEntry->Parms.IsRatePercent = FALSE; // not supported
    pEntry->Parms.PIR = pPolicerOvr->PIR;
    pEntry->Parms.CIR = pPolicerOvr->CIR;
    pEntry->Parms.MBS = pPolicerOvr->MBS;
    pEntry->Parms.CBS = pPolicerOvr->CBS;
    pEntry->Parms.PacketByteOffset = pPolicerOvr->pktOffset;
    pEntry->Parms.PolicerStatMode = Ingress ? tqm_IngMibPStatModeToIomStatMode(pPolicerOvr->statMode) :
                                              tqm_EgrMibPStatModeToIomStatMode(pPolicerOvr->statMode);

    if (Ingress)
        SLAProfileIngressQosPlcrAddCnt++;
    else 
        SLAProfileEgressQosPlcrAddCnt++;
    
    /* If we reached the limit, flush the message */
    if (pSLAProfPolicerOverrideAddReqMesg->NumEntries == SMMaxNumSLAProfPolicerOverrideEntriesPerMesg) {
        smgrFlushSLAProfPolicerOverrideAddMesg();
        if (pBatch)
            pBatch->SLAProfPolicerOverrideAddSent = FALSE;
    } else {
        NextSLAProfPolicerOverrideAddEntry++;
        if (pBatch)
            pBatch->SLAProfPolicerOverrideAddSent = TRUE;
    }
        
    return SUCCESS;
}


/* Flush batched up SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSLAProfPolicerOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSLAProfPolicerOverrideAddIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD;
        
    if (pSLAProfPolicerOverrideAddReqMesg &&
        (pSLAProfPolicerOverrideAddReqMesg->NumEntries > 0)) {
        
        if (SLAProfileIngressQosPlcrAddCnt) {
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSLAProfileIngPlcrOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileIngressQosPlcrAddCnt, PreFlush);
        } 
        if (SLAProfileEgressQosPlcrAddCnt) {        
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSLAProfileEgrPlcrOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileEgressQosPlcrAddCnt, PreFlush);
        }
        pSLAProfPolicerOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSLAProfPolicerOverrideAddReqMesg->NumEntries);
        
        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSLAProfPolicerOverrideAddReqMesg->NumEntries, IomBitMask);

        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for ingress and egress profile we could use the ICC socket either from ingress/egress IccInfo */
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSLAProfPolicerOverrideAddReqMesg, 
                                          pSLAProfPolicerOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSLAProfPolicerOverrideAddReqMesg);
        }

        /* Start a new batch */
        NextSLAProfPolicerOverrideAddEntry = 0;
        SLAProfileIngressQosPlcrAddCnt = 0;
        SLAProfileEgressQosPlcrAddCnt = 0;
        
        /* Since we use the async ICC interface, the message will be freed later on */
        pSLAProfPolicerOverrideAddReqMesg = NULL;
    }
    
    return s;
}

PUBLIC tStatus smgrFlushSLAProfPolicerOverrideAddMesg(void)
{
    return smgrDoFlushSLAProfPolicerOverrideAddMesg(FALSE);
}

/* Send an SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSLAProfPolicerOverrideDelMesg(tSbmSLAProfPolicerOvr *pPolicerOvr,
                                                     tBoolean Ingress, tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s policer=%u bitpmap=%4X",
                 pPolicerOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pPolicerOvr->qosPolicerId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfPlcrOvrDownloadInfo(&IccInfo, pPolicerOvr, Op, ALL_APPLICABLE_IOMS, FALSE, Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    req->Entries[0].SlaProfileQosPolicyOverride.SlaProfileId = pPolicerOvr->pSLAProf->iomId;
    req->Entries[0].SlaProfileQosPolicyOverride.QosQueueId =
        MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicerOvr->qosPolicerId), Ingress);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, 
                                      req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up an SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSLAProfPolicerOverrideDelMesg(tSbmSLAProfPolicerOvr *pPolicerOvr,
                                                      tBoolean Ingress, tUint32 IomBitMask,
                                                      tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSlaProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
     
    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s policer=%u bitmap=%08x",
                 pPolicerOvr->pSLAProf->iomId,
                 (Ingress == TRUE) ? "ingress" : "egress",
                 pPolicerOvr->qosPolicerId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfPlcrOvrDownloadInfo(&IccInfo, pPolicerOvr, Op,
                                         ALL_APPLICABLE_IOMS,FALSE,Ingress);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSLAProfPolicerOverrideDelEntry != 0) &&
        (IomBitMask != PrevSLAProfPolicerOverrideDelIomBitMask))
        smgrDoFlushSLAProfPolicerOverrideDelMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSLAProfPolicerOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSLAProfPolicerOverrideDelReqMesg == NULL) {
        if ((pSLAProfPolicerOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op,
                     SMMaxNumSLAProfPolicerOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSLAProfPolicerOverrideDelReqMesg->NumEntries = NextSLAProfPolicerOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSLAProfPolicerOverrideDelReqMesg, Op,
                                       NextSLAProfPolicerOverrideDelEntry);
    pElm->Op = Op;
    pEntry = &pElm->SlaProfileQosPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SlaProfileId = pPolicerOvr->pSLAProf->iomId;
    pEntry->QosQueueId =
        MAKE_QOS_QUEUE_ID_POLICER(MIB_PID_TO_IOM_PID(pPolicerOvr->qosPolicerId), Ingress);

    if (Ingress)
        SLAProfileIngressQosPlcrDeleteCnt++;
    else 
        SLAProfileEgressQosPlcrDeleteCnt++;
    
    /* If we reached the limit, flush the message */
    if (pSLAProfPolicerOverrideDelReqMesg->NumEntries ==
        SMMaxNumSLAProfPolicerOverrideEntriesPerMesg) {
        smgrFlushSLAProfPolicerOverrideDelMesg();
        if (pBatch)
            pBatch->SLAProfPolicerOverrideDelSent = FALSE;
    } else {
        NextSLAProfPolicerOverrideDelEntry++;
        if (pBatch)
            pBatch->SLAProfPolicerOverrideDelSent = TRUE;
    }
    
    return SUCCESS;
}


/* Flush batched up SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSLAProfPolicerOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSLAProfPolicerOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
    
    if (pSLAProfPolicerOverrideDelReqMesg &&
        (pSLAProfPolicerOverrideDelReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSLAProfPolicerOverrideDelReqMesg->NumEntries, IomBitMask);
        
        if (SLAProfileIngressQosPlcrDeleteCnt) {
            
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSLAProfileIngPlcrOvr, Op);
            
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileIngressQosPlcrDeleteCnt, PreFlush);
        } 
        if (SLAProfileEgressQosPlcrDeleteCnt) {
            
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSLAProfileEgrPlcrOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SLAProfileEgressQosPlcrDeleteCnt, PreFlush);
        }
        pSLAProfPolicerOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE,
                                       pSLAProfPolicerOverrideDelReqMesg->NumEntries);

        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for ingress and egress profile we could use the ICC socket either from ingress/egress IccInfo */
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSLAProfPolicerOverrideDelReqMesg, 
                                          pSLAProfPolicerOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSLAProfPolicerOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSLAProfPolicerOverrideDelEntry = 0;
        SLAProfileIngressQosPlcrDeleteCnt = 0;
        SLAProfileEgressQosPlcrDeleteCnt = 0;
        
        /* Since we use the async ICC interface, the message will be freed later on */
        pSLAProfPolicerOverrideDelReqMesg = NULL;

    }
}

PUBLIC void smgrFlushSLAProfPolicerOverrideDelMesg(void)
{
    smgrDoFlushSLAProfPolicerOverrideDelMesg(FALSE);
}


PRIVATE void smgrGetSbmSLAProfSchedOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                   const tSbmSLAProfSchedOvr *pSchedOvr,
                                                   tUint32 IomOp,
                                                   tUint32 SlotBitmap,
                                                   tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSLAProfileSchedOvr,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSLAProfSchedOvrCmp,
                          pSchedOvr);
}


/* Send a SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSLAProfVSOverrideAddMesg(tSbmSLAProfSchedOvr *pSchedOvr,
                                                tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;

    SVCMGR_EVENT(IOM_CALL,
                 "slaprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSLAProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SLA_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str),
            pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSLAProf->iomId;
    pEntry->OverrideMask = QOS_GROUP_OVERRIDE_RATE |
                           QOS_GROUP_OVERRIDE_CIR  |
                           QOS_GROUP_OVERRIDE_CIR_IS_SUM_MEMBER_CIRS;
    pEntry->Parms.Scheduler.Rate = pSchedOvr->PIR;
    pEntry->Parms.Scheduler.CIRIsSumMemberCIRs =
        (pSchedOvr->summedCIR == VAL_tmnxSLAProfSchedOvrSummedCIR_true) ? TRUE : FALSE;
    pEntry->Parms.Scheduler.CIR = pSchedOvr->CIR;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);

    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSLAProfVSOverrideAddMesgPriv(tSbmSLAProfSchedOvr *pSchedOvr,
                                                     tUint32 IomBitMask,
                                                     tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                     tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;

    SVCMGR_EVENT(IOM_CALL,
                 "slaprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSLAProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op, SlotBitmap, IsCardOnline);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSLAProfVSOverrideAddEntry != 0) &&
        (IomBitMask != PrevSLAProfVSOverrideAddIomBitMask))
        smgrDoFlushSLAProfVSOverrideAddMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSLAProfVSOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSLAProfVSOverrideAddReqMesg == NULL) {
        if ((pSLAProfVSOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSLAProfVSOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSLAProfVSOverrideAddReqMesg->NumEntries = NextSLAProfVSOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSLAProfVSOverrideAddReqMesg, Op,
                                       NextSLAProfVSOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SLA_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSLAProf->iomId;
    pEntry->OverrideMask = QOS_GROUP_OVERRIDE_RATE |
                           QOS_GROUP_OVERRIDE_CIR  |
                           QOS_GROUP_OVERRIDE_CIR_IS_SUM_MEMBER_CIRS;
    pEntry->Parms.Scheduler.Rate = pSchedOvr->PIR;
    pEntry->Parms.Scheduler.CIRIsSumMemberCIRs =
        (pSchedOvr->summedCIR == VAL_tmnxSLAProfSchedOvrSummedCIR_true) ? TRUE : FALSE;
    pEntry->Parms.Scheduler.CIR = pSchedOvr->CIR;

    /* If we reached the limit, flush the message */
    if (pSLAProfVSOverrideAddReqMesg->NumEntries == SMMaxNumSLAProfVSOverrideEntriesPerMesg) {
        smgrFlushSLAProfVSOverrideAddMesg();
        if (pBatch)
            pBatch->SLAProfVSOverrideAddSent = FALSE;
    } else {
        NextSLAProfVSOverrideAddEntry++;
        if (pBatch)
            pBatch->SLAProfVSOverrideAddSent = TRUE;
    }

    return SUCCESS;
}


/* Flush batched up SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSLAProfVSOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSLAProfVSOverrideAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD;

    if (pSLAProfVSOverrideAddReqMesg && (pSLAProfVSOverrideAddReqMesg->NumEntries > 0)) {
        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSLAProfVSOverrideAddReqMesg->NumEntries,
                     IomBitMask);

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmSLAProfileSchedOvr, Op);
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSLAProfVSOverrideAddReqMesg, PreFlush);
        pSLAProfVSOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSLAProfVSOverrideAddReqMesg->NumEntries);

        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op, IomBitMask,
                                          pSLAProfVSOverrideAddReqMesg,
                                          pSLAProfVSOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSLAProfVSOverrideAddReqMesg);
        }

        /* Start a new batch */
        NextSLAProfVSOverrideAddEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSLAProfVSOverrideAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSLAProfVSOverrideAddMesg(void)
{
    return smgrDoFlushSLAProfVSOverrideAddMesg(FALSE);
}

/* Send a SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSLAProfVSOverrideDelMesg(tSbmSLAProfSchedOvr *pSchedOvr,
                                                tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;

    SVCMGR_EVENT(IOM_CALL,
                 "slaprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSLAProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op,
                                          ALL_APPLICABLE_IOMS,FALSE);

    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SLA_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSLAProf->iomId;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);

    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req,  req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSLAProfVSOverrideDelMesg(struct sbmSLAProfSchedOvr *pSchedOvr,
                                                 tUint32 IomBitMask, tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;

    SVCMGR_EVENT(IOM_CALL, "slaprofid=%u direction=%s scheduler=%s bitmap=%08x",
                 pSchedOvr->pSLAProf->iomId,
                 (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ?
                 "ingress" : "egress",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSLAProfSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op, ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSLAProfVSOverrideDelEntry != 0) &&
        (IomBitMask != PrevSLAProfVSOverrideDelIomBitMask))
        smgrDoFlushSLAProfVSOverrideDelMesg(TRUE);

    /* Set the previous iom bit mask */
    PrevSLAProfVSOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSLAProfVSOverrideDelReqMesg == NULL) {
        if ((pSLAProfVSOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSLAProfVSOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSLAProfVSOverrideDelReqMesg->NumEntries = NextSLAProfVSOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSLAProfVSOverrideDelReqMesg, Op,
                                       NextSLAProfVSOverrideDelEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SLA_PROFILE;
    pEntry->SchedulerId.TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == VAL_tmnxSLAProfSchedOvrDirection_ingress) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.SubMgmtProfile.ProfileId = pSchedOvr->pSLAProf->iomId;

    /* If we reached the limit, flush the message */
    if (pSLAProfVSOverrideDelReqMesg->NumEntries ==
        SMMaxNumSLAProfVSOverrideEntriesPerMesg) {
        smgrFlushSLAProfVSOverrideDelMesg();
        if (pBatch)
            pBatch->SLAProfVSOverrideDelSent = FALSE;
    } else {
        NextSLAProfVSOverrideDelEntry++;
        if (pBatch)
            pBatch->SLAProfVSOverrideDelSent = TRUE;
    }

    return SUCCESS;
}


/* Flush batched up SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSLAProfVSOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSLAProfVSOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE;

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SbmSLAProfileSchedOvr, Op);

    if (pSLAProfVSOverrideDelReqMesg && (pSLAProfVSOverrideDelReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSLAProfVSOverrideDelReqMesg->NumEntries,
                     IomBitMask);

        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSLAProfVSOverrideDelReqMesg, PreFlush);
        pSLAProfVSOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSLAProfVSOverrideDelReqMesg->NumEntries);

        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSLAProfVSOverrideDelReqMesg,
                                          pSLAProfVSOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSLAProfVSOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSLAProfVSOverrideDelEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSLAProfVSOverrideDelReqMesg = NULL;
    }
}

PUBLIC void smgrFlushSLAProfVSOverrideDelMesg(void)
{
    smgrDoFlushSLAProfVSOverrideDelMesg(FALSE);
}


PRIVATE void smgrGetSbmSubProfHsmda2EgrQOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                        const  tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr,
                                                        tUint32 IomOp,
                                                        tUint32 SlotBitmap,
                                                        tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubProfileHsmda2EgrQOvr,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSubProfHsmda2EgrQOvrCmp,
                          pQueueOvr);
    
}

/* Send an SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSubProfHsmda2EgrQueueOverrideAddMesg(tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr,
                                                            tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tIomSubProfileQosPolicyOverride *pEntry;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
     
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u queue=%u bitmap=%08x",
                 pQueueOvr->pSubProf->iomId,
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfHsmda2EgrQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                               ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubProfileQosPolicyOverride;
    pEntry->SubProfileId = pQueueOvr->pSubProf->iomId;
    pEntry->QosQueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQueueOvr->qosQueueId), FALSE);

    if (pQueueOvr->PIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PIR;
    /* no CIR support in HSMDA-2 */
    if (pQueueOvr->slopePolicyId != 0)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_SLOPEPOLICY;
    if (pQueueOvr->WrrWeight != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_WRR_WEIGHT;
    if (pQueueOvr->MBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_MBS;

    pEntry->Parms.PIR = pQueueOvr->PIR;
    pEntry->Parms.CIR = -2; /* no CIR support in HSMDA-2 */
    pEntry->Parms.SlopePolicyId = pQueueOvr->slopePolicyId;
    pEntry->Parms.WRRWeight = pQueueOvr->WrrWeight;
    pEntry->Parms.MBS = pQueueOvr->MBS;

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }
    
    return s;
}


/* Batch up an SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSubProfHsmda2EgrQueueOverrideAddMesgPriv(
    tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr,
    tUint32 IomBitMask, tSMSlot SlotBitmap, tBoolean IsCardOnline,
    tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    tIomSubProfileQosPolicyOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u queue=%u bitmap=%08x",
                 pQueueOvr->pSubProf->iomId,
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfHsmda2EgrQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                               SlotBitmap, IsCardOnline);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubProfHsmda2EgrQueueOverrideAddEntry != 0) &&
        (IomBitMask != PrevSubProfHsmda2EgrQueueOverrideAddIomBitMask))
        smgrDoFlushSubProfHsmda2EgrQueueOverrideAddMesg(TRUE);
 
    /* Set the previous iom bit mask */
    PrevSubProfHsmda2EgrQueueOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubProfHsmda2EgrQueueOverrideAddReqMesg == NULL) {
        if ((pSubProfHsmda2EgrQueueOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubProfQueueOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubProfHsmda2EgrQueueOverrideAddReqMesg->NumEntries = NextSubProfHsmda2EgrQueueOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubProfHsmda2EgrQueueOverrideAddReqMesg, Op,
                                       NextSubProfHsmda2EgrQueueOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubProfileQosPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SubProfileId = pQueueOvr->pSubProf->iomId;
    pEntry->QosQueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQueueOvr->qosQueueId), FALSE);

    if (pQueueOvr->PIR != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_PIR;
    /* no CIR support in HSMDA-2 */
    if (pQueueOvr->slopePolicyId != 0)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_SLOPEPOLICY;
    if (pQueueOvr->WrrWeight != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_WRR_WEIGHT;
    if (pQueueOvr->MBS != -2)
        pEntry->OverrideMask |= QOS_ELEMENT_OVERRIDE_MBS;

    pEntry->Parms.PIR = pQueueOvr->PIR;
    pEntry->Parms.CIR = -2; /* no CIR support in HSMDA-2 */
    pEntry->Parms.SlopePolicyId = pQueueOvr->slopePolicyId;
    pEntry->Parms.WRRWeight = pQueueOvr->WrrWeight;
    pEntry->Parms.MBS = pQueueOvr->MBS;

    SubProfileHsmda2EgressQosQAddCnt++;
    
    /* If we reached the limit, flush the message */
    if (pSubProfHsmda2EgrQueueOverrideAddReqMesg->NumEntries ==
                          SMMaxNumSubProfQueueOverrideEntriesPerMesg) {
        smgrFlushSubProfHsmda2EgrQueueOverrideAddMesg();
        if (pBatch)
            pBatch->SubProfHsmda2EgrQueueOverrideAddSent = FALSE;
    } else {
        NextSubProfHsmda2EgrQueueOverrideAddEntry++;
        if (pBatch)
            pBatch->SubProfHsmda2EgrQueueOverrideAddSent = TRUE;
    }

    return SUCCESS;
}


/* Flush batched up SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSubProfHsmda2EgrQueueOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubProfHsmda2EgrQueueOverrideAddIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD;
    
    if (pSubProfHsmda2EgrQueueOverrideAddReqMesg &&
        (pSubProfHsmda2EgrQueueOverrideAddReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubProfHsmda2EgrQueueOverrideAddReqMesg->NumEntries, IomBitMask);
        
        if (SubProfileHsmda2EgressQosQAddCnt) {        
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSubProfileHsmda2EgrQOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SubProfileHsmda2EgressQosQAddCnt, PreFlush);
        }
        pSubProfHsmda2EgrQueueOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubProfHsmda2EgrQueueOverrideAddReqMesg->NumEntries);
               
        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for ingress and egress profile we could 
         * use the ICC socket either from ingress/egress IccInfo */
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket,
                                          Op, IomBitMask,
                                          pSubProfHsmda2EgrQueueOverrideAddReqMesg,
                                          pSubProfHsmda2EgrQueueOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSubProfHsmda2EgrQueueOverrideAddReqMesg);
        }  

        /* Start a new batch */
        NextSubProfHsmda2EgrQueueOverrideAddEntry = 0;
        SubProfileHsmda2EgressQosQAddCnt = 0;
        
        /* Since we use the async ICC interface, the message will be freed later on */
        pSubProfHsmda2EgrQueueOverrideAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSubProfHsmda2EgrQueueOverrideAddMesg(void)
{
    return smgrDoFlushSubProfHsmda2EgrQueueOverrideAddMesg(FALSE);
}

/* Send an SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSubProfHsmda2EgrQueueOverrideDelMesg(tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr,
                                                            tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
 
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u queue=%u bitpmap=%4X",
                 pQueueOvr->pSubProf->iomId,
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfHsmda2EgrQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                               ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;

    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    req->Entries[0].SubProfileQosPolicyOverride.SubProfileId = pQueueOvr->pSubProf->iomId;
    req->Entries[0].SubProfileQosPolicyOverride.QosQueueId =
        MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQueueOvr->qosQueueId), FALSE);

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up an SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSubProfHsmda2EgrQueueOverrideDelMesg(tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr,
                                                             tUint32 IomBitMask, tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSubProfileQosPolicyOverride *pEntry;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE;
    tSmgrMsgrIccInfo IccInfo;
 
    SVCMGR_EVENT(IOM_CALL, "subprofid=%u queue=%u bitmap=%08x",
                 pQueueOvr->pSubProf->iomId,
                 pQueueOvr->qosQueueId,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSbmSubProfHsmda2EgrQOvrDownloadInfo(&IccInfo, pQueueOvr, Op,
                                               ALL_APPLICABLE_IOMS, FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS; 

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubProfHsmda2EgrQueueOverrideDelEntry != 0) &&
        (IomBitMask != PrevSubProfHsmda2EgrQueueOverrideDelIomBitMask))
        smgrDoFlushSubProfHsmda2EgrQueueOverrideDelMesg(TRUE);
 
    /* Set the previous iom bit mask */
    PrevSubProfHsmda2EgrQueueOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubProfHsmda2EgrQueueOverrideDelReqMesg == NULL) {
        if ((pSubProfHsmda2EgrQueueOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubProfQueueOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubProfHsmda2EgrQueueOverrideDelReqMesg->NumEntries = NextSubProfHsmda2EgrQueueOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubProfHsmda2EgrQueueOverrideDelReqMesg, Op,
                                       NextSubProfHsmda2EgrQueueOverrideDelEntry);
    pElm->Op = Op;

    pEntry = &pElm->SubProfileQosPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SubProfileId = pQueueOvr->pSubProf->iomId;
    pEntry->QosQueueId = MAKE_QOS_QUEUE_ID_QUEUE(MIB_QMDAQID_TO_IOM_QMDAQID(pQueueOvr->qosQueueId), FALSE);

    SubProfileHsmda2EgressQosQDeleteCnt++;
    
    /* If we reached the limit, flush the message */
    if (pSubProfHsmda2EgrQueueOverrideDelReqMesg->NumEntries == SMMaxNumSubProfQueueOverrideEntriesPerMesg) {
        smgrFlushSubProfHsmda2EgrQueueOverrideDelMesg();
        if (pBatch)
            pBatch->SubProfHsmda2EgrQueueOverrideDelSent = FALSE;
    } else {
        NextSubProfHsmda2EgrQueueOverrideDelEntry++;
        if (pBatch)
            pBatch->SubProfHsmda2EgrQueueOverrideDelSent = TRUE;
    }

    return SUCCESS;
}

/* Flush batched up SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSubProfHsmda2EgrQueueOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubProfHsmda2EgrQueueOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE;

    if (pSubProfHsmda2EgrQueueOverrideDelReqMesg &&
        (pSubProfHsmda2EgrQueueOverrideDelReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubProfHsmda2EgrQueueOverrideDelReqMesg->NumEntries, IomBitMask);

        if (SubProfileHsmda2EgressQosQDeleteCnt) {        
            smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                       SmgrMsgrEntry_SbmSubProfileHsmda2EgrQOvr, Op);
            SMGR_MESG_UPDATE_NUM_STATS(&IccInfo, SubProfileHsmda2EgressQosQDeleteCnt, PreFlush);
        }
        pSubProfHsmda2EgrQueueOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubProfHsmda2EgrQueueOverrideDelReqMesg->NumEntries);

        /* Send the message to all applicable IOM's */
        /* Since the ICC socket is same for ingress and egress profile we could use the ICC socket either from ingress/egress IccInfo */
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket,
                                          Op, IomBitMask,
                                          pSubProfHsmda2EgrQueueOverrideDelReqMesg,
                                          pSubProfHsmda2EgrQueueOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL, SMIccCleanSemId,
                                          FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !",
                         IomBitMask);
            SMGR_MESG_MEM_FREE(pSubProfHsmda2EgrQueueOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSubProfHsmda2EgrQueueOverrideDelEntry = 0;
        SubProfileHsmda2EgressQosQDeleteCnt = 0;
 
        /* Since we use the async ICC interface, the message will be freed later on */
        pSubProfHsmda2EgrQueueOverrideDelReqMesg = NULL;
    }
}

PUBLIC void smgrFlushSubProfHsmda2EgrQueueOverrideDelMesg(void)
{
    smgrDoFlushSubProfHsmda2EgrQueueOverrideDelMesg(FALSE);
}

PRIVATE void smgrGetSbmSubSchedOvrDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                               const  tSbmSubSchedOvr *pSchedOvr,
                                               tUint32 IomOp,
                                               tUint32 SlotBitmap,
                                               tBoolean IsCardOnline)
{
 
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubSchedOvr,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmSubSchedOvrCmp,
                          pSchedOvr);
    
}
/* Send a SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrSendSubVSOverrideAddMesg(tSbmSubSchedOvr *pSchedOvr, tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tUint32 overrideMask;
    tUint32 overrideRate;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    tIomQosGroupOverride *pEntry;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "subId=%u dir=%s isArbiter=%s sched=%s ovrMask=0x%x "
                           "pir=%u igmpDelta=%d RadiusRate=%d ovrPres=0x%x "
                           "iomBitMask=0x%08x",
                 pSchedOvr->pActSub->iomId,
                 (pSchedOvr->direction == SBM_ING_SCHED) ? "ingress" : "egress",
                 pSchedOvr->isArbiter ? "yes" : "no",
                 pSchedOvr->virtSchedname.name,
                 pSchedOvr->overrideMask,
                 pSchedOvr->PIR,
                 pSchedOvr->IgmpRateDelta,
                 pSchedOvr->RadiusRate,
                 pSchedOvr->OverridePresent,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this message.
     * If we end up with the empty set, then don't bother trying to send it...
     */
    smgrGetSbmSubSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op,
                                      ALL_APPLICABLE_IOMS,FALSE);
    IomBitMask &= IccInfo.IomBitMask;
   
    if (IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
        
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUBSCRIBER;
    pEntry->SchedulerId.TypeId.Obj = pSchedOvr->isArbiter ? QOS_SCHEDULER_OBJ_ARBITER : QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == SBM_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.Subscriber.SubscriberId = pSchedOvr->pActSub->iomId;

    /* Always fill in the IGMP RateDelta */
    pEntry->IgmpRateDelta = pSchedOvr->IgmpRateDelta;

    /* Only PIR override supported for subscribers currently */
    if ((pSchedOvr->OverridePresent & SBM_OVERRIDE_CREATOR_ANCP) &&
        (pSchedOvr->overrideMask & QOS_GROUP_OVERRIDE_RATE)) {
        /* These are always sent as ANCP rate overrides */
        overrideMask = QOS_GROUP_OVERRIDE_ANCP_RATE;
        overrideRate = pSchedOvr->PIR;
    } else if (pSchedOvr->OverridePresent & SBM_OVERRIDE_CREATOR_RADIUS) {
        overrideMask = QOS_GROUP_OVERRIDE_RATE;
        overrideRate = pSchedOvr->RadiusRate;
    } else {
        overrideMask = 0;
    }

    if (overrideMask) {
        pEntry->OverrideMask = overrideMask;
        if (pSchedOvr->isArbiter) {
            pEntry->Parms.Arbiter.IsRoot = 1;
            pEntry->Parms.Arbiter.Rate = overrideRate;
        } else {
            pEntry->Parms.Scheduler.Rate = overrideRate;
        }
    }

    /* We need to flush all pending adds first */
    smgrFlushSubVSOverrideAddMesg();        

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a SUB_SCHEDULER_POLICY_OVERRIDE_ADD message */
PUBLIC tStatus smgrBatchSubVSOverrideAddMesgPriv(tSbmSubSchedOvr *pSchedOvr, tUint32 IomBitMask,
                                                 tUint32 SlotBitmap,tBoolean IsCardOnline,
                                                 tBatchProcessing *pBatch)
{
    tIomQosGroupOverride *pEntry;
    tUint32 overrideMask;
    tUint32 overrideRate;
    tSmgrMsgrIccInfo IccInfo;
    tIomSapSubMixedEntry *pElm = NULL;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD;
    
    SVCMGR_EVENT(IOM_CALL, "subId=%u dir=%s isArbiter=%s sched=%s ovrMask=0x%x "
                           "pir=%u igmpDelta=%d RadiusRate=%d ovrPres=0x%x "
                           "iomBitMask=0x%08x",
                 pSchedOvr->pActSub->iomId,
                 (pSchedOvr->direction == SBM_ING_SCHED) ? "ingress" : "egress",
                 pSchedOvr->isArbiter ? "yes" : "no",
                 pSchedOvr->virtSchedname.name,
                 pSchedOvr->overrideMask,
                 pSchedOvr->PIR,
                 pSchedOvr->IgmpRateDelta,
                 pSchedOvr->RadiusRate,
                 pSchedOvr->OverridePresent,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this message.
     * If we end up with the empty set, then don't bother trying to send it...
     */
    smgrGetSbmSubSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op,
                                      SlotBitmap,IsCardOnline);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;

    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubVSOverrideAddEntry != 0) &&
        (IomBitMask != PrevSubVSOverrideAddIomBitMask))
        smgrDoFlushSubVSOverrideAddMesg(TRUE);
    
    /* Set the previous iom bit mask */
    PrevSubVSOverrideAddIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubVSOverrideAddReqMesg == NULL) {
        if ((pSubVSOverrideAddReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubscrVSOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubVSOverrideAddReqMesg->NumEntries = NextSubVSOverrideAddEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubVSOverrideAddReqMesg, Op,
                                       NextSubVSOverrideAddEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUBSCRIBER;
    pEntry->SchedulerId.TypeId.Obj = pSchedOvr->isArbiter ? QOS_SCHEDULER_OBJ_ARBITER : QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == SBM_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.Subscriber.SubscriberId = pSchedOvr->pActSub->iomId;
    
    /* Always fill in the IGMP RateDelta */
    pEntry->IgmpRateDelta = pSchedOvr->IgmpRateDelta;

    /* Only PIR override supported for subscribers currently */
    if ((pSchedOvr->OverridePresent & SBM_OVERRIDE_CREATOR_ANCP) &&
        (pSchedOvr->overrideMask & QOS_GROUP_OVERRIDE_RATE)) {
        /* These are always sent as ANCP rate overrides */
        overrideMask = QOS_GROUP_OVERRIDE_ANCP_RATE;
        overrideRate = pSchedOvr->PIR;
    } else if (pSchedOvr->OverridePresent & SBM_OVERRIDE_CREATOR_RADIUS) {
        overrideMask = QOS_GROUP_OVERRIDE_RATE;
        overrideRate = pSchedOvr->RadiusRate;
    } else {
        overrideMask = 0;
    }

    if (overrideMask) {
        pEntry->OverrideMask = overrideMask;
        if (pSchedOvr->isArbiter) {
            pEntry->Parms.Arbiter.IsRoot = 1;
            pEntry->Parms.Arbiter.Rate = overrideRate;
        } else {
            pEntry->Parms.Scheduler.Rate = overrideRate;
        }
    }

    /* If we reached the limit, flush the message */
    if (pSubVSOverrideAddReqMesg->NumEntries == SMMaxNumSubscrVSOverrideEntriesPerMesg) {
        smgrFlushSubVSOverrideAddMesg();
        if (pBatch)
            pBatch->SubVSOverrideAddSent = FALSE;
    } else {
        NextSubVSOverrideAddEntry++;
        if (pBatch)
            pBatch->SubVSOverrideAddSent = TRUE;
    }
    return SUCCESS;
}


/* Flush batched up SUB_SCHEDULER_POLICY_OVERRIDE_ADD messages */
PRIVATE tStatus smgrDoFlushSubVSOverrideAddMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubVSOverrideAddIomBitMask;
    tStatus s = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD;

    if (pSubVSOverrideAddReqMesg && (pSubVSOverrideAddReqMesg->NumEntries > 0)) {

        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubVSOverrideAddReqMesg->NumEntries, IomBitMask);

        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmSubSchedOvr, Op);
        
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubVSOverrideAddReqMesg, PreFlush);
        pSubVSOverrideAddReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubVSOverrideAddReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSubVSOverrideAddReqMesg, 
                                          pSubVSOverrideAddReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSubVSOverrideAddReqMesg);
        }

        /* Start a new batch */
        NextSubVSOverrideAddEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubVSOverrideAddReqMesg = NULL;
    }
    return s;
}

PUBLIC tStatus smgrFlushSubVSOverrideAddMesg(void)
{
    return smgrDoFlushSubVSOverrideAddMesg(FALSE);
}

    
/* Send a SUB_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrSendSubVSOverrideDelMesg(tSbmSubSchedOvr *pSchedOvr, tUint32 IomBitMask)
{
    tIomSapSubMixedRequest *req;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    tIomQosGroupOverride *pEntry;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE;
    
    SVCMGR_EVENT(IOM_CALL, "subscriber=%u direction=%s isArbiter=%s "
                           "scheduler=%s iomBitMask=0x%08x",
                 pSchedOvr->pActSub->iomId,
                 (pSchedOvr->direction == SBM_ING_SCHED) ? "ingress" : "egress",
                 pSchedOvr->isArbiter ? "yes" : "no",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this message.
     * If we end up with the empty set, then don't bother trying to send it...
     */
    smgrGetSbmSubSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op,
                                      ALL_APPLICABLE_IOMS,FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;
    
    if ((req = SMGR_MESG_MEM_CALLOC(1, smgrMesgIccSapSubMsgSize(Op, 1))) == NULL)
        return FAIL;
        
    req->NumEntries = 1;
    req->Entries[0].Op = Op;
    pEntry = &req->Entries[0].SubSchedulerPolicyOverride;
    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUBSCRIBER;
    pEntry->SchedulerId.TypeId.Obj = pSchedOvr->isArbiter ? QOS_SCHEDULER_OBJ_ARBITER : QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == SBM_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.Subscriber.SubscriberId = pSchedOvr->pActSub->iomId;

    /* We need to flush all pending adds first */
    smgrFlushSubVSOverrideAddMesg();        

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, req, FALSE);
    req->TotalLength = smgrMesgIccSapSubMsgSize(Op, req->NumEntries);
    
    s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                      IomBitMask, req, req->TotalLength,
                                      NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                      SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
        SMGR_MESG_MEM_FREE(req);
    }

    return s;
}


/* Batch up a IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE message */
PUBLIC tStatus smgrBatchSubVSOverrideDelMesg(struct sbmSubSchedOvr *pSchedOvr, tUint32 IomBitMask,
                                             tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomQosGroupOverride *pEntry;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE;
     
    SVCMGR_EVENT(IOM_CALL, "subscriber=%u direction=%s isArbiter=%s "
                           "scheduler=%s iomBitMask=0x%08x",
                 pSchedOvr->pActSub->iomId,
                 (pSchedOvr->direction == SBM_ING_SCHED) ? "ingress" : "egress",
                 pSchedOvr->isArbiter ? "yes" : "no",
                 pSchedOvr->virtSchedname.name,
                 IomBitMask);

    /* Determine the set of IOM's that should receive this message.
     * If we end up with the empty set, then don't bother trying to send it...
     */
    smgrGetSbmSubSchedOvrDownloadInfo(&IccInfo, pSchedOvr, Op,
                                      ALL_APPLICABLE_IOMS,FALSE);
    IomBitMask &= IccInfo.IomBitMask;

    if (IomBitMask == 0)
        return SUCCESS;
    
    /* If the specified slot number differs from the previous 
     * one, flush the message and start a new batch so that we
     * don't send messages to the wrong set of IOM's!
     */
    if ((NextSubVSOverrideDelEntry != 0) && (IomBitMask != PrevSubVSOverrideDelIomBitMask))
        smgrFlushSubVSOverrideDelMesg();
    
    /* Set the previous iom bit mask */
    PrevSubVSOverrideDelIomBitMask = IomBitMask;

    /* After a flush, the pointer will be NULL */
    if (pSubVSOverrideDelReqMesg == NULL) {
        if ((pSubVSOverrideDelReqMesg =
             SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubscrVSOverrideEntriesPerMesg))) == NULL)
            return FAIL;
    }

    pSubVSOverrideDelReqMesg->NumEntries = NextSubVSOverrideDelEntry + 1;
    pElm = smgrSapSubGetMixedEntryAddr(pSubVSOverrideDelReqMesg, Op,
                                       NextSubVSOverrideDelEntry);
    pElm->Op = Op;
    pEntry = &pElm->SubSchedulerPolicyOverride;
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SchedulerId.TypeId.Loc = QOS_SCHEDULER_LOC_SUBSCRIBER;
    pEntry->SchedulerId.TypeId.Obj = pSchedOvr->isArbiter ? QOS_SCHEDULER_OBJ_ARBITER : QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pEntry->SchedulerId.TypeId.Dir = (pSchedOvr->direction == SBM_ING_SCHED) ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pEntry->SchedulerId.ObjId.SchedulerName.Str,
            sizeof(pEntry->SchedulerId.ObjId.SchedulerName.Str), pSchedOvr->virtSchedname.name);
    pEntry->SchedulerId.LocId.Subscriber.SubscriberId = pSchedOvr->pActSub->iomId;
    
    /* If we reached the limit, flush the message */
    if (pSubVSOverrideDelReqMesg->NumEntries == SMMaxNumSubscrVSOverrideEntriesPerMesg) {
        smgrFlushSubVSOverrideDelMesg();
        if (pBatch)
            pBatch->SubVSOverrideDelSent = FALSE;
    } else {
        NextSubVSOverrideDelEntry++;
        if (pBatch)
            pBatch->SubVSOverrideDelSent = TRUE;
    }
    return SUCCESS;
}


/* Flush batched up IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE messages */
PRIVATE void smgrDoFlushSubVSOverrideDelMesg(tBoolean PreFlush)
{
    tUint32 IomBitMask = PrevSubVSOverrideDelIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s;
    const eSapSubOp Op = IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE;
       
    if (pSubVSOverrideDelReqMesg &&
        (pSubVSOverrideDelReqMesg->NumEntries > 0)) {         
        smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                                   SmgrMsgrEntry_SbmSubSchedOvr, Op);
        
        SVCMGR_EVENT(IOM_CALL, "entries=%u mask=%08x",
                     pSubVSOverrideDelReqMesg->NumEntries, IomBitMask);
    
        /* Send the message to all applicable IOM's */
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubVSOverrideDelReqMesg, PreFlush);
        pSubVSOverrideDelReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubVSOverrideDelReqMesg->NumEntries);
        
        s = smgrSendClientCustomMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                          IomBitMask, pSubVSOverrideDelReqMesg, 
                                          pSubVSOverrideDelReqMesg->TotalLength,
                                          NULL, SMGR_DNDLER_MAY_BLOCK, NULL,
                                          SMIccCleanSemId, FALSE, TRUE, smgrIccCleanSendSapSub);
        if (s != SUCCESS) {
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
            SMGR_MESG_MEM_FREE(pSubVSOverrideDelReqMesg);
        }

        /* Start a new batch */
        NextSubVSOverrideDelEntry = 0;

        /* Since we use the async ICC interface, the message will be freed later on */
        pSubVSOverrideDelReqMesg = NULL;
    }
}

PUBLIC void smgrFlushSubVSOverrideDelMesg(void)
{
    smgrDoFlushSubVSOverrideDelMesg(FALSE);
}

/* Send a SCHEDULER_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSubSchedStatsReadMesg(tSbmActSub *pActSub, const char *Name,
                                             tBoolean IsSched, tBoolean Ingress, tSchedulerQosStats *pStats, tBoolean *pHaveSmgrLock)
{
    tIomSapSchedulerStatsRequest  *pReq = NULL;
    tIomSapSchedulerStatsResponse *pRep = NULL;
    tUint32 iomBitMask = 0;
    tSlot slotNum;
    tIccTransaction *pIccTran = NULL;
    tIccError s;

    SVCMGR_EVENT(IOM_CALL, "subid=%u name=%s (%s) direction=%s",
                 pActSub->iomId,
                 Name,
                 (IsSched) ? "scheduler" : "arbiter",
                 (Ingress) ? "ingress" : "egress");

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);
    
    /* Create request */
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    pReq->Op = IOM_SCHEDULER_QOS_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_SUBSCRIBER;
    pReq->SapSchedulers[0].TypeId.Obj = IsSched ? QOS_SCHEDULER_OBJ_USER_SCHEDULER : QOS_SCHEDULER_OBJ_ARBITER;
    pReq->SapSchedulers[0].TypeId.Dir = Ingress ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pReq->SapSchedulers[0].ObjId.SchedulerName.Str, sizeof(pReq->SapSchedulers[0].ObjId.SchedulerName.Str), Name);
    pReq->SapSchedulers[0].LocId.Subscriber.SubscriberId = pActSub->iomId;

    /* Get the set of IOMs where this subscriber exists */
    iomBitMask = sbmGetActSubIomBitMask(pActSub);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this subscriber is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(iomBitMask, slotNum))
            continue;
        
        /* ICC Transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
        
        /* Fill out ICC transaction */       
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
 
        SVCMGR_EVENT(IOM_CALL, "sock=%d slot=%d len=%d", pIccTran->Socket, slotNum, pIccTran->RequestFragments[0].Length);

        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }

        /* Copy the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = pRep->Stats[0].Stats.AvgStatsTime;
            
            /* Fill up the stats */   
            pStats->IomStats.PktsForwarded += pRep->Stats[0].Stats.IomStats.PktsForwarded;
            pStats->IomStats.OctetsForwarded += pRep->Stats[0].Stats.IomStats.OctetsForwarded;
        }

        iccFreeTransaction(pIccTran);
    }

    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send a SCHEDULER_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSubSchedStatsResetMesg(tSbmActSub *pActSub, tIomSapSchedulerStatsRequest *req)
{
    tIccTransaction *pIccTran;
    tIccError s;

    tUint32 iomBitMask = 0;
    tSlot slotNum;

    SVCMGR_EVENT(IOM_CALL, "subid=%u", pActSub->iomId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* Get the set of IOMs where this subscriber exists */
    iomBitMask = sbmGetActSubIomBitMask(pActSub);

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this subscriber is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(iomBitMask, slotNum)) {
            continue;
        }
       
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);
        
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            return FAIL;
        }
        
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            return FAIL;
        }
    }

    return SUCCESS;
}


/* Send a SUBSCRIBER_APP_STATS_READ message */
PUBLIC tStatus smgrSendSLAProfInstStatsReadMesg(tSbmSLAProfInst *pSLAProfInst, tSubscriberAppStats *pStats, tBoolean *pHaveSmgrLock)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubAppStatsRequest req;
    tIomSubAppStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomSubscriberAppStats *pDst;
    tIomSubscriberAppStats *pSrc;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading SLAProfInst Stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request. 
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);

    req.Op = IOM_SUBSCRIBER_APP_STATS_READ;
    req.NumEntries = 1;
    req.PollHardware = FALSE;
    ZERO_STRUCT(req.Entries[0]);
    req.Entries[0].SubscriberId = pActSub->iomId;
    req.Entries[0].SapId = pSap->SapId;
    req.Entries[0].SlaProfileId = pSLAProf->iomId;
    req.Entries[0].ComplexNum = INVALID_COMPLEX_NUM;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_APP_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_APP_STATS_REQUEST_MSG(req.NumEntries);
        pIccTran->RequestFragments[0].Addr = &req;
        
        s = iccSendRequest(pIccTran, TRUE);

        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_APP_STATS, s);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }

        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgIngressStatsTime = pRep->Entries[0].Stats.AvgIngressStatsTime;
            pStats->AvgEgressStatsTime = pRep->Entries[0].Stats.AvgEgressStatsTime;
            
            /* Fill up the stats */                
            pDst = &pStats->IomStats;
            pSrc = &pRep->Entries[0].Stats.IomStats;

            pDst->IngressPchipOfferedHiPrioPackets += pSrc->IngressPchipOfferedHiPrioPackets;
            pDst->IngressPchipOfferedHiPrioOctets += pSrc->IngressPchipOfferedHiPrioOctets;
            pDst->IngressPchipOfferedLoPrioPackets += pSrc->IngressPchipOfferedLoPrioPackets;
            pDst->IngressPchipOfferedLoPrioOctets += pSrc->IngressPchipOfferedLoPrioOctets;
            pDst->IngressPchipOfferedUncolouredPackets += pSrc->IngressPchipOfferedUncolouredPackets;
            pDst->IngressPchipOfferedUncolouredOctets += pSrc->IngressPchipOfferedUncolouredOctets;
            pDst->IngressPchipOfferedMcastManagedPackets += pSrc->IngressPchipOfferedMcastManagedPackets;
            pDst->IngressPchipOfferedMcastManagedOctets += pSrc->IngressPchipOfferedMcastManagedOctets;
            pDst->IngressQchipDroppedHiPrioPackets += pSrc->IngressQchipDroppedHiPrioPackets;
            pDst->IngressQchipDroppedHiPrioOctets += pSrc->IngressQchipDroppedHiPrioOctets;
            pDst->IngressQchipDroppedLoPrioPackets += pSrc->IngressQchipDroppedLoPrioPackets;
            pDst->IngressQchipDroppedLoPrioOctets += pSrc->IngressQchipDroppedLoPrioOctets;
            pDst->IngressQchipForwardedInProfPackets += pSrc->IngressQchipForwardedInProfPackets;
            pDst->IngressQchipForwardedInProfOctets += pSrc->IngressQchipForwardedInProfOctets;
            pDst->IngressQchipForwardedOutProfPackets += pSrc->IngressQchipForwardedOutProfPackets;
            pDst->IngressQchipForwardedOutProfOctets += pSrc->IngressQchipForwardedOutProfOctets;
            pDst->EgressQchipDroppedInProfPackets += pSrc->EgressQchipDroppedInProfPackets;
            pDst->EgressQchipDroppedInProfOctets += pSrc->EgressQchipDroppedInProfOctets;
            pDst->EgressQchipDroppedOutProfPackets += pSrc->EgressQchipDroppedOutProfPackets;
            pDst->EgressQchipDroppedOutProfOctets += pSrc->EgressQchipDroppedOutProfOctets;
            pDst->EgressQchipForwardedInProfPackets += pSrc->EgressQchipForwardedInProfPackets;
            pDst->EgressQchipForwardedInProfOctets += pSrc->EgressQchipForwardedInProfOctets;
            pDst->EgressQchipForwardedOutProfPackets += pSrc->EgressQchipForwardedOutProfPackets;
            pDst->EgressQchipForwardedOutProfOctets += pSrc->EgressQchipForwardedOutProfOctets;
        }
    
        iccFreeTransaction(pIccTran);
    }

    return SUCCESS;
}


/* Send a SUBSCRIBER_APP_STATS_RESET message */
PUBLIC tStatus smgrSendSLAProfInstStatsResetMesg(tSbmSLAProfInst *pSLAProfInst)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    tIomSubAppStatsRequest req;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);

    req.Op = IOM_SUBSCRIBER_APP_STATS_RESET;
    req.NumEntries = 1;
    req.PollHardware = FALSE;
    ZERO_STRUCT(req.Entries[0]);
    req.Entries[0].SubscriberId = pActSub->iomId;
    req.Entries[0].SapId = pSap->SapId;
    req.Entries[0].SlaProfileId = pSLAProf->iomId;
    req.Entries[0].ComplexNum = INVALID_COMPLEX_NUM;

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SUB_APP_STATS_REQUEST_MSG(req.NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_APP_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;        
        memcpy(pIccTran->RequestFragments[0].Addr, &req, pIccTran->RequestFragments[0].Length);
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SUBSCRIBER_APP_STATS, s);
            return FAIL;
        }
    }

    return SUCCESS;
}    

PUBLIC tStatus smgrSendSubAppStatsReadMesg(tUint32  subId,
                                           tUint32  slaProfId,
                                           tSapId  *pSapId,
                                           tUint32  iomPresentBitMask,
                                           tUint32  numStats,
                                           tUint8  *pStatIdList,
                                           tUint32 *pNumStatsResp,
                                           tIomSubQueueStats *pStats,
                                           tBoolean relative)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tUint32 statsRequested = 0;
    tUint32 i;

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u numStats=%d",
                 subId,
                 smgrFmtSapIdVerboseForDebug(pSapId),
                 slaProfId, numStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* Initialize the response */
    memset(pStats, 0, numStats * sizeof(*pStats));

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(MAX_SUB_QUEUE_STATS_ENTRIES_PER_MSG))) == NULL)
        return FAIL;

    while (statsRequested < numStats)
    {    
        pReq->Op = relative ? IOM_QOS_QUEUE_STATS_READ_RELATIVE : IOM_QOS_QUEUE_STATS_READ_ABSOLUTE;
        pReq->NumEntries = MIN(numStats - statsRequested,
                               MAX_SUB_QUEUE_STATS_ENTRIES_PER_MSG);
        pReq->PollHardware = FALSE;
        for (i = 0; i < pReq->NumEntries; i++)
        {
            pReq->SubQueues[i].SubscriberId = subId;
            pReq->SubQueues[i].SapId = *pSapId;
            pReq->SubQueues[i].SlaProfileId = slaProfId;
            pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
            pReq->SubQueues[i].QosQueueId = pStatIdList[statsRequested++];
        }

        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this SAP is not present */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(iomPresentBitMask, slotNum))
                continue;
    
            if ((pIccTran = iccNewTransaction()) == NULL) {
                SMGR_MESG_MEM_FREE(pReq);
                return FAIL;
            }
       
            /* Fill out ICC transaction */
            pIccTran->Slot = slotNum;
            pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
            pIccTran->Priority = ICC_HIGHEST_PRIORITY;
            pIccTran->NumRequestFragments = 1;
            pIccTran->RequestFragments[0].Length =
                SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
            pIccTran->RequestFragments[0].Addr = pReq;
        
            s = iccSendRequest(pIccTran, TRUE);
    
            /* If the IOM is removed during the transaction, we may
             * get an ICC_ERR_UNREACHABLE that can be safely ignored.
             */
            if (s == ICC_ERR_UNREACHABLE) {
                iccFreeTransaction(pIccTran);
                continue;
            }
    
            /* Check the return code */
            if (s != ICC_ERR_NONE) {
                SVCMGR_ERROR(NOCLASS,
                             "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                             slotNum, pIccTran->TransactionId,
                             ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
                iccFreeTransaction(pIccTran);
                SMGR_MESG_MEM_FREE(pReq);
                return FAIL;
            }
    
            /* Do some sanity checks */
            if ((pRep = smgrValidateIomResponse(pIccTran, 0, FALSE)) == NULL) {
                SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
                iccFreeTransaction(pIccTran);
                SMGR_MESG_MEM_FREE(pReq);
                return FAIL;
            }
    
            /* Accumulate the stats into the buffer */
            if (pRep->NumEntries > 0) {
                for (i = 0; i < pRep->NumEntries; i++)
                {
                    pStats[*pNumStatsResp] = pRep->Stats[i];
                    ++(*pNumStatsResp);
                }
            }

            iccFreeTransaction(pIccTran);
        }
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSLAProfInstIngQStatsReadMesg(tSbmSLAProfInst *pSLAProfInst, int QueueId,
                                                    tAccessIngressQosQueueStats *pStats,
                                                    tBoolean *pHaveSmgrLock)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u queue=%d",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId, QueueId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level here");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);
    
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].SlaProfileId = pSLAProf->iomId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_ING_QUEUE(QueueId);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            sapStatsIngQosPlcyQueueAdd(pStats, &pRep->Stats[0].Stats.Ingress);
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSLAProfInstIngPStatsResetMesg(tSbmSLAProfInst *pSLAProfInst)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numIngPolicers;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8 ingPolicerIdList[MAX_QOS_POLICERS_PER_ING_QOS_POL + 3];

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);
    
    numIngPolicers = qosGetSLAProfInstIngPolicerIdList(pSLAProfInst, ingPolicerIdList);

    /* Allocate for max number of queues */
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(SMMaxNumSubQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->PollHardware = FALSE;

    numIterations = (numIngPolicers / SMMaxNumSubQueueStatsEntriesPerMesg) +
                    ((numIngPolicers % SMMaxNumSubQueueStatsEntriesPerMesg) ? 1 : 0);
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in ingPolicerIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSubQueueStatsEntriesPerMesg;

        pReq->NumEntries = MIN(numIngPolicers, SMMaxNumSubQueueStatsEntriesPerMesg);
        numIngPolicers  -= pReq->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < pReq->NumEntries; i++) {
            pReq->SubQueues[i].SubscriberId = pActSub->iomId;
            pReq->SubQueues[i].SapId = pSap->SapId;
            pReq->SubQueues[i].SlaProfileId = pSLAProf->iomId;
            pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
            pReq->SubQueues[i].QosQueueId = MAKE_QOS_QUEUE_ID_ING_POLICER(ingPolicerIdList[iterationIndex + i]);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this SAP is not present */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, slotNum, pReq,
                                   SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSLAProfInstIngQStatsResetMesg(tSbmSLAProfInst *pSLAProfInst)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numIngQueues;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tUint8 ingQueueIdList[MAX_QOS_QUEUES_PER_INGRESS_QOS_POLICY + 3];

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);
    
    numIngQueues = qosGetSLAProfInstIngQueueIdList(pSLAProfInst, ingQueueIdList);

    /* Allocate for max number of queues */
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(SMMaxNumSubQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->PollHardware = FALSE;

    numIterations = (numIngQueues / SMMaxNumSubQueueStatsEntriesPerMesg) +
                    ((numIngQueues % SMMaxNumSubQueueStatsEntriesPerMesg) ? 1 : 0);
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in ingQueueIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSubQueueStatsEntriesPerMesg;

        pReq->NumEntries = MIN(numIngQueues, SMMaxNumSubQueueStatsEntriesPerMesg);
        numIngQueues    -= pReq->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < pReq->NumEntries; i++) {
            pReq->SubQueues[i].SubscriberId = pActSub->iomId;
            pReq->SubQueues[i].SapId = pSap->SapId;
            pReq->SubQueues[i].SlaProfileId = pSLAProf->iomId;
            pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
            pReq->SubQueues[i].QosQueueId = MAKE_QOS_QUEUE_ID_ING_QUEUE(ingQueueIdList[iterationIndex + i]);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this SAP is not present */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, slotNum, pReq,
                                   SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSLAProfInstEgrQStatsReadMesg(tSbmSLAProfInst *pSLAProfInst, int QueueId,
                                                    tAccessEgressQosQueueStats *pStats,
                                                    tBoolean *pHaveSmgrLock)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomAccessEgressQosQueueStats *pDst;
    tIomAccessEgressQosQueueStats *pSrc;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u queue=%d",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId, QueueId);

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].SlaProfileId = pSLAProf->iomId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = QueueId;
    
    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = pRep->Stats[0].Stats.Egress.AvgStatsTime;

            /* Fill up the stats */   
            pDst = &pStats->IomStats;
            pSrc = &pRep->Stats[0].Stats.Egress.IomStats;

            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->InProfilePktsDropped += pSrc->InProfilePktsDropped;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->OutOfProfilePktsDropped += pSrc->OutOfProfilePktsDropped;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->InProfileOctetsDropped += pSrc->InProfileOctetsDropped;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
            pDst->OutOfProfileOctetsDropped += pSrc->OutOfProfileOctetsDropped;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSLAProfInstEgrPStatsResetMesg(tSbmSLAProfInst *pSLAProfInst)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numEgrPolicers;
    int i;
    tUint8 egrPolicerIdList[NUM_FC];
    tIccTransaction *pIccTran;
    tIccError s;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);
    
    numEgrPolicers = qosGetSLAProfInstEgrPolicerIdList(pSLAProfInst, egrPolicerIdList);

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(numEgrPolicers))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->NumEntries = numEgrPolicers;
    pReq->PollHardware = FALSE;

    for (i = 0; i < numEgrPolicers; i++) {
        pReq->SubQueues[i].SubscriberId = pActSub->iomId;
        pReq->SubQueues[i].SapId = pSap->SapId;
        pReq->SubQueues[i].SlaProfileId = pSLAProf->iomId;
        pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
        pReq->SubQueues[i].QosQueueId = MAKE_QOS_QUEUE_ID_EGR_POLICER(egrPolicerIdList[i]);
    }
        
    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, pReq, pIccTran->RequestFragments[0].Length);
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}

/* Send an ACCESS_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSLAProfInstEgrQStatsResetMesg(tSbmSLAProfInst *pSLAProfInst)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numEgrQueues;
    int i;
    tUint8 egrQueueIdList[NUM_FC];
    tIccTransaction *pIccTran;
    tIccError s;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);
    
    numEgrQueues = qosGetSLAProfInstEgrQueueIdList(pSLAProfInst, egrQueueIdList);

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(numEgrQueues))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->NumEntries = numEgrQueues;
    pReq->PollHardware = FALSE;

    for (i = 0; i < numEgrQueues; i++) {
        pReq->SubQueues[i].SubscriberId = pActSub->iomId;
        pReq->SubQueues[i].SapId = pSap->SapId;
        pReq->SubQueues[i].SlaProfileId = pSLAProf->iomId;
        pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
        pReq->SubQueues[i].QosQueueId = egrQueueIdList[i];
    }
        
    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, pReq, pIccTran->RequestFragments[0].Length);
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}

/* Send an ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSLAProfInstIngPStatsReadMesg(
                                          tSbmSLAProfInst *pSLAProfInst,
                                          int PolicerId,
                                          tAccessIngressQosPolicerStats *pStats,
                                          tBoolean *pHaveSmgrLock)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomQosPolicerStats_Generic *pDst;
    tIomQosPolicerStats_Generic *pSrc;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u policer=%d",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId, PolicerId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level here");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);
    
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].SlaProfileId = pSLAProf->iomId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_ING_POLICER(PolicerId);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = 
                pRep->Stats[0].Stats.IngressPolicer.AvgStatsTime;
            pStats->StatMode     = 
                pRep->Stats[0].Stats.IngressPolicer.StatMode;

            /* Fill up the stats */   
            pDst = &pStats->IomStats.Generic;
            pSrc = &pRep->Stats[0].Stats.IngressPolicer.IomStats.Generic;

            pDst->HighPktsOffered += pSrc->HighPktsOffered;
            pDst->HighPktsDropped += pSrc->HighPktsDropped;
            pDst->LowPktsOffered += pSrc->LowPktsOffered;
            pDst->LowPktsDropped += pSrc->LowPktsDropped;
            pDst->HighOctetsOffered += pSrc->HighOctetsOffered;
            pDst->HighOctetsDropped += pSrc->HighOctetsDropped;
            pDst->LowOctetsOffered += pSrc->LowOctetsOffered;
            pDst->LowOctetsDropped += pSrc->LowOctetsDropped;
            pDst->UncolouredPktsOffered += pSrc->UncolouredPktsOffered;
            pDst->UncolouredOctetsOffered += pSrc->UncolouredOctetsOffered;
            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}

/* Send an ACCESS_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSLAProfInstEgrPStatsReadMesg(
                                          tSbmSLAProfInst *pSLAProfInst,
                                          int PolicerId,
                                          tAccessIngressQosPolicerStats *pStats,
                                          tBoolean *pHaveSmgrLock)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomQosPolicerStats_Generic *pDst;
    tIomQosPolicerStats_Generic *pSrc;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u policer=%d",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId, PolicerId);

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;
        
    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].SlaProfileId = pSLAProf->iomId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_EGR_POLICER(PolicerId);

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = 
                pRep->Stats[0].Stats.EgressPolicer.AvgStatsTime;
            pStats->StatMode     = 
                pRep->Stats[0].Stats.EgressPolicer.StatMode;

            /* Fill up the stats */   
            pDst = &pStats->IomStats.Generic;
            pSrc = &pRep->Stats[0].Stats.EgressPolicer.IomStats.Generic;

            pDst->HighPktsOffered += pSrc->HighPktsOffered;
            pDst->LowPktsOffered += pSrc->LowPktsOffered;
            pDst->HighOctetsOffered += pSrc->HighOctetsOffered;
            pDst->LowOctetsOffered += pSrc->LowOctetsOffered;
            pDst->UncolouredPktsOffered += pSrc->UncolouredPktsOffered;
            pDst->UncolouredOctetsOffered += pSrc->UncolouredOctetsOffered;
            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->HighPktsDropped += pSrc->HighPktsDropped;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->LowPktsDropped += pSrc->LowPktsDropped;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->HighOctetsDropped += pSrc->HighOctetsDropped;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
            pDst->LowOctetsDropped += pSrc->LowOctetsDropped;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send a SCHEDULER_QOS_STATS_READ_RELATIVE message */
PUBLIC tStatus smgrSendSLAProfInstSchedStatsReadMesg(tSbmSLAProfInst *pSLAProfInst, const char *Name,
                                                     tBoolean Ingress, tSchedulerQosStats *pStats, tBoolean *pHaveSmgrLock)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    int slotNum;
    tIomSapSchedulerStatsRequest *pReq;
    tIomSapSchedulerStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u name=%s direction=%s",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId,
                 Name,
                 (Ingress) ? "ingress" : "egress");

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSLAProfInst->pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    pReq->Op = IOM_SCHEDULER_QOS_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->SapSchedulers[0].TypeId.Loc = QOS_SCHEDULER_LOC_SLA_PROFILE_INSTANCE;
    pReq->SapSchedulers[0].TypeId.Obj = QOS_SCHEDULER_OBJ_USER_SCHEDULER;
    pReq->SapSchedulers[0].TypeId.Dir = Ingress ? QOS_DIRECTION_INGRESS : QOS_DIRECTION_EGRESS;
    strcpyn(pReq->SapSchedulers[0].ObjId.SchedulerName.Str, sizeof(pReq->SapSchedulers[0].ObjId.SchedulerName.Str), Name);
    pReq->SapSchedulers[0].LocId.SlaProfileInstance.SubscriberId =  pActSub->iomId;
    pReq->SapSchedulers[0].LocId.SlaProfileInstance.SapId = pSap->SapId;
    pReq->SapSchedulers[0].LocId.SlaProfileInstance.SlaProfileId = pSLAProf->iomId;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;

        /* ICC Transaction */
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS;
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;

        s = iccSendRequest(pIccTran, TRUE);

        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }

        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }

        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, TRUE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }

        /* Copy the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = pRep->Stats[0].Stats.AvgStatsTime;

            /* Fill up the stats */
            pStats->IomStats.PktsForwarded += pRep->Stats[0].Stats.IomStats.PktsForwarded;
            pStats->IomStats.OctetsForwarded += pRep->Stats[0].Stats.IomStats.OctetsForwarded;
        }

        iccFreeTransaction(pIccTran);
    }

    SMGR_MESG_MEM_FREE(pReq);

    return SUCCESS;
}


/* Send a SCHEDULER_QOS_STATS_SET_BASELINE message */
PUBLIC tStatus smgrSendSLAProfInstSchedStatsResetMesg(tSbmSLAProfInst *pSLAProfInst, tIomSapSchedulerStatsRequest *req)
{
    tSbmActSub *pActSub;
    tSapRec *pSap;
    tSbmSLAProf *pSLAProf;
    tSMPortInfo sapPortInfo;
    tIccTransaction *pIccTran;
    tIccError s;
    tSlot slotNum;

    if ((pActSub = pSLAProfInst->pActSub) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pActSub == NULL");
        return FAIL;
    }

    if ((pSap = pSLAProfInst->pSap) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSap == NULL");
        return FAIL;
    }

    if ((pSLAProf = pSLAProfInst->pSLAProf) == NULL) {
        SVCMGR_ERROR(NOCLASS, "pSLAProf == NULL");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u sap=%s slaprofid=%u",
                 pActSub->iomId,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSLAProf->iomId);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (IS_HSMDA_PORT(pSap->PortRec)) {
        /* Ignore this request on a hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset SLAProfInst stats on a hsmda, stats "
                                 "are at subscriber level on this mda");
        return SUCCESS;
    }

    /* If the port where the SAP is defined is not present,
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &sapPortInfo);

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not present */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(sapPortInfo.IomPresentBitMask, slotNum))
            continue;

        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_SCHEDULER_STATS_REQUEST_MSG(req->NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) {
            return FAIL;
        }

        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_SCHEDULER_STATS;
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, req, pIccTran->RequestFragments[0].Length);

        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }

        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            return FAIL;
        }

        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_SCHEDULER_STATS, s);
            return FAIL;
        }
    }

    return SUCCESS;
}


/* Send a SUBSCRIBER_APP_STATS_READ message on qmda */
PUBLIC tStatus smgrSendActSubStatsReadMesg(struct sbmActSub *pActSub, struct SubscriberAppStats *pStats, tBoolean *pHaveSmgrLock)
{
    int slotNum;
    tIomSubAppStatsRequest req;
    tIomSubAppStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomSubscriberAppStats *pDst;
    tIomSubscriberAppStats *pSrc;
    tSbmSLAProfInst        *pSPI;
    tSapRec                *pSap;
    tUint32                IomBitMask;

    if (!pActSub->pPortRec)
    {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_PORT(pActSub->pPortRec))
    {
        /* Ignore this request on a non hsmda */
        SVCMGR_WARNING(IOM_CALL, "Reading subscriber stats on a non hsmda, "
                                 "stats are at SLAProfInst level on this mda");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on hsmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap)
    {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    req.Op = IOM_SUBSCRIBER_APP_STATS_READ;
    req.NumEntries = 1;
    req.PollHardware = FALSE;
    ZERO_STRUCT(req.Entries[0]);
    req.Entries[0].SubscriberId = pActSub->iomId;
    req.Entries[0].SapId = pSap->SapId;
    req.Entries[0].ComplexNum = INVALID_COMPLEX_NUM;

    IomBitMask = pActSub->pPortRec->IomBitMask;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(IomBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_APP_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_APP_STATS_REQUEST_MSG(req.NumEntries);
        pIccTran->RequestFragments[0].Addr = &req;
        
        s = iccSendRequest(pIccTran, TRUE);

        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_APP_STATS, s);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }

        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, FALSE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            return FAIL;
        }
 
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgIngressStatsTime = pRep->Entries[0].Stats.AvgIngressStatsTime;
            pStats->AvgEgressStatsTime = pRep->Entries[0].Stats.AvgEgressStatsTime;
 
            /* Fill up the stats */                
            pDst = &pStats->IomStats;
            pSrc = &pRep->Entries[0].Stats.IomStats;

            pDst->IngressPchipOfferedHiPrioPackets += pSrc->IngressPchipOfferedHiPrioPackets;
            pDst->IngressPchipOfferedHiPrioOctets += pSrc->IngressPchipOfferedHiPrioOctets;
            pDst->IngressPchipOfferedLoPrioPackets += pSrc->IngressPchipOfferedLoPrioPackets;
            pDst->IngressPchipOfferedLoPrioOctets += pSrc->IngressPchipOfferedLoPrioOctets;
            pDst->IngressPchipOfferedUncolouredPackets += pSrc->IngressPchipOfferedUncolouredPackets;
            pDst->IngressPchipOfferedUncolouredOctets += pSrc->IngressPchipOfferedUncolouredOctets;
            pDst->IngressPchipOfferedMcastManagedPackets += pSrc->IngressPchipOfferedMcastManagedPackets;
            pDst->IngressPchipOfferedMcastManagedOctets += pSrc->IngressPchipOfferedMcastManagedOctets;
            pDst->IngressQchipDroppedHiPrioPackets += pSrc->IngressQchipDroppedHiPrioPackets;
            pDst->IngressQchipDroppedHiPrioOctets += pSrc->IngressQchipDroppedHiPrioOctets;
            pDst->IngressQchipDroppedLoPrioPackets += pSrc->IngressQchipDroppedLoPrioPackets;
            pDst->IngressQchipDroppedLoPrioOctets += pSrc->IngressQchipDroppedLoPrioOctets;
            pDst->IngressQchipForwardedInProfPackets += pSrc->IngressQchipForwardedInProfPackets;
            pDst->IngressQchipForwardedInProfOctets += pSrc->IngressQchipForwardedInProfOctets;
            pDst->IngressQchipForwardedOutProfPackets += pSrc->IngressQchipForwardedOutProfPackets;
            pDst->IngressQchipForwardedOutProfOctets += pSrc->IngressQchipForwardedOutProfOctets;
            pDst->EgressQchipDroppedInProfPackets += pSrc->EgressQchipDroppedInProfPackets;
            pDst->EgressQchipDroppedInProfOctets += pSrc->EgressQchipDroppedInProfOctets;
            pDst->EgressQchipDroppedOutProfPackets += pSrc->EgressQchipDroppedOutProfPackets;
            pDst->EgressQchipDroppedOutProfOctets += pSrc->EgressQchipDroppedOutProfOctets;
            pDst->EgressQchipForwardedInProfPackets += pSrc->EgressQchipForwardedInProfPackets;
            pDst->EgressQchipForwardedInProfOctets += pSrc->EgressQchipForwardedInProfOctets;
            pDst->EgressQchipForwardedOutProfPackets += pSrc->EgressQchipForwardedOutProfPackets;
            pDst->EgressQchipForwardedOutProfOctets += pSrc->EgressQchipForwardedOutProfOctets;
        }
    
        iccFreeTransaction(pIccTran);
    }

    return SUCCESS;
}


/* Send a SUBSCRIBER_APP_STATS_RESET message on qmda */
PUBLIC tStatus smgrSendActSubStatsResetMesg(struct sbmActSub *pActSub)
{
    tIomSubAppStatsRequest req;
    int slotNum;
    tIccTransaction *pIccTran;
    tIccError s;
    tSbmSLAProfInst        *pSPI;
    tSapRec                *pSap;

    if (!pActSub->pPortRec)
    {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_PORT(pActSub->pPortRec))
    {
        /* Ignore this request on a non hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset subscriber stats on a non hsmda, "
                                 "stats are at SLAProfInst level on this mda");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on qmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap)
    {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    req.Op = IOM_SUBSCRIBER_APP_STATS_RESET;
    req.NumEntries = 1;
    req.PollHardware = FALSE;
    ZERO_STRUCT(req.Entries[0]);
    req.Entries[0].SubscriberId = pActSub->iomId;
    req.Entries[0].SapId = pSap->SapId;
    req.Entries[0].ComplexNum = INVALID_COMPLEX_NUM;

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(pActSub->pPortRec->IomBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SUB_APP_STATS_REQUEST_MSG(req.NumEntries), ICC_TRANS_OPT_AUTOFREE)) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_APP_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;        
        memcpy(pIccTran->RequestFragments[0].Addr, &req, pIccTran->RequestFragments[0].Length);
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SUBSCRIBER_APP_STATS, s);
            return FAIL;
        }
    }

    return SUCCESS;
}    


/* Send an ACCESS_QOS_STATS_READ_RELATIVE message on qmda */
PUBLIC tStatus smgrSendActSubIngQStatsReadMesg(struct sbmActSub *pActSub, int QueueId,
                                               tAccessIngressQosQueueStats *pStats,
                                               tBoolean *pHaveSmgrLock)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tSbmSLAProfInst        *pSPI;
    tSapRec                *pSap;
    tUint32                IomBitMask;

    if (!pActSub->pPortRec) {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_PORT(pActSub->pPortRec)) {
        /* Ignore this request on a non hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading subscriber stats on a non hsmda, "
                                 "stats are at SLAProfInst level on this mda");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on qmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap) {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_ING_QUEUE(QueueId);

    IomBitMask = pActSub->pPortRec->IomBitMask;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(IomBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, FALSE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            sapStatsIngQosPlcyQueueAdd(pStats, &pRep->Stats[0].Stats.Ingress);
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_SET_BASELINE message on qmda */
PUBLIC tStatus smgrSendActSubIngQStatsResetMesg(struct sbmActSub *pActSub)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numIngQueues;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tSbmSLAProfInst *pSPI;
    tSapRec *pSap;
    tUint8 ingQueueIdList[MAX((NUM_QOS_QMDAQUEUES_PER_INGRESS_QOS_POLICY + 
                               NUM_QOS_QMDAOVERRIDECOUNTERS_PER_INGRESS_QOS_POLICY),
                              (MAX_QOS_QUEUES_PER_INGRESS_QOS_POLICY)) + 3];

    if (!pActSub->pPortRec) {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_PORT(pActSub->pPortRec)) {
        /* Ignore this request on a non hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset subscriber stats on a non hsmda, "
                                 "stats are at SLAProfInst level on this mda");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on qmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap) {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    /* Allocate for max number of queues */
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(SMMaxNumSubQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->PollHardware = FALSE;

    if (IS_HSMDA_V2_PORT(pActSub->pPortRec)) {
        numIngQueues = qosGetHsmda2ActSubIngQueueIdList(pActSub, ingQueueIdList);
    }
    else {
        numIngQueues = NUM_QOS_QMDAQUEUES_PER_INGRESS_QOS_POLICY + 
                       NUM_QOS_QMDAOVERRIDECOUNTERS_PER_INGRESS_QOS_POLICY;
        for (i = 0; i < numIngQueues; i++) {
            ingQueueIdList[i] = i;
        }
    }

    numIterations = (numIngQueues / SMMaxNumSubQueueStatsEntriesPerMesg) +
                    ((numIngQueues % SMMaxNumSubQueueStatsEntriesPerMesg) ? 1 : 0);
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        iterationIndex = iteration * SMMaxNumSubQueueStatsEntriesPerMesg;

        pReq->NumEntries = MIN(numIngQueues, SMMaxNumSubQueueStatsEntriesPerMesg);
        numIngQueues    -= pReq->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < pReq->NumEntries; i++) {
            pReq->SubQueues[i].SubscriberId = pActSub->iomId;
            pReq->SubQueues[i].SapId = pSap->SapId;
            pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
            pReq->SubQueues[i].QosQueueId =
                MAKE_QOS_QUEUE_ID_ING_QUEUE(ingQueueIdList[iterationIndex + i]);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this SAP is not defined */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(pActSub->pPortRec->IomBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, slotNum, pReq,
                                   SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_READ_RELATIVE message on qmda */
PUBLIC tStatus smgrSendActSubEgrQStatsReadMesg(struct sbmActSub *pActSub, int QueueId,
                                               tAccessEgressQosQueueStats *pStats,
                                               tBoolean *pHaveSmgrLock)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomAccessEgressQosQueueStats *pDst;
    tIomAccessEgressQosQueueStats *pSrc;
    tSbmSLAProfInst        *pSPI;
    tSapRec                *pSap;
    tUint32                IomBitMask;

    if (!pActSub->pPortRec)
    {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_PORT(pActSub->pPortRec))
    {
        /* Ignore this request on a non hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reading subscriber stats on a non hsmda, "
                                 "stats are at SLAProfInst level on this mda");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on qmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap)
    {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = QueueId;

    IomBitMask = pActSub->pPortRec->IomBitMask; 

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(IomBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, FALSE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = pRep->Stats[0].Stats.Egress.AvgStatsTime;

            /* Fill up the stats */   
            pDst = &pStats->IomStats;
            pSrc = &pRep->Stats[0].Stats.Egress.IomStats;

            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->InProfilePktsDropped += pSrc->InProfilePktsDropped;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->OutOfProfilePktsDropped += pSrc->OutOfProfilePktsDropped;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->InProfileOctetsDropped += pSrc->InProfileOctetsDropped;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
            pDst->OutOfProfileOctetsDropped += pSrc->OutOfProfileOctetsDropped;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_SET_BASELINE message on qmda */
PUBLIC tStatus smgrSendActSubEgrQStatsResetMesg(struct sbmActSub *pActSub)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numEgrQueues;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tSbmSLAProfInst        *pSPI;
    tSapRec                *pSap;

    if (!pActSub->pPortRec)
    {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_PORT(pActSub->pPortRec))
    {
        /* Ignore this request on a non hsmda*/
        SVCMGR_WARNING(IOM_CALL, "Reset subscriber stats on a non hsmda, "
                                 "stats are at SLAProfInst level on this mda");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on qmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap)
    {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    /* Allocate for max number of queues */
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(SMMaxNumSubQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->PollHardware = FALSE;

    numEgrQueues =  NUM_QOS_QMDAQUEUES_PER_EGRESS_QOS_POLICY + 
                    NUM_QOS_QMDAOVERRIDECOUNTERS_PER_EGRESS_QOS_POLICY;
    numIterations = (numEgrQueues / SMMaxNumSubQueueStatsEntriesPerMesg) +
                    ((numEgrQueues % SMMaxNumSubQueueStatsEntriesPerMesg) ? 1 : 0);
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        iterationIndex = iteration * SMMaxNumSubQueueStatsEntriesPerMesg;

        pReq->NumEntries = MIN(numEgrQueues, SMMaxNumSubQueueStatsEntriesPerMesg);
        numEgrQueues    -= pReq->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < pReq->NumEntries; i++) {
            pReq->SubQueues[i].SubscriberId = pActSub->iomId;
            pReq->SubQueues[i].SapId = pSap->SapId;
            pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
            pReq->SubQueues[i].QosQueueId = (iterationIndex + i);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this SAP is not defined */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(pActSub->pPortRec->IomBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, slotNum, pReq,
                                   SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_READ_RELATIVE message on hsmda */
PUBLIC tStatus smgrSendActSubIngPStatsReadMesg(tSbmActSub *pActSub,
                                               int PolicerId,
                                               tAccessIngressQosPolicerStats *pStats,
                                               tBoolean *pHaveSmgrLock)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    tIomSubQueueStatsResponse *pRep;
    tIccTransaction *pIccTran;
    tIccError s;
    tIomQosPolicerStats_Generic *pDst;
    tIomQosPolicerStats_Generic *pSrc;
    tSbmSLAProfInst        *pSPI;
    tSapRec                *pSap;
    tUint32 IomBitMask;

    if (!pActSub->pPortRec)
    {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_V2_PORT(pActSub->pPortRec))
    {
        /* Ignore this request on a non hsmda2*/
        SVCMGR_WARNING(IOM_CALL, "Reading subscriber ingress policer stats on "
                                 "a non hsmda2");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on hsmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap)
    {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(1))) == NULL)
        return FAIL;

    pReq->Op = IOM_QOS_QUEUE_STATS_READ_RELATIVE;
    pReq->NumEntries = 1;
    pReq->PollHardware = FALSE;
    pReq->SubQueues[0].SubscriberId = pActSub->iomId;
    pReq->SubQueues[0].SapId = pSap->SapId;
    pReq->SubQueues[0].ComplexNum = INVALID_COMPLEX_NUM;
    pReq->SubQueues[0].QosQueueId = MAKE_QOS_QUEUE_ID_ING_POLICER(PolicerId);

    IomBitMask = pActSub->pPortRec->IomBitMask;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this SAP is not defined */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(IomBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) {
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SUBSCRIBER_QUEUE_STATS; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries);
        pIccTran->RequestFragments[0].Addr = pReq;
        
        s = iccSendRequest(pIccTran, TRUE);
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, s);
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Do some sanity checks */
        if ((pRep = smgrValidateIomResponse(pIccTran, 1, FALSE)) == NULL) {
            SVCMGR_ERROR(NOCLASS, "Malformed IOM response !");
            iccFreeTransaction(pIccTran);
            SMGR_MESG_MEM_FREE(pReq);
            return FAIL;
        }
    
        /* Accumulate the stats into the buffer */
        if (pRep->NumEntries > 0) {
            /* Update TimeStamp */
            pStats->AvgStatsTime = 
                pRep->Stats[0].Stats.IngressPolicer.AvgStatsTime;
            pStats->StatMode     = 
                pRep->Stats[0].Stats.IngressPolicer.StatMode;

            /* Fill up the stats */   
            pDst = &pStats->IomStats.Generic;
            pSrc = &pRep->Stats[0].Stats.IngressPolicer.IomStats.Generic;

            pDst->HighPktsOffered += pSrc->HighPktsOffered;
            pDst->HighPktsDropped += pSrc->HighPktsDropped;
            pDst->LowPktsOffered += pSrc->LowPktsOffered;
            pDst->LowPktsDropped += pSrc->LowPktsDropped;
            pDst->HighOctetsOffered += pSrc->HighOctetsOffered;
            pDst->HighOctetsDropped += pSrc->HighOctetsDropped;
            pDst->LowOctetsOffered += pSrc->LowOctetsOffered;
            pDst->LowOctetsDropped += pSrc->LowOctetsDropped;
            pDst->UncolouredPktsOffered += pSrc->UncolouredPktsOffered;
            pDst->UncolouredOctetsOffered += pSrc->UncolouredOctetsOffered;
            pDst->InProfilePktsForwarded += pSrc->InProfilePktsForwarded;
            pDst->OutOfProfilePktsForwarded += pSrc->OutOfProfilePktsForwarded;
            pDst->InProfileOctetsForwarded += pSrc->InProfileOctetsForwarded;
            pDst->OutOfProfileOctetsForwarded += pSrc->OutOfProfileOctetsForwarded;
        }
    
        iccFreeTransaction(pIccTran);
    }
     
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


/* Send an ACCESS_QOS_STATS_SET_BASELINE message on hsmda */
PUBLIC tStatus smgrSendActSubIngPStatsResetMesg(tSbmActSub *pActSub)
{
    int slotNum;
    tIomSubQueueStatsRequest *pReq;
    int numIterations, iteration;
    int iterationIndex;
    int i;
    tSbmSLAProfInst *pSPI;
    tSapRec *pSap;
    int numIngPolicers;
    tUint8 ingPolicerIdList[MAX_QOS_POLICERS_PER_ING_QOS_POL + 3];

    if (!pActSub->pPortRec)
    {
        SVCMGR_WARNING(NOCLASS,"pActSub->pPortRec = NULL, is this subscriber "
                               "currently being deleted?");
        return FAIL;
    }

    SVCMGR_EVENT(IOM_CALL, "subid=%u port=%s",
                 pActSub->iomId,
                 smgrFmtPortIdVerboseForDebug(pActSub->pPortRec->PortId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }

    if (!IS_HSMDA_V2_PORT(pActSub->pPortRec))
    {
        /* Ignore this request on a non hsmda2 */
        SVCMGR_WARNING(IOM_CALL, "Reset subscriber ingress policer stats on a "
                                 "non hsmda2");
        return SUCCESS;
    }

    /* If the port where the subscriber is defined is not present,
     * ignore the request. 
     */
    if (!SMGR_MESG_IS_ACT_SUB_PRESENT_TO_DOWNLOAD(pActSub))
        return SUCCESS;

    /* get the sap, because we need to send the full sap-id to the iom 
     * (it is used to detect if the sap is on hsmda, after this only 
     * port will be used) */
    pSPI = sbmGetFirstNonMatchingSPIforActSub(pActSub, NULL);
    pSap = pSPI ? pSPI->pSap : NULL;
    if (!pSap)
    {
        SVCMGR_ERROR(NOCLASS,"No Sap Found for subscriber %s",
                     pActSub->subId);
        return SUCCESS;
    }

    /* Allocate for max number of queues */
    if ((pReq = SMGR_MESG_MEM_CALLOC(1, SIZE_SUB_QUEUE_STATS_REQUEST_MSG(SMMaxNumSubQueueStatsEntriesPerMesg))) == NULL)
        return FAIL;
    
    pReq->Op = IOM_QOS_QUEUE_STATS_SET_BASELINE;
    pReq->PollHardware = FALSE;

    numIngPolicers = qosGetHsmda2ActSubIngPolicerIdList(pActSub, ingPolicerIdList);

    numIterations = (numIngPolicers / SMMaxNumSubQueueStatsEntriesPerMesg) +
                    ((numIngPolicers % SMMaxNumSubQueueStatsEntriesPerMesg) ? 1 : 0);
    
    for (iteration = 0; iteration < numIterations; iteration++) {

        /* Tracks starting point in ingPolicerIdList for this iteration */
        iterationIndex = iteration * SMMaxNumSubQueueStatsEntriesPerMesg;

        pReq->NumEntries = MIN(numIngPolicers, SMMaxNumSubQueueStatsEntriesPerMesg);
        numIngPolicers  -= pReq->NumEntries; /* Tracking remaining queues */
        
        for (i = 0; i < pReq->NumEntries; i++) {
            pReq->SubQueues[i].SubscriberId = pActSub->iomId;
            pReq->SubQueues[i].SapId = pSap->SapId;
            pReq->SubQueues[i].ComplexNum = INVALID_COMPLEX_NUM;
            pReq->SubQueues[i].QosQueueId =
                MAKE_QOS_QUEUE_ID_ING_POLICER(ingPolicerIdList[iterationIndex + i]);
        }
        
        for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
            /* Skip IOM's that are off-line or where this SAP is not defined */
            if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
                !IOM_BIT_TST(pActSub->pPortRec->IomBitMask, slotNum))
                continue;
            
            smgrSendUnicastIomMesg(ICC_SOCKET_SUBSCRIBER_QUEUE_STATS, slotNum, pReq,
                                   SIZE_SUB_QUEUE_STATS_REQUEST_MSG(pReq->NumEntries));
        }
    }
    
    SMGR_MESG_MEM_FREE(pReq);
    
    return SUCCESS;
}


PUBLIC int smgrShowMesg(int clear, void *pCliEnv)
{
    if (pCliEnv == NULL) {
        if ((pCliEnv = getMyTaskCliEnv()) == NULL) {
            pCliEnv = cliSubTaskToEnv(taskIdSelf());
        }
    }
    if (cliPrintf(pCliEnv, "\n------------------------------------------ \n") < 0) 
        return -1;
    if (cliPrintf(pCliEnv, "Service Manager IOM Info \n") < 0) 
        return -1;
    if (cliPrintf(pCliEnv, "------------------------------------------ \n") < 0) 
        return -1;
    smgrMsgrIomShow(NULL,pCliEnv);
     if (cliPrintf(pCliEnv, "------------------------------------------ \n") < 0) 
        return -1;
    if (!TIMOS_BUILD_TYPE(BETA)) {
        if (cliPrintf(pCliEnv, "To get detail IOM stats please execute smgrMsgrStatShow from shell. Please execute smgrMsgrHelp from shell for help. \n\n" ) < 0)
            return -1;
    }
    return 0;
}
PUBLIC int smgrMesgShow(int clear, void *pCliEnv)
{
    return smgrShowMesg(clear, pCliEnv);
}


/*==========================================================================*
 *                          Private Functions                               *
 *==========================================================================*/
PRIVATE void smgrInitSdpAddReqEntry(tIomSdpEntry *pEntry, tSdpRec *pSdp)
{
    int n;
    tSdpActiveLspType ActiveLspType = sdpActiveLspType(pSdp);
    tTimNetId FarEnd;

    ZERO_STRUCT_PTR(pEntry);

    SVCMGR_EVENT(IOM_CALL, "Sdp %u Delivery %u", pSdp->Id, pSdp->Delivery);
    pEntry->SdpId = pSdp->Id;
    if (pSdp->OperStatus == VAL_sdpOperStatus_up)
        pEntry->Enabled = TRUE;
    else
        pEntry->Enabled = FALSE;
 
    if (sdpGetFarEnd(pSdp, &FarEnd, TRUE /* TunnelFarEnd */) == SUCCESS) {
        pEntry->Ip = TIM_NET_ID_GET_IP(&FarEnd);
    } else {
        TIM_NET_ADDR_INIT(&pEntry->Ip, TRUE);
    }
    
    pEntry->PWBoundPortID = pSdp->EgressPort;
    pEntry->NetDomain = pSdp->NetDomain;
    pEntry->Sdp8021QEtype = pSdp->VlanVcEtype;
    pEntry->Sdp8021QEtypeIndex = pSdp->VlanVcEtypeIndex;

    pEntry->MacInMacEtypeIndex = pSdp->PBBEtypeIndex;
    pEntry->MacInMacEtype = pSdp->PBBEtype;
    switch (pSdp->Delivery) {
        case SMDT_GRE:
            pEntry->Type = SDP_TUNNEL_TYPE_GRE;
            break;
        case SMDT_MPLS:
            pEntry->Type = SDP_TUNNEL_TYPE_LSP;
            if ((ActiveLspType == SDP_ALT_BGP) &&
                (pSdp->BgpTunnelEnabled)) {
                pEntry->u.Lsp.LspIdTable[0] = pSdp->SdpBgpRec->BgpLspId;
                if (pSdp->SdpBgpRec->BgpLspId != 0)
                    pEntry->u.Lsp.NumLsps = 1;
            } else if ((ActiveLspType == SDP_ALT_LDP) &&
                       (pSdp->LdpEnabled == VAL_sdpLdpEnabled_true)) {
                pEntry->u.Lsp.LspIdTable[0] = pSdp->SdpLdpRec->LdpLspId;
                if (pSdp->SdpLdpRec->LdpLspId != 0)
                    pEntry->u.Lsp.NumLsps = 1;
            } else {
                for (n = 0; n < LSPID_LIST_ARRAY_SIZE; n++) {
                    if (pSdp->LspList[n] == 0)
                        break;
                    pEntry->u.Lsp.LspIdTable[n] = pSdp->LspList[n];    
                }
                pEntry->u.Lsp.NumLsps = n;
                if (pSdp->ClassFwdingEnabled == VAL_sdpClassFwdingEnabled_true) {
                    pEntry->u.Lsp.EnableClassFwding = TRUE;
                    for (n = MIN_FC_VALUE; n <= MAX_FC_VALUE; n++) {
                        if (pSdp->FcLspMap[n] != 0) {
                            pEntry->u.Lsp.FcLspIdMap[n] = pSdp->FcLspMap[n];
                        } else {
                            pEntry->u.Lsp.FcLspIdMap[n] = pSdp->DefaultLsp;
                        }
                    }
                    pEntry->u.Lsp.MulticastLspId = (pSdp->MulticastLsp != 0) ? pSdp->MulticastLsp : pSdp->DefaultLsp;
                    pEntry->u.Lsp.DefaultLspId = pSdp->DefaultLsp;
                } else {
                    pEntry->u.Lsp.EnableClassFwding = FALSE;
                }
            }
            break;
        case SMDT_L2TPV3:
            pEntry->Type = SDP_TUNNEL_TYPE_L2TPV3;
            pEntry->u.L2TPv3.IgnoreIngressSessionId = TRUE;
            pEntry->u.L2TPv3.ExtractControlToCPM = FALSE;
            TIM_NET_ADDR_GET_V6(&pEntry->u.L2TPv3.SrcIPAddr,
                                &pSdp->LocalEndInetAddress);
            break;
        default:;
    }
}
   
/* pRetParams can be NULL */
PRIVATE void smgrInitSvcAddReqEntry(tIomSvcEntry *pEntry, tSvcRec *pSvc,
                                    struct SMEventMsg *pCallbackEvent,
                                    tSmgrInitSvcAddReqEntryRetParams *pRetParams,
                                    tBoolean IsCardOnline)
{
    tMirrorObj *pMirror = NULL;
    tMirrorDestL3GwRec *pDestL3EncapGwRec;
    tSvcRec *pParentSvc;
    eSvcPimSnpgState pimSnpg;

    ZERO_STRUCT_PTR(pEntry);

    pEntry->SvcId = pSvc->Id;
    if (pSvc->OperStatus == VAL_svcOperStatus_up)
        pEntry->Enabled = TRUE;
    else
        pEntry->Enabled = FALSE;    
    pEntry->ServiceMtu = pSvc->Mtu;

    switch (pSvc->Type) {
        case ST_EPIPE:
        case ST_P3PIPE:
            pEntry->Type = SVC_TYPE_EPIPE;

            pEntry->u.Epipe.TlsChild.Isid = tlsMimGetOperIsid(pSvc);
            pEntry->u.Epipe.TlsChild.IsidIndex = tlsMimGetOperIsidIndex(pSvc);
            pEntry->u.Epipe.TlsChild.ForceQTagFwding = tlsMimGetForceQTagFwd(pSvc);
            pEntry->u.Epipe.DpiReachableMask = SVC_GET_DPI_DIVERT_MASK(pSvc);
            pParentSvc = tlsMimGetParentSvc(pSvc);
            if (!IS_VALID_ISID(pEntry->u.Epipe.TlsChild.Isid) ||
                !IS_VALID_ISID_INDEX(pEntry->u.Epipe.TlsChild.IsidIndex) ||
                !pParentSvc) {
                pEntry->u.Epipe.TlsChild.Isid = TLS_INVALID_ISID;
                pEntry->u.Epipe.TlsChild.IsidIndex = TLS_INVALID_ISID_INDEX;
                pEntry->u.Epipe.TlsChild.ParentTlsInstanceId = 0;
                pEntry->u.Epipe.ParentTls.DestMacAddr = NullMacAddr;
                pEntry->u.Epipe.ParentTls.MimDestIdx = TLSFDB_INVALID_MIM_IDX;
            } else {
                pEntry->u.Epipe.TlsChild.ParentTlsInstanceId = IS_TLS(pParentSvc) ? pParentSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;
                pEntry->u.Epipe.ParentTls.DestMacAddr = EPIPE_PBB_TUNNEL_INFO(pSvc)->OperDestMac;
                pEntry->u.Epipe.ParentTls.MimDestIdx = EPIPE_PBB_TUNNEL_INFO(pSvc)->pMimEntry->DestIdx;
            }
            if (pSvc->AdminStatus == VAL_svcAdminStatus_up)
                pEntry->u.Epipe.AdminEnabled = TRUE;
            else
                pEntry->u.Epipe.AdminEnabled = FALSE;
            pEntry->u.Epipe.DoPerSvcHashing = pSvc->u.EpipeInfo->DoPerSvcHashing;
            pEntry->u.Epipe.PbbEpipeCpePing = pSvc->u.EpipeInfo->CpePingExtraction;
            break;

        case ST_APIPE:
            pEntry->Type = SVC_TYPE_APIPE;
            switch (pSvc->VllType) {
                case SMVC_ATMSDU:
                    pEntry->u.Apipe.PipeServiceType = PIPE_SVC_TYPE_ATM_SDU;
                    break;
                case SMVC_ATMVCC:
                    pEntry->u.Apipe.PipeServiceType = PIPE_SVC_TYPE_ATM_VCC;
                    break;   
                case SMVC_ATMVPC:
                    pEntry->u.Apipe.PipeServiceType = PIPE_SVC_TYPE_ATM_VPC;
                    break;                     
                case SMVC_ATMCELL:
                    pEntry->u.Apipe.PipeServiceType = PIPE_SVC_TYPE_ATM_CELL;
                    break;                     
                case SMVC_NONE:
                case SMVC_UNDEF:
                case SMVC_ETHER:
                case SMVC_VLAN:
                case SMVC_MIRROR:
                case SMVC_FRDLCI:
                case SMVC_IPIPE:
                case SMVC_SATOPE1:
                case SMVC_SATOPT1:
                case SMVC_SATOPE3:
                case SMVC_SATOPT3:
                case SMVC_CESOPSN:
                case SMVC_CESOPSNCAS:
                default:
                    break;
            }
            switch (pSvc->u.ApipeInfo->Interworking) {
                case SMAPIPEINTERWORKING_NONE:
                    pEntry->u.Apipe.Interworking = APIPE_INTERWORKING_NONE;
                    break;
                case SMAPIPEINTERWORKING_FRF5:
                    pEntry->u.Apipe.Interworking = APIPE_INTERWORKING_FRF_5;                
                    break;
                case SMAPIPEINTERWORKING_FRF82TRANSLATE:
                    pEntry->u.Apipe.Interworking = APIPE_INTERWORKING_FRF_8_2_TRANSLATE;                
                    break;
                default:
                    break;
            }
            if (pSvc->AdminStatus == VAL_svcAdminStatus_up)
                pEntry->u.Apipe.AdminEnabled = TRUE;
            else
                pEntry->u.Apipe.AdminEnabled = FALSE;
            break;
    
        case ST_FPIPE:
            pEntry->Type = SVC_TYPE_FPIPE;
            /* always FR-DLCI for now */
            pEntry->u.Fpipe.PipeServiceType = PIPE_SVC_TYPE_FR_DLCI;
            break;
            
        case ST_IPIPE:
            pEntry->Type = SVC_TYPE_IPIPE;
            pEntry->u.Ipipe.PipeServiceType = PIPE_SVC_TYPE_IPIPE;
            pEntry->u.Ipipe.DpiReachableMask = SVC_GET_DPI_DIVERT_MASK(pSvc);
            pEntry->u.Ipipe.Ipv6Enabled = pSvc->u.IpipeInfo->Ipv6CeDiscovery;
            break;

        case ST_CPIPE:
            pEntry->Type = SVC_TYPE_CPIPE;
            switch (pSvc->VllType) {
                case SMVC_SATOPE1:
                    pEntry->u.Cpipe.PipeServiceType = PIPE_SVC_TYPE_SATOPE1;
                    break;
                case SMVC_SATOPT1:
                    pEntry->u.Cpipe.PipeServiceType = PIPE_SVC_TYPE_SATOPT1;
                    break;
                case SMVC_SATOPE3:
                    pEntry->u.Cpipe.PipeServiceType = PIPE_SVC_TYPE_SATOPE3;
                    break;
                case SMVC_SATOPT3:
                    pEntry->u.Cpipe.PipeServiceType = PIPE_SVC_TYPE_SATOPT3;
                    break;
                case SMVC_CESOPSN:
                    pEntry->u.Cpipe.PipeServiceType = PIPE_SVC_TYPE_CESOPSN;
                    break;
                case SMVC_CESOPSNCAS:
                    pEntry->u.Cpipe.PipeServiceType = PIPE_SVC_TYPE_CESOPSNCAS;
                    break;
                case SMVC_NONE:
                case SMVC_UNDEF:
                case SMVC_ETHER:
                case SMVC_VLAN:
                case SMVC_MIRROR:
                case SMVC_ATMSDU:
                case SMVC_ATMCELL:
                case SMVC_ATMVCC:
                case SMVC_ATMVPC:
                case SMVC_FRDLCI:
                case SMVC_IPIPE:
                default:
                    break;
            }
            if (pSvc->AdminStatus == VAL_svcAdminStatus_up)
                pEntry->u.Cpipe.AdminEnabled = TRUE;
            else
                pEntry->u.Cpipe.AdminEnabled = FALSE;
            break;

        case ST_VPLS_LITE:
            pEntry->Type = SVC_TYPE_PW_PORT;
            break;
            
        case ST_TLS:
            pEntry->Type = SVC_TYPE_TLS;           
            
            if ((stpGetTlsStpAdminStat(pSvc->u.Tls->SvcBrig) == VAL_svcTlsStpAdminStatus_enabled) &&
                 stpTopologyChange(pSvc->u.Tls->SvcBrig))
                pEntry->u.Tls.LocalMacAgeTime = stpGetFwdDelay(pSvc->u.Tls->SvcBrig);
            else            
                pEntry->u.Tls.LocalMacAgeTime = pSvc->u.Tls->MacAge[TlsFdbMacAge_Local].AgeTime;
            if (stpGetTlsStpAdminStat(pSvc->u.Tls->SvcBrig) == VAL_svcTlsStpAdminStatus_enabled) { 
                pEntry->u.Tls.PassBpduToCpm = TRUE;
                pEntry->u.Tls.PassL2ptBpduToCpm = FALSE;
            } else {
                pEntry->u.Tls.PassBpduToCpm = pSvc->u.Tls->L2ptEnable;
                pEntry->u.Tls.PassL2ptBpduToCpm = pSvc->u.Tls->L2ptEnable;
            }
            pEntry->u.Tls.PassMmrpToCpm = mrpIsMrpEnabled(pSvc);
            pEntry->u.Tls.MmrpEarlyDetection = mrpIsMmrpFloodTimeEnabled(pSvc);
            pEntry->u.Tls.PassMvrpToCpm = mrpIsMrpEnabled(pSvc);

            /* 
             * B-Vpls:IOM should use the VPLS flood list rather than then 
             *        MMRP/SPB flood list 
             * I-Vpls:IOM should use MFib rather than then B-Vpls Flood List
             */
            pEntry->u.Tls.IsidUseVplsFloodList = svcUseIsidFloodList(pSvc) ? FALSE : TRUE;

            /* Update IomParentMcastId only if req is sent to all IOMs */
            if (IS_IVPLS_SVC(pSvc)) {
                tTlsIVplsObj *pIVplsObj = pSvc->u.Tls->Pbb.pIVplsObj;
                pEntry->u.Tls.IsidPrunedMId = IsCardOnline ? pIVplsObj->IomParentMcastId : pIVplsObj->ParentMcastId;
                if (pRetParams) {
                    if (pEntry->u.Tls.IsidPrunedMId != pIVplsObj->IomParentMcastId)
                        pRetParams->IomParentMcastIdChgd = TRUE;
                    
                    pRetParams->OldIomParentMcastId = pIVplsObj->IomParentMcastId;
                }
            
                pIVplsObj->IomParentMcastId = pEntry->u.Tls.IsidPrunedMId;
                
            } else {
                pEntry->u.Tls.IsidPrunedMId = 0; /* N/A for non I-VPLS Svcs */
            }
            
            pEntry->u.Tls.LearningDisabled = !tlsFdbDoMacLearning(pSvc);

            pEntry->u.Tls.AgeingDisabled = !tlsFdbDoMacAgeing(pSvc);

            pEntry->u.Tls.DiscardUnknownDest = tlsFdbDoDiscardUnknownDest(pSvc);

            pEntry->u.Tls.IgmpSnoopingEnabled = snpgIsSnoopingEnabled(IGMP_MODE, pSvc->u.Tls->IgmpSnpgBridge) || subhtIsTrackingEnabled(pSvc->Id);
            pEntry->u.Tls.MldSnoopingEnabled  = snpgIsSnoopingEnabled(MLD_MODE, pSvc->u.Tls->IgmpSnpgBridge);

            pimSnpg = pSvc->pimSnpgOperState;
            pEntry->u.Tls.PimHelloSnoopingEnabled = pimSnpg == SVC_PIM_SNPG_STATE_DOWN ? FALSE : TRUE;
            pEntry->u.Tls.PimJoinPruneCopyToCpm   = pimSnpg == SVC_PIM_SNPG_STATE_SNOOP ? TRUE : FALSE;
            pEntry->u.Tls.PimJoinPruneFwdToCpm    = pimSnpg == SVC_PIM_SNPG_STATE_PROXY ? TRUE : FALSE;
            pEntry->u.Tls.PimFwdEnabled           = pSvc->pimFwdEnabled;

            pEntry->u.Tls.ArpSnoopingEnabled = (pSvc->u.Tls->TlsArpSnoopingRefCnt ? TRUE : FALSE);
            pEntry->u.Tls.TlsInstanceId = pSvc->u.Tls->TlsInstanceId;

            if (pSvc->u.Tls->MacRelearnOnly == VAL_svcTlsMacRelearnOnly_true ||
                pSvc->u.Tls->MacRelearnOnlyMIM == VAL_svcTlsMacRelearnOnly_true)
                pEntry->u.Tls.RelearnOnly = TRUE;
            else
                pEntry->u.Tls.RelearnOnly = FALSE;
            
            pEntry->u.Tls.IsBvpls = IS_BVPLS_SVC(pSvc) ? TRUE : FALSE;
            if (pEntry->u.Tls.IsBvpls) {
                tIomSvcBvplsEntry *pBvpls = &pEntry->u.Tls.u.Bvpls;
                tlsMimGetBVplsOperLocalSourceMac(pSvc, &pBvpls->LocalMac);
                pBvpls->DoFateShareLookup = pSvc->u.Tls->Pbb.pBVplsObj->DualHomingEnabled;
            }
            
            pEntry->u.Tls.DoPerSvcHashing = pSvc->u.Tls->DoPerSvcHashing;
            
            pEntry->u.Tls.IsIvpls = IS_IVPLS_SVC(pSvc) ? TRUE : FALSE;
            if (pEntry->u.Tls.IsIvpls) {
                tIomSvcIvplsEntry *pIvpls = &pEntry->u.Tls.u.Ivpls;
                
                pParentSvc = tlsMimGetParentSvc(pSvc);
                pIvpls->TlsChild.ParentTlsInstanceId = (pParentSvc && IS_TLS(pParentSvc)) ? pParentSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;
                pIvpls->TlsChild.Isid = tlsMimGetOperIsid(pSvc);
                pIvpls->TlsChild.IsidIndex = tlsMimGetOperIsidIndex(pSvc);
                // All or nothing for the IOMs for parenting and ISID
                if ((pIvpls->TlsChild.ParentTlsInstanceId == SMGR_NULL_TLS_INST_ID) ||
                    (pIvpls->TlsChild.Isid == TLS_INVALID_ISID) ||
                    (pIvpls->TlsChild.IsidIndex == TLS_INVALID_ISID_INDEX)) {
                    pIvpls->TlsChild.ParentTlsInstanceId = SMGR_NULL_TLS_INST_ID;
                    pIvpls->TlsChild.Isid = TLS_INVALID_ISID;
                    pIvpls->TlsChild.IsidIndex = SMGR_NULL_TLS_INST_ID;                    
                }               
                pIvpls->TlsChild.ForceQTagFwding = tlsMimGetForceQTagFwd(pSvc);
                
                pIvpls->PipLinkBlocked = (pEntry->Enabled) ? stpIsPipBlocked(pSvc->u.Tls->SvcBrig) : TRUE;
            }
            
            pEntry->u.Tls.DpiReachableMask = SVC_GET_DPI_DIVERT_MASK(pSvc);
            pEntry->u.Tls.Dot1agMepIngressLevel = svcTlsGetDot1agIngressMepLevel(pSvc);
            pEntry->u.Tls.Dot1agIngressSubRingLevel = svcTlsGetDot1agIngressSubRingLevel(pSvc);
            pEntry->u.Tls.Dot1agVmepInHw = svcTlsGetDot1agVmepFwdInHw(pSvc) && (svcTlsGetDot1agIngressMepLevel(pSvc) != SMGR_DOT1AG_LEVEL_DISABLED);
            pEntry->u.Tls.SubnetLength = pSvc->u.Tls->SubnetLength;    
            pEntry->u.Tls.RvplsInterfaceIndex = pSvc->u.Tls->IesIfRec ? pSvc->u.Tls->IesIfRec->PipIfInstanceId : 0;
            pEntry->u.Tls.IsRoutedVpls = pSvc->u.Tls->IsRoutedVpls;
            pEntry->u.Tls.RvplsEgrReclassPolicyId = pSvc->u.Tls->IesIfRec && pSvc->u.Tls->IesIfRec->EgrQosReclassifyRec ? pSvc->u.Tls->IesIfRec->EgrQosReclassifyRec->Id : 0;
            if (svcIsMgdBySPBM(pSvc)) {
                pEntry->u.Tls.UsePrunedMeshMcList = TRUE;
                pEntry->u.Tls.UsePrunedSpokeMcList = TRUE;
                pEntry->u.Tls.UsePrunedSapMcList = TRUE;
                pEntry->u.Tls.SpbMgd = TRUE;
            } else {
                pEntry->u.Tls.UsePrunedMeshMcList = FALSE;
                pEntry->u.Tls.UsePrunedSpokeMcList = FALSE;
                pEntry->u.Tls.UsePrunedSapMcList = pSvc->u.Tls->pCtrldTlsInfo ? pSvc->u.Tls->pCtrldTlsInfo->PrunedSapMcListInUse : FALSE;
                pEntry->u.Tls.SpbMgd = FALSE;
            }
            pEntry->u.Tls.IgnoreMvrpDisableSap = (pSvc->u.Tls->pCtrldTlsInfo && pEntry->u.Tls.UsePrunedSapMcList) ? FALSE : TRUE; /* Don't ignore Mvrp's DisableSap when PrunedSapMcList is in Use for MVRP */
            pEntry->u.Tls.FastFloodReqBitmap = pSvc->u.Tls->TempFlood.ReqBitmap;
            break;
            
        case ST_VPRN:
            pEntry->Type = SVC_TYPE_VPRN;
            // vprn type : regular/hub/spoke/wholesale-retail
            switch (pSvc->u.VprnInfo->pipVprnType) {
            case VAL_vRtrVprnType_regular:
                pEntry->u.Vprn.Type = VPRN_SVC_TYPE_REGULAR;
                break;
            case VAL_vRtrVprnType_hub:
                pEntry->u.Vprn.Type = VPRN_SVC_TYPE_HUB;
                break;
            case VAL_vRtrVprnType_spoke:
                pEntry->u.Vprn.Type = VPRN_SVC_TYPE_SPOKE;
                break;
            case VAL_vRtrVprnType_subscriberSplitHorizon:
                pEntry->u.Vprn.Type = VPRN_SVC_TYPE_SUB_SPLIT_HORIZON;
                break;
            default:
                pEntry->u.Vprn.Type = VPRN_SVC_TYPE_REGULAR;
            }
            pEntry->u.Vprn.VrId = pSvc->VRtrId;
            pEntry->u.Vprn.LimitedVrId = pSvc->u.VprnInfo->pipLimitedVrId; // zero ==> unused, used in retail, hub and spoke vprns
            pEntry->u.Vprn.LeakToGRT = pSvc->u.VprnInfo->pipGrtLeakingEnabled; // 0 -- disable GRT leaking; 1 enable GRT leaking
            pEntry->u.Vprn.InsertEntropyLabel = pSvc->u.VprnInfo->HashLabel;
            pEntry->u.Vprn.DpiReachableMask = SVC_GET_DPI_DIVERT_MASK(pSvc);
            break;
            
        case ST_IES:
            pEntry->Type = SVC_TYPE_IES;
            pEntry->u.Ies.DpiReachableMask = SVC_GET_DPI_DIVERT_MASK(pSvc);
            break;

        case ST_MIRROR:
            pEntry->Type = SVC_TYPE_MIRROR;

            pMirror = pSvc->u.MirrorInfo;
            pDestL3EncapGwRec = pMirror->pDestL3EncapGwRec;

            pEntry->u.Mirror.MirrorServiceType = mirrorDestGetIOMEncapsulation(pMirror->Encap);
            pEntry->u.Mirror.Fc = pMirror->DestFC;
            pEntry->u.Mirror.SliceSize = pMirror->SliceSize;
            pEntry->u.Mirror.EnableRemoteSource = pMirror->RemoteSource;
            pEntry->u.Mirror.MirrorServiceIndex = pMirror->InstanceId;
            pEntry->u.Mirror.ControlWordType = 
                (pMirror->Encap == VAL_tMirrorDestinationEncapsulation_atmSdu ) ? 
                IOM_CONTROL_WORD_ATM : IOM_CONTROL_WORD_NONE;
            pEntry->u.Mirror.InsertPortId = pMirror->EnablePortId;
            pEntry->u.Mirror.DestIsaAaGrp = 
                IS_PORTID_ISA_AA_GRP(pMirror->isaAaGrpDestPortId);
            pEntry->u.Mirror.DestIsaAaPortId = 
                isaAaGroupGetPhysFromVirtPortId(pMirror->isaAaGrpDestPortId);
                
            pEntry->u.Mirror.EncapRouterInstance
                = (pMirror->DestL3EncapServId == NULL_SERV_ID)? 
                  DEF_VR_INSTANCE : smgrGetVRtrId(pMirror->DestL3EncapServId);
            pEntry->u.Mirror.EncapDirectionBit = pMirror->DestL3EncapDirBit;
            switch (pMirror->DestL3EncapHdrType) {
            case SM_DEST_ENCAP_IPUDPSHIM:
                pEntry->u.Mirror.EncapHeaderType = MIRROR_ENCAP_HDR_TYPE_IP_UDP_SHIM;
                if (pDestL3EncapGwRec) {
                    /* Only IPv4 supported for these addrs */
                    TIM_NET_ADDR_GET_V4(pEntry->u.Mirror.u.EncapIpAddrUdp.SrcIPAddr, &pDestL3EncapGwRec->SrcAddr);
                    TIM_NET_ADDR_GET_V4(pEntry->u.Mirror.u.EncapIpAddrUdp.DestIPAddr, &pDestL3EncapGwRec->DstAddr);
                    pEntry->u.Mirror.u.EncapIpAddrUdp.SrcUDPPort = pDestL3EncapGwRec->SrcPort;
                    pEntry->u.Mirror.u.EncapIpAddrUdp.DestUDPPort = pDestL3EncapGwRec->DstPort;
                }
                break;
            case SM_DEST_ENCAP_IPGRE:
                pEntry->u.Mirror.EncapHeaderType = MIRROR_ENCAP_HDR_TYPE_IP_GRE;
                if (pDestL3EncapGwRec) {
                    /* Only IPv4 supported for these addrs */
                    TIM_NET_ADDR_GET_V4(pEntry->u.Mirror.u.EncapIpAddr.SrcIPAddr, &pDestL3EncapGwRec->SrcAddr);
                    TIM_NET_ADDR_GET_V4(pEntry->u.Mirror.u.EncapIpAddr.DestIPAddr, &pDestL3EncapGwRec->DstAddr);
                }
                break;
            default:
                /* Do nothing */
                break;
            }
            break;
        
        case ST_UNDEF:
        case ST_SIZE:
        default:;
    }
    
    pEntry->handle.Cpm = pCallbackEvent;
}

PRIVATE void smgrInitSvcVirtPortStateEntry(tIomSvcPipEntry *pEntry, tSvcRec *pSvc)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SvcId = pSvc->Id;

    if (IS_IVPLS_SVC(pSvc)) {
        pEntry->PipLinkBlocked =
            (pSvc->OperStatus == VAL_svcOperStatus_up) ? stpIsPipBlocked(pSvc->u.Tls->SvcBrig) : TRUE;
    } else {
        pEntry->PipLinkBlocked = FALSE;
    }
}

PRIVATE void smgrInitSvcTlsFloodUpdateEntry(tIomSvcTlsFloodEntry *pEntry, tSvcRec *pSvc)
{
    if (!IS_TLS(pSvc) || !pSvc->u.Tls) return;
                           
    ZERO_STRUCT_PTR(pEntry);
    
    pEntry->SvcId = pSvc->Id;

    if (svcIsMgdBySPBM(pSvc)) {
        pEntry->UsePrunedMeshMcList = TRUE;
        pEntry->UsePrunedSpokeMcList = TRUE;
        pEntry->UsePrunedSapMcList = TRUE;
    } else {
        pEntry->UsePrunedMeshMcList = FALSE;
        pEntry->UsePrunedSpokeMcList = FALSE;
        pEntry->UsePrunedSapMcList = pSvc->u.Tls->pCtrldTlsInfo ? pSvc->u.Tls->pCtrldTlsInfo->PrunedSapMcListInUse : FALSE;
    }
    pEntry->IgnoreMvrpDisableSap = (pSvc->u.Tls->pCtrldTlsInfo && pEntry->UsePrunedSapMcList) ? FALSE : TRUE; /* Don't ignore Mvrp's DisableSap when PrunedSapMcList is in Use for MVRP */
    
    pEntry->FastFloodReqBitmap = pSvc->u.Tls->TempFlood.ReqBitmap;
    
    /* When Temp Flooding is active, force an update.
       Note: At present, for a given service, either STP or MVRP (not
       both) can request fast flood using this mech. So, we can safely
       assume that requestor who needs to force an update is same as
       the active requestor. */
    pEntry->ForceFastFloodReqBitmap = (pSvc->u.Tls->TempFlood.Active)? pSvc->u.Tls->TempFlood.ReqBitmap : 0x0;
}

PRIVATE void smgrInitSapAddReqEntry(tIomSapEntry *pEntry, tSapRec *pSap,
                                    eSapSdpState IomFwdState,
                                    struct SMEventMsg *pCallbackEvent)
{
    tSvcRec *pSvc = pSap->SvcRec;
    tMssRec *pMss;
    tTlsShgRec *pShg;
    tTlsEmgRec *pEmg;
    tPortEncapType encapType;
    tInt32 tmpAggRateLimit = 0;
    int i; 
    tEthRingSapInfo *pEthRingSapInfo; 
    tPwPortRec *pwPort = NULL;
      
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SapId = pSap->SapId;
    pEntry->SvcId = pSvc->Id;
    pEntry->GlobalInstanceId = pSap->InstanceId;
    pEntry->PortEncap = (pSap->PortRec) ? pSap->PortRec->EncapType : PORT_ENCAP_NULL;
    
    if (IS_PORTID_ETH_TUNNEL(pSap->SapId.PortId))
        memcpy(pEntry->EthTunEncapValue, pSap->pEthTunSapInfo->EncapValue,
               sizeof(pEntry->EthTunEncapValue));
            
    pEthRingSapInfo = sapGetEthRingInfo(pSap);
    if (pEthRingSapInfo != NULL) {     
        pEntry->Config.u.Tls.RingApsPathId.Ring = pEthRingSapInfo->EthRingId; 
        pEntry->Config.u.Tls.RingApsPathId.Path =
            (pEthRingSapInfo->EthRingPathId == VAL_tmnxEthRingPathIndex_pathA)?
            RING_APS_PATH_A : RING_APS_PATH_B; 
        pEntry->Config.u.Tls.RingApsCtlSap = pEthRingSapInfo->EthRingIsControl;
    }
    
    pEntry->Config.SapSdpState = IomFwdState;
    
    pEntry->AdminEnabled = (pSap->AdminStatus == VAL_sapAdminStatus_up)? 1 : 0;
    pEntry->MakeNonLocal = !IS_SAP_PRESENT(pSap);
    pEntry->FwdUnknownSubscribersToSap =  pSap->FwdUnknownSubscribersToSap;
    if (pSap->SubType == SAP_TYPE_MSAP)
        pEntry->IsAutoSap = TRUE;
    else
        pEntry->IsAutoSap = FALSE;

    // PW Resiliency initializations
    if (IS_SAP_EP_SUPPORTED(pSvc)) {
        pEntry->Config.SapSdpRedCfg.ActiveTransmit = pSap->SapEpObj->TxActive;
        pEntry->Config.SapSdpRedCfg.EndpointGroup = pSap->SapEpObj->EpRec->EpId - 1;
        pEntry->Config.SapSdpRedCfg.EndpointIsICB = FALSE;
        SVCMGR_EVENT(IOM_CALL, "sap=%s inst=%d state=%d ActiveTx=%d epg=%d",
                     smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                     pEntry->GlobalInstanceId, pEntry->Config.SapSdpState,
                     pEntry->Config.SapSdpRedCfg.ActiveTransmit, 
                     pEntry->Config.SapSdpRedCfg.EndpointGroup);
    } else {
        pEntry->Config.SapSdpRedCfg.ActiveTransmit = TRUE;
        pEntry->Config.SapSdpRedCfg.EndpointGroup = INVALID_ENDPOINT_GROUP_ID;
        pEntry->Config.SapSdpRedCfg.EndpointIsICB = FALSE;
    } 

    switch (pSvc->Type) {
        case ST_EPIPE:
        case ST_P3PIPE:
            pEntry->SvcType = SVC_TYPE_EPIPE;
            if (pSvc->Type == ST_EPIPE) {
                pEntry->Config.u.Pipe.ForceIngressDest = pSap->IgnoreSapOperDownForSvc;
            }
            break;
        
        case ST_APIPE:
            {
                tEndpointRec *pMateEp;
                tSdpBndRec *pSdpBnd = NULL;
                tEpId EpId = (pSap->SapEpObj && pSap->SapEpObj->EpRec) ? 
                    pSap->SapEpObj->EpRec->EpId : INVALID_EP_ID;
                            
                pMateEp = pwbFindMateEpRec(pSvc, EpId);
                if (pMateEp) {
                    if (epNumSpokes(pMateEp) > 1) {
                        /* If there is more than one binding, always try to use the active Tx binding */
                        pSdpBnd = pwbFindEpTxActiveSdp(pMateEp);
                    } else {
                        /* Just get the one binding and use it */
                        pSdpBnd = pwbFindEpFirstSdp(pSap->SvcRec, pMateEp);
                    }
                }
                
                pEntry->SvcType = SVC_TYPE_APIPE;
                if ((pSdpBnd != NULL) && (SDPBND_APIPE_INFO(pSdpBnd))) {
                    pEntry->Config.u.Pipe.u.Apipe.CellCount = pSdpBnd->SvcTypeInfo.ApipeSdpBndRec->OperCellCount;
                    pEntry->Config.u.Pipe.u.Apipe.MaxDelay = pSdpBnd->SvcTypeInfo.ApipeSdpBndRec->MaxDelay;
                    pEntry->Config.u.Pipe.u.Apipe.ClpAware = pSdpBnd->SvcTypeInfo.ApipeSdpBndRec->ClpAware;
                    pEntry->Config.u.Pipe.u.Apipe.Aal5FrAware = pSdpBnd->SvcTypeInfo.ApipeSdpBndRec->Aal5FrAware;
                } else {
                    pEntry->Config.u.Pipe.u.Apipe.CellCount = LEAF_sdpBindApipeAdminConcatCellCount;
                    pEntry->Config.u.Pipe.u.Apipe.MaxDelay = DEFVAL_sdpBindApipeConcatMaxDelay;
                    pEntry->Config.u.Pipe.u.Apipe.ClpAware = MIB_TRUTHVAL_TO_BOOLEAN(DEFVAL_sdpBindApipeConcatCellClp);
                    pEntry->Config.u.Pipe.u.Apipe.Aal5FrAware = MIB_TRUTHVAL_TO_BOOLEAN(DEFVAL_sdpBindApipeConcatCellAal5Fr);
                }
            }
            break;
            
        case ST_FPIPE:
            pEntry->SvcType = SVC_TYPE_FPIPE;
            break;

        case ST_IPIPE:
            pEntry->SvcType = SVC_TYPE_IPIPE;
            
            if (ipipeIsPortRequireArp (pSap)) {
                memcpy (&pEntry->L2Config.u.IpipeMac.OurMacAddr, 
                        &pSap->SapIpipe->u.sapIpipeMacAddress, 
                        sizeof (tMacAddr));
                if (pSap->SapIpipe->sapIpipeArpEntry.isValid) {
                    memcpy (&pEntry->L2Config.u.IpipeMac.TheirIpv4MacAddr, 
                            &(pSap->SapIpipe->sapIpipeArpEntry.ipipeTheirMacAddress), 
                            sizeof (tMacAddr));
                } else if (pSap->SapIpipe->sapIpipeArpEntry.isBroadcast) {
                    memcpy (&pEntry->L2Config.u.IpipeMac.TheirIpv4MacAddr,
                            &BcastMacAddr,
                            sizeof (tMacAddr));
                } else {
                    memset (&pEntry->L2Config.u.IpipeMac.TheirIpv4MacAddr, 
                            0, 
                            sizeof (tMacAddr));
                }
                if (pSap->SapIpipe->sapIpipeIpv6ArpEntry.isValid) {
                     memcpy (&pEntry->L2Config.u.IpipeMac.TheirIpv6MacAddr, 
                            &(pSap->SapIpipe->sapIpipeIpv6ArpEntry.ipipeTheirMacAddress), 
                            sizeof (tMacAddr));
                } else {
                    memset (&pEntry->L2Config.u.IpipeMac.TheirIpv6MacAddr, 
                            0,
                            sizeof (tMacAddr));
                }
            } else {
                smgrGetPortEncapType (pSap->PortRec, &encapType);
                if (encapType == PORT_ENCAP_ATM) {
                    pEntry->L2Config.u.Atm.u.vc.encap =
                        (eATMAal5Encap) (pSap->SapIpipe->u.sapIpipeL2Encapsulation);
                }
                    
            }
            break;

        case ST_CPIPE:
            pEntry->SvcType = SVC_TYPE_CPIPE;
            break;

        case ST_TLS:
            pEntry->SvcType = SVC_TYPE_TLS;
            if ((pShg = sapGetShg(pSap)) != NULL) {
                pEntry->Config.u.Tls.TlsSplitHorizonGroup = pShg->InstanceId;
                pEntry->Config.u.Tls.IsResidential = pShg->IsResidential;
                if (pShg->RestProtSrcMacEnabled)
                    pEntry->Config.u.Tls.RestrictProtectedSrc = TRUE;
                if (pShg->RestUnprotDstMacEnabled)
                    pEntry->Config.u.Tls.RestrictUnprotectedDest = TRUE;
            }
            pEntry->Config.u.Tls.LearningDisabled = !pSap->SapTls->MacLearningEnabled;
            pEntry->Config.u.Tls.AgeingDisabled = !pSap->SapTls->MacAgeingEnabled;
            pEntry->Config.u.Tls.DiscardUnknownSource = tlsSapDoDiscardUnknownSource(pSap);

            pEntry->Config.u.Tls.MacFdbFull = pSap->SapTls->MacRelearnOnly;
                       
            pEntry->Config.u.Tls.DhcpSnoopingEnabled =
                (dhsIsSnoopingEnabledOnSap(pSap) ||
                 dhs6IsSnoopingEnabledOnSap(pSap)) ? TRUE : FALSE;
            if (pSap->IgmpSnpgPort && 
                snpgPortIsMvrEnabled(IGMP_MODE, pSap->IgmpSnpgPort))
                pEntry->Config.u.Tls.IgmpMvrEnabled = TRUE;
            else
                pEntry->Config.u.Tls.IgmpMvrEnabled = FALSE;
            if (pSap->IgmpSnpgPort && 
                snpgPortIsMvrEnabled(MLD_MODE, pSap->IgmpSnpgPort))
                pEntry->Config.u.Tls.MldMvrEnabled = TRUE; 
            else
                pEntry->Config.u.Tls.MldMvrEnabled = FALSE;
            if (pSap->SapTls->C.RestProtSrcMacEnabled)
                pEntry->Config.u.Tls.RestrictProtectedSrc = TRUE;
            if (pSap->SapTls->RestUnprotDstMacEnabled)
                pEntry->Config.u.Tls.RestrictUnprotectedDest = TRUE;
            if ((pEmg = pSap->SapTls->EmgRec) != NULL)
                pEntry->Config.u.Tls.EgressMulticastGroup = pEmg->InstanceId;
            if ((pSap->SapSubMgmt != NULL) &&
                (pSap->SapSubMgmt->macDaHashing == VAL_sapSubMgmtMacDaHashing_true))
                pEntry->Config.u.Tls.SubscriberLagHashMac = TRUE;
            else
                pEntry->Config.u.Tls.SubscriberLagHashMac = FALSE;

            if (pSap->SubType == SAP_TYPE_CAPTURE)
                pEntry->Config.u.Tls.IsCaptureSap = TRUE;
            else
                pEntry->Config.u.Tls.IsCaptureSap = FALSE;
            
            pEntry->Config.u.Tls.CaptureTriggerPppoe = pSap->SapTls->PppoeMsapTrigger;
            pEntry->Config.u.Tls.CaptureTriggerDhcp  = pSap->SapTls->DhcpMsapTrigger || 
                                                       pSap->SapTls->Dhcp6MsapTrigger;
            pEntry->Config.u.Tls.CaptureTriggerV6RouterSolicit = FALSE;

            /* Set vmda enabled flag for video sap */
            pEntry->Config.u.Tls.VmdaEnabled = (pSap->SubType == SAP_TYPE_VIDEO) ? TRUE : FALSE ;

            if (pSap->SapTls->MvrpCtrld) {
                pEntry->Config.u.Tls.IsMcListPrunedEndpoint = pSap->SapTls->MvrpRegd ? TRUE : FALSE;
                pEntry->Config.u.Tls.MvrpDisableSap = pSap->SapTls->MvrpRegd ? FALSE : TRUE;
            } else {
                pEntry->Config.u.Tls.IsMcListPrunedEndpoint = svcIsTlsMvrpCtrld(pSap->SvcRec);
                pEntry->Config.u.Tls.MvrpDisableSap = FALSE;
            }
            if (svcIsMgdBySPBM(pSvc)) {
                pEntry->Config.u.Tls.IsMcListPrunedEndpoint = (tlsFdbGetSapSbindMcastDestRefCnt(pSap, NULL) != 0) ? TRUE : FALSE;
                /* Following indicates to IOM to do Ingress checks for traffic received on this sap */
                if (svcSPBMDoIngrChks(pSvc)) {
                    pEntry->Config.u.Tls.MacFdbFull = TRUE;
                    pEntry->Config.u.Tls.RestrictProtectedSrc = TRUE;
                }
            }
            pEntry->Config.u.Tls.SpbEndpoint = svcIsSpbCtrlSvc(pSvc); /* All saps in SpbCtrl Svc */
            break;
            
        case ST_VPRN:
            pEntry->SvcType = SVC_TYPE_VPRN;
            pEntry->Config.u.Ies_Vprn.IesIfIndex = pSap->IesIfRec->PipIfInstanceId;
            pEntry->Config.u.Ies_Vprn.IsIpipe = FALSE;
            pEntry->Config.u.Ies_Vprn.Ipv4FlowspecEnabled = pSap->IngressFlowspec == VAL_sapIngressFlowspec_true;
            pEntry->Config.u.Ies_Vprn.Ipv6FlowspecEnabled = pSap->IngressIPv6Flowspec == VAL_sapIngressIPv6Flowspec_true;
            break;
            
        case ST_IES:
            pEntry->SvcType = SVC_TYPE_IES;
            pEntry->Config.u.Ies_Vprn.IesIfIndex = pSap->IesIfRec->PipIfInstanceId;
            pEntry->Config.u.Ies_Vprn.IsIpipe = FALSE;
            pEntry->Config.u.Ies_Vprn.Ipv4FlowspecEnabled = pSap->IngressFlowspec == VAL_sapIngressFlowspec_true;
            pEntry->Config.u.Ies_Vprn.Ipv6FlowspecEnabled = pSap->IngressIPv6Flowspec == VAL_sapIngressIPv6Flowspec_true;
            break;

        case ST_MIRROR:
            pEntry->SvcType = SVC_TYPE_MIRROR;
            
            if (pSap->IpMirrorMacAddr) {
                /* For IP mirroring */
                pEntry->L2Config.u.IpipeMac.OurMacAddr = pSap->IpMirrorMacAddr->sa;
                pEntry->L2Config.u.IpipeMac.TheirIpv4MacAddr = pSap->IpMirrorMacAddr->da;
                pEntry->L2Config.u.IpipeMac.TheirIpv6MacAddr = pSap->IpMirrorMacAddr->da;
            } else {
                pEntry->L2Config.u.IpipeMac.OurMacAddr = NullMacAddr;
                pEntry->L2Config.u.IpipeMac.TheirIpv4MacAddr = NullMacAddr;
                pEntry->L2Config.u.IpipeMac.TheirIpv6MacAddr = NullMacAddr;
            }
            break;

        case ST_UNDEF:
        case ST_VPLS_LITE:
        case ST_SIZE:
        default:;
    }                

    if (pSap->pTransitIpPlcy) {
        pEntry->DpiTransitPlcyIdx = pSap->pTransitIpPlcy->plcyId.intId;
        pEntry->DpiTransitIpv6Len = pSap->pTransitIpPlcy->transitIPv6PrefixLength;
    } else if (pSap->pTransitPrefixPlcy) {
        pEntry->DpiTransitPlcyIdx = pSap->pTransitPrefixPlcy->plcyId.intId;
        pEntry->DpiTransitPlcyIdx |= DPI_SMGR_TRANSIT_POL_ID_PREFIX_TYPE;
        pEntry->DpiTransitIpv6Len = 0;
    } else {
        pEntry->DpiTransitPlcyIdx = INVALID_AA_TRANSIT_IP_POLICY_ID;
        pEntry->DpiTransitIpv6Len = 0;
    }
    
    if ((pSap->pAppProf) && (pSap->pAppProf->divert) && IS_VALID_DPI_DIVERT_INDEX(pSap->DpiEnabledIndex)) {
        pEntry->DpiDivertIndex = pSap->DpiEnabledIndex;
    } else {
        pEntry->DpiDivertIndex = NO_DPI_DIVERT_SYS_INDEX;
    }
    
    if (pSap->pAppProf) {
        pEntry->DpiReverseDirection = pSap->DpiReverseDirection;
    } else {
        pEntry->DpiReverseDirection = FALSE;
    }
    pEntry->DpiAarpIdx = pSap->aarpIntId;
    pEntry->DpiAarpRefType = pSap->aarpRefType;
    
    if ((pMss = pSap->MssRec) != NULL) {
        pEntry->SiteId = pMss->InstanceId;
        if (pMss->IngQosSchedPolicyRec)
            pEntry->IngressSchedulerPolicyId = pMss->IngQosSchedPolicyRec->InstanceId;
        if (pMss->EgrQosSchedPolicyRec)
            pEntry->EgressSchedulerPolicyId = pMss->EgrQosSchedPolicyRec->InstanceId;
    } else {
        if (pSap->IngQosSchedPolicyRecCur)
            pEntry->IngressSchedulerPolicyId = pSap->IngQosSchedPolicyRecCur->InstanceId;
        if (pSap->EgrQosSchedPolicyRecCur)
            pEntry->EgressSchedulerPolicyId = pSap->EgrQosSchedPolicyRecCur->InstanceId;
    }
    if (pSap->IngQosPolicerCtrlPolRec)
        pEntry->IngressArbiterPolicyId = pSap->IngQosPolicerCtrlPolRec->InstanceId;
    if (pSap->EgrQosPolicerCtrlPolRec)
        pEntry->EgressArbiterPolicyId = pSap->EgrQosPolicerCtrlPolRec->InstanceId;
    pEntry->IngressQosPolicyId = pSap->IngQosPolRecCur->Id;
    if (pSap->IngSharedQueuePolicyRec) {
        pEntry->SharedIngressPolicyId = pSap->IngSharedQueuePolicyRec->Request.PolicyId;
        if (USE_SHARED_MULTIPOINT_ING_QUEUES(pSap))
            pEntry->MultipointShared = TRUE;
        else 
            pEntry->MultipointShared = FALSE;
    }
    if (pSap->IngMatchQinQDot1PBits == VAL_sapIngressMatchQinQDot1PBits_default)
        pEntry->QinqDot1pPos = QINQ_DOT1P_POS_DEFAULT;
    else if (pSap->IngMatchQinQDot1PBits == VAL_sapIngressMatchQinQDot1PBits_top)
        pEntry->QinqDot1pPos = QINQ_DOT1P_POS_TOP;
    else
        pEntry->QinqDot1pPos = QINQ_DOT1P_POS_BOTTOM;
    if (pSap->EgrQinQMarkTopOnly == VAL_sapEgressQinQMarkTopOnly_true)
        pEntry->QinQMarkTopOnly = TRUE;
    pEntry->EgressQosPolicyId = pSap->EgrQosPolRecCur->Id;
    pEntry->Config.IngressMacFilterId = pSap->IngMacFilterIdCur;
    pEntry->Config.EgressMacFilterId = pSap->EgrMacFilterIdCur;
    pEntry->Config.IngressIpv4FilterId = pSap->IngIpFilterIdCur; // can be flowSpec filter
    pEntry->Config.IngressIpv6FilterId = pSap->IngIpv6FilterIdCur;
    pEntry->Config.EgressIpv4FilterId = pSap->EgrIpFilterIdCur;
    pEntry->Config.EgressIpv6FilterId = pSap->EgrIpv6FilterIdCur;
    pEntry->Config.IngressRedirectQGroup = pSap->IngQosFPQGrp;
    pEntry->Config.EgressRedirectQGroup  = pSap->EgrQosPortQGrp;
    pEntry->Config.IngressL2CflowdEnabled = pSap->L2CflowdEnabled;
    
    if (pSap->PortRec->Flags & PF_REP_LAG_QOS)
        pEntry->LagFullQosEverySapInstance = TRUE;
    else
        pEntry->LagFullQosEverySapInstance = FALSE;
    if (pSap->PortRec->Flags & PF_INCLUDEEGRHASHCFG)
        pEntry->LagIncludeEgrHashConfig = TRUE;
    else
        pEntry->LagIncludeEgrHashConfig = FALSE;
    if (pSap->PortRec->Flags & PF_ING_PERFP_QUEUING)
        pEntry->LagPerFPIngressQueuing = TRUE;
    else
        pEntry->LagPerFPIngressQueuing = FALSE;
    if (pSap->PortRec->Flags & PF_EGR_PERFP_QUEUING)
        pEntry->LagPerFPEgressQueuing = TRUE;
    else
        pEntry->LagPerFPEgressQueuing = FALSE;

    /*Lag Profile information*/
    pEntry->LagProfileIndexPair.PrimaryLagProfile = pSap->lagLinkMapInfo.PrimProf;
    pEntry->LagProfileIndexPair.SecondaryLagProfile = pSap->lagLinkMapInfo.SecProf;

    /* Init the agg rate limit fields */
    if (!IS_SAP_HSMDA(pSap)) {
        pEntry->IngressQmdaAggRateLimit = -1; // obsolete
        pEntry->EgressQmdaAggRateLimit = -1; // unused for regular SAPs
    } else {
        pEntry->IngressQmdaAggRateLimit = -1; // obsolete
        pEntry->EgressAggRateLimit = -1;  // unused for HSMDA-v2 SAPs
    }
    /* Resolve the proper Egress Agg-Rate-Limit to send */
    if ((pSap->EgrAggRateLimit == MAX_sapEgressAggRateLimit_1) &&
        (pSap->AncpEgrAggRateLimit == 0)) {
        /* since the SAP agg-rate-limit is max, and there's no ANCP
         * override, we can't apply the IGMP Rate Delta.
         * So just send down the SAP agg-rate-limit as is.
         */
        if (!IS_SAP_HSMDA(pSap)) {
            pEntry->EgressAggRateLimit = pSap->EgrAggRateLimit;
        } else {
            pEntry->EgressQmdaAggRateLimit = pSap->EgrAggRateLimit;
        }
    } else {
        if (pSap->AncpEgrAggRateLimit != 0) {
            /* If ANCP is overriding the Egress agg-rate-limit, then
             * start with the lesser of the ANCP vs the SAP agg-rate-limit
             * and then factor in the IGMP Rate Delta
             */
            if ((pSap->EgrAggRateLimit == MAX_sapEgressAggRateLimit_1) ||
                (pSap->AncpEgrAggRateLimit < pSap->EgrAggRateLimit)) {
                tmpAggRateLimit = pSap->AncpEgrAggRateLimit + pSap->IgmpEgrAggRateLimitDelta;
            } else {
                tmpAggRateLimit = pSap->EgrAggRateLimit + pSap->IgmpEgrAggRateLimitDelta;
            }
        } else {
            /* (pSap->EgrAggRateLimit != MAX_sapEgressAggRateLimit_1)
             * must be true at this point
             */
            tmpAggRateLimit = (pSap->EgrAggRateLimit + pSap->IgmpEgrAggRateLimitDelta);
        }

        /* cap the value in the regular range for agg-rate-limit. */
        if (tmpAggRateLimit > MAX_sapEgressAggRateLimit_2) {
            tmpAggRateLimit = MAX_sapEgressAggRateLimit_2;
        } else if (tmpAggRateLimit < MIN_sapEgressAggRateLimit_2) {
            tmpAggRateLimit = MIN_sapEgressAggRateLimit_2;
        }
        if (!IS_SAP_HSMDA(pSap)) {
            pEntry->EgressAggRateLimit = tmpAggRateLimit;
        } else {
            pEntry->EgressQmdaAggRateLimit = tmpAggRateLimit;
        }
    }

    pEntry->EgressAggRateOnTheWire = pSap->EgrFrameBasedAccnt == VAL_sapEgressFrameBasedAccounting_true ? TRUE : FALSE;

    if ((IS_PORTID_PW_PORT(pSap->SapId.PortId)) &&
        ((pwPort = pwPortFindRecById(GET_PW_PORT_ID(pSap->SapId.PortId))) != NULL)) {
        pEntry->EgressQosVportId = pwPort->EgrVportId; 
    } else {
        pEntry->EgressQosVportId = 0;
    }

    if (pSap->EgrQmdaShaperOverride != NULL && !STRNULL(pSap->EgrQmdaShaperOverride)) {
        strcpyn(pEntry->SecondaryShaperName.Name,
                sizeof(pEntry->SecondaryShaperName),
                pSap->EgrQmdaShaperOverride);
    } else if (pwPort != NULL && pwPort->PwSapSecShaper != NULL) {
        strcpyn(pEntry->SecondaryShaperName.Name,
                sizeof(pEntry->SecondaryShaperName),
                pwPort->PwSapSecShaper);
    } else {
        ZERO_STRUCT(pEntry->SecondaryShaperName);
    }

    if (pSap->EgrHsmdaWrrPolicyOverride == NULL) {
        pEntry->OverrideEgressWrrPolicyId = 0;
    } else {
        pEntry->OverrideEgressWrrPolicyId = tHsmdaWrrPolicyEntry_id(pSap->EgrHsmdaWrrPolicyOverride);
    }

    pEntry->OverrideIngressPacketByteOffset = FALSE; // obsolete
    pEntry->IngressPacketByteOffset = 0;             // obsolete
    if (pSap->EgrQmdaPacketOffsetOverride != DEFVAL_sapEgressHsmdaPacketOffOverride) {
        pEntry->OverrideEgressPacketByteOffset = TRUE;
        pEntry->EgressPacketByteOffset = pSap->EgrQmdaPacketOffsetOverride;
    } else {
        pEntry->OverrideEgressPacketByteOffset = FALSE;
        pEntry->EgressPacketByteOffset = 0;
    }

    /* see if we need to fill in the L2 config */
    switch (pSap->PortRec->EncapType) {
        case PORT_ENCAP_ATM:
            if (pSap->SubType == SAP_TYPE_CAPTURE) {
                sapAtmCaptureRetrieveIOMInfo(pSap, &(pEntry->L2Config.u.AtmMsap));
            } else {
                atmEPRetrieveIOMInfo(pSap->VcHand, &(pEntry->L2Config.u.Atm));
            }
            break;
        case PORT_ENCAP_CEM:
            cemRetrieveIOMInfo(pSap, &(pEntry->L2Config.u.Cem));
            break;
        case PORT_ENCAP_FR:
            frRetrievePvcIOMInfo(pSap->VcHand, &(pEntry->L2Config.u.Fr));
            break;
        default:
            /* nothing to do for all other port encaps */
            break;            
    }

    pEntry->InsertDot1P = FALSE; // MAF: do we insert dot1p for default saps

    /* Subscriber management configuration */
    if (pSap->SrrpMessaging) {
        /* SRRP Saps must disable antispoofing to get SRRP msgs across */
        pEntry->SubscriberType = SUBSCRIBER_TYPE_NONE;
        pEntry->RoutedSubscriberSap = FALSE;
    } else {
        pEntry->SubscriberType = sapGetIomAntiSpoofingType(pSap);
        pEntry->RoutedSubscriberSap = (sapGetAntiSpoofingType(pSap) == VAL_sapAntiSpoofing_nextHopIpAndMacAddr);
    }
        
    if ((pSap->SapSubMgmt != NULL) &&
        (pSap->SapSubMgmt->adminStatus == VAL_sapSubMgmtAdminStatus_enabled))
        pEntry->SubscriberSap = TRUE;
    else
        pEntry->SubscriberSap = FALSE;
    if (IS_CONTROL_TERMINATED_SAP(pSap)) 
        pEntry->NoSapQueues = TRUE;
    else
        pEntry->NoSapQueues = FALSE;

    if (pSap->IngVlanTranslation == VAL_sapIngressVlanTranslation_none)
        pEntry->TranslationQtag = 0;
    else
        if (pSap->IngVlanTranslation == VAL_sapIngressVlanTranslation_copyOuter)
            pEntry->TranslationQtag = pSap->SapId.EncapValue.qinq.TopVlanId;
        else
            pEntry->TranslationQtag = pSap->IngVlanTranslationId;

    pEntry->DCpuProtPolicyId = pSap->DcpuProtPlcyId;

    pEntry->sapRec.Cpm = pSap;
    pEntry->handle.Cpm = pCallbackEvent;

    dot1agPointerLock();
    if (pSap->pDot1ag != NULL) {
        pEntry->Dot1agMipLevel =  pSap->pDot1ag->Dot1agMipLevel;
        /* We program the SAP with the higher of the SAP and facility MEP level */
        if (pSap->pDot1ag->Dot1agIngressMepLevel != SMGR_DOT1AG_LEVEL_DISABLED) {
            pEntry->Dot1agMepIngressLevel = pSap->pDot1ag->Dot1agIngressMepLevel;
        } else {
            pEntry->Dot1agMepIngressLevel = sapGetEthOamFacilityMepLevel(pSap);
        }
        pEntry->Dot1agMepEgressLevel = pSap->pDot1ag->Dot1agEgressMepLevel;
        memcpy(&pEntry->Dot1agPhysIngrLevel, &pSap->pDot1ag->Dot1agPhysIngrLevel, sizeof(pEntry->Dot1agPhysIngrLevel));
    } else {
        pEntry->Dot1agMipLevel = SMGR_DOT1AG_LEVEL_DISABLED;
        pEntry->Dot1agMepIngressLevel = sapGetEthOamFacilityMepLevel(pSap);
        pEntry->Dot1agMepEgressLevel = SMGR_DOT1AG_LEVEL_DISABLED;

        for (i = 0; i < sizeof(pEntry->Dot1agPhysIngrLevel); i++) {
            pEntry->Dot1agPhysIngrLevel[i] = SMGR_DOT1AG_LEVEL_DISABLED;
        }
    }
    dot1agPointerUnlock();

    pEntry->CfmVmepFilter = pSap->CfmVmepFilter;
}

PRIVATE void smgrInitSapStateEntry(tIomSapCompactEntry *pEntry, tSapRec *pSap,
                                   eSapSdpState IomSapFwdState,
                                   struct SMEventMsg *pCallbackEvent)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->GlobalInstanceId = pSap->InstanceId;

    pEntry->u.SapSdpState = IomSapFwdState;

    pEntry->sapRec.Cpm = pSap;
    pEntry->handle.Cpm = pCallbackEvent;
}

PRIVATE void smgrInitSapMcListPruneAndMvrpEntry(tIomSapCompactEntry *pEntry, tSapRec *pSap) {
    ZERO_STRUCT_PTR(pEntry);

    pEntry->GlobalInstanceId = pSap->InstanceId;

    if (pSap->SapTls->MvrpCtrld) {
        pEntry->u.McListPruneAndMvrp.IsMcListPrunedSap = pSap->SapTls->MvrpRegd ? TRUE : FALSE;
        pEntry->u.McListPruneAndMvrp.MvrpDisableSap = pSap->SapTls->MvrpRegd ? FALSE : TRUE;
    } else {
        pEntry->u.McListPruneAndMvrp.IsMcListPrunedSap = svcIsTlsMvrpCtrld(pSap->SvcRec);
        pEntry->u.McListPruneAndMvrp.MvrpDisableSap = FALSE;
    }
    if (svcIsMgdBySPBM(pSap->SvcRec)) {
        pEntry->u.McListPruneAndMvrp.IsMcListPrunedSap = (tlsFdbGetSapSbindMcastDestRefCnt(pSap, NULL) != 0) ? TRUE : FALSE;
    }
    pEntry->sapRec.Cpm = pSap;
    pEntry->handle.Cpm = NULL;
}

PRIVATE void smgrInitSapSwitchReqEntry(tIomSapSdpSwitchConfig *pEntry, tSapRec *pSap,
                                       tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs)
{
    tSvcRec *pSvc = pSap->SvcRec;
    
    ZERO_STRUCT_PTR(pEntry);

    // PW Resiliency initializations
    if (IS_SAP_EP_SUPPORTED(pSvc)) {
        pEntry->GlobalInstanceId = pSap->InstanceId;
        
        pEntry->EndpointState = pSap->SapEpObj->TxActive ? SAP_SDP_FORWARDING : SAP_SDP_DISABLED;
        sapSetFwdStateWithLock(pSap, pEntry->EndpointState, pEntry->EndpointState, pDndlerCbEvtMsgs);
        pEntry->Cfg.ActiveTransmit = pSap->SapEpObj->TxActive;
        pEntry->Cfg.EndpointIsICB = FALSE,
        pEntry->Cfg.EndpointGroup = pSap->SapEpObj->EpRec->EpId - 1;
        SVCMGR_EVENT(IOM_CALL, "sap=%s inst=%d state=%d ActiveTx=%d epg=%d", smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                     pEntry->GlobalInstanceId, pEntry->EndpointState,
                     pEntry->Cfg.ActiveTransmit, pEntry->Cfg.EndpointGroup);
    } else if (IS_TLS(pSvc)) {
        pEntry->Cfg.ActiveTransmit = TRUE;
        pEntry->Cfg.EndpointGroup  = INVALID_ENDPOINT_GROUP_ID;
        pEntry->Cfg.EndpointIsICB  = FALSE;
    }
}

PRIVATE void smgrInitSapCfmPrimVlanReqEntry(tIomSapCfmPrimVlanEntry *pEntry, const tSapRec *pSap,
                                            const tDot1agSapPvEntry *pPrimVlanCfg)
{
    ZERO_STRUCT_PTR(pEntry);
    pEntry->GlobalInstanceId = pSap->InstanceId;
    pEntry->VlanId = pPrimVlanCfg->VlanId;
    pEntry->Dot1agMepIngressLevel = pPrimVlanCfg->Dot1agMepIngressLevel;
    pEntry->Dot1agMepEgressLevel = pPrimVlanCfg->Dot1agMepEgressLevel;
    pEntry->Dot1agMipMask = pPrimVlanCfg->Dot1agMipMask;
}


PRIVATE void smgrInitSdpBindReqEntry(tIomSvcBindEntry *pEntry, tSdpBndRec *pSdpBnd, eSapSdpState IomFwdState, 
                                     struct SMEventMsg *pCallbackEvent, tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs)
{
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    tTlsShgRec *pShg;

    ZERO_STRUCT_PTR(pEntry);

    pEntry->SdpId = pSdpBnd->SdpRec->Id;
    pEntry->SvcId = pSdpBnd->SvcRec->Id;
    pEntry->GlobalInstanceId = pSdpBnd->InstanceId;
    if (pSdpBnd->Type == VAL_sdpBindType_spoke) {
        pEntry->SdpBindingIsSpoke = TRUE;
    } else {
        pEntry->SdpBindingIsSpoke = FALSE;
    }

    if (SDPBND_IS_L2TPV3(pSdpBnd)) {
        pEntry->L2TPv3.IngressSessionID = -1; /* Always set to -1 */
        pEntry->L2TPv3.EgressSessionID  = -1; /* Always set to -1 */
        pEntry->L2TPv3.IngressCookie    = pSdpBnd->pL2TPv3->IngressCookie;
        pEntry->L2TPv3.EgressCookie     = pSdpBnd->pL2TPv3->EgressCookie;
    }

    pEntry->SdpBindingMirrorRemSrc = !! pSdpBnd->IsMirrorRemoteSrc;

    if (IS_PE_EP_SPOKE(pSdpBnd) && ! pSdpBnd->SdpEpObj->TxActive) {
        pEntry->SdpBindingBlockSpokeTx = TRUE;
        sdpBindSetBlockTxState(pSdpBnd, TRUE, pDndlerCbEvtMsgs);
    } else if (pSdpBnd->BlockTxOnPeerFault && ! pSdpBnd->SdpEpObj->TxActive) {
        pEntry->SdpBindingBlockSpokeTx = TRUE;
        sdpBindSetBlockTxState(pSdpBnd, TRUE, pDndlerCbEvtMsgs);
    } else {
        pEntry->SdpBindingBlockSpokeTx = FALSE;
        sdpBindSetBlockTxState(pSdpBnd, FALSE, pDndlerCbEvtMsgs);
    }

    if (pSdpBnd->OperHashLabel) {
        pEntry->EnableEntropyLabel = TRUE;
    } else {
        pEntry->EnableEntropyLabel = FALSE;
    }

    pEntry->ExtendedPwachSupport = pSdpBnd->ExtendedPwAchSupport;

    pEntry->Config.SapSdpState = IomFwdState;

    // PW Resiliency initializations
    if (IS_EP_SUPPORTED(pSvc) && pSdpBnd->Type == VAL_sdpBindType_spoke) {
        tSdpBndId SdpBndId;
        pEntry->Config.SapSdpRedCfg.ActiveTransmit = pSdpBnd->SdpEpObj->TxActive;
        pEntry->Config.SapSdpRedCfg.EndpointGroup  = (pSdpBnd->SdpEpObj->EpRec) ? 
                                                     pSdpBnd->SdpEpObj->EpRec->EpId - 1 : INVALID_ENDPOINT_GROUP_ID;
        pEntry->Config.SapSdpRedCfg.EndpointIsICB  = IS_ICB_SPOKE(pSdpBnd) ? TRUE : FALSE;
        sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
        SVCMGR_EVENT(IOM_CALL, "sdp=%s inst=%d state=%d ActiveTx=%d epg=%d", smgrFmtSdpBndIdForDebug(&SdpBndId), 
                     pEntry->GlobalInstanceId, pEntry->Config.SapSdpState,
                     pEntry->Config.SapSdpRedCfg.ActiveTransmit, pEntry->Config.SapSdpRedCfg.EndpointGroup);
    } else {
       pEntry->Config.SapSdpRedCfg.ActiveTransmit = TRUE; 
       pEntry->Config.SapSdpRedCfg.EndpointGroup = INVALID_ENDPOINT_GROUP_ID; 
       pEntry->Config.SapSdpRedCfg.EndpointIsICB = FALSE; 
    }
    switch (pSvc->Type) {
        case ST_EPIPE:
        case ST_P3PIPE:
            pEntry->SvcType = SVC_TYPE_EPIPE;
            break;
        
        case ST_APIPE:
            pEntry->SvcType = SVC_TYPE_APIPE;
            break;
            
        case ST_FPIPE:
            pEntry->SvcType = SVC_TYPE_FPIPE;
            break;

        case ST_IPIPE:
            pEntry->SvcType = SVC_TYPE_IPIPE;
            break;

        case ST_CPIPE:
            pEntry->SvcType = SVC_TYPE_CPIPE;
            break;

        case ST_TLS:
            pEntry->SvcType = SVC_TYPE_TLS;
            // as a sanity check make sure SdpBndTls has not yet been freed
            if (SDPBND_TLS_INFO(pSdpBnd)) {
                if ((pShg = pSdpBnd->SvcTypeInfo.SdpBndTls->C.ShgRec) != NULL) {
                    pEntry->Config.u.Tls.TlsSplitHorizonGroup = pShg->InstanceId;
                }
                pEntry->Config.u.Tls.RestrictProtectedSrc = pSdpBnd->SvcTypeInfo.SdpBndTls->C.RestProtSrcMacEnabled;
            }
            pEntry->Config.u.Tls.DhcpSnoopingEnabled =
                (dhsIsSnoopingEnabledOnSdpBnd(pSdpBnd) ||
                 dhs6IsSnoopingEnabledOnSdpBnd(pSdpBnd)) ? TRUE : FALSE;
            if ((pSdpBnd->SapRec != NULL) &&                // need to check because update can be sent
                (pSdpBnd->SapRec->SapTls != NULL)) {        // after bind has been deleted                
                pEntry->Config.u.Tls.LearningDisabled = !pSdpBnd->SapRec->SapTls->MacLearningEnabled;
                pEntry->Config.u.Tls.AgeingDisabled = !pSdpBnd->SapRec->SapTls->MacAgeingEnabled;
                pEntry->Config.u.Tls.DiscardUnknownSource = tlsSapDoDiscardUnknownSource(pSdpBnd->SapRec);
                pEntry->Config.u.Tls.MacFdbFull = pSdpBnd->SapRec->SapTls->MacRelearnOnly;
            }
            if (svcIsMgdBySPBM(pSvc)) {
                pEntry->Config.u.Tls.IsMcListPrunedEndpoint = (tlsFdbGetSapSbindMcastDestRefCnt(NULL, pSdpBnd) != 0) ? TRUE : FALSE;
                /* Following indicates to IOM to do Ingress checks for traffic received on this bind */
                if (svcSPBMDoIngrChks(pSvc)) {
                    pEntry->Config.u.Tls.MacFdbFull = TRUE;
                    pEntry->Config.u.Tls.RestrictProtectedSrc = TRUE;
                }
            }
            pEntry->Config.u.Tls.SpbEndpoint = svcIsSpbCtrlSvc(pSvc); /* All binds in SpbCtrl Svc */
            
            pEntry->Config.u.Tls.IsBgpAdSdpBind = SDPBND_IS_ORIGIN_BGP_L2VPN_AUTO_BIND(pSdpBnd->CreationOrigin);
            pEntry->Config.u.Tls.IsPmsiSdpBind = (pSdpBnd->CreationOrigin == VAL_sdpBindCreationOrigin_vplsPmsi);
            if (pEntry->Config.u.Tls.IsPmsiSdpBind)
                pEntry->Config.u.Tls.P2MP.MplsMcastTunnelIndex = pSdpBnd->SvcTypeInfo.SdpBndTls->PmsiInfo.P2mpId;
            else if (pEntry->Config.u.Tls.IsBgpAdSdpBind)
                pEntry->Config.u.Tls.P2MP.RpfTunnelIndex = pSdpBnd->SvcTypeInfo.SdpBndTls->PmsiInfo.IlmIfIndex;
            break;

        case ST_VPLS_LITE:
            pEntry->SvcType = SVC_TYPE_TLS;
            break;

        case ST_VPRN:
            pEntry->SvcType = SVC_TYPE_VPRN;
            if (pSdpBnd->IesIfRec) {
                pEntry->Config.u.Ies_Vprn.IesIfIndex = pSdpBnd->IesIfRec->PipIfInstanceId;
            }
            pEntry->Config.u.Ies_Vprn.IsIpipe = (pSdpBnd->VcType == VAL_sdpBindVcType_ipipe);
            pEntry->Config.u.Ies_Vprn.Ipv4FlowspecEnabled = pSdpBnd->IngressFlowspec;
            pEntry->Config.u.Ies_Vprn.Ipv6FlowspecEnabled = pSdpBnd->IngressIPv6Flowspec;
            break;
            
        case ST_IES:
            pEntry->SvcType = SVC_TYPE_IES;
            pEntry->Config.u.Ies_Vprn.IesIfIndex = pSdpBnd->IesIfRec->PipIfInstanceId;
            pEntry->Config.u.Ies_Vprn.IsIpipe = (pSdpBnd->VcType == VAL_sdpBindVcType_ipipe);
            pEntry->Config.u.Ies_Vprn.Ipv4FlowspecEnabled = pSdpBnd->IngressFlowspec;
            pEntry->Config.u.Ies_Vprn.Ipv6FlowspecEnabled = pSdpBnd->IngressIPv6Flowspec;
            break;

        case ST_MIRROR:
            pEntry->SvcType = SVC_TYPE_MIRROR;
            break;

        case ST_UNDEF:
        case ST_SIZE:
        default:;
    }                

    // Use the Filter Id that IOM is programmed with
    if (pSdpBnd->IngIpFilterId){
        pEntry->Config.IngressIpv4FilterId = pSdpBnd->IngIpFilterId;
    } else if (pSdpBnd->IngressFlowspec){
        pEntry->Config.IngressIpv4FilterId = pSdpBnd->IngressIpFlowSpecFltrId;
    } else {
        pEntry->Config.IngressIpv4FilterId = 0;
    }

    if (pSdpBnd->IngIpv6FilterId){
        pEntry->Config.IngressIpv6FilterId = pSdpBnd->IngIpv6FilterId;
    } else if (pSdpBnd->IngressIPv6Flowspec){
        pEntry->Config.IngressIpv6FilterId = pSdpBnd->IngressIpv6FlowSpecFltrId;
    } else {
        pEntry->Config.IngressIpv6FilterId = 0;
    }

    pEntry->Config.EgressIpv4FilterId = pSdpBnd->EgrIpFilterId;
    pEntry->Config.EgressIpv6FilterId = pSdpBnd->EgrIpv6FilterId;
    pEntry->Config.IngressMacFilterId = pSdpBnd->IngMacFilterId;
    pEntry->Config.EgressMacFilterId = pSdpBnd->EgrMacFilterId;
    pEntry->Config.IngressRedirectQGroup = pSdpBnd->IngRedirectQGrp;
    pEntry->Config.EgressRedirectQGroup = pSdpBnd->EgrRedirectQGrp;
    pEntry->Config.IngressL2CflowdEnabled = pSdpBnd->L2CflowdEnabled;    

    if ((IS_MIRROR(pSvc) && IS_NULL_TP_ID(&pSdpBnd->SdpRec->TpFarEndId)) ||
        (pSdpBnd->OperIngressVcLabel == PEND_VC_LABEL)) {
        /* Non-MPLS-TP SDP binding under a mirror svc does not have an ingress label */
        pEntry->IngressVcLabel = NULL_VC_LABEL;
    } else {
        pEntry->IngressVcLabel = pSdpBnd->OperIngressVcLabel;
    }

    pEntry->EgressVcLabel = pSdpBnd->OperEgressVcLabel;
    
    if (pSdpBnd->VcType == VAL_sdpBindVcType_ether) {
        pEntry->SdpVcType = IOM_SDP_BINDING_VC_TYPE_ETHERNET;
    } else if (pSdpBnd->VcType == VAL_sdpBindVcType_vlan) {
        pEntry->SdpVcType = IOM_SDP_BINDING_VC_TYPE_VLAN;
    }  else {
        pEntry->SdpVcType = IOM_SDP_BINDING_VC_TYPE_UNDEF;
    }
    if (pSdpBnd->ForceVlanVcForwarding == VAL_sdpBindForceVlanVcForwarding_true)
        pEntry->SdpVcType = IOM_SDP_BINDING_VC_TYPE_VLAN;

    if (pSdpBnd->OperVlanVcTag != DEFVAL_sdpBindVlanVcTag)
        pEntry->VlanVcTagValue = pSdpBnd->OperVlanVcTag;
    else
        pEntry->VlanVcTagValue = pSdpBnd->AdminVlanVcTag;

    // Application-assurance (DPI)
    if (pSdpBnd->pTransitIpPlcy) {
        pEntry->DpiTransitPlcyIdx = pSdpBnd->pTransitIpPlcy->plcyId.intId;
        pEntry->DpiTransitIpv6Len = pSdpBnd->pTransitIpPlcy->transitIPv6PrefixLength;
    } else if (pSdpBnd->pTransitPrefixPlcy) {
        pEntry->DpiTransitPlcyIdx = pSdpBnd->pTransitPrefixPlcy->plcyId.intId;
        pEntry->DpiTransitPlcyIdx |= DPI_SMGR_TRANSIT_POL_ID_PREFIX_TYPE;
        pEntry->DpiTransitIpv6Len = 0;
    } else {
        pEntry->DpiTransitPlcyIdx = INVALID_AA_TRANSIT_IP_POLICY_ID;
        pEntry->DpiTransitIpv6Len = 0;
    }
    
    if ((pSdpBnd->pAppProf) && (pSdpBnd->pAppProf->divert) && IS_VALID_DPI_DIVERT_INDEX(pSdpBnd->DpiEnabledIndex)) {
        pEntry->DpiDivertIndex = pSdpBnd->DpiEnabledIndex;
    } else {
        pEntry->DpiDivertIndex = NO_DPI_DIVERT_SYS_INDEX;
    }
    
    if (pSdpBnd->pAppProf) {
        pEntry->DpiReverseDirection = pSdpBnd->DpiReverseDirection;
    } else {
        pEntry->DpiReverseDirection = FALSE;
    }
    pEntry->DpiAarpIdx = pSdpBnd->aarpIntId;
    pEntry->DpiAarpRefType = pSdpBnd->aarpRefType;
    
    switch (pSdpBnd->ControlWordType) {
        case SMCW_NONE:
            pEntry->SdpCwType = IOM_CONTROL_WORD_NONE; break;
        case SMCW_NULL:
            pEntry->SdpCwType = IOM_CONTROL_WORD_NULL; break;
        case SMCW_ATM:
            pEntry->SdpCwType = IOM_CONTROL_WORD_ATM; break;
        case SMCW_FR_NEW:
            pEntry->SdpCwType = IOM_CONTROL_WORD_FR_NEW; break;
        case SMCW_CE:
            pEntry->SdpCwType = IOM_CONTROL_WORD_CEM; break;
        default:;
    }

    dot1agPointerLock();
    if (pSdpBnd->pDot1ag != NULL) {
        pEntry->Dot1agMipLevel =  pSdpBnd->pDot1ag->Dot1agMipLevel;
        pEntry->Dot1agMepIngressLevel =  pSdpBnd->pDot1ag->Dot1agIngressMepLevel;
        pEntry->Dot1agMepEgressLevel = pSdpBnd->pDot1ag->Dot1agEgressMepLevel;
    } else {
        pEntry->Dot1agMipLevel = SMGR_DOT1AG_LEVEL_DISABLED;
        pEntry->Dot1agMepIngressLevel =  SMGR_DOT1AG_LEVEL_DISABLED;
        pEntry->Dot1agMepEgressLevel = SMGR_DOT1AG_LEVEL_DISABLED;
    }
    dot1agPointerUnlock();

    // PW-port
    pEntry->PWPortID = pSdpBnd->pPwPort ? BUILD_PORTID_PW_PORT(pSdpBnd->pPwPort->Id) : INVALID_PORTID;
    pEntry->PWPortEncap = pSdpBnd->pPwPort ? pSdpBnd->pPwPort->EncapType : PORT_ENCAP_NULL;

    pEntry->CfmVmepFilter = pSdpBnd->CfmVmepFilter;
    pEntry->handle.Cpm = pCallbackEvent;

    pEntry->IngressNetworkPolicyId = pSdpBnd->IngNetworkQosPolId;
    pEntry->EgressNetworkPolicyId = pSdpBnd->EgrNetworkQosPolId;
}

PRIVATE void smgrInitSdpBindSwitchReqEntry(tIomSapSdpSwitchConfig *pEntry, tSdpBndRec *pSdpBnd,
                                           tSmgrDndlerSapBindCbEvtMsgs *pDndlerCbEvtMsgs)
{
    tSvcRec *pSvc = pSdpBnd->SvcRec;
    
    ZERO_STRUCT_PTR(pEntry);

    // PW Resiliency initializations
    if (IS_EP_SUPPORTED(pSvc) && pSdpBnd->Type == VAL_sdpBindType_spoke) {
        tSdpBndId SdpBndId;
        tSdpBndEpObj *pSdpEp = pSdpBnd->SdpEpObj;
        
        pEntry->GlobalInstanceId = pSdpBnd->InstanceId;
        pEntry->EndpointState = pSdpEp->TxActive ? SAP_SDP_FORWARDING : sdpBindGetFwdPortState(pSdpBnd);
        pEntry->BlockSpokeTx = (IS_PE_EP_SPOKE(pSdpBnd) && (pSdpEp->TxActive != TRUE)) ? TRUE : FALSE;
        pEntry->Cfg.ActiveTransmit = pSdpEp->TxActive;
        pEntry->Cfg.EndpointIsICB = IS_ICB_SPOKE(pSdpBnd) ? TRUE : FALSE;
        pEntry->Cfg.EndpointGroup = pSdpEp->EpRec ? pSdpEp->EpRec->EpId - 1 : INVALID_ENDPOINT_GROUP_ID;
        
        sdpBindSetFwdState(pSdpBnd, pEntry->EndpointState, pDndlerCbEvtMsgs);
        sdpBindFormatId(pSdpBnd->SllHdr.Id, &SdpBndId);
        SVCMGR_EVENT(IOM_CALL, "sdp=%s inst=%d state=%d ActiveTx=%d epg=%d", smgrFmtSdpBndIdForDebug(&SdpBndId), 
                     pEntry->GlobalInstanceId, pEntry->EndpointState,
                     pEntry->Cfg.ActiveTransmit, pEntry->Cfg.EndpointGroup);
    } else if (IS_TLS(pSvc)) {
        pEntry->Cfg.ActiveTransmit = TRUE;
        pEntry->Cfg.EndpointIsICB = FALSE;
        pEntry->Cfg.EndpointGroup = INVALID_ENDPOINT_GROUP_ID;
    }
}

PRIVATE void smgrInitSdpBindStateEntry(tIomSvcBindStateEntry *pEntry, tSdpBndRec *pSdpBnd, eSapSdpState IomFwdState,
                                       struct SMEventMsg *pCallbackEvent)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SdpId = pSdpBnd->SdpRec->Id;
    pEntry->SvcId = pSdpBnd->SvcRec->Id;
    pEntry->GlobalInstanceId = pSdpBnd->InstanceId;
    pEntry->SapSdpState = IomFwdState;
    pEntry->handle.Cpm = pCallbackEvent;
}

PRIVATE void smgrInitSdpBindMcListPruneEntry(tIomSvcBindMcListPruneEntry* pEntry, tSdpBndRec* pSdpBnd)
{
    ZERO_STRUCT_PTR(pEntry);
    
    pEntry->SvcId = pSdpBnd->SvcRec->Id;
    pEntry->SdpId = pSdpBnd->SdpRec->Id;
    pEntry->GlobalInstanceId = pSdpBnd->InstanceId;
    if (svcIsMgdBySPBM(pSdpBnd->SvcRec)) {
        pEntry->IsMcListPrunedBind = (tlsFdbGetSapSbindMcastDestRefCnt(NULL, pSdpBnd) != 0) ? TRUE : FALSE;
    }
    pEntry->handle.Cpm = NULL;
}

PRIVATE void smgrInitTlsMacAddReqEntry(tIomTlsMacAddEntry *pEntry, tSvcRec *pSvc, tTlsFdbRec *pRec,
                                       tSlot SrcSlotNum, struct SMEventMsg *pCallbackEvent)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;
    pEntry->MacAddr = pRec->MacAddr;
    if (pRec->Type == VAL_tlsFdbType_learned) {
        pEntry->IsStatic = FALSE;
    } else {
        pEntry->IsStatic = TRUE;
    }
    if (pRec->Type == VAL_tlsFdbType_oam) {
        pEntry->IsOam = TRUE;
    } else {
        pEntry->IsOam = FALSE;
    }
    if (pRec->Locale == VAL_tlsFdbLocale_sap) {
        pEntry->Dest.DestType = IOM_TLS_MAC_DEST_SAP;
        pEntry->Dest.u.SapInstanceId = pRec->DestInfo.Sap.Rec->InstanceId;
        pEntry->Dest.OrigSlotNum =  SrcSlotNum;
    } else if (pRec->Locale == VAL_tlsFdbLocale_sdp) {
        pEntry->Dest.DestType = IOM_TLS_MAC_DEST_SDPB;
        pEntry->Dest.u.SdpInstanceId = pRec->DestInfo.SdpBnd.Rec->InstanceId;
        pEntry->Dest.OrigSlotNum =  SrcSlotNum;
    } else if (pRec->Locale == VAL_tlsFdbLocale_endpoint) {
        if (pRec->DestInfo.EndPoint.RealRec) {
            pEntry->Dest.DestType = IOM_TLS_MAC_DEST_SDPB;
            pEntry->Dest.u.SdpInstanceId = pRec->DestInfo.EndPoint.RealRec->InstanceId;
            pEntry->Dest.OrigSlotNum =  SrcSlotNum;
        } else {
            SVCMGR_BERROR(NOCLASS,"Null RealRec. svc=%u mac=%s dst=%s", 
                          pSvc->Id, smgrFmtMacAddrForDebug(&pRec->MacAddr),
                          smgrFmtMacDestForDebug(pRec->Locale,&pRec->DestInfo));
            return;
        }
    } else {
        if (pRec->Type == VAL_tlsFdbType_host) {
            pEntry->Dest.DestType = IOM_TLS_MAC_DEST_CPM;
            pEntry->IsIpHost = TRUE;
        } else if (pRec->Type == VAL_tlsFdbType_intf) {
            pEntry->Dest.DestType = IOM_TLS_MAC_DEST_RVPLS_INTF;
        } else {
            pEntry->Dest.DestType = IOM_TLS_MAC_DEST_CPM;
            pEntry->IsIpHost = FALSE;
        }
    }
    pEntry->FdbId = pRec->FdbId;
    switch(pRec->Protected) {
    case TLS_MAC_NOT_PROTECTED:
        pEntry->ProtectType = IOM_TLS_MAC_NOT_PROTECTED;
        break;
    case TLS_MAC_PROTECTED:
        pEntry->ProtectType = IOM_TLS_MAC_PROTECTED;        
        break;
    case TLS_MAC_PROTECTED_ALARM:
        pEntry->ProtectType = IOM_TLS_MAC_PROTECTED_ALARM;
        break;
    }
    
    if (tlsMimIsCVplsEntry(pRec) || tlsMimIsBVplsEntry(pRec)) {
        pEntry->ParentTls.MimDestIdx = pRec->pMimEntry->DestIdx;
        pEntry->ParentTls.DestMacAddr = pRec->pMimEntry->BMacAddr;
    } else if (IS_BVPLS_SVC(pRec->pTlsFdb->SvcRec)) {
        pEntry->ParentTls.MimDestIdx = 0;
        pEntry->ParentTls.DestMacAddr = pRec->MacAddr;
    }

    if (svcIsMgdBySPBM(pSvc)) {
        pEntry->ProtectType = IOM_TLS_MAC_PROTECTED; /* For SPBM Svcs - indicates to IOM to do Ingress checks */
        pEntry->McastDest.IsValid = TRUE;
        if (pRec->McastDestInfo.EndPt != TLS_FDB_MCAST_ENDPT_NULL) {
            if (TLS_FDB_MCAST_ENDPT_IS_SAP(pRec->McastDestInfo.EndPt)) {
                tSapRec *pSap = (tSapRec *)(TLS_FDB_MCAST_ENDPT_TO_SAP_REC(pRec->McastDestInfo.EndPt));
                pEntry->McastDest.IsSdp = FALSE;
                pEntry->McastDest.u.SapInstanceId = pSap->InstanceId;
            } else {
                tSdpBndRec *pSdpBnd = (tSdpBndRec *)(TLS_FDB_MCAST_ENDPT_TO_SDPBND_REC(pRec->McastDestInfo.EndPt));
                pEntry->McastDest.IsSdp = TRUE;
                pEntry->McastDest.u.SdpInstanceId = pSdpBnd->InstanceId;
            }
        } else {
            pEntry->McastDest.IsSdp = FALSE;
            pEntry->McastDest.u.SapInstanceId = SMGR_NULL_SAP_INST_ID;
        }
    } else {
        pEntry->McastDest.IsValid = FALSE;
    }
    
    pEntry->handle.Cpm = pCallbackEvent;
}
PRIVATE void smgrInitTlsMacDelReqEntry(tIomTlsMacDelEntry *pEntry, tSvcRec *pSvc, tTlsFdbRec *pRec)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;
    
    pEntry->MacAddr = pRec->MacAddr;
}
PRIVATE void smgrInitTlsMacDelDstReqEntry(tIomTlsMacDelDstEntry *pEntry, tSvcRec *pSvc, tSdpBndRec *pSdpBnd, tSapRec* pSap,
                                          tBoolean DelStatic, tTlsFdbRequestorType RequestorType,
                                          tSMGenEventMsg *pCbEvt)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;
    pEntry->IsStatic = DelStatic;

    if (pSdpBnd) {
        SVCMGR_EVENT(IOM_CALL, "svc=%u sdp=%u:%u", 
                     pSvc->Id, sdpBindGetSdpId(pSdpBnd), sdpBindGetVcId(pSdpBnd));
        pEntry->Dest.DestType = IOM_TLS_MAC_DEST_SDPB;
        pEntry->Dest.u.SdpInstanceId = pSdpBnd->InstanceId;
    } else {
        SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s RequestorType=%u",
                     pSvc->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                     RequestorType);

        pEntry->Dest.DestType = IOM_TLS_MAC_DEST_SAP;
        pEntry->Dest.u.SapInstanceId = pSap->InstanceId;

        pEntry->RequestorBitMap = smgrTlsMacDelGetFastFloodRequestorBitMap(pSvc, RequestorType);
    }
    
    pEntry->handle.Cpm = pCbEvt;
}
PRIVATE void smgrInitTlsMacDelTlsReqEntry(tIomTlsMacDelTlsEntry *pEntry, tSvcRec *pSvc,
                                          tBoolean DelStatic, tTlsFdbRequestorType RequestorType,
                                          tSMGenEventMsg *pCbEvt)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;
    pEntry->IsStatic = DelStatic;
    pEntry->RequestorBitMap = smgrTlsMacDelGetFastFloodRequestorBitMap(pSvc, RequestorType);
    pEntry->handle.Cpm = pCbEvt;
}
PRIVATE void smgrInitTlsMacDelMimReqEntry(tIomTlsMacDelMimEntry *pEntry, tSvcRec *pSvc,
                                          tSMGenEventMsg *pCbEvt)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;

    pEntry->handle.Cpm = pCbEvt;
}
PRIVATE void smgrInitTlsMacMoveReqEntry(tIomTlsMacMoveEntry *pEntry, tSvcRec *pSvc,
                                        tSdpBndRec *pOldSdpBnd,tSdpBndRec *pNewSdpBnd)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;

    pEntry->Source.DestType = IOM_TLS_MAC_DEST_SDPB;
    pEntry->Source.OrigSlotNum = INVALID_SLOT_NUM;
    pEntry->Source.u.SdpInstanceId = pOldSdpBnd->InstanceId;

    pEntry->Target.DestType = IOM_TLS_MAC_DEST_SDPB;
    pEntry->Target.OrigSlotNum = INVALID_SLOT_NUM;
    pEntry->Target.u.SdpInstanceId = pNewSdpBnd->InstanceId;
    
}
PRIVATE void smgrInitTlsMacQueryReqEntry(tIomTlsMacQueryEntry *pEntry, tSvcRec *pSvc, tTlsFdbRec *pRec, tBoolean MultipleIoms)
{
    ZERO_STRUCT_PTR(pEntry);

    pEntry->TlsInstanceId = IS_TLS(pSvc) ? pSvc->u.Tls->TlsInstanceId : SMGR_NULL_TLS_INST_ID;

    pEntry->MacAddr = pRec->MacAddr;

    /* The following info is not used by the IOM but instead
     * used when a response from the IOM is recieved 
     */
    pEntry->MultipleIoms = MultipleIoms;
}
PRIVATE tFastFldReqBitMap smgrTlsMacDelGetFastFloodRequestorBitMap(tSvcRec *pSvc,
                                                                   tTlsFdbRequestorType RequestorType)
{
    tFastFldReqBitMap RequestorBitMap = 0;
    switch (RequestorType) {
    case TFRT_ETHRING:
        RequestorBitMap |= (1 << TLS_FAST_FLOOD_REQUESTOR_RAPS);
        break;
    case TFRT_MVRP:
        if (IS_TLS(pSvc) && (pSvc->u.Tls->TempFlood.ReqBitmap & (1 << TLS_FAST_FLOOD_REQUESTOR_MVRP))) {
            RequestorBitMap |= (1 << TLS_FAST_FLOOD_REQUESTOR_MVRP);
        }
        break;
    case TFRT_STP:
        if (IS_TLS(pSvc) && (pSvc->u.Tls->TempFlood.ReqBitmap & (1 << TLS_FAST_FLOOD_REQUESTOR_STP))) {
            RequestorBitMap |= (1 << TLS_FAST_FLOOD_REQUESTOR_STP);
        }
        break;
    case TFRT_UNDEF:
    default:
        ;
    }
    return RequestorBitMap;
}

PRIVATE void smgrInitMssAddReqEntry(tMultiServiceSite *pEntry, tMssRec *pMss)
{
    tInt32 tmpAggRateLimit = 0;
 
    ZERO_STRUCT_PTR(pEntry);

    pEntry->SiteId = pMss->InstanceId;
    pEntry->PortAssignment = (pMss->Scope == VAL_custMultSvcSiteScope_port);
    /* Resolve the proper Egress Agg-Rate-Limit to send */
    if ((pMss->EgrAggRateLimit == MAX_custMultSvcSiteEgressAggRateLimit_1) &&
        (pMss->AncpEgrAggRateLimit == 0)) {
        /* since the MSS agg-rate-limit is max, and there's no ANCP
         * override, we can't apply the IGMP Rate Delta.
         * So just send down the MSS agg-rate-limit as is.
         */
        pEntry->EgressAggRateLimit = pMss->EgrAggRateLimit;
    } else {
        if (pMss->AncpEgrAggRateLimit != 0) {
            /* If ANCP is overriding the Egress agg-rate-limit, then
             * start with the lesser of the ANCP vs the MSS agg-rate-limit
             * and then factor in the IGMP Rate Delta
             */
            if ((pMss->EgrAggRateLimit == MAX_custMultSvcSiteEgressAggRateLimit_1) ||
                (pMss->AncpEgrAggRateLimit < pMss->EgrAggRateLimit)) {
                tmpAggRateLimit = pMss->AncpEgrAggRateLimit + pMss->IgmpEgrAggRateLimitDelta;
            } else {
                tmpAggRateLimit = pMss->EgrAggRateLimit + pMss->IgmpEgrAggRateLimitDelta;
            }
        } else {
            /* (pMss->EgrAggRateLimit !=MAX_custMultSvcSiteEgressAggRateLimit_1)
             * must be true at this point
             */
            tmpAggRateLimit = (pMss->EgrAggRateLimit + pMss->IgmpEgrAggRateLimitDelta);
        }

        /* cap the value in the regular range for agg-rate-limit. */
        if (tmpAggRateLimit > MAX_custMultSvcSiteEgressAggRateLimit_2) {
            pEntry->EgressAggRateLimit = MAX_custMultSvcSiteEgressAggRateLimit_2;
        } else if (tmpAggRateLimit < MIN_custMultSvcSiteEgressAggRateLimit_2) {
            pEntry->EgressAggRateLimit = MIN_custMultSvcSiteEgressAggRateLimit_2;
        } else {
            pEntry->EgressAggRateLimit = tmpAggRateLimit;
        }
    }
    pEntry->EgressAggRateOnTheWire = pMss->FrameBasedAccnt == VAL_custMultSvcSiteFrameBasedAccnt_true ? TRUE : FALSE;
    if (pMss->IngQosSchedPolicyRec)
        pEntry->IngressSchedulerPolicyId = pMss->IngQosSchedPolicyRec->InstanceId;
    if (pMss->EgrQosSchedPolicyRec)
        pEntry->EgressSchedulerPolicyId = pMss->EgrQosSchedPolicyRec->InstanceId;
    if (pMss->IngQosPolicerCtrlPolRec)
        pEntry->IngressPolicerCtrlPolicyId = pMss->IngQosPolicerCtrlPolRec->InstanceId;
    if (pMss->EgrQosPolicerCtrlPolRec)
        pEntry->EgressPolicerCtrlPolicyId = pMss->EgrQosPolicerCtrlPolRec->InstanceId;
}


PRIVATE void smgrEncodeQosVirtSchedEntry(char *Key, void *Value, void *Arg1, void *Arg2)
{
    tQosVirtSchedRec *pVSch = Value;
    tIomQosSchedulerPolicyRequest *pMsg = Arg1;
    tVirtSchedEntryInfo *pEntryInfo = Arg2;
    int n;
    tQosScheduler *pEntry;
    
    n = pEntryInfo->EntryNum;
    pEntry = &pMsg->Policy.Scheduler[n];
    pEntry->InUse = TRUE;
    strcpyn(pEntry->Name.Str, sizeof(pEntry->Name.Str), pVSch->Entry->tVirtualSchedulerName.name);
    strcpyn(pEntry->Cfg.ParentSchedulerName.Str, sizeof(pEntry->Cfg.ParentSchedulerName.Str), pVSch->Entry->tVirtualSchedulerParent.name);

    if (pVSch->Entry->tVirtualSchedulerUsePortParent == VAL_tVirtualSchedulerUsePortParent_true) {
        pEntry->Cfg.UsePortParent = TRUE;

        pEntry->Cfg.CIRLevel = pVSch->Entry->tVirtualSchedulerPortCIRLvl;
        pEntry->Cfg.CIRWeight = pVSch->Entry->tVirtualSchedulerPortCIRWght;
        pEntry->Cfg.AboveCIRLevel = pVSch->Entry->tVirtualSchedulerPortLvl;
        pEntry->Cfg.AboveCIRWeight = pVSch->Entry->tVirtualSchedulerPortWght;
    } else {
        pEntry->Cfg.UsePortParent = FALSE;

        pEntry->Cfg.CIRLevel = pVSch->Entry->tVirtualSchedulerCIRLevel;
        pEntry->Cfg.CIRWeight = pVSch->Entry->tVirtualSchedulerCIRWeight;
        pEntry->Cfg.AboveCIRLevel = pVSch->Entry->tVirtualSchedulerLevel;
        pEntry->Cfg.AboveCIRWeight = pVSch->Entry->tVirtualSchedulerWeight;
    }
    
    pEntry->Cfg.CIRIsSumMemberCIRs = (pVSch->Entry->tVirtualSchedulerSummedCIR == VAL_tVirtualSchedulerSummedCIR_true) ? TRUE : FALSE; 
    pEntry->Cfg.CIR  = MIB_64BIT_UNSIGNEDRATE_TO_IOM_32BIT_UNSIGNEDRATE(pVSch->Entry->tVirtualSchedulerCIRU64);
    pEntry->Cfg.Rate = MIB_64BIT_UNSIGNEDRATE_TO_IOM_32BIT_UNSIGNEDRATE(pVSch->Entry->tVirtualSchedulerPIRU64);
    pEntry->Cfg.OnTheWireRates = pEntryInfo->FrameBasedAccnt == VAL_tSchedulerPolicyFrameBasedAccnt_true ? TRUE : FALSE; 

    pEntry->Cfg.AvgOverhead = 0;
    pEntry->Cfg.ForceUseAvgOverhead = FALSE;
    
    pEntryInfo->EntryNum = ++n;
}

PRIVATE void smgrEncodeQosPolicerArbiterEntry(char *Key, void *Value, void *Arg1, void *Arg2)
{
    tQosPolicerArbiterRec *pArbiter = Value;
    tIomQosArbiterPolicyRequest *pMsg = Arg1;
    tUint32 *pEntryNum = Arg2;
    int n;
    tQosArbiter *pEntry;
    
    n = *pEntryNum;
    pEntry = &pMsg->Policy.Arbiter[n];
    pEntry->InUse = TRUE;
    strcpyn(pEntry->Name.Str, sizeof(pEntry->Name.Str), pArbiter->Entry->tQosPolicerArbiterName.name);
    pEntry->Cfg.IsRoot = FALSE;
    pEntry->Cfg.Rate = pArbiter->Entry->tQosPolicerArbiterRate;
    if (strcmp(pArbiter->Entry->tQosPolicerArbiterParent.name, DEFVAL_tQosPolicerArbiterParent) == 0) {
        strcpyn(pEntry->Cfg.Cfg.NonRoot.ParentArbiterName.Str,
                sizeof(QOS_ROOT_ARBITER_NAME), QOS_ROOT_ARBITER_NAME);
    } else {
        strcpyn(pEntry->Cfg.Cfg.NonRoot.ParentArbiterName.Str,
                sizeof(pEntry->Cfg.Cfg.NonRoot.ParentArbiterName.Str),
                pArbiter->Entry->tQosPolicerArbiterParent.name);
    }

    pEntry->Cfg.Cfg.NonRoot.Level = pArbiter->Entry->tQosPolicerArbiterLevel;
    pEntry->Cfg.Cfg.NonRoot.Weight = pArbiter->Entry->tQosPolicerArbiterWeight;
    
    *pEntryNum = ++n;
}



PRIVATE void smgrEncodeSapIngQosPolIpRule(tIpQosFilterRule *pRule,
                                          STRUCT_tSapIngressIPCriteriaEntry *pEntry)
{
    tUint16 portLow;
    tUint16 portHigh;
    tBoolean isIpv6 = QOS_IS_IPV6INDEX(pEntry->tSapIngressIPCriteriaIndex);
    eQosIpType qosIpType= (isIpv6) ? QOS_IPTYPE_IP : QOS_IPTYPE_IPv6;
        
    SVCMGR_EVENT(NOCLASS, "pol=%u rule=%u type %s", 
                 QOS_ANYINDEX_2_INDEX(pEntry->tSapIngressIndex), 
                 QOS_ANYINDEX_2_INDEX(pEntry->tSapIngressIPCriteriaIndex), 
                 qos_IpType_Name[qosIpType]);

    ZERO_STRUCT_PTR(pRule);

    pRule->IsIpv6 = isIpv6; 
    pRule->RuleIndex = QOS_ANYINDEX_2_INDEX(pEntry->tSapIngressIPCriteriaIndex);
    pRule->Match.IsIpv6 = isIpv6;


    if (isIpv6) {
        pRule->Match.SourceAddr.Ipv6 = pEntry->tSapIngressIPCriteriaSourceIpAddr.u.addr6; 
        maskLenToValue6(pEntry->tSapIngressIPCriteriaSourceIpMask, &pRule->Match.SourceAddrMask.Ipv6, sizeof(pRule->Match.SourceAddrMask.Ipv6));
        pRule->Match.DestAddr.Ipv6 = pEntry->tSapIngressIPCriteriaDestIpAddr.u.addr6;
        maskLenToValue6(pEntry->tSapIngressIPCriteriaDestIpMask, &pRule->Match.DestAddrMask.Ipv6, sizeof(pRule->Match.DestAddrMask.Ipv6));
    } else {
        pRule->Match.SourceAddr.Ipv4 = pEntry->tSapIngressIPCriteriaSourceIpAddr.u.addr; 
        pRule->Match.SourceAddrMask.Ipv4 = maskLenToValue(pEntry->tSapIngressIPCriteriaSourceIpMask);
        pRule->Match.DestAddr.Ipv4 = pEntry->tSapIngressIPCriteriaDestIpAddr.u.addr;
        pRule->Match.DestAddrMask.Ipv4 = maskLenToValue(pEntry->tSapIngressIPCriteriaDestIpMask);
    }
    if (pEntry->tSapIngressIPCriteriaProtocol == DEFVAL_tSapIngressIPCriteriaProtocol) {
        pRule->Match.ProtocolMatch = FALSE;
        pRule->Match.Protocol = 0;
        pRule->Match.ProtocolTcpAndUdp = FALSE;
    } else if (pEntry->tSapIngressIPCriteriaProtocol == MIN_tSapIngressIPCriteriaProtocol) {
        pRule->Match.ProtocolMatch = TRUE;
        pRule->Match.Protocol = 0;
        pRule->Match.ProtocolTcpAndUdp = TRUE;
    } else {
        pRule->Match.ProtocolMatch = TRUE;
        pRule->Match.Protocol = pEntry->tSapIngressIPCriteriaProtocol;
        pRule->Match.ProtocolTcpAndUdp = FALSE;
    }
    pRule->Match.Dscp = tqm_GetDSCPVal(pEntry->tSapIngressIPCriteriaDSCP.name);
    pRule->Match.DscpValid = (pRule->Match.Dscp != DSCP_INVALID);

    getPortRngVal (pEntry->tSapIngressIPCriteriaSourcePortOperator,
                   pEntry->tSapIngressIPCriteriaSourcePortValue1,
                   pEntry->tSapIngressIPCriteriaSourcePortValue2,
                   &portLow,
                   &portHigh);
    pRule->Match.SourcePortLow  = portLow;
    pRule->Match.SourcePortHigh = portHigh;

    getPortRngVal (pEntry->tSapIngressIPCriteriaDestPortOperator,
                   pEntry->tSapIngressIPCriteriaDestPortValue1,
                   pEntry->tSapIngressIPCriteriaDestPortValue2,
                   &portLow,
                   &portHigh);
    pRule->Match.DestPortLow = portLow;
    pRule->Match.DestPortHigh = portHigh;

    pRule->Match.Option = 0;
    pRule->Match.OptionMask = 0;
    pRule->Match.IcmpType = 0;
    pRule->Match.IcmpTypeMask = 0;
    pRule->Match.IcmpCode = 0;
    pRule->Match.IcmpCodeMask = 0;

    if (pEntry->tSapIngressIPCriteriaFragment == VAL_tSapIngressIPCriteriaFragment_off) {
        pRule->Match.MatchFragmentEnable = FALSE;
        pRule->Match.MatchFragment = FALSE;
    } else if (pEntry->tSapIngressIPCriteriaFragment == VAL_tSapIngressIPCriteriaFragment_false) {
        pRule->Match.MatchFragmentEnable = TRUE;
        pRule->Match.MatchFragment = FALSE;
    } else {
        pRule->Match.MatchFragmentEnable = TRUE;
        pRule->Match.MatchFragment = TRUE; 
    }
    pRule->Match.FirstFragment = 0;
    pRule->Match.FirstFragmentEnable = 0;
    pRule->Match.OptionPresent = 0;
    pRule->Match.OptionPresentEnable = 0;
    pRule->Match.MultipleOption = 0;
    pRule->Match.MultipleOptionEnable = 0;
    pRule->Match.TcpSyn = 0;
    pRule->Match.TcpSynEnable = 0;
    pRule->Match.TcpAck = 0;
    pRule->Match.TcpAckEnable = 0;
    pRule->Match.Flowspec = 0;
    pRule->Match.FlowspecEnable = 0;
    pRule->Match.SrcRouteOption = 0;
    pRule->Match.SrcRouteOptionEnable = 0;
    pRule->Match.IPv6RT0Opt = 0;
    pRule->Match.IPv6RT0OptEnable = 0;
    pRule->Match.IPv6NextHopOpt = 0;
    pRule->Match.IPv6NextHopOptEnable = 0;
    pRule->Match.IPv6FlowLabel = 0;
    pRule->Match.IPv6FlowLabelEnable = 0;
    
    pRule->Match.CamEntriesRequired = getNumPrtRngEntries(pEntry->tSapIngressIPCriteriaProtocol,
                                                          pEntry->tSapIngressIPCriteriaSourcePortOperator,
                                                          pEntry->tSapIngressIPCriteriaSourcePortValue1,
                                                          pEntry->tSapIngressIPCriteriaSourcePortValue2,
                                                          pEntry->tSapIngressIPCriteriaDestPortOperator,
                                                          pEntry->tSapIngressIPCriteriaDestPortValue1,
                                                          pEntry->tSapIngressIPCriteriaDestPortValue2);

    pRule->Action.QmdaCntrOverrideValid = FALSE;
    pRule->Action.QmdaCntrOverride = 0;

    if (pEntry->tSapIngressIPCriteriaActionFC.length != 0) { 
        pRule->Action.FcValid = TRUE; 
        pRule->Action.SubFc = tqm_tSapIngressFCEntry_subFcId(QOS_ANYINDEX_2_INDEX(pEntry->tSapIngressIndex),
                                                             pEntry->tSapIngressIPCriteriaActionFC.name);
    } else { 
        pRule->Action.FcValid = FALSE; 
    } 
    if (pEntry->tSapIngressIPCriteriaActionPriority != VAL_tSapIngressIPCriteriaActionPriority_default) { 
        pRule->Action.DpValid = TRUE; 
        pRule->Action.Dp = MIB_PRIO_TO_IOM_DP(pEntry->tSapIngressIPCriteriaActionPriority); 
    } else { 
        pRule->Action.DpValid = FALSE; 
    } 

}


PRIVATE void smgrEncodeSapIngQosPolMacRule(tInt32 macFltrType,
                                           tMacQosFilterRule *pRule,
                                           STRUCT_tSapIngressMacCriteriaEntry *pEntry)
{
    SVCMGR_EVENT(NOCLASS, "pol=%u rule=%u", pEntry->tSapIngressIndex, pEntry->tSapIngressMacCriteriaIndex);

    ZERO_STRUCT_PTR(pRule);

    pRule->RuleIndex = pEntry->tSapIngressMacCriteriaIndex;
    memcpy(&pRule->Match.SourceAddr, pEntry->tSapIngressMacCriteriaSrcMacAddr, sizeof (tMacAddr));
    memcpy(&pRule->Match.SourceMask, pEntry->tSapIngressMacCriteriaSrcMacMask, sizeof (tMacAddr));
    memcpy(&pRule->Match.DestAddr, pEntry->tSapIngressMacCriteriaDstMacAddr, sizeof (tMacAddr));
    memcpy(&pRule->Match.DestMask, pEntry->tSapIngressMacCriteriaDstMacMask, sizeof (tMacAddr));
    pRule->Match.dot1pValue = pEntry->tSapIngressMacCriteriaDot1PValue;
    pRule->Match.dot1pMask = pEntry->tSapIngressMacCriteriaDot1PMask;

    if (macFltrType == VAL_tSapIngressMacCritType_vid) {
        pRule->Match.Prot = MAC_PROT_MATCH_VID;
        if (pEntry->tSapIngressMacCritInnerTagValue == DEFVAL_tSapIngressMacCritInnerTagValue) {
            pRule->Match.u.Vid.InnerTag     = 0;
            pRule->Match.u.Vid.InnerTagMask = 0;
        } else {
            pRule->Match.u.Vid.InnerTag     = pEntry->tSapIngressMacCritInnerTagValue;
            pRule->Match.u.Vid.InnerTagMask = pEntry->tSapIngressMacCritInnerTagMask;
        }
        if (pEntry->tSapIngressMacCritOuterTagValue == DEFVAL_tSapIngressMacCritOuterTagValue) {
            pRule->Match.u.Vid.OuterTag     = 0;
            pRule->Match.u.Vid.OuterTagMask = 0;
        } else {
            pRule->Match.u.Vid.OuterTag     = pEntry->tSapIngressMacCritOuterTagValue;
            pRule->Match.u.Vid.OuterTagMask = pEntry->tSapIngressMacCritOuterTagMask;
        }
    } else if (pEntry->tSapIngressMacCriteriaFrameType == VAL_tSapIngressMacCriteriaFrameType_ethernetII) {
        pRule->Match.Prot = MAC_PROT_MATCH_ETYPE;
        if (pEntry->tSapIngressMacCriteriaEthernetType != DEFVAL_tSapIngressMacCriteriaEthernetType) {
            pRule->Match.u.Etype.EtherType = pEntry->tSapIngressMacCriteriaEthernetType;
            pRule->Match.u.Etype.EtherTypeMask = 0xFFFF;
        } else {
            pRule->Match.u.Etype.EtherType = 0;
            pRule->Match.u.Etype.EtherTypeMask = 0;
        }
    } else if (pEntry->tSapIngressMacCriteriaFrameType == VAL_tSapIngressMacCriteriaFrameType_e802dot2SNAP) {
        pRule->Match.Prot = MAC_PROT_MATCH_SNAP_PID;
        if (pEntry->tSapIngressMacCriteriaSnapPid != DEFVAL_tSapIngressMacCriteriaSnapPid) {
            pRule->Match.u.Snap.SnapPid = pEntry->tSapIngressMacCriteriaSnapPid;
            pRule->Match.u.Snap.SnapPidMask = 0xFFFF;
        } else {
            pRule->Match.u.Snap.SnapPid = 0;
            pRule->Match.u.Snap.SnapPidMask = 0;
        }
    } else if (pEntry->tSapIngressMacCriteriaFrameType == VAL_tSapIngressMacCriteriaFrameType_e802dot2LLC) {
        pRule->Match.Prot = MAC_PROT_MATCH_SSAP_DSAP;
        if (pEntry->tSapIngressMacCriteriaSSAP != DEFVAL_tSapIngressMacCriteriaSSAP) {
            pRule->Match.u.Saps.Ssap = pEntry->tSapIngressMacCriteriaSSAP;
            pRule->Match.u.Saps.SsapMask = pEntry->tSapIngressMacCriteriaSSAPMask;
        } else {
            pRule->Match.u.Saps.Ssap = 0;
            pRule->Match.u.Saps.SsapMask = 0;
        }
        if (pEntry->tSapIngressMacCriteriaDSAP != DEFVAL_tSapIngressMacCriteriaDSAP) {
            pRule->Match.u.Saps.Dsap = pEntry->tSapIngressMacCriteriaDSAP;
            pRule->Match.u.Saps.DsapMask = pEntry->tSapIngressMacCriteriaDSAPMask;
        } else {
            pRule->Match.u.Saps.Dsap = 0;
            pRule->Match.u.Saps.DsapMask = 0;
        }
    } else if (pEntry->tSapIngressMacCriteriaFrameType == VAL_tSapIngressMacCriteriaFrameType_atm) {
        pRule->Match.Prot = MAC_PROT_MATCH_ATM_VCI;
        if (pEntry->tSapIngressMacCriteriaAtmVci != DEFVAL_tSapIngressMacCriteriaAtmVci) {
            pRule->Match.u.Atm.Vci = pEntry->tSapIngressMacCriteriaAtmVci;
            pRule->Match.u.Atm.VciMask = 0xFFFF;
        } else {
            pRule->Match.u.Atm.Vci = 0;
            pRule->Match.u.Atm.VciMask = 0;
        }
    } else {
        pRule->Match.Prot = MAC_PROT_MATCH_NONE;
    }
    if (pEntry->tSapIngressMacCriteriaSnapOui == VAL_tSapIngressMacCriteriaSnapOui_off) {
        pRule->Match.OuiMatch = FALSE;    
        pRule->Match.OuiZero = FALSE;
    } else if (pEntry->tSapIngressMacCriteriaSnapOui == VAL_tSapIngressMacCriteriaSnapOui_zero) {
        pRule->Match.OuiMatch = TRUE;
        pRule->Match.OuiZero = TRUE;
    } else {
        pRule->Match.OuiMatch = TRUE;    
        pRule->Match.OuiZero = FALSE;
    }
    pRule->Match.CamEntriesRequired = 1;

    if (pEntry->tSapIngressMacCriteriaActionFC.length != 0) { 
        pRule->Action.FcValid = TRUE; 
        pRule->Action.SubFc = tqm_tSapIngressFCEntry_subFcId(pEntry->tSapIngressIndex, pEntry->tSapIngressMacCriteriaActionFC.name);
    } else { 
        pRule->Action.FcValid = FALSE; 
    } 
    if (pEntry->tSapIngressMacCriteriaActionPriority != VAL_tSapIngressMacCriteriaActionPriority_default) { 
        pRule->Action.DpValid = TRUE; 
        pRule->Action.Dp = MIB_PRIO_TO_IOM_DP(pEntry->tSapIngressMacCriteriaActionPriority); 
    } else { 
        pRule->Action.DpValid = FALSE; 
    } 
    pRule->Action.QmdaCntrOverride = 0;          // not supported
    pRule->Action.QmdaCntrOverrideValid = FALSE; // not supported
}               


PRIVATE void smgrEncodeSapEgrQosPolIpRule(tIpQosFilterRule *pRule,
                                          STRUCT_tSapEgrIPCritEntry *pEntry)
{
    tUint16 portLow;
    tUint16 portHigh;
    tBoolean isIpv6 = (pEntry->tSapEgrIPCritAddrType == VAL_tSapEgrIPCritAddrType_ipv6);
    eQosIpType qosIpType= (isIpv6) ? QOS_IPTYPE_IPv6 : QOS_IPTYPE_IP;
        
    SVCMGR_EVENT(NOCLASS, "pol=%u rule=%u type %s", 
                 pEntry->tSapEgressIndex, 
                 pEntry->tSapEgrIPCritIndex, 
                 qos_IpType_Name[qosIpType]);

    ZERO_STRUCT_PTR(pRule);

    pRule->IsIpv6 = isIpv6; 
    pRule->RuleIndex = pEntry->tSapEgrIPCritIndex;
    pRule->Match.IsIpv6 = isIpv6;


    if (isIpv6) {
        pRule->Match.SourceAddr.Ipv6 = pEntry->tSapEgrIPCritSourceIpAddr.u.addr6; 
        maskLenToValue6(pEntry->tSapEgrIPCritSourceIpMask, &pRule->Match.SourceAddrMask.Ipv6, sizeof(pRule->Match.SourceAddrMask.Ipv6));
        pRule->Match.DestAddr.Ipv6 = pEntry->tSapEgrIPCritDestIpAddr.u.addr6;
        maskLenToValue6(pEntry->tSapEgrIPCritDestIpMask, &pRule->Match.DestAddrMask.Ipv6, sizeof(pRule->Match.DestAddrMask.Ipv6));
    } else {
        pRule->Match.SourceAddr.Ipv4 = pEntry->tSapEgrIPCritSourceIpAddr.u.addr; 
        pRule->Match.SourceAddrMask.Ipv4 = maskLenToValue(pEntry->tSapEgrIPCritSourceIpMask);
        pRule->Match.DestAddr.Ipv4 = pEntry->tSapEgrIPCritDestIpAddr.u.addr;
        pRule->Match.DestAddrMask.Ipv4 = maskLenToValue(pEntry->tSapEgrIPCritDestIpMask);
    }
    if (pEntry->tSapEgrIPCritProtocol == DEFVAL_tSapEgrIPCritProtocol) {
        pRule->Match.ProtocolMatch = FALSE;
        pRule->Match.Protocol = 0;
        pRule->Match.ProtocolTcpAndUdp = FALSE;
    } else if (pEntry->tSapEgrIPCritProtocol == MIN_tSapEgrIPCritProtocol) {
        pRule->Match.ProtocolMatch = TRUE;
        pRule->Match.Protocol = 0;
        pRule->Match.ProtocolTcpAndUdp = TRUE;
    } else {
        pRule->Match.ProtocolMatch = TRUE;
        pRule->Match.Protocol = pEntry->tSapEgrIPCritProtocol;
        pRule->Match.ProtocolTcpAndUdp = FALSE;
    }
    pRule->Match.Dscp = tqm_GetDSCPVal(pEntry->tSapEgrIPCritDSCP.name);
    pRule->Match.DscpValid = (pRule->Match.Dscp != DSCP_INVALID);

    getPortRngVal (pEntry->tSapEgrIPCritSourcePortOperator,
                   pEntry->tSapEgrIPCritSourcePortValue1,
                   pEntry->tSapEgrIPCritSourcePortValue2,
                   &portLow,
                   &portHigh);
    pRule->Match.SourcePortLow  = portLow;
    pRule->Match.SourcePortHigh = portHigh;

    getPortRngVal (pEntry->tSapEgrIPCritDestPortOperator,
                   pEntry->tSapEgrIPCritDestPortValue1,
                   pEntry->tSapEgrIPCritDestPortValue2,
                   &portLow,
                   &portHigh);
    pRule->Match.DestPortLow = portLow;
    pRule->Match.DestPortHigh = portHigh;

    pRule->Match.Option = 0;
    pRule->Match.OptionMask = 0;
    pRule->Match.IcmpType = 0;
    pRule->Match.IcmpTypeMask = 0;
    pRule->Match.IcmpCode = 0;
    pRule->Match.IcmpCodeMask = 0;

    if (pEntry->tSapEgrIPCritFragment == VAL_tSapEgrIPCritFragment_off) {
        pRule->Match.MatchFragmentEnable = FALSE;
        pRule->Match.MatchFragment = FALSE;
    } else if (pEntry->tSapEgrIPCritFragment == VAL_tSapEgrIPCritFragment_false) {
        pRule->Match.MatchFragmentEnable = TRUE;
        pRule->Match.MatchFragment = FALSE;
    } else {
        pRule->Match.MatchFragmentEnable = TRUE;
        pRule->Match.MatchFragment = TRUE; 
    }
    pRule->Match.FirstFragment = 0;
    pRule->Match.FirstFragmentEnable = 0;
    pRule->Match.OptionPresent = 0;
    pRule->Match.OptionPresentEnable = 0;
    pRule->Match.MultipleOption = 0;
    pRule->Match.MultipleOptionEnable = 0;
    pRule->Match.TcpSyn = 0;
    pRule->Match.TcpSynEnable = 0;
    pRule->Match.TcpAck = 0;
    pRule->Match.TcpAckEnable = 0;
    pRule->Match.Flowspec = 0;
    pRule->Match.FlowspecEnable = 0;
    pRule->Match.SrcRouteOption = 0;
    pRule->Match.SrcRouteOptionEnable = 0;
    pRule->Match.IPv6RT0Opt = 0;
    pRule->Match.IPv6RT0OptEnable = 0;
    pRule->Match.IPv6NextHopOpt = 0;
    pRule->Match.IPv6NextHopOptEnable = 0;
    pRule->Match.IPv6FlowLabel = 0;
    pRule->Match.IPv6FlowLabelEnable = 0;
    
    pRule->Match.CamEntriesRequired = getNumPrtRngEntries(pEntry->tSapEgrIPCritProtocol,
                                                          pEntry->tSapEgrIPCritSourcePortOperator,
                                                          pEntry->tSapEgrIPCritSourcePortValue1,
                                                          pEntry->tSapEgrIPCritSourcePortValue2,
                                                          pEntry->tSapEgrIPCritDestPortOperator,
                                                          pEntry->tSapEgrIPCritDestPortValue1,
                                                          pEntry->tSapEgrIPCritDestPortValue2);

    if (pEntry->tSapEgrIPCritActionHsmdaCntrOvr != DEFVAL_tSapEgrIPCritActionHsmdaCntrOvr) { 
        pRule->Action.QmdaCntrOverrideValid = TRUE; 
        pRule->Action.QmdaCntrOverride = MIB_QMDACNTRID_TO_IOM_QMDACNTRID(pEntry->tSapEgrIPCritActionHsmdaCntrOvr);
    } else { 
        pRule->Action.QmdaCntrOverrideValid = FALSE; 
        pRule->Action.QmdaCntrOverride = 0;
    }
    
    if (pEntry->tSapEgrIPCritActionProfile != DEFVAL_tSapEgrIPCritActionProfile) { 
        pRule->Action.DpValid = TRUE; 
        pRule->Action.Dp      = (pEntry->tSapEgrIPCritActionProfile == VAL_tSapEgrIPCritActionProfile_in) ? DP_INPROFILE : DP_OUTPROFILE;
    } else { 
        pRule->Action.DpValid = FALSE; 
        pRule->Action.Dp      = 0;
    }

    if (pEntry->tSapEgrIPCritActionFC.length > 0) {
        pRule->Action.SubFc   = tqm_tSapEgressFCEntry_subFcId(QOS_ANYINDEX_2_INDEX(pEntry->tSapEgressIndex),
                                                              pEntry->tSapEgrIPCritActionFC.name);
        pRule->Action.FcValid = pRule->Action.SubFc != SMGR_SAP_ING_FCID_INVALID;
    } else { 
        pRule->Action.SubFc   = SMGR_SAP_ING_FCID_INVALID;
        pRule->Action.FcValid = FALSE; 
    }
}


/* Send a SAP_CEM_REQUEST_MSG message */
PUBLIC tStatus smgrSendSapCemStatsReadMesg(
    tSapRec      *pSap, 
    tSapCemStats *pStats,
    tBoolean     absolute,
    tBoolean     *pHaveSmgrLock)
{
    tIomSapCemReq       msg;
    tIomSapCemResp      *rep;
    tSMPortInfo         SapPortInfo;
    tUint32             slotNum;
    tIccTransaction     *pIccTran;
    tIccError           s;
    tSapId              SapId;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pStats);

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap)) 
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    ZERO_STRUCT(msg);
    msg.Op = (absolute) ? IOM_SAP_CEM_STATS_READ_ABSOLUTE : IOM_SAP_CEM_STATS_READ;
    msg.SapId = pSap->SapId;

    SapId = pSap->SapId;

    if ((pHaveSmgrLock) && (*pHaveSmgrLock)) {
        *pHaveSmgrLock = FALSE;
        smgrUnlock();
    }

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_CEM; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_CEM_REQUEST_MSG;
        pIccTran->RequestFragments[0].Addr = &msg;
        
        s = iccSendRequest(pIccTran, TRUE);

        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }

        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%u id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_CEM, s);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }

        /* Do some sanity checks */
        if ((pIccTran->NumResponseFragments != 1) ||
            (pIccTran->ResponseFragments[0].Length != SIZE_SAP_CEM_RESPONSE_MSG)) {
            SVCMGR_ERROR(NOCLASS,
                         "Malformed IOM response! Expected Fragments %u of size %zu. Received Fragments %u of size %u",
                         1, SIZE_SAP_CEM_RESPONSE_MSG,
                         pIccTran->NumRequestFragments,
                         pIccTran->RequestFragments[0].Length);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }
        rep = pIccTran->ResponseFragments[0].Addr;

        /* Accumulate the stats into the buffer */
        if (!sapCmpIds((char *) &rep->SapId, (char *)&SapId)) {
            pStats->IngressFwdPkts             += rep->u.Stats.IngressFwdPkts;
            pStats->IngressDroppedPkts         += rep->u.Stats.IngressDroppedPkts;
            pStats->EgressFwdPkts              += rep->u.Stats.EgressFwdPkts;
            pStats->EgressDroppedPkts          += rep->u.Stats.EgressDroppedPkts;
            pStats->EgressMissingPkts          += rep->u.Stats.EgressMissingPkts;
            pStats->EgressPktsReOrder          += rep->u.Stats.EgressPktsReOrder;
            pStats->EgressJtrBfrUnderruns      += rep->u.Stats.EgressJtrBfrUnderruns;
            pStats->EgressJtrBfrOverruns       += rep->u.Stats.EgressJtrBfrOverruns;
            pStats->EgressMisOrderDropped      += rep->u.Stats.EgressMisOrderDropped;
            pStats->EgressMalformedPkts        += rep->u.Stats.EgressMalformedPkts;
            pStats->EgressErrorSeconds         += rep->u.Stats.EgressErrorSeconds;
            pStats->EgressSeverelyErrorSeconds += rep->u.Stats.EgressSeverelyErrorSeconds;
            pStats->EgressUnavailableSeconds   += rep->u.Stats.EgressUnavailableSeconds;
            pStats->EgressFailureCounts        += rep->u.Stats.EgressFailureCounts;
            pStats->EgressLBitDropped          += rep->u.Stats.EgressLBitDropped;
            pStats->EgressOverrunCounts        += rep->u.Stats.EgressOverrunCounts;
            pStats->EgressUnderrunCounts       += rep->u.Stats.EgressUnderrunCounts;
            // The jitter buffer depth is not a counter--copy it!
            pStats->EgressJtrBfrDepth           = rep->u.Stats.EgressJtrBfrDepth;
        }
        iccFreeTransaction(pIccTran);
    }
        
    return SUCCESS;
}

/* Send a SAP_CEM_REQUEST_MSG message */
PUBLIC tStatus smgrSendSapCemStatsResetMesg(
    tSapRec *pSap)
{
    tIomSapCemReq      msg;
    tSMPortInfo        SapPortInfo;
    tUint32            slotNum;
    tIccTransaction    *pIccTran;
    tIccError          s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));

    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);

    ZERO_STRUCT(msg);
    msg.Op = IOM_SAP_CEM_STATS_RESET;
    msg.SapId = pSap->SapId;

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransactionAlloc(MOD_SM_MESG, SIZE_SAP_CEM_REQUEST_MSG, ICC_TRANS_OPT_AUTOFREE)) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_CEM;
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        memcpy(pIccTran->RequestFragments[0].Addr, &msg, pIccTran->RequestFragments[0].Length);
        
        s = iccSendRequestAsyncS(pIccTran, NULL);
        if (s != ICC_ERR_NONE) {
            iccFreeTransaction(pIccTran);
        }    
    
        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            continue;
        }
    
        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%d sock=%d failed with error=%d !",
                         slotNum, ICC_SOCKET_SAP_CEM, s);
            return FAIL;
        }
    }
    return SUCCESS;
}

/* Send a SAP_CEM_REQUEST_MSG message */
PUBLIC tStatus smgrSendSapCemAlarmReqMesg(
    tSapRec      *pSap,
    tUint16      *pAlarmStatus)
{
    tIomSapCemReq       msg;
    tIomSapCemResp      *rep;
    tSMPortInfo         SapPortInfo;
    tUint32             slotNum;
    tIccTransaction     *pIccTran;
    tIccError           s;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s",
                 pSap->SvcRec->Id,
                 smgrFmtSapIdVerboseForDebug(&pSap->SapId));
    
    /* Initialize the response */
    ZERO_STRUCT_PTR(pAlarmStatus);
    
    if (smgrRedAmInactive) {
        SVCMGR_ERROR(NOCLASS,"Message from ICPM to IOM %s:%s Line %d",
                     __FILE__,__FUNCTION__,__LINE__);
        return SUCCESS;
    }
    
    /* If the port where the SAP is defined is not present
     * ignore the request.
     */
    if (!IS_SAP_PRESENT(pSap))
        return SUCCESS;

    /* Get the set of ports where this SAP is defined */
    smgrGetPortInfo(pSap->PortRec, &SapPortInfo);
    
    ZERO_STRUCT(msg);

    msg.SapId = pSap->SapId;
    msg.Op = IOM_SAP_CEM_ALARM_STATUS;

    for (slotNum = MIN_CHASSIS_SLOT; slotNum <= MAX_CHASSIS_SLOT; slotNum++) {
        /* Skip IOM's that are off-line or where this
         * SAP is not present.
         */
        if (!IOM_BIT_TST(SMOnLineIomBitMask, slotNum) ||
            !IOM_BIT_TST(SapPortInfo.IomPresentBitMask, slotNum))
            continue;
    
        if ((pIccTran = iccNewTransaction()) == NULL) 
            return FAIL;
       
        /* Fill out ICC transaction */
        pIccTran->Slot = slotNum;
        pIccTran->Socket = ICC_SOCKET_SAP_CEM; 
        pIccTran->Priority = ICC_HIGHEST_PRIORITY;
        pIccTran->NumRequestFragments = 1;
        pIccTran->RequestFragments[0].Length = SIZE_SAP_CEM_REQUEST_MSG;
        pIccTran->RequestFragments[0].Addr = &msg;
        
        s = iccSendRequest(pIccTran, TRUE);

        /* If the IOM is removed during the transaction, we may
         * get an ICC_ERR_UNREACHABLE that can be safely ignored.
         */
        if (s == ICC_ERR_UNREACHABLE) {
            iccFreeTransaction(pIccTran);
            continue;
        }

        /* Check the return code */
        if (s != ICC_ERR_NONE) {
            SVCMGR_ERROR(NOCLASS,
                         "iccSendRequest() to iom=%u id=%u sock=%d failed with error=%d !",
                         slotNum, pIccTran->TransactionId, ICC_SOCKET_SAP_CEM, s);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }

        if ((pIccTran->NumResponseFragments != 1) ||
            (pIccTran->ResponseFragments[0].Length != SIZE_SAP_CEM_RESPONSE_MSG)) {
            SVCMGR_ERROR(NOCLASS,
                         "Malformed IOM response! Expected Fragments %u of size %zu. Received Fragments %u of size %u",
                         1, SIZE_SAP_CEM_RESPONSE_MSG,
                         pIccTran->NumRequestFragments,
                         pIccTran->RequestFragments[0].Length);
            iccFreeTransaction(pIccTran);
            return FAIL;
        }
        rep = pIccTran->ResponseFragments[0].Addr;

        if (!sapCmpIds((char *) &rep->SapId, (char *)&pSap->SapId)) {
            *pAlarmStatus |= rep->u.AlarmStatus;
        }
        iccFreeTransaction(pIccTran);
    }
    
    return SUCCESS;
}


PRIVATE void smgrGetSapLoopBackDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                               const tSapRec *pSap,
                                               tUint32 IomOp,
                                               tUint32 SlotBitmap,
                                               tBoolean IsCardOnline)
{
    switch (SlotBitmap) {
    case THIS_SAP_IOMS:
        pIccInfo->IomBitMask = smgrGetPortRecIomBitMask(pSap->PortRec);
        break;
    case ALL_APPLICABLE_IOMS:
        pIccInfo->IomBitMask = 0xffffffff;
        break;
    default:
        pIccInfo->IomBitMask = SlotBitmap;

        if (IsCardOnline)
            pIccInfo->IomBitMask &= pSap->PortRec->IomBitMask;
    }

    smgrMsgrGetObjIccBitMask(pIccInfo,
                             pSmgrIccMsgr,
                             SmgrMsgrEntry_SapLoopBack,
                             IomOp,
                             SlotBitmap,
                             IsCardOnline,
                             FALSE,
                             smgrMesgSapCmp,
                             pSap);
}


/* Send a single IOM_SAP_MAC_LPBK message */
PRIVATE tStatus smgrSendSapLoopBackMesgPriv(tSapRec *pSap, tSapMacLpbk *pSapLoopBack, tUint32 SlotBitmap, tBoolean Start, tBoolean IsCardOnline)
{
    tIomSapSubMixedRequest      *pMsg;
    tIomSapSdpMacLpbkEntry      *pMacLpbk;
    tSmgrMsgrIccInfo            IccInfo;
    tStatus                     s;

    s = SUCCESS;
    
    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s start=%s",
                 pSap->SvcRec->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId), pSap->InstanceId, SapAdminStatusName[pSap->AdminStatus],
                 SapOperStatusName[pSap->OperStatus], (Start ? "true" : "false"));

    if (TST_SF(pSap, SF_NOT_PROGRAMMED)) {
        SVCMGR_EVENT(IOM_CALL, "sap not programmed, svc=%u sap=%s", pSap->SvcRec->Id, smgrFmtSapIdVerboseForDebug(&pSap->SapId));
        return SUCCESS;
    }

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSapLoopBackDownloadInfo(&IccInfo, pSap, IOM_SAP_MAC_LPBK, SlotBitmap, IsCardOnline);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((pMsg = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(IOM_SAP_MAC_LPBK, 1))) == NULL) {
        SVCMGR_EVENT(NOCLASS, "No more memory for ICC message");
        return FAIL;
    }

    pMsg->NumEntries    = 1;
    pMsg->Entries[0].Op = IOM_SAP_MAC_LPBK;
    pMacLpbk            = &pMsg->Entries[0].MacLpbk;

    pMacLpbk->GlobalInstanceId = pSap->InstanceId;
    pMacLpbk->Add              = Start;
    pMacLpbk->IsIngress        = pSapLoopBack->IsIngress;
    pMacLpbk->Swap             = pSapLoopBack->MacSwap;
    pMacLpbk->MacSwapAll       = pSapLoopBack->MacSwapAll;
    memcpy(&pMacLpbk->SwapMacAddr, &pSapLoopBack->SwapMacAddr, sizeof (tMacAddr));

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    pMsg->TotalLength = smgrMesgIccSapSubMsgSize(IOM_SAP_MAC_LPBK, pMsg->NumEntries);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, IOM_SAP_MAC_LPBK, IccInfo.IomBitMask, pMsg, pMsg->TotalLength, NULL, SMGR_DNDLER_BLOCK);

    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x", IccInfo.IomBitMask);
    }

    smgrFreeClientMsg(pMsg, s);

    return s;
}


/* Send a single IOM_SAP_MAC_LPBK message */
PUBLIC tStatus smgrSendSapLoopBackMesg(tSapRec *pSap, tSapMacLpbk *pSapLoopBack, tSMSlot SlotNum, tBoolean Start)
{
    tUint32 SlotBitmap = 0;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u SlotNum=%u",
                 pSapLoopBack->SvcId, smgrFmtSapIdVerboseForDebug(&pSap->SapId),
                 pSap->InstanceId, SlotNum);

    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);

    return(smgrSendSapLoopBackMesgPriv(pSap, pSapLoopBack, SlotBitmap, Start, FALSE));
}


PRIVATE void smgrGetSdpBindLoopBackDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                        const tSdpBndRec *pSdpBnd,
                                        tUint32 IomOp,
                                        tUint32 SlotBitmap,
                                        tBoolean IsCardOnline,
                                        tBoolean UseChmgrBitmap)
{
    if (pSdpBnd->DoNotDownload) {
        pIccInfo->IomBitMask = 0;
        return;
    }

    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SdpBindLoopBack,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          UseChmgrBitmap,
                          smgrMesgSdpBindCmp,
                          pSdpBnd);
}

/* Send a single IOM_SVC_BIND_MAC_LPBK message */
PRIVATE tStatus smgrSendSbindLoopBackMesgPriv(tSdpBndRec *pSdpBnd, tSdpBindMacLpbk *pSbindLoopBack, tUint32 SlotBitmap, tBoolean Start, tBoolean IsCardOnline)
{
    tIomSvcBindRequest          *pMsg;
    tIomSapSdpMacLpbkEntry      *pMacLpbk;
    tSmgrMsgrIccInfo            IccInfo;
    tStatus                     s;

    s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sap=%s inst=%u admin=%s oper=%s start=%s",
                 pSbindLoopBack->SvcId, smgrFmtSdpBndIdForDebug(&pSbindLoopBack->SdpBindId), pSdpBnd->InstanceId, SdpBindAdminStatusName[pSdpBnd->AdminStatus],
                 SdpBindOperStatusName[pSdpBnd->OperStatus], (Start ? "true" : "false"));

    /* Determine the set of IOM's that should receive this
     * message. If we end up with the empty set, then don't
     * bother trying to send it...
     */
    smgrGetSdpBindLoopBackDownloadInfo(&IccInfo, pSdpBnd, IOM_SVC_BIND_MAC_LPBK, SlotBitmap, IsCardOnline, FALSE);

    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    if ((pMsg = SMGR_MESG_MEM_MALLOC(smgrMesgIccSdpBindMsgSize(IOM_SVC_BIND_MAC_LPBK, 1))) == NULL) {
        SVCMGR_EVENT(NOCLASS, "No more memory for ICC message");
        return FAIL;
    }

    pMsg->NumEntries = 1;
    pMsg->Op         = IOM_SVC_BIND_MAC_LPBK;
    pMacLpbk         = &pMsg->u.MacLpbk[0];

    pMacLpbk->GlobalInstanceId = pSdpBnd->InstanceId;
    pMacLpbk->Add              = Start;
    pMacLpbk->IsIngress        = pSbindLoopBack->IsIngress;
    pMacLpbk->Swap             = pSbindLoopBack->MacSwap;
    pMacLpbk->MacSwapAll       = pSbindLoopBack->MacSwapAll;
    memcpy(&pMacLpbk->SwapMacAddr, &pSbindLoopBack->SwapMacAddr, sizeof (tMacAddr));

    /* Send the message to all applicable IOM's */
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);

    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, IOM_SVC_BIND_MAC_LPBK, IccInfo.IomBitMask, pMsg, SIZE_SVC_BIND_MAC_LPBK_MSG(pMsg->NumEntries), NULL, SMGR_DNDLER_BLOCK);

    if (s != SUCCESS) {
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x", IccInfo.IomBitMask);
    }

    smgrFreeClientMsg(pMsg, s);

    return s;
}


/* Send a single IOM_SVC_BIND_MAC_LPBK message */
PUBLIC tStatus smgrSendSbindLoopBackMesg(struct SdpBndRec *pSdpBnd, struct SdpBindMacLpbk *pSbindLoopBack, tSMSlot SlotNum, tBoolean Start)
{
    tUint32 SlotBitmap = 0;

    SVCMGR_EVENT(IOM_CALL, "svc=%u sdp-id=%s inst=%u SlotNum=%u",
                 pSbindLoopBack->SvcId, smgrFmtSdpBndIdForDebug(&pSbindLoopBack->SdpBindId),
                 pSdpBnd->InstanceId, SlotNum);

    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);

    return(smgrSendSbindLoopBackMesgPriv(pSdpBnd, pSbindLoopBack, SlotBitmap, Start, FALSE));
}



/* Process a SME_SAP_BATCH_CALLBACK message */
PUBLIC void smgrProcessSapBatchCallback(tSMEventMsg *pMsg)
{
    tSMGenEventMsg *pGenMsg = (tSMGenEventMsg*)pMsg;
    queue_data_t   *pQueueHead;
    pQueueHead = &pGenMsg->u.SapBatchCallback.SapQueue;
    while (!queue_isempty(pQueueHead)) {
        queue_data_t   *pQueueItem;
        tSapRec        *pSap;
        pQueueItem = queue_first(pQueueHead);
        pSap = queue_coerce_field(pQueueItem, tSapRec *, SapCallbackLink);
        if (pSap->SapCallback) {
            (*pSap->SapCallback)(pSap, eSapBatchExecuted);
            pSap->SapCallback = NULL;
        }
        queue_remove(pQueueItem);
        queue_init(pQueueItem);
    }
}

PRIVATE void smgrGetSbmIesIfGroupIfRingNodeDownloadInfo(tSmgrMsgrIccInfo *pIccInfo, // Out
                                                        const  struct SMMcRingnodeRec *pRingnode,
                                                        tUint32 IomOp,
                                                        tUint32 SlotBitmap,
                                                        tBoolean IsCardOnline)
{
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SbmSubIesIfGroupIfRingNode,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccSbmIesIfGroupIfRingNodeCmp,
                          pRingnode);
}

/* Batch an IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD message */
PUBLIC tStatus smgrBatchMcRingRingnodeAddMesgPriv(struct SMMcRingnodeRec *pRingnode,
                                                  tUint32 SlotBitmap, tBoolean IsCardOnline,
                                                  tBatchProcessing *pBatch)
{
    tIomSapSubMixedEntry *pElm = NULL;
    tIomSubL3RedInterDestGroupConfig *pReqCfg;
    const eSapSubOp Op = IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD;
    tSmgrMsgrIccInfo IccInfo;
    
    SVCMGR_EVENT(IOM_CALL, "SRRP=%u ringnode=%s reachable=%s",
                 pRingnode->SrrpRec->SrrpId, pRingnode->Name,
                 pRingnode->Reachable ? "Yes" : "No");

    smgrGetSbmIesIfGroupIfRingNodeDownloadInfo(&IccInfo, pRingnode, Op,
                                               SlotBitmap,IsCardOnline);

    if (IccInfo.IomBitMask == 0) {
        return SUCCESS;
    }
    
    /* If the slots are different, flush any pending messages */
    if (IccInfo.IomBitMask != PrevSubL3RedInterDestGroupIdIomBitMask)
        smgrDoFlushMcRingRingnodeAddMesg(TRUE);
    

    /* If necessary, allocate our message */
    if (!pSubL3RedInterDestGroupReqMesg) {
        if ((pSubL3RedInterDestGroupReqMesg = SMGR_MESG_MEM_MALLOC(
                smgrMesgIccSapSubMsgSize(Op, SMMaxNumSubL3RedInterDestGroupIdEntriesPerMesg))) == NULL) {
            return FAIL;
        }
        pSubL3RedInterDestGroupReqMesg->NumEntries = 0;
    }

    
    pElm = smgrSapSubGetMixedEntryAddr(pSubL3RedInterDestGroupReqMesg, Op,
                                       NextSubL3RedInterDestGroupAddEntry);
    pElm->Op = Op;
    pReqCfg = &pElm->SubL3RedInterDestGroup;

    ZERO_STRUCT_PTR(pReqCfg);

    pReqCfg->InterfaceIndex = pRingnode->SrrpRec->GrpIf->PipIfInstanceId;
    pReqCfg->InterDestId = pRingnode->InstanceId;
    pReqCfg->IsLocallyReachable = pRingnode->Reachable;

    PrevSubL3RedInterDestGroupIdIomBitMask = IccInfo.IomBitMask;
    pSubL3RedInterDestGroupReqMesg->NumEntries++;
    NextSubL3RedInterDestGroupAddEntry++;

    if (pSubL3RedInterDestGroupReqMesg->NumEntries >= SMMaxNumSubL3RedInterDestGroupIdEntriesPerMesg) {
        smgrFlushMcRingRingnodeAddMesg();
        if (pBatch)
            pBatch->McRingRingnodeAddSent = FALSE;
    } else {
        if (pBatch)
            pBatch->McRingRingnodeAddSent = TRUE;
    }

    return SUCCESS;
}

/* Flush batched IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD messages */
PRIVATE tStatus smgrDoFlushMcRingRingnodeAddMesg(tBoolean PreFlush)
{
    tStatus rc = SUCCESS;
    tUint32 IomBitMask = PrevSubL3RedInterDestGroupIdIomBitMask;
    tSmgrMsgrIccInfo IccInfo;
    const eSapSubOp Op = IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD;
    
    if (!pSubL3RedInterDestGroupReqMesg)
        return SUCCESS;

    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_SbmSubIesIfGroupIfRingNode, Op);
    
    SVCMGR_EVENT(IOM_CALL, "entries=%u mask =%08x",
                 pSubL3RedInterDestGroupReqMesg->NumEntries,
                 PrevSubL3RedInterDestGroupIdIomBitMask);

    if (pSubL3RedInterDestGroupReqMesg->NumEntries > 0) {
        SMGR_MESG_UPDATE_STATS(&IccInfo, pSubL3RedInterDestGroupReqMesg, PreFlush);
        pSubL3RedInterDestGroupReqMesg->TotalLength
            = smgrMesgIccSapSubMsgSize(Op, pSubL3RedInterDestGroupReqMesg->NumEntries);
        
        rc = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op,
                                     IomBitMask, pSubL3RedInterDestGroupReqMesg, 
                                     pSubL3RedInterDestGroupReqMesg->TotalLength,
                                     NULL, SMGR_DNDLER_MAY_BLOCK);
        if (rc != SUCCESS)
            SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IomBitMask);
        
        smgrFreeClientMsg(pSubL3RedInterDestGroupReqMesg, rc);
        
        /* Start a new batch */
        pSubL3RedInterDestGroupReqMesg = NULL;
        NextSubL3RedInterDestGroupAddEntry = 0;
    }
    return rc;
}

PUBLIC tStatus smgrFlushMcRingRingnodeAddMesg(void)
{
    return smgrDoFlushMcRingRingnodeAddMesg(FALSE);
}

/* Send an IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD message*/
PUBLIC tStatus smgrSendMcRingRingnodeAddMesg(struct SMMcRingnodeRec *pRingnode, tUint32 SlotNum)
{
    SVCMGR_EVENT(IOM_CALL, "SRRP=%u ringnode=%s", pRingnode->SrrpRec->SrrpId, pRingnode->Name);

    /* Flush old messages, if any */
    if (smgrDoFlushMcRingRingnodeAddMesg(TRUE) != SUCCESS) {
        return FAIL;
    }
    
    /* Batch then flush the new message */
    if (smgrBatchMcRingRingnodeAddMesg(pRingnode, SlotNum, NULL) != SUCCESS) {
        return FAIL;
    }
    
    if (smgrFlushMcRingRingnodeAddMesg() != SUCCESS)
        return FAIL;

    return SUCCESS;
}

/* Send an IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE message */
PUBLIC tStatus smgrSendMcRingRingnodeDelMesg(struct SMMcRingnodeRec *pRingnode, tUint32 SlotNum)
{
    tIomSapSubMixedRequest *pReq = NULL;
    const eSapSubOp Op = IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE;
    tStatus rc = SUCCESS;
    tSmgrMsgrIccInfo IccInfo;
    tUint32 SlotBitmap=0;
    
    SVCMGR_EVENT(IOM_CALL, "SRRP=%u ringnode=%s", pRingnode->SrrpRec->SrrpId, pRingnode->Name);
    
    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);
    smgrGetSbmIesIfGroupIfRingNodeDownloadInfo(&IccInfo, pRingnode, Op,
                                               SlotBitmap,FALSE);
    if (IccInfo.IomBitMask == 0)
        return SUCCESS;

    pReq = SMGR_MESG_MEM_MALLOC(smgrMesgIccSapSubMsgSize(Op, 1));
    if (pReq == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Cannot alloc mem for IOM request");
        return FAIL;
    }

    pReq->NumEntries = 1;
    pReq->Entries[0].Op = Op;
    ZERO_STRUCT(pReq->Entries[0].SubL3RedInterDestGroup);
    pReq->Entries[0].SubL3RedInterDestGroup.InterfaceIndex = pRingnode->SrrpRec->GrpIf->PipIfInstanceId;
    pReq->Entries[0].SubL3RedInterDestGroup.InterDestId = pRingnode->InstanceId;

    SMGR_MESG_UPDATE_STATS(&IccInfo, pReq, FALSE);
    pReq->TotalLength = smgrMesgIccSapSubMsgSize(Op, pReq->NumEntries);

    rc = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, Op, IccInfo.IomBitMask, pReq,
                                 pReq->TotalLength, NULL, SMGR_DNDLER_BLOCK);
    if (rc != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "IOM download failed for mask=%08x !", IccInfo.IomBitMask);
    
    smgrFreeClientMsg(pReq, rc);

    return rc;
}

/* Send an IOM_SVC_SYS_WIDE_UPDATE message */
PUBLIC tStatus smgrSendSvcSysWideUpdateMesgPriv(tUint32 SlotBitmap, tBoolean IsCardOnline)
{
    tIomSvcConfigRequest *pMsg;
    int i;
    tSmgrMsgrIccInfo IccInfo;
    tStatus s = SUCCESS;

    SVCMGR_EVENT(IOM_CALL, "SysWideUpdate");
                 
    smgrMsgrGetIccBitMask(&IccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_SysWide,
                          IOM_SVC_SYS_WIDE_UPDATE,
                          SlotBitmap,
                          IsCardOnline,
                          FALSE,
                          smgrMesgOkCmp,
                          NULL);

    if (IccInfo.IomBitMask == 0) {
        return SUCCESS;
    }
    
    if ((pMsg = SMGR_MESG_MEM_MALLOC(SIZE_SVC_REQUEST_MSG(IOM_SVC_SYS_WIDE_UPDATE, 1))) == NULL) {
        TRACE_UNUSUALEVENT(MOD_SVCMGR, IOM_CALL, "Unable to obtain memory for SVC system-wide update");
        return FAIL;
    }
    
    pMsg->Op = IOM_SVC_SYS_WIDE_UPDATE;
    pMsg->NumEntries = 1;

    ZERO_STRUCT(pMsg->u.System);
    pMsg->u.System.IntfTapMap.ServiceIntfTapMap = SMSvcIntfTapMap;
    for (i = 0; i < PIP_MAX_NET_DOMAINS; i++) {        
        pMsg->u.System.IntfTapMap.NetworkIntfTapMap[i] = SMNetIntfTapMap[i];
    }
    pMsg->u.System.QinQUntagged.NewQinqUntaggedSap = smgrNewQinqUntaggedSap;
    pMsg->u.System.TlsLearning.RelearnOnly = TlsFdbRelearnOnly;

    oamGetOamChassisMacAddr(&pMsg->u.System.CpePingMac.ChassisMacAddr);
    
    /* Send to all IOMS*/
    SMGR_MESG_UPDATE_STATS(&IccInfo, pMsg, FALSE);
    
    s = smgrSendClientMsgToIoms(IccInfo.pMsgrEntry->IccSocket, pMsg->Op, IccInfo.IomBitMask,
                                pMsg, SIZE_SVC_REQUEST_MSG(pMsg->Op, pMsg->NumEntries),
                                NULL, SMGR_DNDLER_MAY_BLOCK);
    if (s != SUCCESS)
        SVCMGR_ERROR(NOCLASS, "smgrSendClientMsgToIoms() failed for mask %08x",
                     IccInfo.IomBitMask);

    smgrFreeClientMsg(pMsg, s);

    return s;
}

////////////////////////////////////////////////////////////////////////////////

PRIVATE tStatus smgrMesgPre(void)
{
    smgrLock();
    return OK;
}

PRIVATE tStatus smgrMesgPost(void)
{
    smgrUnlock();
    return OK;
}

PRIVATE tStatus smgrMesgOkCmp(const void *pLastKey,
                              tUint32 IomOp,
                              void *p)
{
    return OK;
}
////////////////////////////////////////////////////////////////////////////////
// DpiIp - ICC_SOCKET_DPI_IP_TABLE 

PRIVATE tStatus smgrMesgIccDpiIpCmp(const void *pLastKey,
                                    tUint32 IomOp)

{
    // Currently handled outside of smgr_msgr
    return OK;
   
}
PRIVATE tStatus smgrMesgDpiIpUpdate(tUint32     SlotBitmap, /* In: */
                                    tBoolean  First,   /* In: */
                                    void     *pKey,    /* In/Out: */
                                    tBoolean *pMore)   /* Out: returns if there is more data */
{
    // Currently handled outside of smgr_msgr
    *pMore = FALSE; 
    return OK;
}

////////////////////////////////////////////////////////////////////////////////
// DpiPrefix - ICC_SOCKET_DPI_PREFIX_FILTERS

PRIVATE tStatus smgrMesgIccDpiPrefixCmp(const void *pLastKey,
                                    tUint32 IomOp)

{
    // Currently handled outside of smgr_msgr
    return OK;   
}

PRIVATE tStatus smgrMesgDpiPrefixUpdate(tUint32     SlotBitmap, /* In: */
                                        tBoolean    First,      /* In: */
                                        void       *pKey,       /* In/Out: */
                                        tBoolean   *pMore)      /* Out: returns if there is more data */
{
    // Currently handled outside of smgr_msgr
    *pMore = FALSE; 
    return OK;
}


////////////////////////////////////////////////////////////////////////////////
// Sdp - ICC_SOCKET_SDP_BINDING_STATS
PRIVATE tStatus smgrMesgSdpBindStatsUpdate(tUint32     SlotBitmap, /* In: */
                                           tBoolean  First,   /* In: */
                                           void     *pKey,    /* In/Out: */
                                           tBoolean *pMore)   /* Out: returns if there is more data */
{

    *pMore = FALSE; 
    return OK;
}    

////////////////////////////////////////////////////////////////////////////////
// SysWide - ICC_SOCKET_SVC_TABLE - 
PRIVATE tStatus smgrMesgSvcSysWideUpdate(tUint32     SlotBitmap, /* In: */
                                         tBoolean  First,   /* In: */
                                         void     *pKey,    /* In/Out: */
                                         tBoolean *pMore)   /* Out: returns if there is more data */
{
    smgrSendSvcSysWideUpdateMesgPriv(SlotBitmap, TRUE);
    *pMore = FALSE;
    return OK;
}

////////////////////////////////////////////////////////////////////////////////
// L2tp - ICC_SOCKET_SVC_SDP_TABLE - just calls their download function

PUBLIC void smgrMesgL2tpSdpDownloadInfoGet(struct SmgrMsgrIccInfo *pIccInfo, // Out
                                           const struct tL2tpPeerAddress *pAddress,
                                           tUint32 IomOp,
                                           tUint32 SlotBitmap,
                                           tBoolean IsCardOnline,
                                           tL2tpSdpCmpFn CmpFn)
{
    if (SlotBitmap == L2TP_ALL_APPLICABLE_SLOTS) {
        SlotBitmap = ALL_APPLICABLE_IOMS;
    }
    smgrMsgrGetIccBitMask(pIccInfo, pSmgrIccMsgr,
                          SmgrMsgrEntry_L2tp,
                          IomOp, SlotBitmap,
                          IsCardOnline, FALSE,
                          (CmpFn), pAddress);

    if (pIccInfo->IomBitMask && pIccInfo->pStats) {
        pIccInfo->pStats->EntryUpdate++;
    }
}

PUBLIC void smgrMesgL2tpSdpIncrMesgStat(tUint32 IomOp)
{
    tSmgrMsgrIccInfo IccInfo;
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_L2tp,
                               IomOp);    
    if (IccInfo.pStats) {
        IccInfo.pStats->MesgUpdate++;
    }
}

PRIVATE tStatus smgrMesgL2tpUpdate(tUint32     SlotBitmap, /* In: */
                                   tBoolean  First,   /* In: */
                                   void     *pKey,    /* In/Out: */
                                   tBoolean *pMore)   /* Out: returns if there is more data */
{
    return l2tpCardOnLineUpdateForSdp(
        SlotBitmap, First,
        (struct tL2tpPeerAddress *)pKey,
        pMore);
}

////////////////////////////////////////////////////////////////////////////////
// SBMGTP - ICC_SOCKET_SVC_SDP_TABLE - just calls their download function

PUBLIC void smgrMesgGtpSdpDownloadInfoGet(struct SmgrMsgrIccInfo *pIccInfo, // Out
                                          const struct tGtpApiPeerAddress *pAddress,
                                          tUint32 IomOp,
                                          tUint32 SlotBitmap,
                                          tBoolean IsCardOnline,
                                          tGtpApiSdpCmpFn CmpFn)
{
    if (SlotBitmap == GTPAPI_ALL_APPLICABLE_SLOTS) {
        SlotBitmap = ALL_APPLICABLE_IOMS;
    }
    smgrMsgrGetIccBitMask(pIccInfo, pSmgrIccMsgr,
                          SmgrMsgrEntry_Gtp,
                          IomOp, SlotBitmap,
                          IsCardOnline, FALSE,
                          (CmpFn), pAddress);

    if (pIccInfo->IomBitMask && pIccInfo->pStats) {
        pIccInfo->pStats->EntryUpdate++;
    }
}

PUBLIC void smgrMesgGtpSdpIncrMesgStat(tUint32 IomOp)
{
    tSmgrMsgrIccInfo IccInfo;
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_Gtp,
                               IomOp);
    if (IccInfo.pStats) {
        IccInfo.pStats->MesgUpdate++;
    }
}

PRIVATE tStatus smgrMesgGtpUpdate(tUint32    SlotBitmap, /* In: */
                                   tBoolean  First,   /* In: */
                                   void     *pKey,    /* In/Out: */
                                   tBoolean *pMore)   /* Out: returns if there is more data */
{
    return gtpApiCardOnLineUpdateForSdp(
        SlotBitmap, First,
        (struct tGtpApiPeerAddress *)pKey,
        pMore);
}

////////////////////////////////////////////////////////////////////////////////
// SDPs - ICC_SOCKET_SVC_SDP_TABLE

typedef struct {
    tSdpId Id;
} tSmgrMesgSdp;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgSdpCmp(const void *pLastKey,
                               tUint32 IomOp,
                               const tSdpRec *pSdp)
{
    tSmgrMesgSdp *pLast = (tSmgrMesgSdp*) pLastKey;

    switch (IomOp) {
    case IOM_SDP_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLast->Id > pSdp->Id)
        return OK;
    
    if (pLast->Id < pSdp->Id)
        return ERROR;
    return OK;
}

PRIVATE tStatus smgrMesgSdpUpdate(tUint32     SlotBitmap, /* In: */
                                  tBoolean  First,   /* In: */
                                  void     *pKey,    /* In/Out: */
                                  tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgSdp *pSdpKey = (tSmgrMesgSdp*) pKey;
    tSdpRec *pSdp;
    
    if (First) {
        pSdpKey->Id = NULL_SDP_ID;
    }

    do {
        pSdp = sdpFindNextRec(pSdpKey->Id);
        if (pSdp) {
            pSdpKey->Id = pSdp->Id;
        }
    } while (pSdp && (sdpGetFarEnd(pSdp, NULL, TRUE /* TunnelFarEnd */) != SUCCESS));

    if (pSdp) {
        // Send to the IOM
        smgrBatchSdpAddMesgPriv(pSdp, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pSdpKey->Id = pSdp->Id;
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgSdpDump(const void *pLastKey)
{
    const tSmgrMesgSdp *pLast = (tSmgrMesgSdp*) pLastKey;
    printf ("Sdp %u", pLast->Id);
}


////////////////////////////////////////////////////////////////////////////////
// QOS scheduler Policy - ICC_SOCKET_QOS_POLICY_SCHEDULER_TABLE

typedef struct {
    unsigned char Name[MAXSIZE_TNamedItem + 1];
} tSmgrMesgQosPolicyName;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosSchedPolCmp(const void *pLastKey,
                                       tUint32 IomOp,
                                       const tQosSchedPolRec *pPol)
{
   char *pLastPolName = ((tSmgrMesgQosPolicyName*)pLastKey)->Name;
   char* pNewPolName;
   int rc;
    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }

    pNewPolName = (char*)pPol->Name;
    rc = strcmp(pLastPolName,pNewPolName);
    return ((rc >= 0) ? OK : ERROR);

}

PRIVATE tStatus smgrMesgQosSchedPolUpdate(tUint32     SlotBitmap, /* In: */
                                  tBoolean  First,   /* In: */
                                  void     *pKey,    /* In/Out: */
                                  tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosPolicyName *pPolKey = (tSmgrMesgQosPolicyName*) pKey;
    tQosSchedPolRec *pPol = NULL;
    
    if (First) 
        pPol = qosFindNextSchedPolRec("");
    else 
        pPol = qosFindNextSchedPolRec(pPolKey->Name);
   
    if (pPol) {
        // Send to the IOM
        smgrSendQosSchedPolicyAddMesgPriv(pPol, SlotBitmap, TRUE);
        snprintf(pPolKey->Name,sizeof(tSmgrMesgQosPolicyName),"%s",pPol->Name);
        *pMore = TRUE;
        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosSchedPolDump(const void *pLastKey)
{
    const tSmgrMesgQosPolicyName *pLast = (tSmgrMesgQosPolicyName*) pLastKey;
    printf ("Qos Sched Policy: %s", pLast->Name);
}


////////////////////////////////////////////////////////////////////////////////
// QOS Policer control Policy - ICC_SOCKET_QOS_POLICY_ARBITER_TABLE

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosPolicerCtrlPolCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const tQosPolicerCtrlPolRec *pPol)
{
     char *pLastPolName = ((tSmgrMesgQosPolicyName*)pLastKey)->Name;
     char *pNewPolName;
     int rc;
     
    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    pNewPolName = (char*)pPol->Name;
    
    rc = strcmp(pLastPolName,pNewPolName);
    return ((rc >= 0) ? OK : ERROR);

}

PRIVATE tStatus smgrMesgQosPolicerCtrlPolUpdate(tUint32     SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosPolicyName *pPolKey = (tSmgrMesgQosPolicyName*) pKey;
    tQosPolicerCtrlPolRec *pPol = NULL;
    
    if (First) 
        pPol = qosFindNextPolicerCtrlPolRec("");
    else 
        pPol = qosFindNextPolicerCtrlPolRec(pPolKey->Name);
    
    if (pPol) {
        // Send to the IOM
         smgrSendQosPolicerCtrlPolAddMesgPriv(pPol, SlotBitmap,TRUE);
         snprintf(pPolKey->Name,sizeof(tSmgrMesgQosPolicyName),"%s",pPol->Name);
         *pMore = TRUE;
        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosPolicerCtrlPolDump(const void *pLastKey)
{
    const tSmgrMesgQosPolicyName *pLast = (tSmgrMesgQosPolicyName*) pLastKey;
    printf ("Qos Policer Control Policy: %s", pLast->Name);
}

////////////////////////////////////////////////////////////////////////////////
// QOS Sap Ingress policy - ICC_SOCKET_QOS_POLICY_INGRESS_SAP_BASE_TABLE

typedef struct {
    tUint32 Id;
} tSmgrMesgQosSapPolicy;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosSapIngPolCmp(const void *pLastKey,
                                        tUint32 IomOp,
                                        const tSapIngQosPolRec *pPol)
{
    tSmgrMesgQosSapPolicy *pLastPol = (tSmgrMesgQosSapPolicy*)pLastKey;
    

    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLastPol->Id > pPol->Id)
        return OK;
    
    if (pLastPol->Id  < pPol->Id)
        return ERROR;
    
    return OK;
   
}

PRIVATE tStatus smgrMesgQosSapIngPolUpdate(tUint32     SlotBitmap, /* In: */
                                           tBoolean  First,   /* In: */
                                           void     *pKey,    /* In/Out: */
                                           tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosSapPolicy *pPolKey = (tSmgrMesgQosSapPolicy*) pKey;
    tSapIngQosPolRec *pPol = NULL;
    
    if (First) 
        pPol = qosFindNextSapIngPolRec(NULL);
    else 
        pPol = qosFindNextSapIngPolRec(pPolKey->Id);
    
    if (pPol) {
        // Send to the IOM
        smgrSendSapIngQosPolicyAddMesgPriv(pPol, FALSE, SlotBitmap, TRUE);
        pPolKey->Id = pPol->Id;
        *pMore = TRUE;        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosSapIngPolDump(const void *pLastKey)
{
    const tSmgrMesgQosSapPolicy *pLast = (tSmgrMesgQosSapPolicy*) pLastKey;
    printf ("Qos Sap Ingress Policy Id: %u", pLast->Id);
}

///////////////////////////////////////////////////////////////////////////////
// QOS Sap Ingress policy Mac Filters - ICC_SOCKET_QOS_POLICY_INGRESS_SAP_MAC_FILTER_TABLE

typedef struct {
    tUint32 PolId;
    tUint32 FilterId;
} tSmgrMesgQosSapIngPolicyFilter;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosSapIngPolMacFilterCmp(const void *pLastKey,
                                                 tUint32 IomOp,
                                                 const tSapIngQosPolRec *pPol, 
                                                 int ruleNum)
{
    tSmgrMesgQosSapIngPolicyFilter *pKey = (tSmgrMesgQosSapIngPolicyFilter*)pLastKey;
    

    if (pKey->PolId > pPol->Id)
        return OK;
    
    if (pKey->PolId  < pPol->Id)
        return ERROR;

    if (pKey->FilterId > ruleNum)
        return OK;
    
    if (pKey->FilterId < ruleNum)
        return ERROR;
    
    return OK;
   
}

PRIVATE tStatus smgrMesgQosSapIngPolMacFilterUpdate(tUint32     SlotBitmap, /* In: */
                                                    tBoolean  First,   /* In: */
                                                    void     *pKey,    /* In/Out: */
                                                    tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosSapIngPolicyFilter *pPolKey = (tSmgrMesgQosSapIngPolicyFilter*) pKey;
    tSapIngQosPolRec *pPol = NULL;
    tSapIngQosPolMacRuleRec *pRule = NULL;
    
    if (First) {
        pPol = qosFindNextSapIngPolRec(NULL);
        if (pPol) {
            avlpFirst(&pPol->MacRules, NULL, (void **)&pRule);
        }
    } else  {
        pPol = qosFindSapIngPolRecById(pPolKey->PolId);
        if (pPol) {
            avlpNext(&pPol->MacRules, AVL_CAST_INT_TO_KEY(pPolKey->FilterId),NULL,(void **)&pRule);
        } else {
            /* The policy was probably deleted . Get the next filter */
            pPol = qosFindNextSapIngPolRec(pPolKey->PolId);
            if (pPol) {
                avlpFirst(&pPol->MacRules, NULL, (void **)&pRule);
            }
        }
       
    }    
    while(!pRule && pPol) {
        pPol = qosFindNextSapIngPolRec(pPol->Id);
        if (pPol) {
            avlpFirst(&pPol->MacRules, NULL, (void **)&pRule);
        }
    }
    
    if (pRule) {
        // Send to the IOM
        smgrBatchSapIngQosPolMacRuleAddMesg(pPol,pRule,SlotBitmap,TRUE);
        pPolKey->PolId = pPol->Id;
        pPolKey->FilterId = pRule->Id;
        *pMore = TRUE;        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosSapIngPolMacFilterDump(const void *pLastKey)
{
    const tSmgrMesgQosSapIngPolicyFilter *pLast = (tSmgrMesgQosSapIngPolicyFilter*) pLastKey;
    printf ("Qos Sap Ingress Policy Id: %u Mac Filter Id: %u \n", pLast->PolId,pLast->FilterId);
}

///////////////////////////////////////////////////////////////////////////////
// QOS Sap Ingress policy Ip Filters - ICC_SOCKET_QOS_POLICY_INGRESS_SAP_IP_FILTER_TABLE

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosSapIngPolIpFilterCmp(const void *pLastKey,
                                                tUint32 IomOp,
                                                const tSapIngQosPolRec *pPol, 
                                                int ruleNum)
{
    tSmgrMesgQosSapIngPolicyFilter *pKey = (tSmgrMesgQosSapIngPolicyFilter*)pLastKey;
    

    if (pKey->PolId > pPol->Id)
        return OK;
    
    if (pKey->PolId  < pPol->Id)
        return ERROR;

    if (pKey->FilterId > ruleNum)
        return OK;
    
    if (pKey->FilterId < ruleNum)
        return ERROR;
    
    return OK;
   
}

PRIVATE tStatus smgrMesgQosSapIngPolIpFilterUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosSapIngPolicyFilter *pPolKey = (tSmgrMesgQosSapIngPolicyFilter*) pKey;
    tSapIngQosPolRec *pPol = NULL;
    tSapIngQosPolIpRuleRec *pRule = NULL;
    
    if (First) {
        pPol = qosFindNextSapIngPolRec(NULL);
        if (pPol) {
            avlpFirst(&pPol->IpRules, NULL, (void **)&pRule);
        }
    } else  {
        pPol = qosFindSapIngPolRecById(pPolKey->PolId);
        if (pPol) {
            avlpNext(&pPol->IpRules, AVL_CAST_INT_TO_KEY(pPolKey->FilterId),NULL,(void **)&pRule);
        } else {
            /* The policy was probably deleted . Get the next filter */
            pPol = qosFindNextSapIngPolRec(pPolKey->PolId);
            if (pPol) {
                avlpFirst(&pPol->IpRules, NULL, (void **)&pRule);
            }    
        }
    }   
 
    while(!pRule && pPol) {
         pPol = qosFindNextSapIngPolRec(pPol->Id);
         if (pPol) {
             avlpFirst(&pPol->IpRules, NULL, (void **)&pRule);
         }
    }
    
    if (pRule) {
        // Send to the IOM
        smgrBatchSapIngQosPolIpRuleAddMesg(pPol,pRule,SlotBitmap,TRUE);
        pPolKey->PolId = pPol->Id;
        pPolKey->FilterId = pRule->Id;
        *pMore = TRUE;        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosSapIngPolIpFilterDump(const void *pLastKey)
{
    const tSmgrMesgQosSapIngPolicyFilter *pLast = (tSmgrMesgQosSapIngPolicyFilter*) pLastKey;
    printf ("Qos Sap Ingress Policy Id: %u IP Filter Id: %u \n", pLast->PolId,pLast->FilterId);
}

///////////////////////////////////////////////////////////////////////////////
// QOS Sap Egress policy Ip Filters - ICC_SOCKET_QOS_POLICY_Egress_SAP_IP_FILTER_TABLE

typedef struct {
    tUint32 PolId;
    tSapEgrQosPolIpRuleId RuleId;
} tSmgrMesgQosSapEgrPolicyFilter;


// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosSapEgrPolIpFilterCmp(const void *pLastKey,
                                                tUint32 IomOp,
                                                const tSapEgrQosPolRec *pPol, 
                                                const tSapEgrQosPolIpRuleId *pRuleId)
{
    tSmgrMesgQosSapEgrPolicyFilter *pKey = (tSmgrMesgQosSapEgrPolicyFilter*)pLastKey;
    

    if (pKey->PolId > pPol->Id)
        return OK;
    
    if (pKey->PolId  < pPol->Id)
        return ERROR;

    if (pKey->RuleId.FltrType > pRuleId->FltrType)
        return OK;

    if (pKey->RuleId.FltrType < pRuleId->FltrType)
        return ERROR;

    if (pKey->RuleId.EntryId > pRuleId->EntryId)
        return OK;

    if (pKey->RuleId.EntryId < pRuleId->EntryId)
        return ERROR;
    
    return OK;
   
}

PRIVATE tStatus smgrMesgQosSapEgrPolIpFilterUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosSapEgrPolicyFilter *pPolKey = (tSmgrMesgQosSapEgrPolicyFilter*) pKey;
    tSapEgrQosPolRec *pPol = NULL;
    tSapEgrQosPolIpRuleRec *pRule = NULL;
    
    if (First) {
        pPol = qosFindNextSapEgrPolRec(NULL);
        if (pPol) {
            avlpFirst(&pPol->IpRules, NULL, (void **)&pRule);
        }
    } else  {
        pPol = qosFindSapEgrPolRecById(pPolKey->PolId);
        if (pPol) {
            avlpNext(&pPol->IpRules,(char*)&pPolKey->RuleId,NULL,(void **)&pRule);
        } else {
            /* The policy was probably deleted . Get the next filter */
            pPol = qosFindNextSapEgrPolRec(pPolKey->PolId);
            if (pPol) {
                avlpFirst(&pPol->IpRules, NULL, (void **)&pRule);
            }
        }
       
    }    
 
    while(!pRule && pPol) {
        pPol = qosFindNextSapEgrPolRec(pPol->Id);
        if (pPol) {
            avlpFirst(&pPol->IpRules, NULL, (void **)&pRule);
        }
    }
    
    if (pRule) {
        // Send to the IOM
        smgrBatchSapEgrQosPolIpRuleAddMesg(pPol,pRule,SlotBitmap,TRUE);
        pPolKey->PolId = pPol->Id;
        pPolKey->RuleId = pRule->Id;
        *pMore = TRUE;        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosSapEgrPolIpFilterDump(const void *pLastKey)
{
    const tSmgrMesgQosSapEgrPolicyFilter *pLast = (tSmgrMesgQosSapEgrPolicyFilter*) pLastKey;
    printf ("Qos Sap Egress Policy Id: %u IP Rule Filtertype: %u EntryId: %d \n",
            pLast->PolId, pLast->RuleId.FltrType,pLast->RuleId.EntryId);
}

////////////////////////////////////////////////////////////////////////////////
// QOS Sap Egress policy - ICC_SOCKET_QOS_POLICY_EGRESS_SAP_TABLE

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgQosSapEgrPolCmp(const void *pLastKey,
                                        tUint32 IomOp,
                                        const tSapEgrQosPolRec *pPol)
{
    tSmgrMesgQosSapPolicy *pLastPol = (tSmgrMesgQosSapPolicy*)pLastKey;


    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLastPol->Id > pPol->Id)
        return OK;
    
    if (pLastPol->Id  < pPol->Id)
        return ERROR;
    
    return OK;
   
}

PRIVATE tStatus smgrMesgQosSapEgrPolUpdate(tUint32   SlotBitmap, /* In: */
                                           tBoolean  First,   /* In: */
                                           void     *pKey,    /* In/Out: */
                                           tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgQosSapPolicy *pPolKey = (tSmgrMesgQosSapPolicy*) pKey;
    tSapEgrQosPolRec *pPol = NULL;
    
    if (First) 
        pPol = qosFindNextSapEgrPolRec(NULL);
    else 
        pPol = qosFindNextSapEgrPolRec(pPolKey->Id);
    
    if (pPol) {
        // Send to the IOM
         smgrSendSapEgrQosPolicyAddMesgPriv(pPol, FALSE, SlotBitmap,TRUE);
         pPolKey->Id = pPol->Id;
         *pMore = TRUE;
        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgQosSapEgrPolDump(const void *pLastKey)
{
    const tSmgrMesgQosSapPolicy *pLast = (tSmgrMesgQosSapPolicy*) pLastKey;
    printf ("Qos Sap Egress Policy Id: %u", pLast->Id);
}

////////////////////////////////////////////////////////////////////////////////
// Qos MSS - ICC_SOCKET_QOS_MULTI_SERVICE_SITE_TABLE

typedef struct {
    tCustId Id;
    char    MssName[SERV_OBJ_NAME_ARRAY_SIZE];
} tSmgrMesgCustMssKey;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgCustMssCmp(const void *pLastKey,
                                   tUint32 IomOp,
                                   const tMssRec *pUpdateMss)
{
    tSmgrMesgCustMssKey *pLast = (tSmgrMesgCustMssKey*) pLastKey;
    int i;

    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLast->Id > pUpdateMss->CustRec->Id)
        return OK;
    
    if (pLast->Id < pUpdateMss->CustRec->Id)
        return ERROR;

    i = strcmp(pLast->MssName, pUpdateMss->Name);
    if (i > 0) {
        return OK;
    }
    if (i < 0) {
        return ERROR;
    }

    return OK;
}


PRIVATE tStatus smgrMesgCustMssUpdate(tUint32   SlotBitmap, /* In: */
                                      tBoolean  First,   /* In: */
                                      void     *pKey,    /* In/Out: */
                                      tBoolean *pMore)   /* Out: returns if there is more data */
{
    tMssRec *pMss = NULL;
    tSmgrMesgCustMssKey *pMssKey = (tSmgrMesgCustMssKey*) pKey;
    
    if (First) {
        pMss = custMssFindNextRecById(SIA_FIRST_VALUE, 0, NULL, NULL);
    } else {
        pMss = custMssFindNextRecById(SIA_NEXT_VALUE, pMssKey->Id,
                                      pMssKey->MssName, NULL);
    }
    
    if (pMss) {
        // Send to the IOM
        smgrBatchMultSvcSiteAddMesgPriv(pMss, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pMssKey->Id = pMss->CustRec->Id;
        strcpyn(pMssKey->MssName, sizeof(pMssKey->MssName), pMss->Name);
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    
    return OK;
}


PRIVATE void smgrMesgCustMssDump(const void *pLastKey)
{
    const tSmgrMesgCustMssKey *pLast = (tSmgrMesgCustMssKey*) pLastKey;
    printf ("Cust %u MssName %s", pLast->Id, pLast->MssName);
}

PRIVATE void smgrCustMssShow(void) {
    tMssRec *pMss;
    tUint32 i;
    smgrLock();
    for (i = 0, pMss = custMssFindNextRecById(SIA_FIRST_VALUE, 0, NULL, NULL);
         pMss;
         pMss = custMssFindNextRecById(SIA_NEXT_VALUE, pMss->CustRec->Id,
                                      pMss->Name, NULL), i++) {
        printf ("%02u Cust %u MssName %s\n", i,
                pMss->CustRec->Id,
                pMss->Name);
    }
    smgrUnlock();
}


////////////////////////////////////////////////////////////////////////////////
// Qos Mss Sched Ov - ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE

typedef struct {
    tCustId  Id;
    char     MssName[SERV_OBJ_NAME_ARRAY_SIZE];
    int      Direction;
    char     OverrideName[USER_SCHEDULER_NAME_LEN];
} tSmgrMesgCustMssVsOvKey;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgCustMssVsOvCmp(const void *pLastKey,
                                       tUint32 IomOp,
                                       const tMssRec *pUpdateMss,
                                       int Direction,
                                       const tQosVSchedOverrideRec *pVSched)
{
    tSmgrMesgCustMssVsOvKey *pLast = (tSmgrMesgCustMssVsOvKey*) pLastKey;
    int i;

    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLast->Id > pUpdateMss->CustRec->Id)
        return OK;
    
    if (pLast->Id < pUpdateMss->CustRec->Id)
        return ERROR;

    i = strcmp(pLast->MssName, pUpdateMss->Name);
    if (i > 0)
        return OK;
    if (i < 0)
        return ERROR;

    if (pLast->Direction > Direction)
        return OK;
            
    if (pLast->Direction < Direction)
        return ERROR;

    i = strcmp(pLast->OverrideName, pVSched->Name.Str);
    if (i > 0)
        return OK;
    if (i < 0)
        return ERROR;
   
    return OK;
}

PRIVATE tStatus smgrMesgCustMssVsOvUpdate(tUint32   SlotBitmap, /* In: */
                                          tBoolean  First,   /* In: */
                                          void     *pKey,    /* In/Out: */
                                          tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgCustMssVsOvKey *pMssVsOvKey = (tSmgrMesgCustMssVsOvKey*) pKey;
    tQosVSchedOverrideRec *pVSRec;
    tMssRec *pMss;
    int Direction;
    tBatchProcessing Batch = {0};

    Batch.Batch = TRUE;
    
    if (First) {
        pVSRec = custMssVSoverrideFindNextRecById(0,"",CUST_MSS_ING_SCHED,"",
                                                  &pMss, &Direction);
    } else {
        pVSRec = custMssVSoverrideFindNextRecById(pMssVsOvKey->Id,
                                                  pMssVsOvKey->MssName,
                                                  pMssVsOvKey->Direction,
                                                  pMssVsOvKey->OverrideName,
                                                  &pMss, &Direction);
    }
    
    if (pVSRec) {
        // Send to the IOM
        smgrSendMssVSOverrideAddMesgPriv(pMss, Direction, pVSRec, SlotBitmap, &Batch, TRUE);
        // No flush is done at this point. SmgrMsgr will flush at the end

        pMssVsOvKey->Id = pMss->CustRec->Id;                
        strcpyn(pMssVsOvKey->MssName, sizeof(pMssVsOvKey->MssName), pMss->Name);
        pMssVsOvKey->Direction = Direction;
        strcpyn(pMssVsOvKey->OverrideName,
                sizeof(pMssVsOvKey->OverrideName), pVSRec->Name.Str);        
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    
    return OK;
}

PRIVATE void smgrMesgCustMssVsOvDump(const void *pLastKey)
{
    const tSmgrMesgCustMssVsOvKey *pLast = (tSmgrMesgCustMssVsOvKey*) pLastKey;
    printf ("Cust %u MssName %s %s VsOName %s",
            pLast->Id, pLast->MssName,
            pLast->Direction == CUST_MSS_ING_SCHED ? "Ing" : "Egr",
            pLast->OverrideName);
}


PRIVATE void smgrCustMssVsOvShow(void) {
    tQosVSchedOverrideRec *pVSRec;
    tMssRec *pMss;
    int Direction;
    tUint32 i;
    smgrLock();
    for (i = 0, pVSRec = custMssVSoverrideFindNextRecById(0,"",CUST_MSS_ING_SCHED,"",
                                                  &pMss, &Direction);
         pVSRec;
         pVSRec = custMssVSoverrideFindNextRecById(pMss->CustRec->Id,
                                                   pMss->Name,
                                                   Direction,
                                                   pVSRec->Name.Str,
                                                   &pMss, &Direction), i++) {
        printf ("%02u Cust %u MssName %s %s VsOName %s\n", i,
                pMss->CustRec->Id,
                pMss->Name,
                Direction == CUST_MSS_ING_SCHED ? "Ing" : "Egr",
                pVSRec->Name.Str);        
    }
    smgrUnlock();
}

////////////////////////////////////////////////////////////////////////////////
// Egress Multicast Groups - ICC_SOCKET_TLS_EMG_TABLE

typedef struct {
    char Name[SERV_OBJ_NAME_ARRAY_SIZE];
} tSmgrMesgEmg;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgEmgCmp(const void *pLastKey,
                               tUint32 IomOp,
                               const tTlsEmgRec *pEmg)
{
    tSmgrMesgEmg *pLast = (tSmgrMesgEmg*) pLastKey;
    int i;

    switch (IomOp) {
    case IOM_EMG_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    i = strcmp(pLast->Name, pEmg->Name);
    if (i > 0) {
        return OK;
    }
    if (i < 0) {
        return ERROR;
    }

    return OK;
}

PRIVATE tStatus smgrMesgEmgUpdate(tUint32   SlotBitmap, /* In: */
                                  tBoolean  First,   /* In: */
                                  void     *pKey,    /* In/Out: */
                                  tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgEmg *pEmgKey = (tSmgrMesgEmg*) pKey;
    tTlsEmgRec *pEmg;
    
    if (First) {
        pEmg = tlsEmgFindNextRec("");
    } else {
        pEmg = tlsEmgFindNextRec(pEmgKey->Name);
    }
    
    if (pEmg) {
        // Send to the IOM
        smgrBatchEmgAddMesgPriv(pEmg, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        strcpyn(pEmgKey->Name, sizeof(pEmgKey->Name), pEmg->Name);
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    
    return OK;
}

PRIVATE void smgrMesgEmgDump(const void *pLastKey)
{
    const tSmgrMesgEmg *pEmgKey = (tSmgrMesgEmg*) pLastKey;
    printf ("EMG %s ", pEmgKey->Name);
}

////////////////////////////////////////////////////////////////////////////////
// SVCs - ICC_SOCKET_SVC_SVC_TABLE

typedef struct {
    tServId Id;
} tSmgrMesgSvc;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgSvcCmp(const void *pLastKey,
                               tUint32 IomOp,
                               const tSvcRec *pSvc)
{
    tSmgrMesgSvc *pLast = (tSmgrMesgSvc*) pLastKey;

    switch (IomOp) {
    case IOM_SVC_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLast->Id > pSvc->Id)
        return OK;
    
    if (pLast->Id < pSvc->Id)
        return ERROR;
    
    return OK;
}

PRIVATE tStatus smgrMesgSvcUpdate(tUint32   SlotBitmap, /* In: */
                                  tBoolean  First,   /* In: */
                                  void     *pKey,    /* In/Out: */
                                  tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgSvc *pSvcKey = (tSmgrMesgSvc*) pKey;
    tSvcRec *pSvc = NULL;
    
    if (First) {
        pSvcKey->Id = NULL_SERV_ID;
    }

    pSvc = svcFindNextRec(pSvcKey->Id);
    
    if (pSvc) {
        // Send to the IOM
        smgrBatchSvcAddMesgPriv(pSvc, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pSvcKey->Id = pSvc->Id;
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE tStatus smgrMesgSvcTlsUpdate(tUint32   SlotBitmap, /* In: */
                                     tBoolean  First,   /* In: */
                                     void     *pKey,    /* In/Out: */
                                     tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgSvc *pSvcKey = (tSmgrMesgSvc*) pKey;
    tSvcRec *pSvc = NULL;
    
    if (First) {
        pSvcKey->Id = NULL_SERV_ID;
    }

    pSvc = svcFindNextRecByType(pSvcKey->Id, ST_TLS);
    
    if (pSvc) {
        // Send to the IOM
        smgrBatchSvcTlsMesgPriv(pSvc, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end

        pSvcKey->Id = pSvc->Id;
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgSvcDump(const void *pLastKey)
{
    const tSmgrMesgSvc *pLast = (tSmgrMesgSvc*) pLastKey;
    printf ("Svc %u", pLast->Id);
}


////////////////////////////////////////////////////////////////////////////////
// SAP - ICC_SOCKET_SAP_SUB

typedef struct {
    tSapId Id;
} tSmgrMesgSap;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgSapCmp(const void *pLastKey,
                               tUint32 IomOp,
                               const tSapRec *pSap)
{
    tSmgrMesgSap *pLast = (tSmgrMesgSap*) pLastKey;

    switch (IomOp) {
    case IOM_SAP_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (pLast->Id.PortId > pSap->SapId.PortId)
        return OK;
        
    if (pLast->Id.PortId < pSap->SapId.PortId)
        return ERROR;
        
    if (pLast->Id.EncapValue.u32 >pSap->SapId.EncapValue.u32)
        return OK;
        
    if (pLast->Id.EncapValue.u32 < pSap->SapId.EncapValue.u32)
        return ERROR;
    
    return OK;
}

PRIVATE tStatus smgrMesgSapUpdate(tUint32   SlotBitmap, /* In: */
                                  tBoolean  First,   /* In: */
                                  void     *pKey,    /* In/Out: */
                                  tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgSap *pSapKey = (tSmgrMesgSap*) pKey;
    tSapRec *pSap = NULL;
    tUint32 DwldBitmap = SlotBitmap;
    
    if (First) 
        pSap = sapFindFirstRec(NULL);
    else 
        pSap = sapFindNextRec(NULL,&pSapKey->Id);
    
    if (pSap) {

        /* Only download real SAPs here */
        if (!pSap->SdpBnd) {            
            // Send to the IOM
            smgrBatchSapAddMesgPriv(pSap, DwldBitmap, NULL, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }
        
        pSapKey->Id.PortId = pSap->SapId.PortId;
        pSapKey->Id.EncapValue.u32 = pSap->SapId.EncapValue.u32;
        
        *pMore = TRUE;
        
    } else {
        *pMore = FALSE;
    }
    return OK;
}

PRIVATE void smgrMesgSapDump(const void *pLastKey)
{
    const tSmgrMesgSap *pLast = (tSmgrMesgSap*) pLastKey;
    printf ("Sap %s", smgrFmtSapIdVerboseForDebug(&pLast->Id));
}

typedef struct {
    tSapId  SapId;
    tUint16 PrimVlanId;
} tSmgrMesgSapCfmPrimVlan;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgSapCfmPrimVlanCmp(const void *pLastKey,
                                          tUint32 IomOp,
                                          const tSapRec *pSap,
                                          tUint32 PrimVlanId)
{
    tSmgrMesgSapCfmPrimVlan *pLast = (tSmgrMesgSapCfmPrimVlan *)pLastKey;
    int                      rc = 0;
    tUint32                  LastPrimVlanId;
    
    if (IomOp != IOM_SAP_CFM_PVLAN)
        return ERROR;
    
    if (! pLast || ! pSap)
        return ERROR;
        
    LastPrimVlanId = pLast->PrimVlanId;
    
    if ((rc = sapCmpIds((const char *)&(pLast->SapId), (const char *)&pSap->SapId)) != 0) {
        return ((rc > 0)? OK : ERROR);
    }

    rc = avlpNumCmp(AVL_CAST_INT_TO_KEY(LastPrimVlanId), AVL_CAST_INT_TO_KEY(PrimVlanId));
    
    return ((rc >= 0)? OK : ERROR);
    
}

PRIVATE tStatus smgrMesgSapCfmPrimVlanUpdate(tUint32   SlotBitmap, /* In: */
                                             tBoolean  First,      /* In: */
                                             void     *pKey,       /* In/Out: */
                                             tBoolean *pMore)      /* Out: returns if there is more data */
{
    tSmgrMesgSapCfmPrimVlan *pSapCfmPrimVlanKey = (tSmgrMesgSapCfmPrimVlan *)pKey;
    tDot1agSapPvEntry        PrimVlanCfg;
    tSapRec                 *pSap = NULL;
    tStatus                  s;
    
    if (First) {
        ZERO_STRUCT_PTR(pSapCfmPrimVlanKey);
        s = dot1agSapGetFirstPrimVlanCfg(&pSap, &PrimVlanCfg);
    } else {
        s = dot1agSapGetNextPrimVlanCfg(&pSapCfmPrimVlanKey->SapId, pSapCfmPrimVlanKey->PrimVlanId,
                                        &pSap, &PrimVlanCfg);
    }

    if (s == OK) {
        smgrBatchSapCfmPrimVlanMesgPriv(pSap, &PrimVlanCfg, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        pSapCfmPrimVlanKey->SapId = pSap->SapId;  
        pSapCfmPrimVlanKey->PrimVlanId = PrimVlanCfg.VlanId;        
        
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    
    return OK;
}

PRIVATE void smgrMesgSapCfmPrimVlanDump(const void *pLastKey)
{
    const tSmgrMesgSapCfmPrimVlan *pLast = pLastKey;
    printf("Sap %s PrimVlanId %u", 
           smgrFmtSapIdVerboseForDebug(&pLast->SapId), pLast->PrimVlanId);
}


typedef struct {
    tServId    SvcId;
    tSapId     SapId;
} tSmgrMesgSapLoopBack;


PRIVATE tStatus smgrMesgSapLoopBackUpdate(tUint32   SlotBitmap, /* In: */
                                          tBoolean  First,      /* In: */
                                          void     *pKey,       /* In/Out: */
                                          tBoolean *pMore)      /* Out: returns if there is more data */
{
    tSmgrMesgSapLoopBack  *pMsgKey = (tSmgrMesgSapLoopBack *)pKey;
    tSapMacLpbk           *pSapLoopBack;
    tSapRec               *pSap;

    if (First) {
        ZERO_STRUCT_PTR(pMsgKey);
    }

    if ((pSapLoopBack = sapGetLoopBack(pMsgKey->SvcId, &pMsgKey->SapId, TRUE)) == NULL) {
        *pMore = FALSE;
        return OK;
    }
    
    pMsgKey->SvcId                = pSapLoopBack->SvcId;
    pMsgKey->SapId.PortId         = pSapLoopBack->SapId.PortId;
    pMsgKey->SapId.EncapValue.u32 = pSapLoopBack->SapId.EncapValue.u32;

    if ((pSap = sapFindRecById(NULL, &pSapLoopBack->SapId)) != NULL) {
        smgrSendSapLoopBackMesgPriv(pSap, pSapLoopBack, SlotBitmap, TRUE, TRUE);
        *pMore = TRUE;
        return OK;
    }

    *pMore = FALSE;
    return OK;
}


PRIVATE void smgrMesgSapLoopBackDump(const void *pLastKey)
{
    const tSmgrMesgSapLoopBack *pLast = pLastKey;
    printf("Sap %s", smgrFmtSapIdVerboseForDebug(&pLast->SapId));
}





////////////////////////////////////////////////////////////////////////////////
// L2TP Bindings - ICC_SOCKET_SVC_BIND

PUBLIC void smgrMesgL2tpSdpBindDownloadInfoGet(tSmgrMsgrIccInfo *pIccInfo, // Out
                                               const struct tL2tpSmgrL2tpSdpBindKey *pSmgrBindKey,
                                               tUint32 IomOp,
                                               tUint32 SlotBitmap,
                                               tBoolean IsCardOnline,
                                               tL2tpSdpBndCmpFn CmpFn)
{
    if (SlotBitmap == L2TP_ALL_APPLICABLE_SLOTS) {
        SlotBitmap = ALL_APPLICABLE_IOMS;
    }
    smgrMsgrGetIccBitMask(pIccInfo, pSmgrIccMsgr,
                          SmgrMsgrEntry_L2tpBind,
                          IomOp, SlotBitmap,
                          IsCardOnline, FALSE,
                          (CmpFn), pSmgrBindKey);
    if (pIccInfo->IomBitMask && pIccInfo->pStats) {
        pIccInfo->pStats->EntryUpdate++;
    }
}

PUBLIC void smgrMesgL2tpSdpBindIncrMesgStat(tUint32 IomOp)
{
    tSmgrMsgrIccInfo IccInfo;
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_L2tpBind,
                               IomOp);
    if (IccInfo.pStats) {
        IccInfo.pStats->MesgUpdate++;
    }
}

PRIVATE tStatus smgrMesgL2tpBindUpdate(tUint32   SlotBitmap, /* In: */
                                       tBoolean  First,   /* In: */
                                       void     *pKey,    /* In/Out: */
                                       tBoolean *pMore)   /* Out: returns if there is more data */
{
    return l2tpCardOnLineUpdateForSdpBind(
        SlotBitmap, First,
        (tL2tpSmgrL2tpSdpBindKey *)pKey,
        pMore);
}

////////////////////////////////////////////////////////////////////////////////
// GTP Bindings - ICC_SOCKET_SVC_BIND

PUBLIC void smgrMesgGtpSdpBindDownloadInfoGet(tSmgrMsgrIccInfo *pIccInfo, // Out
                                              const struct tGtpApiSmgrGtpSdpBindKey *pSmgrBindKey,
                                              tUint32 IomOp,
                                              tUint32 SlotBitmap,
                                              tBoolean IsCardOnline,
                                              tGtpApiSdpBndCmpFn CmpFn)
{
    if (SlotBitmap == GTPAPI_ALL_APPLICABLE_SLOTS) {
        SlotBitmap = ALL_APPLICABLE_IOMS;
    }
    smgrMsgrGetIccBitMask(pIccInfo, pSmgrIccMsgr,
                          SmgrMsgrEntry_GtpBind,
                          IomOp, SlotBitmap,
                          IsCardOnline, FALSE,
                          (CmpFn), pSmgrBindKey);
    if (pIccInfo->IomBitMask && pIccInfo->pStats) {
        pIccInfo->pStats->EntryUpdate++;
    }
}

PUBLIC void smgrMesgGtpSdpBindIncrMesgStat(tUint32 IomOp)
{
    tSmgrMsgrIccInfo IccInfo;
    smgrMsgrGetIccDownloadInfo(&IccInfo, pSmgrIccMsgr,
                               SmgrMsgrEntry_GtpBind,
                               IomOp);
    if (IccInfo.pStats) {
        IccInfo.pStats->MesgUpdate++;
    }
}

PRIVATE tStatus smgrMesgGtpBindUpdate(tUint32   SlotBitmap, /* In: */
                                      tBoolean  First,   /* In: */
                                      void     *pKey,    /* In/Out: */
                                      tBoolean *pMore)   /* Out: returns if there is more data */
{
    return gtpApiCardOnLineUpdateForSdpBind(
        SlotBitmap, First,
        (tGtpApiSmgrGtpSdpBindKey *)pKey,
        pMore);
}
////////////////////////////////////////////////////////////////////////////////
// SDP Bindings - ICC_SOCKET_SVC_BIND

typedef struct {
    tUint64 SdpBindId;
} tSmgrMesgSdpBind;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgSdpBindCmp(const void *pLastKey, tUint32 IomOp,
                                   const tSdpBndRec *pSdpBnd)
{
    tSmgrMesgSdpBind *pLast = (tSmgrMesgSdpBind*) pLastKey;
    int i;

    switch (IomOp) {
    case IOM_SVC_BIND_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare of the id
        ;
    }

    i = sdpBindCmpIds ((const char *)&pLast->SdpBindId,
                       (const char *)&pSdpBnd->SllHdr.Id);

    if (i > 0)
        return OK;        
    if (i < 0)
        return ERROR;        
    return OK;
}

PRIVATE tStatus smgrMesgSdpBindUpdate(tUint32   SlotBitmap, /* In: */
                                      tBoolean  First,   /* In: */
                                      void     *pKey,    /* In/Out: */
                                      tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgSdpBind *pSdpBndKey = (tSmgrMesgSdpBind*) pKey;
    tSdpBndRec *pSdpBnd = NULL;
    tSdpBndId SdpBndId;

    if (First) {
        bzero(&SdpBndId, sizeof(SdpBndId));
    } else {
        sdpBindFormatId(pSdpBndKey->SdpBindId, &SdpBndId);
    }
    pSdpBnd = sdpBindFindNextRecById(&SdpBndId);
    
    if (pSdpBnd) {
        // Send to the IOM
        smgrBatchSdpBindMesgPriv(pSdpBnd, SlotBitmap, NULL, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        pSdpBndKey->SdpBindId = pSdpBnd->SllHdr.Id;        
        *pMore = TRUE;        
    } else {
        *pMore = FALSE;
    }

    return OK;
}

PRIVATE void smgrMesgSdpBindDump(const void *pLastKey)
{
    const tSmgrMesgSdpBind *pLast = (tSmgrMesgSdpBind*) pLastKey;
    tSdpBndId SdpBndId;
    sdpBindFormatId(pLast->SdpBindId, &SdpBndId);
    printf ("SDP Bind %s", smgrFmtSdpBndIdForDebug(&SdpBndId));
}


typedef struct {
    tServId    SvcId;                 
    tSdpBndId  SdpBindId;            
} tSmgrMesgSdpBindLoopBack;


PRIVATE tStatus smgrMesgSdpBindLoopBackUpdate(tUint32   SlotBitmap, /* In: */
                                      tBoolean  First,   /* In: */
                                      void     *pKey,    /* In/Out: */
                                      tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrMesgSdpBindLoopBack *pMsgKey = (tSmgrMesgSdpBindLoopBack*) pKey;
    tSdpBindMacLpbk          *pSbindLoopBack;
    tSdpBndRec               *pSdpBnd;

    if (First) {
        ZERO_STRUCT_PTR(pMsgKey);
    } 

    if ((pSbindLoopBack = sdpBindGetLoopBack(pMsgKey->SvcId, &pMsgKey->SdpBindId, TRUE)) == NULL) {
        *pMore = FALSE;
        return OK;
    }

    pMsgKey->SvcId        = pSbindLoopBack->SvcId;
    pMsgKey->SdpBindId    = pSbindLoopBack->SdpBindId;

    if ((pSdpBnd = sdpBindFindRecById(NULL, &pMsgKey->SdpBindId)) != NULL) {
        smgrSendSbindLoopBackMesgPriv(pSdpBnd, pSbindLoopBack, SlotBitmap, TRUE, TRUE);
        *pMore = TRUE;
        return OK;
    }

    *pMore = FALSE;
    return OK;
}


PRIVATE void smgrMesgSdpBindLoopBackDump(const void *pLastKey)
{
    const tSmgrMesgSdpBindLoopBack *pLast = (tSmgrMesgSdpBindLoopBack*) pLastKey;
    printf ("SDP Bind %u:%u", pLast->SdpBindId.SdpId, pLast->SdpBindId.VcId);
}


////////////////////////////////////////////////////////////////////////////////
// TLS  FDB - ICC_SOCKET_TLS_MAC_TABLE

typedef struct {
    tServId Id;
    tMacAddr Mac;
} tSmgrIcc_TlsFdb;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccTlsFdbCmp(const void *pLastKey,
                                     tUint32 IomOp,
                                     const tTlsFdbRec *pRec)
{
    tSmgrIcc_TlsFdb *pLast = (tSmgrIcc_TlsFdb*)pLastKey;
    int i;


    switch (IomOp) {
    case IOM_TLS_MAC_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;        
    case IOM_TLS_MAC_DELETE_ALL_FOR_DEST:
    case IOM_TLS_MAC_DELETE_ALL_FOR_TLS:
    case IOM_TLS_MAC_DELETE_ALL_FOR_MIM:
    case IOM_TLS_MAC_MOVE_ALL_FOR_DEST:
    case IOM_TLS_MAC_CALLBACK:
        return OK;
    default:
        // All other case do the compare of the name
        ;
    }
    
    if (!pLast || !pRec)
        return ERROR;
    
    if (pLast->Id > pRec->pTlsFdb->SvcRec->Id)
        return OK;
    
    if (pLast->Id  < pRec->pTlsFdb->SvcRec->Id)
        return ERROR;

    i = memcmp(&pLast->Mac,&pRec->MacAddr,sizeof(tMacAddr));
    if (i >= 0)
        return OK;
    
    return ERROR; 

   
}

PRIVATE tStatus smgrMesgIccTlsFdbUpdate(tUint32   SlotBitmap, /* In: */
                                        tBoolean  First,   /* In: */
                                        void     *pKey,    /* In/Out: */
                                        tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_TlsFdb *pTlsFdb = (tSmgrIcc_TlsFdb*) pKey;
    tTlsFdbRec *pRec = NULL;
    tSvcRec *pSvc=NULL;
    char *key;
    int iom_icc_failure = 0;
    
    if (First) {
        if (avlpFirst(TlsSvcRecTbl, &key, (void **)&pSvc) == AVLP_OK){
            avlpFirst(&pSvc->u.Tls->RecTbl, &key, (void **)&pRec);           
        }
    }
    else {
         avlpLookup(TlsSvcRecTbl, AVL_CAST_INT_TO_KEY(pTlsFdb->Id), (void **)&pSvc);
         if (pSvc) {
             avlpNext(&pSvc->u.Tls->RecTbl,(char*)&pTlsFdb->Mac,NULL,(void **)&pRec);
         } else {
             /* The svc rec was probably deleted. Get the next Fdb rec */
             if (avlpNext(TlsSvcRecTbl, AVL_CAST_INT_TO_KEY(pTlsFdb->Id),NULL,(void **)&pSvc) == AVLP_OK) {       
                 avlpFirst(&pSvc->u.Tls->RecTbl, &key, (void **)&pRec); 
             }
         }
    }
    while(!pRec && pSvc) {
        tServId svc_id = pSvc->Id;

        pSvc = NULL;
        if (avlpNext(TlsSvcRecTbl, AVL_CAST_INT_TO_KEY(svc_id),NULL,(void **)&pSvc) == AVLP_OK) {       
            avlpFirst(&pSvc->u.Tls->RecTbl, &key, (void **)&pRec); 
        }
    }
    
    if (pRec) {
        // Send to the IOM
        if ((pRec->Locale == VAL_tlsFdbLocale_sap) || (pRec->Locale ==VAL_tlsFdbLocale_sdp) ||
            (pRec->Locale == VAL_tlsFdbLocale_cpm)){
            
            if (smgrBatchTlsMacAddMesgPriv(pRec->pTlsFdb, pRec, SlotBitmap,
                                           INVALID_SLOT_NUM, TRUE, NULL) != SUCCESS) {
                SVCMGR_ERROR(SVCMGR, "can't restore mac=%s defined on %s to slotbitmap=0x%08x !",
                             smgrFmtMacAddrForDebug(&pRec->MacAddr), 
                             smgrFmtMacDestForDebug(pRec->Locale, &pRec->DestInfo), SlotBitmap);
                iom_icc_failure = 1;
            }
            // No flush is done at this point. SmgrMsgr will flush at the end
        }

        if (!iom_icc_failure) {
            /* update the next key only if the IOM ICC is sucessful */
            pTlsFdb->Id = pSvc->Id;
            pTlsFdb->Mac = pRec->MacAddr;
        }
        *pMore = TRUE;
    } else {
        *pMore = FALSE;
    }
    
    return OK;
}

PRIVATE void smgrMesgIccTlsFdbDump(const void *pLastKey)
{
    const tSmgrIcc_TlsFdb *pLast = (tSmgrIcc_TlsFdb*) pLastKey;
    printf ("Svc Id: %u Mac: %s", pLast->Id, smgrFmtMacAddrForDebug(&pLast->Mac));
}

////////////////////////////////////////////////////////////////////////////////
// TLS  FDB Query - IOM_TLS_MAC_QUERY

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccTlsFdbQueryCmp(const void *pLastKey,
                                          tUint32 IomOp,
                                          const tTlsFdbRec *pRec)
{
    
    return OK;
   
}

PRIVATE tStatus smgrMesgIccTlsFdbQueryUpdate(tUint32   SlotBitmap, /* In: */
                                             tBoolean  First,   /* In: */
                                             void     *pKey,    /* In/Out: */
                                             tBoolean *pMore)   /* Out: returns if there is more data */
{

    *pMore = FALSE; 
    return OK;
}

////////////////////////////////////////////////////////////////////////////////
// Mirror SVC Remote - ICC_SOCKET_MIRROR_SOURCE_TABLE
typedef struct {
    tServId Id;
    tIpAddr Addr;
} tSmgrIcc_MirrorSvcRemote;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccMirrorSvcRemoteCmp(const void *pLastKey,
                                              tUint32 IomOp,
                                              const tMirrorRemSrcRec *pRemSrc)
{
    tSmgrIcc_MirrorSvcRemote *pLast = (tSmgrIcc_MirrorSvcRemote*)pLastKey;


    switch (IomOp) {
    case IOM_MIRROR_SRC_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    
    if(!pLast || !pRemSrc)
        return ERROR;
    
    if (pLast->Id > pRemSrc->SvcRec->Id)
        return OK;
    
    if (pLast->Id  < pRemSrc->SvcRec->Id)
        return ERROR;

   if (pLast->Addr > pRemSrc->Addr)
        return OK;
    
    if (pLast->Addr < pRemSrc->Addr)
        return ERROR;
   
    return OK;
   
}

PRIVATE tStatus smgrMesgIccMirrorSvcRemoteUpdate(tUint32   SlotBitmap, /* In: */
                                                 tBoolean  First,   /* In: */
                                                 void     *pKey,    /* In/Out: */
                                                 tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_MirrorSvcRemote *pRemSrcKey = (tSmgrIcc_MirrorSvcRemote*) pKey;
    tSvcRec *pSvc=NULL;
    tMirrorRemSrcRec *pRemSrc = NULL;
    char *key;
    tUint32 IomBitMask;
     
    if (First) {
        if (avlpFirst(MirrorSvcRecTbl, &key, (void **)&pSvc) == AVLP_OK){
            tMirrorObj *pMirror = pSvc->u.MirrorInfo;
             
            avlpFirst(&pMirror->RemSrcTbl, &key, (void **)&pRemSrc);           
        }
    }
    else {
        avlpLookup(MirrorSvcRecTbl, AVL_CAST_INT_TO_KEY(pRemSrcKey->Id), (void **)&pSvc);
        if (pSvc) {
            avlpNext(&(pSvc->u.MirrorInfo->RemSrcTbl), AVL_CAST_INT_TO_KEY(pRemSrcKey->Addr),NULL,(void **)&pRemSrc);
        } else {
            if (avlpNext(MirrorSvcRecTbl, AVL_CAST_INT_TO_KEY(pRemSrcKey->Id),NULL,(void **)&pSvc) == AVLP_OK) {       
                avlpFirst(&(pSvc->u.MirrorInfo->RemSrcTbl), &key, (void **)&pRemSrc); 
            }
        }
    }
    while(!pRemSrc && pSvc) {
        tServId svc_id = pSvc->Id;

        pSvc = NULL;
        if (avlpNext(MirrorSvcRecTbl, AVL_CAST_INT_TO_KEY(svc_id),NULL,(void **)&pSvc) == AVLP_OK) {       
            avlpFirst(&(pSvc->u.MirrorInfo->RemSrcTbl), &key, (void **)&pRemSrc); 
        }
    }   
    
    if (pRemSrc) {
        // Send to the IOM

        if (VALID_VC_LABEL(pRemSrc->OperIngressVcLabel)) {

            /* Validate the IOM Bitmask */
            IomBitMask = mirrorGetRemSrcIOMBitMask(pRemSrc);
            
            smgrSendMirrorRemSrcMesgPriv(TRUE, pRemSrc, IomBitMask,SlotBitmap,TRUE, NULL);
        }
       
        pRemSrcKey->Id = pRemSrc->SvcRec->Id;
        pRemSrcKey->Addr = pRemSrc->Addr;
     
        *pMore = TRUE;
    }else {
        *pMore = FALSE;
    }
    
    return OK;
}

PRIVATE void smgrMesgIccMirrorSvcRemoteDump(const void *pLastKey)
{
    const tSmgrIcc_MirrorSvcRemote *pLast = (tSmgrIcc_MirrorSvcRemote*) pLastKey;
    printf ("Svc Id: %u RemSrc=%u.%u.%u.%u", pLast->Id, PRINT_IP(pLast->Addr));
}

////////////////////////////////////////////////////////////////////////////////
// Mirror SVC Local - ICC_SOCKET_MIRROR_SOURCE_TABLE

typedef struct {
    tServId Id;
    tMirrorSrcId MirSrcId;
} tSmgrIcc_MirrorSvcLocal;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccMirrorSvcLocalCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const  tMirrorSrcEntryRec *pLocSrc)
{
    tSmgrIcc_MirrorSvcLocal *pLast = (tSmgrIcc_MirrorSvcLocal*)pLastKey;


    switch (IomOp) {
    case IOM_MIRROR_SRC_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    
    if (!pLast || !pLocSrc)
        return ERROR;
    
    if (pLast->Id > pLocSrc->SvcRec->Id)
        return OK;
    
    if (pLast->Id  < pLocSrc->SvcRec->Id)
        return ERROR;

    if (pLast->MirSrcId.Type > pLocSrc->Id.Type)
        return OK;

    if (pLast->MirSrcId.Type < pLocSrc->Id.Type)
        return ERROR;
        
    switch (pLast->MirSrcId.Type) {
    case SMMS_IP:
    case SMMS_IPV6:
    case SMMS_MAC:
        if (pLast->MirSrcId.Id.Fltr.Id > pLocSrc->Id.Id.Fltr.Id)
            return OK;
        if (pLast->MirSrcId.Id.Fltr.Id < pLocSrc->Id.Id.Fltr.Id)
            return ERROR;
        if (pLast->MirSrcId.Id.Fltr.EntryId > pLocSrc->Id.Id.Fltr.EntryId)
            return OK;
        if (pLast->MirSrcId.Id.Fltr.EntryId < pLocSrc->Id.Id.Fltr.EntryId)
            return ERROR;
        break;
    case SMMS_INGLBL:
        if (pLast->MirSrcId.Id.IngressLabel > pLocSrc->Id.Id.IngressLabel)
            return OK;
        if (pLast->MirSrcId.Id.IngressLabel < pLocSrc->Id.Id.IngressLabel)
            return ERROR;
        break;
    case SMMS_PORT:
        if (pLast->MirSrcId.Id.PortId > pLocSrc->Id.Id.PortId)
            return OK;
        if (pLast->MirSrcId.Id.PortId < pLocSrc->Id.Id.PortId)
            return ERROR;
        break;
    case SMMS_SAP:
        if (pLast->MirSrcId.Id.SapId.PortId >  pLocSrc->Id.Id.SapId.PortId)
            return OK;
        if (pLast->MirSrcId.Id.SapId.PortId < pLocSrc->Id.Id.SapId.PortId)
            return ERROR;
        if (pLast->MirSrcId.Id.SapId.EncapValue.u32 > pLocSrc->Id.Id.SapId.EncapValue.u32)
            return OK;
        if (pLast->MirSrcId.Id.SapId.EncapValue.u32 < pLocSrc->Id.Id.SapId.EncapValue.u32)
            return ERROR;
        break;
    case SMMS_SUB:
        if (pLast->MirSrcId.Id.SubId.SubIdName.length == pLocSrc->Id.Id.SubId.SubIdName.length) {
            int rc=0;
            rc =  memcmp(pLast->MirSrcId.Id.SubId.SubIdName.name, 
                         pLocSrc->Id.Id.SubId.SubIdName.name, 
                         pLast->MirSrcId.Id.SubId.SubIdName.length);
            
            if (rc >= 0 )
                return OK;
            else
                return ERROR;
            
        } else if (pLast->MirSrcId.Id.SubId.SubIdName.length > pLocSrc->Id.Id.SubId.SubIdName.length)
            return OK;
        else
            return ERROR;
        break;
    case SMMS_ISAAA:
        if (pLast->MirSrcId.Id.IsaAa.GrpId > pLocSrc->Id.Id.IsaAa.GrpId)
            return OK;
        if (pLast->MirSrcId.Id.IsaAa.GrpId < pLocSrc->Id.Id.IsaAa.GrpId)
            return ERROR;
        break;

    case SMMS_NAT_LSN:
    {
        int idx_cmp;

        if (pLast->MirSrcId.Id.NatLsnSub.subId.vrtrId > pLocSrc->Id.Id.NatLsnSub.subId.vrtrId)
            return OK;
        if (pLast->MirSrcId.Id.NatLsnSub.subId.vrtrId < pLocSrc->Id.Id.NatLsnSub.subId.vrtrId)
            return ERROR;

        idx_cmp = TIM_NET_ADDR_CMP(&pLast->MirSrcId.Id.NatLsnSub.subId.ipAddr,
                                   &pLocSrc->Id.Id.NatLsnSub.subId.ipAddr);
        if (idx_cmp > 0)
            return OK;
        else if (idx_cmp < 0)
            return ERROR;

        if (pLast->MirSrcId.Id.NatLsnSub.subId.prefixLen > pLocSrc->Id.Id.NatLsnSub.subId.prefixLen)
            return OK;
        if (pLast->MirSrcId.Id.NatLsnSub.subId.prefixLen < pLocSrc->Id.Id.NatLsnSub.subId.prefixLen)
            return ERROR;

        break;
    }

    case SMMS_NAT_L2AW:
    {
        int len_x = strlen(pLast->MirSrcId.Id.NatL2awSub.subName);
        int len_y = strlen(pLocSrc->Id.Id.NatL2awSub.subName);
        int idx_cmp;

        if (len_x > len_y)
            return OK;
        if (len_x < len_y)
            return ERROR;

        idx_cmp = strcmp(pLast->MirSrcId.Id.NatL2awSub.subName,
                         pLocSrc->Id.Id.NatL2awSub.subName);

        if (idx_cmp > 0)
            return OK;
        if (idx_cmp < 0)
            return ERROR;

        break;
    }

    case SMMS_NAT_64:
    case SMMS_SIZE:
    default:
        SVCMGR_ERROR(NOCLASS, "Invalid Mirror Src Type");
        return ERROR;
    }
     return OK;   
}

PRIVATE tStatus smgrMesgIccMirrorSvcLocalUpdate(tUint32   SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_MirrorSvcLocal *pLocSrcKey = (tSmgrIcc_MirrorSvcLocal*) pKey;
    tSvcRec *pSvc=NULL;
    tMirrorSrcEntryRec *pLocSrc = NULL;
    char *key;
    tUint32 IomBitMask;
    tPortId LocalSrcPortId = INVALID_PORTID;
    
    if (First) {
        if (avlpFirst(MirrorSvcRecTbl, &key, (void **)&pSvc) == AVLP_OK){
            tMirrorObj *pMirror = pSvc->u.MirrorInfo;
             
            avlpFirst(&pMirror->LocalSrcTbl, &key, (void **)&pLocSrc);           
        }
    }
    else {
         avlpLookup(MirrorSvcRecTbl, AVL_CAST_INT_TO_KEY(pLocSrcKey->Id), (void **)&pSvc);
         if (pSvc) {
             avlpNext(&(pSvc->u.MirrorInfo->LocalSrcTbl),(char*)&(pLocSrcKey->MirSrcId),NULL,(void **)&pLocSrc);
         } else {
            if (avlpNext(MirrorSvcRecTbl, AVL_CAST_INT_TO_KEY(pLocSrcKey->Id),NULL,(void **)&pSvc) == AVLP_OK) {       
                avlpFirst(&(pSvc->u.MirrorInfo->LocalSrcTbl), &key, (void **)&pLocSrc); 
            }
         }
    }
    while (!pLocSrc && pSvc) {
        tServId svc_id = pSvc->Id;

        pSvc = NULL;
        if (avlpNext(MirrorSvcRecTbl,AVL_CAST_INT_TO_KEY(svc_id),NULL,(void **)&pSvc) == AVLP_OK) {       
            avlpFirst(&(pSvc->u.MirrorInfo->LocalSrcTbl), &key, (void **)&pLocSrc); 
        }
    }   
   
    
    if (pLocSrc) {
        // Send to the IOM
        IomBitMask = mirrorGetSrcIOMBitMask(pLocSrc,TRUE);

        switch (pLocSrc->Id.Type) {
           
            case SMMS_INGLBL:
            case SMMS_MAC:
            case SMMS_IP:
            case SMMS_IPV6:
                smgrSendMirrorSrcMesgPriv(TRUE, TRUE, pLocSrc, IomBitMask,SlotBitmap,TRUE);
                break;
            case SMMS_NAT_LSN:
            case SMMS_NAT_L2AW:
                /* NAT sources only if l3 encap is configured */
                if (MIRROR_DEST_GET_L3ENCAP_HDRTYPE(pSvc)) {
                    smgrSendMirrorSrcMesgPriv(TRUE, TRUE, pLocSrc, IomBitMask,SlotBitmap,TRUE);
                }
                break;
            case SMMS_SAP:
            case SMMS_PORT:
            {
                if (pLocSrc->Id.Type == SMMS_SAP)
                    LocalSrcPortId = pLocSrc->Id.Id.SapId.PortId;
                else
                    LocalSrcPortId = pLocSrc->Id.Id.PortId;
            
                tSMPortRec *pPort = smgrFindPortRec(LocalSrcPortId);
            
                if (pPort && PORT_IS_OPERSTATE_PRESENT(pPort)) {
                    /* Download the configuration only if the port is present */
                    if (pLocSrc->Ingress)
                        smgrSendMirrorSrcMesgPriv(TRUE, TRUE, pLocSrc, IomBitMask,SlotBitmap,TRUE);
                
                    if (pLocSrc->Egress)
                        smgrSendMirrorSrcMesgPriv(TRUE, FALSE, pLocSrc, IomBitMask,SlotBitmap,TRUE);    
                }
                
                break;
            }
            case SMMS_SUB:
            case SMMS_ISAAA:
            case SMMS_NAT_64:
            case SMMS_SIZE:
            default:
                ;
        } 
        
        pLocSrcKey->Id = pLocSrc->SvcRec->Id;
        pLocSrcKey->MirSrcId= pLocSrc->Id;
     
        *pMore = TRUE;
    }else {
        *pMore = FALSE;
    }    
    return OK;
}

PRIVATE void smgrMesgIccMirrorSvcLocalDump(const void *pLastKey)
{
    char Buf[FMT_LOC_SRC_BUF_SIZE];
    const tSmgrIcc_MirrorSvcLocal *pLast = (tSmgrIcc_MirrorSvcLocal*) pLastKey;
    printf ("Svc Id: %u Local Src: %s", pLast->Id, mirrorFmtLocSrcId(&(pLast->MirSrcId), Buf, sizeof(Buf)));
}

////////////////////////////////////////////////////////////////////////////////
// Mfib Tls 
PRIVATE tStatus smgrMesgIccMfibTlsUpdate(tUint32   SlotBitmap, /* In: */
                                         tBoolean  First,   /* In: */
                                         void     *pKey,    /* In/Out: */
                                         tBoolean *pMore)   /* Out: returns if there is more data */
{

    tSlot Slot;     
    for (Slot = MIN_CHASSIS_SLOT ; ((Slot <= MAX_CHASSIS_SLOT) && SlotBitmap); Slot++) {        
        if (IOM_BIT_TST(SlotBitmap, Slot)) {
            mfibTlsIomSlotOnline(Slot); 
            IOM_BIT_CLR(SlotBitmap,Slot); 
         }
    } // end of for loop     
    
    *pMore = FALSE;
    return OK;
}


////////////////////////////////////////////////////////////////////////////////
// UssCatMap - ICC_SOCKET_SAP_SUB
typedef struct {
    char   MapName[USS_MAX_CATMAP_LEN + 1];
} tSmgrIcc_UssCatMap;

/* Forward declaration */
struct tUssCategoryMap;

PRIVATE tStatus smgrMesgIccUssCatMapCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const  struct tUssCategoryMap *pCatMap)
{
    tSmgrIcc_UssCatMap *pLast = (tSmgrIcc_UssCatMap*)pLastKey;
    char catMapName[USS_MAX_CATMAP_LEN + 1];
    
    switch (IomOp) {
    case IOM_ESM_CATMAP_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    
    if (!pLast || !pCatMap)
        return ERROR;

    ussApiCategoryMapNameGetNoLock(pCatMap, catMapName, sizeof(catMapName));

    if (strlen(pLast->MapName) > strlen(catMapName))
        return 1;

    if (strlen(pLast->MapName) < strlen(catMapName))
        return -1;

    return strcmp(pLast->MapName, catMapName);
}

PRIVATE tStatus smgrMesgIccUssCatMapUpdate(tUint32   SlotBitmap, /* In: */
                                           tBoolean  First,   /* In: */
                                           void     *pKey,    /* In/Out: */
                                           tBoolean *pMore)   /* Out: returns if there is more data */
{

    struct tUssCategoryMap *pCatMap = NULL;
    tSmgrIcc_UssCatMap *pUssCatMapKey = (tSmgrIcc_UssCatMap*) pKey;
    tSlot Slot;
    
    if (First) {
        pCatMap = ussApiGetNextCategoryMapNoLock("", TRUE);
            
    } else {
        pCatMap = ussApiGetNextCategoryMapNoLock(pUssCatMapKey->MapName, TRUE);
    }
    
    if (pCatMap) {
        for (Slot = MIN_CHASSIS_SLOT ; ((Slot <= MAX_CHASSIS_SLOT) && SlotBitmap) ; Slot++) {        
            if (IOM_BIT_TST(SlotBitmap, Slot)) {
                ussApiSendCatMapToIomUniCastPrivNoLock(pCatMap, IOM_ESM_CATMAP_POLICY_ADD, Slot, TRUE);
            }
            IOM_BIT_CLR(SlotBitmap,Slot);
        }
        ussApiCategoryMapNameGetNoLock(pCatMap, pUssCatMapKey->MapName, sizeof(pUssCatMapKey->MapName));
       *pMore = TRUE; 
    }
    else {
        *pMore = FALSE;
        for (Slot = MIN_CHASSIS_SLOT ; ((Slot <= MAX_CHASSIS_SLOT) && SlotBitmap) ; Slot++) {        
            if (IOM_BIT_TST(SlotBitmap, Slot)) {
                ussApiStatsCardOnlineNoLock(Slot);
                ussApiSetDeactivateDeleteNumNoLock(Slot,0);
            }
            IOM_BIT_CLR(SlotBitmap,Slot);
        }
    }    
    return OK;
}

PUBLIC void smgrGetUssCatMapDownloadInfo(struct SmgrMsgrIccInfo *pIccInfo, // Out
                                         tUint16  *IccSocket, //Out
                                         const  struct tUssCategoryMap *pCatMap,
                                         tUint32 IomOp,
                                         tSlot SlotNum,
                                         tBoolean IsCardOnline,
                                         tBoolean AllIoms)
{
    tUint32 SlotBitmap=0;
    tUint32  oldAsid = 0;

    if (runtime_feature_vmm) 
    {
        oldAsid = vmmGetCurrentAsid();
        vmmSetTaskAsid(0, ASID_CPM);
    }

    if (AllIoms)
        SlotNum = ALL_APPLICABLE_IOMS;

    SlotBitmap = SMGRMSGR_GET_SLOTBITMASK(SlotNum);   
    smgrMsgrGetIccBitMask(pIccInfo,
                          pSmgrIccMsgr,
                          SmgrMsgrEntry_UssCatMap,
                          IomOp,
                          SlotBitmap,
                          IsCardOnline,
                          TRUE,
                          smgrMesgIccUssCatMapCmp,
                          pCatMap);

    if (pIccInfo->IomBitMask && pIccInfo->pStats) {
        pIccInfo->pStats->EntryUpdate++;
        pIccInfo->pStats->MesgUpdate++;
    }
    if (IccSocket) {
        *IccSocket = pIccInfo->pMsgrEntry->IccSocket;
    }

    if (runtime_feature_vmm) 
    {
        vmmSetTaskAsid(0, oldAsid);
    }
}

PRIVATE void smgrMesgIccUssCatMapDump(const void *pLastKey)
{
    const tSmgrIcc_UssCatMap *pLast = (tSmgrIcc_UssCatMap*) pLastKey;
    printf ("ussCatMap Name: %s",pLast->MapName);
}
////////////////////////////////////////////////////////////////////////////////
// Sbm Sub Profile - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem          name;
} tSmgrIcc_SbmSubProfile;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSubProfCmp(const void *pLastKey,
                                         tUint32 IomOp,
                                         const tSbmSubProf *pSubProf)
{
    tSmgrIcc_SbmSubProfile *pLast = (tSmgrIcc_SbmSubProfile*)pLastKey;
    int result;

    switch (IomOp) {
    case IOM_ESM_SUB_PROFILE_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pSubProf)
        return ERROR;
   
   result = STRCMP_TNamedItem_implied(&pLast->name,&pSubProf->name);

   return ((result >=0) ? OK : ERROR);
}

PRIVATE tStatus smgrMesgIccSbmSubProfUpdate(tUint32   SlotBitmap, /* In: */
                                            tBoolean  First,   /* In: */
                                            void     *pKey,    /* In/Out: */
                                            tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_SbmSubProfile *pLastKey = (tSmgrIcc_SbmSubProfile*) pKey;
    tSbmSubProf *pSubProf = NULL;
 
    if (First) {   
        avlpFirst(sbmSubProfTbl, NULL, (void **)&pSubProf);
    }
    else {
        avlpNext(sbmSubProfTbl, (char *)&pLastKey->name, NULL, (void **)&pSubProf);
    }   

    if (pSubProf) {     
        smgrSendSubProfileAddMesgPriv(pSubProf, SlotBitmap,TRUE);
        *pMore = TRUE;
        STRCPY_TNamedItem(&pLastKey->name,pSubProf->name.name,pSubProf->name.length);
    }else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmSubProfDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSubProfile *pLast = (tSmgrIcc_SbmSubProfile*) pLastKey;
    printf ("Sub profile name: %s length: %d ",pLast->name.name,pLast->name.length);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm Sub Profile Scheduler Overrides - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem       subProfName;
   tUint8                  direction;    
   STRUCT_TNamedItem       schedPolname;  
   STRUCT_TNamedItem       virtSchedname; 
} tSmgrIcc_SbmSubProfSchedOvr;


// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSubProfSchedOvrCmp(const void *pLastKey,
                                                 tUint32 IomOp,
                                                 const tSbmSubProfSchedOvr *pSubProfSchedOvr)
{
    tSmgrIcc_SbmSubProfSchedOvr *pLast = (tSmgrIcc_SbmSubProfSchedOvr*)pLastKey;
    int rc;
    
    if(!pLast || !pSubProfSchedOvr)
        return ERROR;
    
    if ((rc = STRNCMP_TNamedItem(&pLast->subProfName,
                                 &pSubProfSchedOvr->pSubProf->name)) != 0)
    {
        return ((rc > 0) ? OK: ERROR);
    }

    /* tmnxSubProfSchedOvrDirection */
    if (pLast->direction < pSubProfSchedOvr->direction)
        return ERROR;
    if (pLast->direction > pSubProfSchedOvr->direction)
        return OK;

    /* tSchedulerPolicyName (!IMPLIED) */
    if ((rc = STRNCMP_TNamedItem(&pLast->schedPolname,
                                 &pSubProfSchedOvr->schedPolname)) != 0)
    {
        return ((rc > 0) ? OK: ERROR);
    }

    /* tVirtualSchedulerName (IMPLIED) */
    rc = STRCMP_TNamedItem_implied(&pLast->virtSchedname,
                                   &pSubProfSchedOvr->virtSchedname);

    return ((rc >= 0) ? OK: ERROR);
   
}

PRIVATE tStatus smgrMesgIccSbmSubProfSchedOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                    tBoolean  First,   /* In: */
                                                    void     *pKey,    /* In/Out: */
                                                    tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_SbmSubProfSchedOvr *pLastKey = (tSmgrIcc_SbmSubProfSchedOvr*) pKey;
    tSbmSubProfSchedOvr *pSubProfSchedOvr = NULL;
    tUint32 IomBitMask;

    if (First) {   
        avlpFirst(sbmSubProfSchedOvrTbl, NULL, (void **)&pSubProfSchedOvr);
    }
    else {
        tSbmSubProfSchedOvr  tmpSchedOvr;
        tSbmSubProf          tmpSubProf;
    
        STRCPY_TNamedItem(&tmpSubProf.name,
                          pLastKey->subProfName.name,
                          pLastKey->subProfName.length);

        tmpSchedOvr.pSubProf  = &tmpSubProf;
        tmpSchedOvr.direction = pLastKey->direction;
        STRCPY_TNamedItem(&tmpSchedOvr.schedPolname,
                          pLastKey->schedPolname.name,
                          pLastKey->schedPolname.length);
        
        STRCPY_TNamedItem(&tmpSchedOvr.virtSchedname,
                          pLastKey->virtSchedname.name,
                          pLastKey->virtSchedname.length);

        avlpNext(sbmSubProfSchedOvrTbl, (char *)&tmpSchedOvr, NULL, (void **)&pSubProfSchedOvr);
    }   

    if (pSubProfSchedOvr) {
        tUint32 SlotMask = SlotBitmap;
         
        IomBitMask = sbmGetSubProfIomBitMask(pSubProfSchedOvr->pSubProf);
        SlotMask &= IomBitMask;
        
        if (SlotMask) {
            smgrBatchSubProfVSOverrideAddMesgPriv(pSubProfSchedOvr,SlotMask,SlotBitmap,TRUE,NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }
        
        STRCPY_TNamedItem(&pLastKey->subProfName,pSubProfSchedOvr->pSubProf->name.name,pSubProfSchedOvr->pSubProf->name.length);
        STRCPY_TNamedItem(&pLastKey->schedPolname,pSubProfSchedOvr->schedPolname.name,pSubProfSchedOvr->schedPolname.length);
        STRCPY_TNamedItem(&pLastKey->virtSchedname,pSubProfSchedOvr->virtSchedname.name,pSubProfSchedOvr->virtSchedname.length);
        pLastKey->direction = pSubProfSchedOvr->direction;
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmSubProfSchedOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSubProfSchedOvr *pLast = (tSmgrIcc_SbmSubProfSchedOvr*) pLastKey;
    printf("Sub profile name: %s length: %d Dir: %u schedPol name: %s length: %d virtSched name: %s length: %d\n",
           pLast->subProfName.name,pLast->subProfName.length,pLast->direction,pLast->schedPolname.name,pLast->schedPolname.length,
           pLast->virtSchedname.name,pLast->virtSchedname.length);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm Sub Profile Policer control Overrides - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem       subProfName;
   tUint8                  direction;    
   STRUCT_TNamedItem       plcrCtrlPolName;  ; 
} tSmgrIcc_SbmSubProfPlcrCtrlOvr;


// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSubProfPlcrCtrlOvrCmp(const void *pLastKey,
                                                    tUint32 IomOp,
                                                    const tSbmSubProfPlcrCtrlOvr *pSubProfPlcrCtrlOvr)
{
    tSmgrIcc_SbmSubProfPlcrCtrlOvr *pLast = (tSmgrIcc_SbmSubProfPlcrCtrlOvr*)pLastKey;
    int rc;
    
    if (!pLast || !pSubProfPlcrCtrlOvr)
        return ERROR;
    
    if ((rc = STRNCMP_TNamedItem(&pLast->subProfName,
                                 &pSubProfPlcrCtrlOvr->pSubProf->name)) != 0)
    {
         return ((rc > 0) ? OK: ERROR);
    }
    /* tmnxSubProfPCtrlOvrDirection */
    if (pLast->direction < pSubProfPlcrCtrlOvr->direction)
        return ERROR;
    if (pLast->direction > pSubProfPlcrCtrlOvr->direction)
        return OK;
    
     /* tQosPolicerCtrlPolName (!IMPLIED) */
    rc = STRNCMP_TNamedItem(&pLast->plcrCtrlPolName,
                            &pSubProfPlcrCtrlOvr->plcrCtrlPolName);

    return ((rc >= 0) ? OK: ERROR);
   
}

PRIVATE tStatus smgrMesgIccSbmSubProfPlcrCtrlOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                       tBoolean  First,   /* In: */
                                                       void     *pKey,    /* In/Out: */
                                                       tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_SbmSubProfPlcrCtrlOvr *pLastKey = (tSmgrIcc_SbmSubProfPlcrCtrlOvr*) pKey;
    tSbmSubProfPlcrCtrlOvr *pSubProfPlcrCtrlOvr = NULL;
    tUint32 IomBitMask;

    if (First) {   
        avlpFirst(sbmSubProfPlcrCtrlOvrTbl, NULL, (void **)&pSubProfPlcrCtrlOvr);
    }
    else {
        tSbmSubProfPlcrCtrlOvr  tmpPlcrCtrlOvr;
        tSbmSubProf             tmpSubProf;
    
        STRCPY_TNamedItem(&tmpSubProf.name,
                          pLastKey->subProfName.name,
                          pLastKey->subProfName.length);

        tmpPlcrCtrlOvr.pSubProf  = &tmpSubProf;
        tmpPlcrCtrlOvr.direction = pLastKey->direction;
        
        STRCPY_TNamedItem(&tmpPlcrCtrlOvr.plcrCtrlPolName,
                          pLastKey->plcrCtrlPolName.name,
                          pLastKey->plcrCtrlPolName.length);
        

        avlpNext(sbmSubProfPlcrCtrlOvrTbl, (char *)&tmpPlcrCtrlOvr, NULL, (void **)&pSubProfPlcrCtrlOvr);
    }   

    if (pSubProfPlcrCtrlOvr) {
        tUint32 SlotMask = SlotBitmap;
        
        IomBitMask = sbmGetSubProfIomBitMask(pSubProfPlcrCtrlOvr->pSubProf);
        SlotMask &= IomBitMask;
        
        if (SlotMask) {           
            smgrBatchSubProfPlcrCtrlOverrideAddMesgPriv(pSubProfPlcrCtrlOvr,SlotMask,SlotBitmap,TRUE,NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }
        
        STRCPY_TNamedItem(&pLastKey->subProfName,pSubProfPlcrCtrlOvr->pSubProf->name.name,pSubProfPlcrCtrlOvr->pSubProf->name.length);
        STRCPY_TNamedItem(&pLastKey->plcrCtrlPolName,pSubProfPlcrCtrlOvr->plcrCtrlPolName.name,pSubProfPlcrCtrlOvr->plcrCtrlPolName.length);
        pLastKey->direction = pSubProfPlcrCtrlOvr->direction;
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmSubProfPlcrCtrlOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSubProfPlcrCtrlOvr *pLast = (tSmgrIcc_SbmSubProfPlcrCtrlOvr*) pLastKey;
    printf("Sub profile name: %s length: %d Dir: %d PlcrCtrl Profile name: %s length: %d \n",
           pLast->subProfName.name,pLast->subProfName.length,pLast->direction,pLast->plcrCtrlPolName.name,pLast->plcrCtrlPolName.length);
}


////////////////////////////////////////////////////////////////////////////////
// Sbm Sub Profile Hsmda2 Egress Q Overrides - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem                subProfName;
   tUint32                          qosPolId;
   tUint32                          qosQueueId ;
} tSmgrIcc_SbmSubProfQOvr;


// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSubProfHsmda2EgrQOvrCmp(const void *pLastKey,
                                                      tUint32 IomOp,
                                                      const tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr)
{
    tSmgrIcc_SbmSubProfQOvr *pLast = (tSmgrIcc_SbmSubProfQOvr*)pLastKey;
    int rc;
    
    if(!pLast || !pQueueOvr)
        return ERROR;

    if ((rc = STRNCMP_TNamedItem(&pLast->subProfName,
                                 &pQueueOvr->pSubProf->name)) != 0)
    {
         return ((rc > 0) ? OK: ERROR);
    }

    /* tSapIngressIndex/tSapEgressIndex */
    if (pLast->qosPolId < pQueueOvr->qosPolId)
        return  ERROR;
    if (pLast->qosPolId > pQueueOvr->qosPolId)
        return OK;

    /* tSapIngressQueue/tSapEgressQueueIndex */
    if (pLast->qosQueueId < pQueueOvr->qosQueueId)
        return ERROR;
    if (pLast->qosQueueId > pQueueOvr->qosQueueId)
        return OK;

    return OK;
}

PRIVATE tStatus smgrMesgIccSbmSubProfHsmda2EgrQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                         tBoolean  First,   /* In: */
                                                         void     *pKey,    /* In/Out: */
                                                         tBoolean *pMore    /* Out: returns if there is more data */)
{
    tSmgrIcc_SbmSubProfQOvr *pLastKey = (tSmgrIcc_SbmSubProfQOvr*) pKey;
    tSbmSubProfHsmda2EgrQueueOvr *pQueueOvr = NULL;
    tUint32 IomBitMask;

    if (First) {       
        avlpFirst(sbmSubProfHsmda2EgrQueueOvrTbl, NULL, (void **)&pQueueOvr);
    }
    else {
        tSbmSubProfHsmda2EgrQueueOvr tmpQueueOvr;
        tSbmSubProf                  tmpSubProf;
    
        STRCPY_TNamedItem(&tmpSubProf.name,
                          pLastKey->subProfName.name,
                          pLastKey->subProfName.length);

        tmpQueueOvr.pSubProf  = &tmpSubProf;
        tmpQueueOvr.qosPolId  = pLastKey->qosPolId;
        tmpQueueOvr.qosQueueId = pLastKey->qosQueueId;
        
        avlpNext(sbmSubProfHsmda2EgrQueueOvrTbl, (char *)&tmpQueueOvr,
                 NULL, (void **)&pQueueOvr);
    }

    if (pQueueOvr) {
        tUint32 SlotMask = SlotBitmap;
        
        IomBitMask =
            smgrGetHsmda2IomBitmask(sbmGetSubProfIomBitMask(pQueueOvr->pSubProf));
        SlotMask &= IomBitMask;
        
        if (SlotMask) {
            
            smgrBatchSubProfHsmda2EgrQueueOverrideAddMesgPriv(pQueueOvr, SlotMask,
                                                              SlotBitmap, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }
 
        STRCPY_TNamedItem(&pLastKey->subProfName,
                          pQueueOvr->pSubProf->name.name,
                          pQueueOvr->pSubProf->name.length);
 
        pLastKey->qosPolId = pQueueOvr->qosPolId;
        pLastKey->qosQueueId = pQueueOvr->qosQueueId;
        *pMore = TRUE;
    } else {
        /* no more entries */
        *pMore = FALSE;
    }

    return OK;
}

PRIVATE void smgrMesgIccSbmSubProfQOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSubProfQOvr *pLast = (tSmgrIcc_SbmSubProfQOvr*) pLastKey;
    printf("Sub profile name: %s length: %d qosPolId: %u qosQId: %u",
           pLast->subProfName.name,pLast->subProfName.length,pLast->qosPolId,pLast->qosQueueId);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm SLA Profile - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem          name;
} tSmgrIcc_SbmSLAProfile;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSLAProfCmp(const void *pLastKey,
                                         tUint32 IomOp,
                                         const tSbmSLAProf *pSLAProf)
{
    tSmgrIcc_SbmSLAProfile *pLast = (tSmgrIcc_SbmSLAProfile*)pLastKey;
    int result;

    switch (IomOp) {
    case IOM_ESM_SLA_PROFILE_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pSLAProf)
        return ERROR;
    
    result = STRCMP_TNamedItem_implied(&pLast->name,&pSLAProf->name);
    
    return((result >= 0) ? OK : ERROR);


}

PRIVATE tStatus smgrMesgIccSbmSLAProfUpdate(tUint32   SlotBitmap, /* In: */
                                            tBoolean  First,   /* In: */
                                            void     *pKey,    /* In/Out: */
                                            tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_SbmSLAProfile *pLastKey = (tSmgrIcc_SbmSLAProfile*) pKey;
    tSbmSLAProf *pSLAProf = NULL;
 
    if (First) {   
        avlpFirst(sbmSLAProfTbl, NULL, (void **)&pSLAProf);
    }
    else {
        avlpNext(sbmSLAProfTbl, (char *)&pLastKey->name, NULL, (void **)&pSLAProf);
    }   

    if (pSLAProf) {     
        smgrSendSLAProfileAddMesgPriv(pSLAProf,SlotBitmap,TRUE);
        *pMore = TRUE;
        STRCPY_TNamedItem(&pLastKey->name,pSLAProf->name.name,pSLAProf->name.length);
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmSLAProfDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSLAProfile *pLast = (tSmgrIcc_SbmSLAProfile*) pLastKey;
    printf ("SLA profile name: %s length: %d ",pLast->name.name,pLast->name.length);
}


////////////////////////////////////////////////////////////////////////////////
// Sbm SLA Profile Q overrides - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem                slaProfName;
   tUint32                          qosPolId;       
   tUint32                          qosQueueId ; 
} tSmgrIcc_SbmSLAProfQOvr;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSLAProfQOvrCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const tSbmSLAProfQueueOvr *pSLAProfQOvr)
{
    tSmgrIcc_SbmSLAProfQOvr *pLast = (tSmgrIcc_SbmSLAProfQOvr*)pLastKey;
    int rc;


    if (!pLast || !pSLAProfQOvr)
        return ERROR;
    
    if ((rc = STRNCMP_TNamedItem(&pLast->slaProfName,
                                 &pSLAProfQOvr->pSLAProf->name)) != 0)
    {
        return ((rc > 0) ? OK: ERROR);
    }
    
    /* tSapIngressIndex/tSapEgressIndex */
    if (pLast->qosPolId < pSLAProfQOvr->qosPolId)
        return  ERROR;
    
    if (pLast->qosPolId > pSLAProfQOvr->qosPolId)
        return OK;

    /* tSapIngressQueue/tSapEgressQueueIndex */
    if (pLast->qosQueueId < pSLAProfQOvr->qosQueueId)
        return ERROR;
    if (pLast->qosQueueId > pSLAProfQOvr->qosQueueId)
        return OK;

   return OK;
}


PRIVATE tStatus smgrMesgIccSbmSLAProfQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore,   /* Out: returns if there is more data */
                                                tBoolean Ingress /*In */)
{
    tSmgrIcc_SbmSLAProfQOvr *pLastKey = (tSmgrIcc_SbmSLAProfQOvr*) pKey;
    tSbmSLAProfQueueOvr *pSLAProfQOvr = NULL;
    tUint32 IomBitMask;
    tAvlpTree *pQOvrTree = NULL;

    if (Ingress)
        pQOvrTree = sbmSLAProfIngQueueOvrTbl;
    else
        pQOvrTree = sbmSLAProfEgrQueueOvrTbl;
    
    if (First) {       
        avlpFirst(pQOvrTree, NULL, (void **)&pSLAProfQOvr);
    } else {
        tSbmSLAProfQueueOvr  tmpQOvr;
        tSbmSLAProf   tmpSLAProf;
    
        STRCPY_TNamedItem(&tmpSLAProf.name,
                          pLastKey->slaProfName.name,
                          pLastKey->slaProfName.length);

        tmpQOvr.pSLAProf   = &tmpSLAProf;
        tmpQOvr.qosPolId   = pLastKey->qosPolId;
        tmpQOvr.qosQueueId = pLastKey->qosQueueId;
        
        avlpNext(pQOvrTree, (char *)&tmpQOvr, NULL, (void **)&pSLAProfQOvr);
    }   

    if (pSLAProfQOvr) {
        tUint32 thisSlotMask = SlotBitmap;
        
        IomBitMask =
            smgrGetNonHsmdaIomBitmask(sbmGetSLAProfIomBitMask(pSLAProfQOvr->pSLAProf));
        thisSlotMask &= IomBitMask;
        
        if (thisSlotMask) {
           
            smgrBatchSLAProfQueueOverrideAddMesgPriv(pSLAProfQOvr, Ingress,
                                                     thisSlotMask,
                                                     SlotBitmap, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }

        STRCPY_TNamedItem(&pLastKey->slaProfName,
                          pSLAProfQOvr->pSLAProf->name.name,
                          pSLAProfQOvr->pSLAProf->name.length);

        pLastKey->qosPolId = pSLAProfQOvr->qosPolId;
        pLastKey->qosQueueId = pSLAProfQOvr->qosQueueId;
        *pMore = TRUE; 
    } else { 
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}

PRIVATE tStatus smgrMesgIccSbmSLAProfIngQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore   /* Out: returns if there is more data */) {
                                  
    return smgrMesgIccSbmSLAProfQOvrUpdate(SlotBitmap,First,pKey,pMore,TRUE);
                                  
}

PRIVATE tStatus smgrMesgIccSbmSLAProfEgrQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore   /* Out: returns if there is more data */) {

     return smgrMesgIccSbmSLAProfQOvrUpdate(SlotBitmap,First,pKey,pMore,FALSE);
                                  
}

PRIVATE void smgrMesgIccSbmSLAProfQOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSLAProfQOvr *pLast = (tSmgrIcc_SbmSLAProfQOvr*) pLastKey;
    printf("SLA profile name: %s length: %d qospolId: %u qosQId: %u \n",
           pLast->slaProfName.name,pLast->slaProfName.length,pLast->qosPolId,pLast->qosQueueId);
}


////////////////////////////////////////////////////////////////////////////////
// Sbm SLA Profile Policer overrides - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem          slaProfName;
   tUint32                    qosPolId;       
   tUint32                    qosPolicerId ; 
} tSmgrIcc_SbmSLAProfPlcrOvr;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSLAProfPlcrOvrCmp(const void *pLastKey,
                                                tUint32 IomOp,
                                                const tSbmSLAProfPolicerOvr *pSLAProfPlcrOvr)
{
    tSmgrIcc_SbmSLAProfPlcrOvr *pLast = (tSmgrIcc_SbmSLAProfPlcrOvr*)pLastKey;
    int rc;


    if (!pLast || !pSLAProfPlcrOvr)
        return ERROR;
    
    if ((rc = STRNCMP_TNamedItem(&pLast->slaProfName,
                                 &pSLAProfPlcrOvr->pSLAProf->name)) != 0)
    {
         return ((rc > 0) ? OK: ERROR);
    }
    
    /* tSapIngressIndex/tSapEgressIndex */
    if (pLast->qosPolId < pSLAProfPlcrOvr->qosPolId)
        return  ERROR;
    
    if (pLast->qosPolId > pSLAProfPlcrOvr->qosPolId)
        return OK;

    /* tSapIngressQueue/tSapEgressQueueIndex */
    if (pLast->qosPolicerId < pSLAProfPlcrOvr->qosPolicerId)
        return ERROR;
    if (pLast->qosPolicerId > pSLAProfPlcrOvr->qosPolicerId)
        return OK;

   return OK;
   
}


PRIVATE tStatus smgrMesgIccSbmSLAProfPlcrOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore,   /* Out: returns if there is more data */
                                                   tBoolean Ingress /*In */)
{
    tSmgrIcc_SbmSLAProfPlcrOvr *pLastKey = (tSmgrIcc_SbmSLAProfPlcrOvr*) pKey;
    tSbmSLAProfPolicerOvr *pSLAProfPlcrOvr = NULL;
    tUint32 IomBitMask;
    tAvlpTree *pQOvrTree = NULL;

    if (Ingress)
        pQOvrTree = sbmSLAProfIngPolicerOvrTbl;
    else
        pQOvrTree = sbmSLAProfEgrPolicerOvrTbl;
    
    if (First) {       
        avlpFirst(pQOvrTree, NULL, (void **)&pSLAProfPlcrOvr);
    }
    else {
        tSbmSLAProfPolicerOvr  tmpPlcrOvr;
        tSbmSLAProf   tmpSLAProf;
    
        STRCPY_TNamedItem(&tmpSLAProf.name,
                          pLastKey->slaProfName.name,
                          pLastKey->slaProfName.length);

        tmpPlcrOvr.pSLAProf  = &tmpSLAProf;
        tmpPlcrOvr.qosPolId  = pLastKey->qosPolId;
        tmpPlcrOvr.qosPolicerId = pLastKey->qosPolicerId;
        
        avlpNext(pQOvrTree, (char *)&tmpPlcrOvr, NULL, (void **)&pSLAProfPlcrOvr);
    }   

    if (pSLAProfPlcrOvr) {
        tUint32 thisSlotMask = SlotBitmap;
        
        IomBitMask =
            smgrGetNonHsmdaIomBitmask(sbmGetSLAProfIomBitMask(pSLAProfPlcrOvr->pSLAProf));

        thisSlotMask &= IomBitMask;
        if (thisSlotMask) {
            smgrBatchSLAProfPolicerOverrideAddMesgPriv(pSLAProfPlcrOvr, Ingress,
                                                       thisSlotMask,
                                                       SlotBitmap, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }

        STRCPY_TNamedItem(&pLastKey->slaProfName,
                          pSLAProfPlcrOvr->pSLAProf->name.name,
                          pSLAProfPlcrOvr->pSLAProf->name.length);

        pLastKey->qosPolId = pSLAProfPlcrOvr->qosPolId;
        pLastKey->qosPolicerId = pSLAProfPlcrOvr->qosPolicerId;
        *pMore = TRUE;        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}

PRIVATE tStatus smgrMesgIccSbmSLAProfIngPlcrOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                      tBoolean  First,   /* In: */
                                                      void     *pKey,    /* In/Out: */
                                                      tBoolean *pMore   /* Out: returns if there is more data */) {
                                  
    return smgrMesgIccSbmSLAProfPlcrOvrUpdate(SlotBitmap,First,pKey,pMore,TRUE);
                                  
}

PRIVATE tStatus smgrMesgIccSbmSLAProfEgrPlcrOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                      tBoolean  First,   /* In: */
                                                      void     *pKey,    /* In/Out: */
                                                      tBoolean *pMore   /* Out: returns if there is more data */) {

     return smgrMesgIccSbmSLAProfPlcrOvrUpdate(SlotBitmap,First,pKey,pMore,FALSE);
                                  
}

PRIVATE void smgrMesgIccSbmSLAProfPlcrOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSLAProfPlcrOvr *pLast = (tSmgrIcc_SbmSLAProfPlcrOvr*) pLastKey;
    printf("SLA profile name: %s length: %d qospolid: %u qosPolicerId: %u \n",
           pLast->slaProfName.name,pLast->slaProfName.length,pLast->qosPolId,pLast->qosPolicerId);
}


////////////////////////////////////////////////////////////////////////////////
// Sbm SLA Profile Scheduler Overrides - ICC_SOCKET_SAP_SUB

typedef struct {
   STRUCT_TNamedItem       slaProfName;
   tUint8                  direction;
   STRUCT_TNamedItem       schedPolname;
   STRUCT_TNamedItem       virtSchedname;
} tSmgrIcc_SbmSLAProfSchedOvr;


// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSLAProfSchedOvrCmp(const void *pLastKey,
                                                 tUint32 IomOp,
                                                 const tSbmSLAProfSchedOvr *pSLAProfSchedOvr)
{
    tSmgrIcc_SbmSLAProfSchedOvr *pLast = (tSmgrIcc_SbmSLAProfSchedOvr *)pLastKey;
    int rc;

    if (!pLast || !pSLAProfSchedOvr)
        return ERROR;

    if ((rc = STRNCMP_TNamedItem(&pLast->slaProfName,
                                 &pSLAProfSchedOvr->pSLAProf->name)) != 0)
    {
        return ((rc > 0) ? OK: ERROR);
    }

    /* tmnxSLAProfSchedOvrDirection */
    if (pLast->direction < pSLAProfSchedOvr->direction)
        return ERROR;
    if (pLast->direction > pSLAProfSchedOvr->direction)
        return OK;

    /* tSchedulerPolicyName (!IMPLIED) */
    if ((rc = STRNCMP_TNamedItem(&pLast->schedPolname,
                                 &pSLAProfSchedOvr->schedPolname)) != 0)
    {
        return ((rc > 0) ? OK: ERROR);
    }

    /* tVirtualSchedulerName (IMPLIED) */
    rc = STRCMP_TNamedItem_implied(&pLast->virtSchedname,
                                   &pSLAProfSchedOvr->virtSchedname);

    return ((rc >= 0) ? OK: ERROR);

}

PRIVATE tStatus smgrMesgIccSbmSLAProfSchedOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                    tBoolean  First,   /* In: */
                                                    void     *pKey,    /* In/Out: */
                                                    tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_SbmSLAProfSchedOvr *pLastKey = (tSmgrIcc_SbmSLAProfSchedOvr *) pKey;
    tSbmSLAProfSchedOvr *pSLAProfSchedOvr = NULL;
    tUint32 IomBitMask;

    if (First) {
        avlpFirst(sbmSLAProfSchedOvrTbl, NULL, (void **)&pSLAProfSchedOvr);
    }
    else {
        tSbmSLAProfSchedOvr  tmpSchedOvr;
        tSbmSLAProf          tmpSLAProf;

        STRCPY_TNamedItem(&tmpSLAProf.name,
                          pLastKey->slaProfName.name,
                          pLastKey->slaProfName.length);

        tmpSchedOvr.pSLAProf  = &tmpSLAProf;
        tmpSchedOvr.direction = pLastKey->direction;
        STRCPY_TNamedItem(&tmpSchedOvr.schedPolname,
                          pLastKey->schedPolname.name,
                          pLastKey->schedPolname.length);

        STRCPY_TNamedItem(&tmpSchedOvr.virtSchedname,
                          pLastKey->virtSchedname.name,
                          pLastKey->virtSchedname.length);

        avlpNext(sbmSLAProfSchedOvrTbl, (char *)&tmpSchedOvr, NULL, (void **)&pSLAProfSchedOvr);
    }

    if (pSLAProfSchedOvr) {
        tUint32 SlotMask = SlotBitmap;

        IomBitMask = sbmGetSLAProfIomBitMask(pSLAProfSchedOvr->pSLAProf);
        SlotMask &= IomBitMask;

        if (SlotMask) {
            smgrBatchSLAProfVSOverrideAddMesgPriv(pSLAProfSchedOvr, SlotMask, SlotBitmap, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }

        STRCPY_TNamedItem(&pLastKey->slaProfName, pSLAProfSchedOvr->pSLAProf->name.name, pSLAProfSchedOvr->pSLAProf->name.length);
        STRCPY_TNamedItem(&pLastKey->schedPolname, pSLAProfSchedOvr->schedPolname.name, pSLAProfSchedOvr->schedPolname.length);
        STRCPY_TNamedItem(&pLastKey->virtSchedname, pSLAProfSchedOvr->virtSchedname.name, pSLAProfSchedOvr->virtSchedname.length);
        pLastKey->direction = pSLAProfSchedOvr->direction;
        *pMore = TRUE;

    } else {
        /* no more entries */
        *pMore = FALSE;
    }
    return OK;
}


PRIVATE void smgrMesgIccSbmSLAProfSchedOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSLAProfSchedOvr *pLast = (tSmgrIcc_SbmSLAProfSchedOvr*) pLastKey;
    printf("SLA profile name: %s length: %d Dir: %u schedPol name: %s length: %d virtSched name: %s length: %d\n",
           pLast->slaProfName.name, pLast->slaProfName.length, pLast->direction, pLast->schedPolname.name, pLast->schedPolname.length,
           pLast->virtSchedname.name, pLast->virtSchedname.length);
}


////////////////////////////////////////////////////////////////////////////////
// Sbm Act subscriber - ICC_SOCKET_SAP_SUB

typedef struct {
  char subId[MAXSIZE_tmnxSubExplicitMapSubIdent + 1] ; 
} tSmgrIcc_SbmActSub;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmActSubCmp(const void *pLastKey,
                                        tUint32 IomOp,
                                        const tSbmActSub *pActSub)
{
    tSmgrIcc_SbmActSub *pLast = (tSmgrIcc_SbmActSub*)pLastKey;
    int rc;


    switch (IomOp) {
    case IOM_ESM_SUBSCRIBER_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pActSub)
        return ERROR;
    
   rc = strcmp(pLast->subId, pActSub->subId);
   return ((rc >= 0) ? OK : ERROR);

}


PRIVATE tStatus smgrMesgIccSbmActSubUpdate(tUint32   SlotBitmap, /* In: */
                                           tBoolean  First,   /* In: */
                                           void     *pKey,    /* In/Out: */
                                           tBoolean *pMore   /* Out: returns if there is more data */)
     
{
    tSmgrIcc_SbmActSub *pLastKey = (tSmgrIcc_SbmActSub*) pKey;
    tSbmActSub *pActSub = NULL;
    
    if (First) {       
        avlpFirst(sbmActSubTbl, NULL, (void **)&pActSub);
    }
    else {
        tSbmActSub  tmpActSub;
    
        sbmStrCpy(tmpActSub.subId, pLastKey->subId, sizeof(tmpActSub.subId));
        
        avlpNext(sbmActSubTbl, (char *)&tmpActSub, NULL, (void **)&pActSub);
    }   

    if (pActSub) {     

        if (pActSub->pSubProf) {
            smgrBatchSubscriberAddMesgPriv(pActSub, SlotBitmap, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
            
            pActSub->sentToIoms = TRUE;
        }        
        sbmStrCpy(pLastKey->subId, pActSub->subId, sizeof(pLastKey->subId));
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmActSubDump(const void *pLastKey)
{
    const tSmgrIcc_SbmActSub *pLast = (tSmgrIcc_SbmActSub*) pLastKey;
    printf ("ActSub: %s \n",pLast->subId);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm Subscriber scheduler overrides - ICC_SOCKET_SAP_SUB

typedef struct {
    char                    subId[MAXSIZE_tmnxSubExplicitMapSubIdent + 1]; /* key */
    tUint8                  direction;                                 /* key */
    tBoolean                isArbiter;                                 /* key */
    STRUCT_TNamedItem       virtSchedname;          /* key */
} tSmgrIcc_SbmSubSchedOvr;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSubSchedOvrCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const tSbmSubSchedOvr *pSchedOvr)
{
    tSmgrIcc_SbmSubSchedOvr *pLast = (tSmgrIcc_SbmSubSchedOvr*)pLastKey;
    int rc;


    if (!pLast || !pSchedOvr)
        return ERROR;
    
   /* subscriber name */
    if ((rc = strcmp(pLast->subId, pSchedOvr->subId)) != 0)
    {
        return ((rc >0) ? OK : ERROR);
    }

    /* subscriber scheduler override direction */
    if (pLast->direction < pSchedOvr->direction)
        return ERROR;
    if (pLast->direction > pSchedOvr->direction)
        return OK;

    /* type: scheduler or arbiter */
    if (!pLast->isArbiter && pSchedOvr->isArbiter)
        return OK;
    if (pLast->isArbiter && !pSchedOvr->isArbiter)
        return ERROR;

    /* tVirtualSchedulerName */
    rc = STRCMP_TNamedItem_implied(&pLast->virtSchedname,
                                   &pSchedOvr->virtSchedname);

   return((rc >=0) ? OK : ERROR);

}


PRIVATE tStatus smgrMesgIccSbmSubSchedOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore   /* Out: returns if there is more data */)
     
{
    tSmgrIcc_SbmSubSchedOvr *pLastKey = (tSmgrIcc_SbmSubSchedOvr*) pKey;
    tSbmSubSchedOvr *pSchedOvr = NULL;
    tUint32 IomBitMask;
    
    if (First) {       
        avlpFirst(sbmSubSchedOvrTbl, NULL, (void **)&pSchedOvr);
    }
    else {
        tSbmSubSchedOvr tmpSchedOvr;
    
        sbmStrCpy(tmpSchedOvr.subId, pLastKey->subId, sizeof(tmpSchedOvr.subId));
        tmpSchedOvr.direction = pLastKey->direction;
        tmpSchedOvr.isArbiter = pLastKey->isArbiter;
        STRCPY_TNamedItem(&tmpSchedOvr.virtSchedname, pLastKey->virtSchedname.name,
                          strlen(pLastKey->virtSchedname.name));

        avlpNext(sbmSubSchedOvrTbl, (char *)&tmpSchedOvr, NULL, (void **)&pSchedOvr);
    }   

    if (pSchedOvr) {     
        if (pSchedOvr->pActSub && pSchedOvr->pActSub->pSubProf) {
            tUint32 thisSlotMask = SlotBitmap;
            
            IomBitMask = sbmGetActSubIomBitMask(pSchedOvr->pActSub);
            thisSlotMask &= IomBitMask;
            
            if (thisSlotMask) {
                smgrBatchSubVSOverrideAddMesgPriv(pSchedOvr, thisSlotMask, SlotBitmap, TRUE, NULL);
                // No flush is done at this point. SmgrMsgr will flush at the end
            }
        }        
        sbmStrCpy(pLastKey->subId, pSchedOvr->subId, sizeof(pLastKey->subId));
        STRCPY_TNamedItem(&pLastKey->virtSchedname, pSchedOvr->virtSchedname.name,
                          strlen(pSchedOvr->virtSchedname.name));

        pLastKey->direction = pSchedOvr->direction;
        pLastKey->isArbiter = pSchedOvr->isArbiter;
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmSubSchedOvrDump(const void *pLastKey)
{
    const tSmgrIcc_SbmSubSchedOvr *pLast = (tSmgrIcc_SbmSubSchedOvr*) pLastKey;
   
    printf("ActSub: \"%s\" Dir: %d IsArbiter: %s Sched: \"%s\" \n",
           pLast->subId, pLast->direction,
           pLast->isArbiter ? "yes" : "no",
           pLast->virtSchedname.name);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm Subscriber L3 Group If  - ICC_SOCKET_SAP_SUB

typedef struct {
     tServId SvcRecId; 
     tUint32 IfIndex;
} tSmgrIcc_SbmIesIfGroupIf;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmIesIfGroupIfCmp(const void *pLastKey,
                                              tUint32 IomOp,
                                              const  tIesIfRec *pIesIf)
{
    tSmgrIcc_SbmIesIfGroupIf *pLast = (tSmgrIcc_SbmIesIfGroupIf*)pLastKey;

    switch (IomOp) {
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pIesIf)
        return ERROR;
    
    if (pLast->SvcRecId > pIesIf->SvcRec->Id) {
        return OK;
    }
    
    if (pLast->SvcRecId < pIesIf->SvcRec->Id) {
        return ERROR;
    }

    if (pLast->IfIndex > pIesIf->IfIndex) {
        return OK;
    }

    if (pLast->IfIndex < pIesIf->IfIndex) {
        return ERROR;
    }
    return OK;

}


PRIVATE tStatus smgrMesgIccSbmIesIfGroupIfUpdate(tUint32   SlotBitmap, /* In: */
                                                 tBoolean  First,   /* In: */
                                                 void     *pKey,    /* In/Out: */
                                                 tBoolean *pMore   /* Out: returns if there is more data */)
     
{
    tSmgrIcc_SbmIesIfGroupIf *pLastKey = (tSmgrIcc_SbmIesIfGroupIf*) pKey;
    tIesIfRec *pIesIf = NULL;

    if (First) {       
        avlpFirst(IesIfTbl, NULL, (void **)&pIesIf);
    } else {
        tIesIfRec IesIf;
        tSvcRec Svc;
       
        IesIf.IfIndex = pLastKey->IfIndex;
        IesIf.SvcRec = &Svc;
        Svc.Id  = pLastKey->SvcRecId;
        
        avlpNext(IesIfTbl, (char*)&IesIf, NULL, (void**) &pIesIf);
    }   

    if (pIesIf) {     
        if (IS_IIT_GROUP_IF(pIesIf)) {
            smgrBatchSubL3RedGroupMesgPriv(pIesIf,SlotBitmap,TRUE,TRUE,TRUE,NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }
        pLastKey->SvcRecId= pIesIf->SvcRec->Id;
        pLastKey->IfIndex= pIesIf->IfIndex;
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmIesIfGroupIfDump(const void *pLastKey)
{
    const tSmgrIcc_SbmIesIfGroupIf *pLast = (tSmgrIcc_SbmIesIfGroupIf*) pLastKey;
   
    printf("Sbm L3 Group scvRecId: %u Ifindex: %u \n",pLast->SvcRecId,pLast->IfIndex);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm Subscriber L3 Group If Ring Node - ICC_SOCKET_SAP_SUB

typedef struct {
    tServId SvcRecId; 
    tUint32 IfIndex;
    char Name[MCR_RING_MAX_NAME_LENGTH+1];
} tSmgrIcc_SbmIesIfGroupIfRingNode;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmIesIfGroupIfRingNodeCmp(const void *pLastKey,
                                                      tUint32 IomOp,
                                                      const  tSMMcRingnodeRec *pRingnode )
{
     tSmgrIcc_SbmIesIfGroupIfRingNode *pLast = (tSmgrIcc_SbmIesIfGroupIfRingNode*)pLastKey;
     tIesIfRec *pIesIf= NULL;
        
     int rc;
     if(!pLast || !pRingnode)
        return ERROR;

    pIesIf = pRingnode->SrrpRec->GrpIf;
   
    if (pLast->SvcRecId > pIesIf->SvcRec->Id) {
        return OK;
    }
    if (pLast->SvcRecId < pIesIf->SvcRec->Id) {
        return ERROR;
    }

    if (pLast->IfIndex > pIesIf->IfIndex) {
        return OK;
    }

    if (pLast->IfIndex < pIesIf->IfIndex) {
        return ERROR;
    }
    rc = strcmp(pLast->Name,pRingnode->Name);
    return ((rc >= 0) ? OK: ERROR);

}


PRIVATE tStatus smgrMesgIccSbmIesIfGroupIfRingNodeUpdate(tUint32   SlotBitmap, /* In: */
                                                         tBoolean  First,   /* In: */
                                                         void     *pKey,    /* In/Out: */
                                                         tBoolean *pMore   /* Out: returns if there is more data */)
     
{
    tSmgrIcc_SbmIesIfGroupIfRingNode *pLastKey = (tSmgrIcc_SbmIesIfGroupIfRingNode*) pKey;
    tIesIfRec *pIesIf = NULL;
    tSMMcRingnodeRec *pRingnode= NULL;
    tIesIfRec IesIf;
    tSvcRec Svc;
    
    if (First) {       
        avlpFirst(IesIfTbl, NULL, (void **)&pIesIf);
        if (pIesIf && IS_IIT_GROUP_IF(pIesIf) && pIesIf->IesIfGrpInfo->SrrpRec ) {
            avlpFirst(pIesIf->IesIfGrpInfo->SrrpRec->RingnodeTree, NULL, (void **)&pRingnode); 
        }
    } else {
        IesIf.IfIndex = pLastKey->IfIndex;
        IesIf.SvcRec = &Svc;
        Svc.Id  = pLastKey->SvcRecId;
        
        avlpLookup(IesIfTbl, (char*)&IesIf, (void**) &pIesIf);

        if (pIesIf && IS_IIT_GROUP_IF(pIesIf) && pIesIf->IesIfGrpInfo->SrrpRec) {   
            avlpNext(pIesIf->IesIfGrpInfo->SrrpRec->RingnodeTree,pLastKey->Name,NULL,(void **)&pRingnode);
        } else if(!pIesIf) {
           avlpNext(IesIfTbl,(char*)&IesIf,NULL,(void **)&pIesIf);
            if (pIesIf && IS_IIT_GROUP_IF(pIesIf) && pIesIf->IesIfGrpInfo->SrrpRec ) {
                avlpFirst(pIesIf->IesIfGrpInfo->SrrpRec->RingnodeTree, NULL, (void **)&pRingnode); 
            }
        }
    }
    while(!pRingnode && pIesIf) {          
        IesIf.IfIndex = pIesIf->IfIndex;
        IesIf.SvcRec = &Svc;
        Svc.Id  = pIesIf->SvcRec->Id;
             
        pIesIf = NULL;
        if (avlpNext(IesIfTbl,(char*)&IesIf,NULL,(void **)&pIesIf) == AVLP_OK) {  
            if (pIesIf && IS_IIT_GROUP_IF(pIesIf) && pIesIf->IesIfGrpInfo->SrrpRec ) {
                avlpFirst(pIesIf->IesIfGrpInfo->SrrpRec->RingnodeTree, NULL, (void **)&pRingnode); 
            }
        } 
    }   

    if (pRingnode) {     
        
        smgrBatchMcRingRingnodeAddMesgPriv(pRingnode, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pLastKey->SvcRecId= pIesIf->SvcRec->Id;
        pLastKey->IfIndex= pIesIf->IfIndex;
        strlcpy(pLastKey->Name,pRingnode->Name,sizeof(pLastKey->Name));
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmIesIfGroupIfRingNodeDump(const void *pLastKey)
{
    const tSmgrIcc_SbmIesIfGroupIfRingNode *pLast = (tSmgrIcc_SbmIesIfGroupIfRingNode*) pLastKey;
   
    printf("Sbm L3 Group scvRecId: %u Ifindex: %u RingNodeName: %s \n",pLast->SvcRecId,pLast->IfIndex,pLast->Name);
}

////////////////////////////////////////////////////////////////////////////////
// Sbm Subscriber Host  - ICC_SOCKET_SAP_SUB

typedef struct {
     tServId          SvcId;
     tSapId           SapId;
     tTimNetAddr      NetAddr;
     tMacAddr         MacAddr;
     tUint16          PppoeSessionId;
} tSmgrIcc_SbmSubHost;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmSubHostCmp(const void *pLastKey,
                                        tUint32 IomOp,
                                        const  tSbmSubHost *pSubHost)
{
    tSmgrIcc_SbmSubHost *pLast = (tSmgrIcc_SbmSubHost*)pLastKey;
    int rc;

    switch (IomOp) {
    case IOM_ESM_HOST_AUDIT:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pSubHost)
        return ERROR;
    
   if (pLast->SvcId > pSubHost->pSvc->Id) {
        return OK;
    }
    if (pLast->SvcId < pSubHost->pSvc->Id) {
        return ERROR;
    }
    if ((rc = sapCmpIds((char *)&pLast->SapId,
                        (char *)&pSubHost->pSap->SapId)) != 0)
    {
        return ((rc >= 0) ? OK: ERROR);
    }

    /* IP addr */
    if ((rc = TIM_NET_ADDR_CMP(&pLast->NetAddr, &pSubHost->netAddr)) != 0)
    {
        return ((rc >= 0) ? OK: ERROR);
    }

    /* MAC addr */
    if ((rc = memcmp(&pLast->MacAddr, &pSubHost->macAddr, sizeof(tMacAddr))) != 0)
    {
        return ((rc >= 0) ? OK: ERROR);
    }

    /* PPPoE session-id */
    if (pLast->PppoeSessionId < pSubHost->pppoeSessionId)
        return ERROR;
    
    if (pLast->PppoeSessionId > pSubHost->pppoeSessionId)
        return OK;

    return OK;
}


PRIVATE tStatus smgrMesgIccSbmSubHostUpdate(tUint32   SlotBitmap, /* In: */
                                            tBoolean  First,   /* In: */
                                            void     *pKey,    /* In/Out: */
                                            tBoolean *pMore   /* Out: returns if there is more data */)
     
{
    tSmgrIcc_SbmSubHost *pLastKey = (tSmgrIcc_SbmSubHost*) pKey;
    tSbmSubHost *pSubHost = NULL;

    if (First) {       
        avlpFirst(sbmSubHostTbl, NULL, (void **)&pSubHost);
    }
    else {
        tSbmSubHost  entry;
        tSvcRec      svc;
        tSapRec      sap;

        svc.Id    = pLastKey->SvcId;
        sap.SapId = pLastKey->SapId;
    
        /* Key */
        entry.pSvc           = &svc;
        entry.pSap           = &sap;
        entry.netAddr        = pLastKey->NetAddr;
        entry.macAddr        = pLastKey->MacAddr;
        entry.pppoeSessionId = pLastKey->PppoeSessionId;
       
     
        avlpNext(sbmSubHostTbl, (char*)&entry, NULL, (void**) &pSubHost);
    }   

    if (pSubHost) {  
        smgrBatchSubscriberHostAddMesgPriv(pSubHost, pSubHost->pSap, SlotBitmap, TRUE, NULL);        
        // No flush is done at this point. SmgrMsgr will flush at the end

        pLastKey->SvcId  = pSubHost->pSvc->Id;
        pLastKey->SapId  = pSubHost->pSap->SapId;
        pLastKey->NetAddr = pSubHost->netAddr;
        pLastKey->MacAddr = pSubHost->macAddr;
        pLastKey->PppoeSessionId = pSubHost->pppoeSessionId;

        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmSubHostDump(const void *pLastKey)
{
   const tSmgrIcc_SbmSubHost *pLast = (tSmgrIcc_SbmSubHost*) pLastKey;
   char  tmpbuf1[FMT_IP6_BUF_SIZE];
   char  tmpbuf2[32];
   
   printf ("svcid: %3u Sap: %-18.18s IP: %-15.15s MAC: %-17.17s PppoeSessId: %u\n",
           pLast->SvcId,
           smgrFmtSapIdVerboseForDebug(&pLast->SapId),
           TIM_NET_ADDR_PRINT(&pLast->NetAddr, tmpbuf1, sizeof(tmpbuf1)),
           FmtMac(&pLast->MacAddr,tmpbuf2,sizeof(tmpbuf2)),
           pLast->PppoeSessionId);
  
}



////////////////////////////////////////////////////////////////////////////////
// Sbm Subscriber Host  - ICC_SOCKET_SAP_SUB

typedef struct {
     tUint32         lnsClientId;
} tSmgrIcc_SbmPppoeLnsSub;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSbmPppoeLnsSubCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             tUint32 lnsClientId)
{
    tSmgrIcc_SbmPppoeLnsSub *pLast = (tSmgrIcc_SbmPppoeLnsSub*)pLastKey;

    if (pLast->lnsClientId <lnsClientId)
        return ERROR;
    if (pLast->lnsClientId > lnsClientId)
        return OK;
    
    return OK; 
}


PRIVATE tStatus smgrMesgIccSbmPppoeLnsSubUpdate(tUint32   SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore   /* Out: returns if there is more data */)
     
{
    tSmgrIcc_SbmPppoeLnsSub *pLastKey = (tSmgrIcc_SbmPppoeLnsSub*) pKey;
    struct pppoeSession *pSession = NULL;

    if (First) {       
       pSession = pppoeFindFirstLnsSession();
    } else {
       pSession = pppoeFindNextLnsSession(pLastKey->lnsClientId);
    }   

    if (pSession) {  
        struct pppoeLnsCI *pCI=NULL;
        
        pCI = pppoeLnsGetConnectInfo(pSession);
     

        if (pppoeLnsConnectInfoSubHostOnIom(pCI)) {

            smgrBatchLnsSubscriberHostAddMesgPriv(
                                       pppoeLnsConnectInfoGetClientId(pCI),
                                       pppoeLnsConnectInfoGetLocTunnelId(pCI),
                                       pppoeLnsConnectInfoGetLocSessionId(pCI),
                                       pppoeLnsConnectInfoGetIsaGlobalIf(pCI),
                                       pppoeLnsConnectInfoGetIsaNhAddress(pCI),
                                       SlotBitmap, TRUE, NULL);
            // No flush is done at this point. SmgrMsgr will flush at the end
        }

        pLastKey->lnsClientId  = pppoeLnsConnectInfoGetClientId(pCI);
        *pMore = TRUE;
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}


PRIVATE void smgrMesgIccSbmPppoeLnsSubDump(const void *pLastKey)
{
   const tSmgrIcc_SbmPppoeLnsSub *pLast = (tSmgrIcc_SbmPppoeLnsSub*) pLastKey;
   
   printf ("Client Id: %u \n", pLast->lnsClientId);
  
}

////////////////////////////////////////////////////////////////////////////////
// Sap Ingress scheduler policy overrides  - ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE

typedef struct {
     tPortId PortId;
     tSapId SapId;    
} tSmgrIcc_SapQosOvrKey;

typedef struct {
     tSmgrIcc_SapQosOvrKey  SapKey;
     tUserSchedulerName Name;     
} tSmgrIcc_SapSchedPlcyOvr;



typedef enum {
    SAP_ING_SCHEDPLCY_OVR = 0,
    SAP_EGR_SCHEDPLCY_OVR,
    SAP_ING_Q_OVR,
    SAP_EGR_Q_OVR,
    SAP_ING_PLCR_OVR,
    SAP_EGR_PLCR_OVR,
    SAP_EGR_QMDA_OVR,
}tSapOvrType;

PRIVATE tAvlpTree* smgrMesgIccGetSapOvrTbl(tSapRec *pSapRec, tSapOvrType OvrTblType) {

    tAvlpTree* pTbl=NULL;
    
    if (!pSapRec)
        return NULL;
    switch (OvrTblType) {
        case SAP_ING_SCHEDPLCY_OVR:
            pTbl = pSapRec->IngSchedPolicyOverrideTbl;
            break;
        case SAP_EGR_SCHEDPLCY_OVR:
            pTbl = pSapRec->EgrSchedPolicyOverrideTbl;
            break;
        case SAP_ING_Q_OVR:
            pTbl = pSapRec->IngQueueOverrideTbl;
            break;
        case SAP_EGR_Q_OVR:
            pTbl = pSapRec->EgrQueueOverrideTbl;
            break;
        case SAP_ING_PLCR_OVR:
            pTbl = pSapRec->IngPolicerOverrideTbl;
            break;
        case SAP_EGR_PLCR_OVR:
            pTbl = pSapRec->EgrPolicerOverrideTbl;
            break;
        case SAP_EGR_QMDA_OVR:
            pTbl = pSapRec->EgrQmdaQueueOverrideTbl;
            break;
        default:
            break;
    }
    return pTbl;
    
}

#define DWLD_PORTSAP_OVR_DISABLED(pPortRec) ((pPortRec->Flags & PF_LAG_MEMBER) ||          \
                                             (! IS_HYBRID_OR_ACCESS_MODE(pPortRec->Mode)))
PRIVATE tStatus smgrMesgIccGetNextSapOverTblEntry(tSmgrIcc_SapQosOvrKey* pSapKey, void* pKey, tSapOvrType OvrTblType, tBoolean First, void** entry_p, tSapRec** ppSapRec) {

    tSMPortRec *pPortRec = NULL;
    tSapRec *pSapRec = NULL;

    if (!entry_p)
       return ERROR;

    *entry_p = NULL;

    if (First) {   
        /* find the first portId entry */
        avlpFirst(&SMPortTable,NULL, (void **)&pPortRec);
        
        if (pPortRec && !DWLD_PORTSAP_OVR_DISABLED(pPortRec)) {
            avlpFirst(&pPortRec->Access.SapTbl,NULL, (void **)&pSapRec);
        }
        if (pSapRec) {
            /* Get the first entry from the override table */
            avlpFirst(smgrMesgIccGetSapOvrTbl(pSapRec,OvrTblType),NULL, entry_p);
          
        }
    } else {
        avlpLookup(&SMPortTable, AVL_CAST_INT_TO_KEY(pSapKey->PortId), (void **) &pPortRec);
       
        if (!pPortRec) {
            /* The port has been deleted get the Next port */
            avlpNext(&SMPortTable, AVL_CAST_INT_TO_KEY(pSapKey->PortId),NULL, (void **)&pPortRec);
         
            if (pPortRec && !DWLD_PORTSAP_OVR_DISABLED(pPortRec)) {
                avlpFirst(&pPortRec->Access.SapTbl,NULL, (void **)&pSapRec);
            }
            if (pSapRec) {
                avlpFirst(smgrMesgIccGetSapOvrTbl(pSapRec,OvrTblType) ,NULL, entry_p);
            }
        }
        else {
            avlpLookup(&pPortRec->Access.SapTbl, (char *) &(pSapKey->SapId), (void **) &pSapRec);
            if (!pSapRec) {
                /*The sap has been deleted, get the next sap record */
                avlpNext(&pPortRec->Access.SapTbl,(char *) &(pSapKey->SapId),NULL, (void **)&pSapRec);
               
                if (pSapRec) {               
                    avlpFirst(smgrMesgIccGetSapOvrTbl(pSapRec,OvrTblType) ,NULL, entry_p);
                }
               
            }
            else {  
                avlpNext(smgrMesgIccGetSapOvrTbl(pSapRec,OvrTblType),(char *) pKey, NULL,entry_p);
            }
        }
    }
    while(pPortRec && !(*entry_p) ) {
        tPortId portId = pPortRec->PortId;
     
        while(!(*entry_p) && pSapRec) {

            tSapId sapId = pSapRec->SapId;
            pSapRec = NULL;
            avlpNext(&pPortRec->Access.SapTbl,(char *) &(sapId),NULL, (void **)&pSapRec);
              
            if (pSapRec) {
                avlpFirst(smgrMesgIccGetSapOvrTbl(pSapRec,OvrTblType),NULL, entry_p);
            }
        }     
            
        if (*entry_p) {
            /* Found the next Rec */
            break;
        }
        /* All the sap recs for the port has been visited. Find the next portId Rec */  
        pPortRec = NULL;
        avlpNext(&SMPortTable, AVL_CAST_INT_TO_KEY(portId), NULL, (void **)&pPortRec);

    
        if (pPortRec && !DWLD_PORTSAP_OVR_DISABLED(pPortRec)) {
            /* find the first pSapRec */
            pSapRec = NULL;
            avlpFirst(&pPortRec->Access.SapTbl,NULL, (void **)&pSapRec);
        }
        if (pSapRec) {      
            avlpFirst(smgrMesgIccGetSapOvrTbl(pSapRec,OvrTblType),NULL, entry_p);
        }
    }
 
    if (ppSapRec) {
        *ppSapRec = pSapRec;
    }
    return OK;
}


    
// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSapSchedPlcyOvrCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const tQosVSchedOverrideRec *pVSched,
                                             const tSapRec *pSap)
{
    tSmgrIcc_SapSchedPlcyOvr *pLast = (tSmgrIcc_SapSchedPlcyOvr*)pLastKey;
    int rc = 0;
    int (*sapCmpFunc)(const char*, const char*);

    sapCmpFunc = NULL;

    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pVSched || !pSap)
        return ERROR;
    
    if ((rc = avlpNumCmp(AVL_CAST_INT_TO_KEY(pLast->SapKey.PortId), AVL_CAST_INT_TO_KEY(pSap->PortRec->PortId))) != 0) {
        return ((rc >0) ? OK: ERROR);
    }
    
    if (pSap->PortRec->EncapType == PORT_ENCAP_QINQ)  {
        sapCmpFunc = sapCmpIdsQinQPort;
    } else {
        sapCmpFunc =  sapCmpIds;
    }
    if ((rc = sapCmpFunc((char *)&(pLast->SapKey.SapId),
                           (char *)&pSap->SapId)) != 0)
    {
        return ((rc > 0) ? OK: ERROR);
    }
    
    rc = strcmp(pLast->Name.Str,pVSched->Name.Str);
    return ((rc >= 0) ? OK: ERROR);
}

PRIVATE tStatus smgrMesgIccSapSchedPlcyOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                 tBoolean  First,   /* In: */
                                                 void     *pKey,    /* In/Out: */
                                                 tBoolean *pMore,   /* Out: returns if there is more data */
                                                 int       Direction /*In */)
     
{
    tSmgrIcc_SapSchedPlcyOvr *pLastKey = (tSmgrIcc_SapSchedPlcyOvr*) pKey;
    tQosVSchedOverrideRec *pSchedOvrRec = NULL;
    tSapRec *pSapRec = NULL;
    tBatchProcessing Batch = {0};

    Batch.Batch = TRUE;

    if (Direction == SAP_ING_SCHED) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey,(void*)pLastKey->Name.Str,SAP_ING_SCHEDPLCY_OVR,First,(void**)&pSchedOvrRec,&pSapRec);
    }
    else if (Direction == SAP_EGR_SCHED) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey,(void*)pLastKey->Name.Str,SAP_EGR_SCHEDPLCY_OVR,First,(void**)&pSchedOvrRec,&pSapRec);
    }
    else 
         return ERROR;
  
    if (pSchedOvrRec && pSapRec) {
        smgrSendSapVSOverrideAddMesgPriv(pSapRec, Direction, pSchedOvrRec, SlotBitmap, &Batch, TRUE);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pLastKey->Name = pSchedOvrRec->Name;
        pLastKey->SapKey.PortId = pSapRec->PortRec->PortId;
        pLastKey->SapKey.SapId = pSapRec->SapId;
        
        *pMore = TRUE;
   
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}

PRIVATE tStatus smgrMesgIccSapIngSchedPlcyOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                    tBoolean  First,   /* In: */
                                                    void     *pKey,    /* In/Out: */
                                                    tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapSchedPlcyOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_ING_SCHED);
   return rc;
   
}
PRIVATE void smgrMesgIccSapIngSchedPlcyOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapSchedPlcyOvr *pLast = (tSmgrIcc_SapSchedPlcyOvr*) pLastKey;
   
   printf("Sap Ingress Sched policy PortId: %u Sap: %-18.18s SchedName: %s \n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Name.Str);
}

////////////////////////////////////////////////////////////////////////////////
// Sap Egress scheduler policy overrides  - ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE

PRIVATE tStatus smgrMesgIccSapEgrSchedPlcyOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                    tBoolean  First,   /* In: */
                                                    void     *pKey,    /* In/Out: */
                                                    tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapSchedPlcyOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_EGR_SCHED);
   return rc;
   
}
PRIVATE void smgrMesgIccSapEgrSchedPlcyOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapSchedPlcyOvr *pLast = (tSmgrIcc_SapSchedPlcyOvr*) pLastKey;
   
   printf("Sap Egress Sched policy PortId: %u Sap: %-18.18s SchedName: %s \n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Name.Str);
}

 

////////////////////////////////////////////////////////////////////////////////
// Sap Ingress and Egress  Policer Control overrides  - ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE
// Returns OK if allowed to download this update

PRIVATE tStatus smgrMesgIccSapPlcrCtrlOvrCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const tSapRec *pSap)
{
    tSmgrIcc_SapSchedPlcyOvr *pLast = (tSmgrIcc_SapSchedPlcyOvr*)pLastKey;
    int rc = 0;
    int (*sapCmpFunc)(const char*, const char*);

    sapCmpFunc = NULL;

    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pSap)
        return ERROR;
    
    if ((rc = avlpNumCmp(AVL_CAST_INT_TO_KEY(pLast->SapKey.PortId), AVL_CAST_INT_TO_KEY(pSap->PortRec->PortId))) != 0) {
        return ((rc >0) ? OK: ERROR);
    }
    
    if (pSap->PortRec->EncapType == PORT_ENCAP_QINQ){
        sapCmpFunc = sapCmpIdsQinQPort;
    } else {
        sapCmpFunc =  sapCmpIds;
    }
    rc = sapCmpFunc((char *)&(pLast->SapKey.SapId),(char *)&pSap->SapId);

    return ((rc >= 0) ? OK: ERROR);
    
}

PRIVATE tStatus smgrMesgIccSapPlcrCtrlOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore,  /* Out: returns if there is more data */
                                                int Direction /* In */ ) {
                                                
    tSmgrIcc_SapQosOvrKey *pLastKey = (tSmgrIcc_SapQosOvrKey*) pKey;
    tSapRec *pSapRec = NULL;
    tSMPortRec *pPortRec = NULL;
    tQosPolicerCtrlOverrideRec *pPlctCtrlOvr = NULL;
    tBatchProcessing Batch = {0};

    Batch.Batch = TRUE;

    if ((Direction != SAP_ING_ARBIT) && (Direction != SAP_EGR_ARBIT))
        return ERROR;
    
    if (First) {   
        /* find the first portId entry */
        avlpFirst(&SMPortTable,NULL, (void **)&pPortRec);
        
        if (pPortRec &&
            IS_HYBRID_OR_ACCESS_MODE(pPortRec->Mode)) {
            avlpFirst(&pPortRec->Access.SapTbl,NULL, (void **)&pSapRec);
        }        
    } else {
        avlpLookup(&SMPortTable, AVL_CAST_INT_TO_KEY(pLastKey->PortId), (void **) &pPortRec);
       
        if (!pPortRec) {
            /* The port has been deleted get the Next port */
            avlpNext(&SMPortTable, AVL_CAST_INT_TO_KEY(pLastKey->PortId),NULL, (void **)&pPortRec);
            if (pPortRec &&
                IS_HYBRID_OR_ACCESS_MODE(pPortRec->Mode)) {
                avlpFirst(&pPortRec->Access.SapTbl,NULL, (void **)&pSapRec);
            }
        } else if (IS_HYBRID_OR_ACCESS_MODE(pPortRec->Mode)) {
            avlpNext(&pPortRec->Access.SapTbl,(char *)&(pLastKey->SapId), NULL,(void**)&pSapRec);   
        }
    }
    if (pSapRec) {
       if (Direction == SAP_ING_ARBIT)
           pPlctCtrlOvr = pSapRec->IngPolicerCtrlOvrRec;
       else
           pPlctCtrlOvr = pSapRec->EgrPolicerCtrlOvrRec;
    }
    
    while(!pPlctCtrlOvr && pPortRec) {

        if (pSapRec) {
           /* get the next Sap rec */
           tSapId sapId = pSapRec->SapId;
           
           pSapRec = NULL;
           avlpNext(&pPortRec->Access.SapTbl,(char *)&sapId, NULL,(void**)&pSapRec);  
        } else {
             /* get the next Port rec */
             tPortId portId = pPortRec->PortId;
             pPortRec = NULL;
             
             avlpNext(&SMPortTable, AVL_CAST_INT_TO_KEY(portId),NULL, (void **)&pPortRec);

             if (pPortRec &&
                 IS_HYBRID_OR_ACCESS_MODE(pPortRec->Mode)) {
                 /* get the first Sap record */
                avlpFirst(&pPortRec->Access.SapTbl,NULL, (void **)&pSapRec); 
                
            }
        }
        if (pSapRec) {  
            if (Direction == SAP_ING_ARBIT)
                pPlctCtrlOvr = pSapRec->IngPolicerCtrlOvrRec;
            else
                pPlctCtrlOvr = pSapRec->EgrPolicerCtrlOvrRec;              
        }
    }
    
    if (pPlctCtrlOvr && pSapRec) {
        smgrSendSapPCOverrideAddMesgPriv(pSapRec, Direction, pPlctCtrlOvr, SlotBitmap, &Batch, TRUE);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pLastKey->PortId = pSapRec->PortRec->PortId;
        pLastKey->SapId = pSapRec->SapId;
        
        *pMore = TRUE;
   
    } else {
        /* no more entries */
        *pMore = FALSE;
    }
    return OK;                                           
}   
PRIVATE tStatus smgrMesgIccSapIngPlcrCtrlOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapPlcrCtrlOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_ING_ARBIT);
   return rc;
   
}
PRIVATE void smgrMesgIccSapIngPlcrCtrlOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvrKey *pLast = (tSmgrIcc_SapQosOvrKey*) pLastKey;
   
   printf("Sap Ingress policer control override PortId: %u Sap: %-18.18s \n", 
          pLast->PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapId)));
}


PRIVATE tStatus smgrMesgIccSapEgrPlcrCtrlOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapPlcrCtrlOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_EGR_ARBIT);
   return rc;
   
}

PRIVATE void smgrMesgIccSapEgrPlcrCtrlOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvrKey *pLast = (tSmgrIcc_SapQosOvrKey*) pLastKey;
   
   printf("Sap Egress policer control override PortId: %u Sap: %-18.18s \n", 
          pLast->PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapId)));
}

////////////////////////////////////////////////////////////////////////////////
// Sap Ingress and Egress  Queue overrides  - ICC_SOCKET_SAP_QOS_POLICY_OVERRIDE
// Returns OK if allowed to download this update

typedef struct {
     tSmgrIcc_SapQosOvrKey  SapKey;
     tUint32 Id;     
} tSmgrIcc_SapQosOvr;

PRIVATE tStatus smgrMesgIccSapOvrCmp(const void *pLastKey,
                                             tUint32 IomOp,
                                             const tSapRec *pSap,
                                             tUint32 QosId)
{
    tSmgrIcc_SapQosOvr *pLast = (tSmgrIcc_SapQosOvr*)pLastKey;
    int rc = 0;
    int (*sapCmpFunc)(const char*, const char*);

    sapCmpFunc = NULL;

    switch (IomOp) {
    case IOM_POLICY_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pSap)
        return ERROR;
    
    if ((rc = avlpNumCmp(AVL_CAST_INT_TO_KEY(pLast->SapKey.PortId), AVL_CAST_INT_TO_KEY(pSap->PortRec->PortId))) != 0) {
        return ((rc >0) ? OK: ERROR);
    }
    
    if (pSap->PortRec->EncapType == PORT_ENCAP_QINQ){
        sapCmpFunc = sapCmpIdsQinQPort;
    } else {
        sapCmpFunc =  sapCmpIds;
    }
    
    if ((rc = sapCmpFunc((char *)&(pLast->SapKey.SapId),(char *)&pSap->SapId)) != 0) {
        return ((rc >0) ? OK: ERROR);
    }

    rc = avlpNumCmp(AVL_CAST_INT_TO_KEY(pLast->Id), AVL_CAST_INT_TO_KEY(QosId));
    
    return ((rc >= 0) ? OK: ERROR);
    
}

PRIVATE tStatus smgrMesgIccSapQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                         tBoolean  First,   /* In: */
                                         void     *pKey,    /* In/Out: */
                                         tBoolean *pMore,  /* Out: returns if there is more data */
                                         int       Direction /* In */ ) {
                                                
    tSmgrIcc_SapQosOvr *pLastKey = (tSmgrIcc_SapQosOvr*) pKey;
    tSapRec *pSapRec = NULL;
    tQueueOverrideRec *pQOvr = NULL;

    if (Direction == SAP_ING_QOS_QUEUE) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey, CAST_INT_TO_PTR(void*, pLastKey->Id),SAP_ING_Q_OVR,First,(void**)&pQOvr,&pSapRec);
    }
    else if (Direction == SAP_EGR_QOS_QUEUE) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey, CAST_INT_TO_PTR(void*, pLastKey->Id),SAP_EGR_Q_OVR,First,(void**)&pQOvr,&pSapRec);
    }
    else 
         return ERROR;       
    
    if (pQOvr && pSapRec) {
        smgrBatchQueueOverrideAddMesgPriv(pSapRec, Direction, pQOvr, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pLastKey->SapKey.PortId = pSapRec->PortRec->PortId;
        pLastKey->SapKey.SapId = pSapRec->SapId;
        pLastKey->Id = pQOvr->QosQueueId;
        *pMore = TRUE;
   
    } else {
        /* no more entries */
        *pMore = FALSE;
    }
    return OK;                                           
}   

PRIVATE tStatus smgrMesgIccSapIngQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                            tBoolean  First,   /* In: */
                                            void     *pKey,    /* In/Out: */
                                            tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapQOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_ING_QOS_QUEUE);
   return rc;
   
}
PRIVATE void smgrMesgIccSapIngQOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvr *pLast = (tSmgrIcc_SapQosOvr*) pLastKey;
   
   printf("Sap Ingress Queue override PortId: %u Sap: %-18.18s  QueueId: %u\n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Id);
}


PRIVATE tStatus smgrMesgIccSapEgrQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                            tBoolean  First,   /* In: */
                                            void     *pKey,    /* In/Out: */
                                            tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapQOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_EGR_QOS_QUEUE);
   return rc;
   
}

PRIVATE void smgrMesgIccSapEgrQOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvr *pLast = (tSmgrIcc_SapQosOvr*) pLastKey;
   
  printf("Sap Egress Queue override PortId: %u Sap: %-18.18s  QueueId: %u\n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Id);
}

 ////////////////////////////////////////////////////////////////////////////////
// Sap Ingress and Egress  Policer overrides  - ICC_SOCKET_SAP_QOS_POLICY_OVERRIDE
// Returns OK if allowed to download this update

PRIVATE tStatus smgrMesgIccSapPlcrOvrUpdate(tUint32   SlotBitmap, /* In: */
                                            tBoolean  First,   /* In: */
                                            void     *pKey,    /* In/Out: */
                                            tBoolean *pMore,  /* Out: returns if there is more data */
                                            int       Direction /* In */ ) {
                                                
    tSmgrIcc_SapQosOvr *pLastKey = (tSmgrIcc_SapQosOvr*) pKey;
    tSapRec *pSapRec = NULL;
    tPolicerOverrideRec *pPlcrOvr = NULL;
    
    if (Direction == SAP_ING_QOS_POLICER) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey, CAST_INT_TO_PTR(void*, pLastKey->Id),SAP_ING_PLCR_OVR,First,(void**)&pPlcrOvr,&pSapRec);
    }
    else if (Direction == SAP_EGR_QOS_POLICER) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey, CAST_INT_TO_PTR(void*, pLastKey->Id),SAP_EGR_PLCR_OVR,First,(void**)&pPlcrOvr,&pSapRec);
    }
    else 
         return ERROR;       
    
    if (pPlcrOvr && pSapRec) {
        smgrBatchPolicerOverrideAddMesgPriv(pSapRec, Direction, pPlcrOvr, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pLastKey->SapKey.PortId = pSapRec->PortRec->PortId;
        pLastKey->SapKey.SapId = pSapRec->SapId;
        pLastKey->Id = pPlcrOvr->QosPolicerId;
        *pMore = TRUE;
   
    } else {
        /* no more entries */
        *pMore = FALSE;
    }
    return OK;                                           
}   

PRIVATE tStatus smgrMesgIccSapIngPlcrOvrUpdate(tUint32   SlotBitmap, /* In: */
                                               tBoolean  First,   /* In: */
                                               void     *pKey,    /* In/Out: */
                                               tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapPlcrOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_ING_QOS_POLICER);
   return rc;
   
}
PRIVATE void smgrMesgIccSapIngPlcrOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvr *pLast = (tSmgrIcc_SapQosOvr*) pLastKey;
   
   printf("Sap Ingress Policer override PortId: %u Sap: %-18.18s  PolicerId: %u\n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Id);
}


PRIVATE tStatus smgrMesgIccSapEgrPlcrOvrUpdate(tUint32   SlotBitmap, /* In: */
                                               tBoolean  First,   /* In: */
                                               void     *pKey,    /* In/Out: */
                                               tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapPlcrOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_EGR_QOS_POLICER);
   return rc;
   
}

PRIVATE void smgrMesgIccSapEgrPlcrOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvr *pLast = (tSmgrIcc_SapQosOvr*) pLastKey;
   
  printf("Sap Egress Policer override PortId: %u Sap: %-18.18s  PolicerId: %u\n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Id);
}

////////////////////////////////////////////////////////////////////////////////
// Sap Ingress and Egress  Qmda Q overrides  - ICC_SOCKET_QMDA
// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSapQmdaQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                             tBoolean  First,   /* In: */
                                             void     *pKey,    /* In/Out: */
                                             tBoolean *pMore,  /* Out: returns if there is more data */
                                             int       Direction /* In */ ) {
                                                
    tSmgrIcc_SapQosOvr *pLastKey = (tSmgrIcc_SapQosOvr*) pKey;
    tSapRec *pSapRec = NULL;
    tQmdaQueueOverrideRec *pQmdaQOvr = NULL;

    if (Direction == SAP_EGR_QOS_QMDA_QUEUE) {
        smgrMesgIccGetNextSapOverTblEntry(&pLastKey->SapKey, CAST_INT_TO_PTR(void*, pLastKey->Id),SAP_EGR_QMDA_OVR,First,(void**)&pQmdaQOvr,&pSapRec);
    }
    else 
         return ERROR;       
    
    if (pQmdaQOvr && pSapRec) {
        smgrBatchQmdaQueueOverrideAddMesgPriv(pSapRec, Direction, pQmdaQOvr, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
        
        pLastKey->SapKey.PortId = pSapRec->PortRec->PortId;
        pLastKey->SapKey.SapId = pSapRec->SapId;
        pLastKey->Id = pQmdaQOvr->QosQmdaQueueId;
        *pMore = TRUE;
   
    } else {
        /* no more entries */
        *pMore = FALSE;
    }
    return OK;                                           
}   


PRIVATE tStatus smgrMesgIccSapEgrQmdaQOvrUpdate(tUint32   SlotBitmap, /* In: */
                                                tBoolean  First,   /* In: */
                                                void     *pKey,    /* In/Out: */
                                                tBoolean *pMore  /* Out: returns if there is more data */) {
   int rc;
   rc  = smgrMesgIccSapQmdaQOvrUpdate(SlotBitmap,First,pKey,pMore,SAP_EGR_QOS_QMDA_QUEUE);
   return rc;
   
}

PRIVATE void smgrMesgIccSapEgrQmdaQOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapQosOvr *pLast = (tSmgrIcc_SapQosOvr*) pLastKey;
   
  printf("Sap Egress Qmda Q override PortId: %u Sap: %-18.18s  QmdaQId: %u\n", 
          pLast->SapKey.PortId,smgrFmtSapIdVerboseForDebug(&(pLast->SapKey.SapId)),pLast->Id);
}


////////////////////////////////////////////////////////////////////////////////
// Sap Egress Encap Groups - ICC_SOCKET_ENCAP_GROUP_TABLE

typedef struct {
    tSapId            SapId;
    STRUCT_TNamedItem Name;
} tSmgrIcc_SapEgrEncapGroup;

PRIVATE tStatus smgrMesgIccSapEgrEncapGroupCmp(const void *pLastKey,
                                               tUint32 IomOp,
                                               const tSapRec *pSap,
                                               const STRUCT_TNamedItem *pName)
{
    tSmgrIcc_SapEgrEncapGroup *pLast = (tSmgrIcc_SapEgrEncapGroup*)pLastKey;
    int rc = 0;
    int (*sapCmpFunc)(const char*, const char*);

    sapCmpFunc = NULL;

    switch (IomOp) {
    case IOM_ENCAP_GROUP_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast || !pSap)
        return ERROR;
    
    if ((rc = avlpNumCmp(AVL_CAST_INT_TO_KEY(pLast->SapId.PortId), AVL_CAST_INT_TO_KEY(pSap->PortRec->PortId))) != 0) {
        return ((rc >0) ? OK: ERROR);
    }
    
    if (pSap->PortRec->EncapType == PORT_ENCAP_QINQ){
        sapCmpFunc = sapCmpIdsQinQPort;
    } else {
        sapCmpFunc =  sapCmpIds;
    }
    
    if ((rc = sapCmpFunc((char *)&(pLast->SapId),(char *)&pSap->SapId)) != 0) {
        return ((rc >0) ? OK: ERROR);
    }

    rc = STRNCMP_TNamedItem(&pLast->Name,pName);
    
    return ((rc >= 0) ? OK: ERROR);
    
}


// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSapEgrEncapGroupUpdate(tUint32   SlotBitmap, /* In: */
                                                  tBoolean  First,   /* In: */
                                                  void     *pKey,    /* In/Out: */
                                                  tBoolean *pMore) { /* Out: returns if there is more data */
                                                
    tSmgrIcc_SapEgrEncapGroup *pLastKey = (tSmgrIcc_SapEgrEncapGroup*) pKey;
    tSapRec *pSapRec = NULL;
    tSapEgrEncapGroupRec *pEncapGroup = NULL;
    tSapId SapId;

    if (First) {
        SVCMGR_EVENT(NOCLASS, "SlotBitmap=0x%08x First=T", SlotBitmap);
    } else {
        SVCMGR_EVENT(NOCLASS, "SlotBitmap=0x%08x First=F LastKey:%s|'%s'", SlotBitmap,
                     smgrFmtSapIdVerboseForDebug(&pLastKey->SapId), pLastKey->Name.name);
    }

    if (First) {
        // Find the first SAP to start searching from
        avlpFirst(SysSapTbl, NULL, (void **) &pSapRec);
    } else {
        avlpLookup(SysSapTbl, (char *) &pLastKey->SapId, (void **) &pSapRec);
        if (pSapRec == NULL) {
            // If the exact SAP doesn't exist, find the next SAP
            avlpNext(SysSapTbl, (char *) &pLastKey->SapId, NULL, (void **) &pSapRec);
        } else if (pSapRec->EgrEncapGroupTbl != NULL) {
            // If the exact SAP exists and has Encap Groups, find the next Group
            avlpNext(pSapRec->EgrEncapGroupTbl, (char *) &pLastKey->Name, NULL, (void **) &pEncapGroup);
            if (pEncapGroup == NULL) {
                // If no group found in this group, continue looking below
                pSapRec = NULL;
                avlpNext(SysSapTbl, (char *) &pLastKey->SapId, NULL, (void **) &pSapRec);
            }
        }
    }
    if (pEncapGroup == NULL) {
        // Since no Group found yet, pickup searching where the above left off
        while ((pSapRec != NULL) &&
               ((pSapRec->EgrEncapGroupTbl == NULL) ||
                (avlpCount(pSapRec->EgrEncapGroupTbl) == 0))) {
            SapId = pSapRec->SapId;
            pSapRec = NULL;
            avlpNext(SysSapTbl, (char *) &SapId, NULL, (void **) &pSapRec);
        }
        if ((pSapRec != NULL) && (pSapRec->EgrEncapGroupTbl != NULL)) {
            avlpFirst(pSapRec->EgrEncapGroupTbl, NULL, (void **) &pEncapGroup);
        }
    }

    if (pEncapGroup && pSapRec) {
        smgrBatchSapEgrEncapGroupAddMesgPriv(pSapRec, pEncapGroup, SlotBitmap, TRUE, NULL);
        // No flush is done at this point. SmgrMsgr will flush at the end
                
        pLastKey->SapId = pSapRec->SapId;
        STRCPY_TNamedItem(&pLastKey->Name, pEncapGroup->Key.Name.name, pEncapGroup->Key.Name.length);
        *pMore = TRUE;
   
        SVCMGR_EVENT(NOCLASS, "  New LastKey:%s|'%s' more=T",
                     smgrFmtSapIdVerboseForDebug(&pLastKey->SapId), pLastKey->Name.name);
    } else {
        /* no more entries */
        *pMore = FALSE;
    }

    return OK;                                           
}   


PRIVATE void smgrMesgIccSapEgrEncapGroupDump(const void *pLastKey)
{
   const tSmgrIcc_SapEgrEncapGroup *pLast = (tSmgrIcc_SapEgrEncapGroup*) pLastKey;
   
  printf("Sap Egress Encap Group Sap: %-18.18s  Name: %s\n", 
         smgrFmtSapIdVerboseForDebug(&(pLast->SapId)),pLast->Name.name);
}

////////////////////////////////////////////////////////////////////////////////
// Sap Egress Encap Members - ICC_SOCKET_ENCAP_GROUP_TABLE

typedef struct {
    tSapId            SapId;
    STRUCT_TNamedItem Name;
    tUint32           MemberId;
} tSmgrIcc_SapEgrEncapMember;

// Returns OK if allowed to download this update
PRIVATE tStatus smgrMesgIccSapEgrEncapMemberUpdate(tUint32   SlotBitmap, /* In: */
                                                   tBoolean  First,   /* In: */
                                                   void     *pKey,    /* In/Out: */
                                                   tBoolean *pMore)   /* Out: returns if there is more data */
{
    tSmgrIcc_SapEgrEncapMember *pLastKey = (tSmgrIcc_SapEgrEncapMember*) pKey;
    tSapRec *pSapRec = NULL;
    tSapEgrEncapGroupRec *pEncapGroup = NULL;
    tUint32 StartMember;
    tUint32 EndMember;
    tSapId SearchSapId;
    STRUCT_TNamedItem SearchGroup;
    tUint32 SearchMember;

    if (First) {
        SVCMGR_EVENT(NOCLASS, "SlotBitmap=0x%08x First=T", SlotBitmap);
    } else {
        SVCMGR_EVENT(NOCLASS, "SlotBitmap=0x%08x First=F LastKey:%s|'%s'|%d", SlotBitmap,
                     smgrFmtSapIdVerboseForDebug(&pLastKey->SapId), pLastKey->Name.name, pLastKey->MemberId);
    }

    SearchMember = 0;
    if (First) {
        // Find the first SAP and Encap Group to start searching from
        avlpFirst(SysSapTbl, NULL, (void **) &pSapRec);
        // Find the next Encap Group below...
    } else {
        avlpLookup(SysSapTbl, (char *) &pLastKey->SapId, (void **) &pSapRec);
        if (pSapRec == NULL) {
            // If the exact SAP doesn't exist, find the next SAP and Encap Group
            avlpNext(SysSapTbl, (char *) &pLastKey->SapId, NULL, (void **) &pSapRec);
            // Find the next Encap Group below...
        } else if (pSapRec->EgrEncapGroupTbl != NULL) {
            pEncapGroup = sapFindEgrEncapGroupRec(pSapRec->EgrEncapGroupTbl, &pLastKey->Name);
            if (pEncapGroup == NULL) {
                // If the exact Encap Group doesn't exist, find the next one
                STRCPY_TNamedItem(&SearchGroup, pEncapGroup->Key.Name.name, pEncapGroup->Key.Name.length);
                pEncapGroup = sapFindNextEgrEncapGroupRec(pSapRec->EgrEncapGroupTbl, &SearchGroup);
                if (pEncapGroup == NULL) {
                    // If the Group doesn't exist, find the next SAP and Group
                    SearchSapId = pSapRec->SapId;
                    pSapRec = NULL;
                    avlpNext(SysSapTbl, (char *) &SearchSapId, NULL, (void **) &pSapRec);
                    // Find the next Encap Group below...
                }
            } else {
                // We found the exact Group, so set the SearchMember
                SearchMember = pLastKey->MemberId;
            }
        }
    }
    // If needed, find the next Encap Group
    if ((pSapRec != NULL) && (pEncapGroup == NULL)) {
        while (pSapRec != NULL) {
            if ((pEncapGroup = sapFindFirstEgrEncapGroupRec(pSapRec->EgrEncapGroupTbl)) != NULL)
                break;
            SearchSapId = pSapRec->SapId;
            pSapRec = NULL;
            avlpNext(SysSapTbl, (char *) &SearchSapId, NULL, (void **) &pSapRec);
        }
    }
    while (pSapRec != NULL) {
        while (pEncapGroup != NULL) {
            if (sapFindNextEgrEncapMemberBlock(pEncapGroup,
                                               SearchMember,
                                               SMGR_MAX_NUM_ENCAP_MEMBERS_TO_DOWNLOAD_ON_CARD_ONLINE,
                                               &StartMember,
                                               &EndMember) == SUCCESS) {
                // Found the next member block!
                smgrBatchSapEgrEncapMemberAddMesgPriv(pSapRec, pEncapGroup, StartMember, EndMember,
                                                      SlotBitmap, TRUE, NULL);
                // No flush is done at this point. SmgrMsgr will flush at the end
                
                // Update the Last Key
                pLastKey->SapId = pSapRec->SapId;
                STRCPY_TNamedItem(&pLastKey->Name, pEncapGroup->Key.Name.name, pEncapGroup->Key.Name.length);
                pLastKey->MemberId = EndMember;
                *pMore = TRUE;
                return OK;
            }
            SearchMember = 0;
            STRCPY_TNamedItem(&SearchGroup, pEncapGroup->Key.Name.name, pEncapGroup->Key.Name.length);
            pEncapGroup = sapFindNextEgrEncapGroupRec(pSapRec->EgrEncapGroupTbl, &SearchGroup);
        }
        SearchSapId = pSapRec->SapId;
        pSapRec = NULL;
        avlpNext(SysSapTbl, (char *) &SearchSapId, NULL, (void **) &pSapRec);
        if (pSapRec && pSapRec->EgrEncapGroupTbl)
            pEncapGroup = sapFindFirstEgrEncapGroupRec(pSapRec->EgrEncapGroupTbl);
    }

    /* no more entries */
    *pMore = FALSE;
    return OK;                                           
}

PRIVATE void smgrMesgIccSapEgrEncapMemberDump(const void *pLastKey)
{
   const tSmgrIcc_SapEgrEncapMember *pLast = (tSmgrIcc_SapEgrEncapMember*) pLastKey;
   
  printf("Sap Egress Encap Member Sap: %-18.18s  Name: %s Member: %d\n", 
         smgrFmtSapIdVerboseForDebug(&(pLast->SapId)),pLast->Name.name, pLast->MemberId);
}


////////////////////////////////////////////////////////////////////////////////
// Sap Subscriber host  Qos overrides  - ICC_SOCKET_SAP_SUB

typedef struct {
     char             SubId[MAXSIZE_tmnxSubExplicitMapSubIdent + 1];
     tSapId           SapId;
     unsigned char    Name[MAXSIZE_TNamedItem + 1];
} tSmgrIcc_SapSubQosOvr;

PRIVATE tStatus smgrMesgIccSapSubQosOvrCmp(const void *pLastKey,
                                           tUint32 IomOp,
                                           const  tSbmSLAProfInst *pSlaProfInst)
{
    tSmgrIcc_SapSubQosOvr *pLast = (tSmgrIcc_SapSubQosOvr*)pLastKey;
    int rc;
    int              len_x;
    int              len_y;
    STRUCT_TNamedItem prof_name;
    
    switch (IomOp) {
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
        // Audit is never allowed to be OR'ed in
        return ERROR;
    default:
        // All other case do the compare
        ;
    }
    if (!pLast)
        return ERROR;
   
    /* Sub-ID (!IMPLIED) */
    ASSERT(pSlaProfInst->pActSub);

    len_x = strlen(pLast->SubId);
    len_y = strlen(pSlaProfInst->pActSub->subId);

    if (len_x < len_y)
        return ERROR;
    if (len_x > len_y)
        return OK;

    if ((rc = strcmp(pLast->SubId,
                     pSlaProfInst->pActSub->subId)) != 0) {
 
        return ((rc < 0) ? ERROR : OK);
    }

    /* SAP-ID */
    ASSERT(pSlaProfInst->pSap);

    if ((rc = sapCmpIds((char *)&pLast->SapId,
                        (char *)&pSlaProfInst->pSap->SapId)) != 0)
    {
        return ((rc < 0) ? ERROR : OK);
    }

    /* SLA profile name (!IMPLIED) */
    ASSERT(pSlaProfInst->pSLAProf);
    
    STRCPY_TNamedItem(&prof_name, pLast->Name, strlen(pLast->Name));
    
    rc = STRNCMP_TNamedItem(&prof_name,&pSlaProfInst->pSLAProf->name);
    
    return  ((rc < 0) ? ERROR : OK);
}

PRIVATE tStatus smgrMesgIccSapSubQosOvrUpdate(tUint32   SlotBitmap, /* In: */
                                              tBoolean  First,   /* In: */
                                              void     *pKey,    /* In/Out: */
                                              tBoolean *pMore   /* Out: returns if there is more data */)
     
{

    tSmgrIcc_SapSubQosOvr *pLastKey = (tSmgrIcc_SapSubQosOvr*) pKey;
    tSbmSLAProfInst *pSLAProfInst = NULL;
    

    
    if (First) {       
        avlpFirst(sbmSLAProfInstTbl, NULL, (void **)&pSLAProfInst);
    }
    else {
        tSbmSLAProfInst  entry;
        tSbmActSub       actSub;
        tSapRec          sap;
        tSbmSLAProf      slaProf;

        snprintf(actSub.subId,sizeof(actSub.subId),"%s",pLastKey->SubId);
        sap.SapId = pLastKey->SapId;
        STRCPY_TNamedItem(&(slaProf.name), pLastKey->Name, strlen(pLastKey->Name));
        
        /* Key */
        entry.pSap     = &sap;
        entry.pActSub  = &actSub;
        entry.pSLAProf = &slaProf;       
     
        avlpNext(sbmSLAProfInstTbl, (char*)&entry, NULL, (void**) &pSLAProfInst);
    }   

    if (pSLAProfInst) {  

        if (pSLAProfInst->pSap         &&
            pSLAProfInst->pActSub) {
        
            smgrSendSubQosOvrAddMesgPriv(pSLAProfInst->pActSub,
                                         pSLAProfInst,
                                         SlotBitmap,TRUE);
            pLastKey->SapId  = pSLAProfInst->pSap->SapId;
            snprintf(pLastKey->SubId,sizeof(pLastKey->SubId),"%s",pSLAProfInst->pActSub->subId);
            snprintf(pLastKey->Name,sizeof(pLastKey->Name),"%s",pSLAProfInst->pSLAProf->name.name);
            *pMore = TRUE;
            
        } else {

            *pMore = FALSE;
        }
        
    } else {
        /* no more entries */
        *pMore = FALSE;
    }    
    return OK;
}

PRIVATE void smgrMesgIccSapSubQosOvrDump(const void *pLastKey)
{
   const tSmgrIcc_SapSubQosOvr *pLast = (tSmgrIcc_SapSubQosOvr*) pLastKey;
   
   printf ("SubId: %s Sap: %-18.18s SlaProfName: %s\n",
           pLast->SubId,
           smgrFmtSapIdVerboseForDebug(&pLast->SapId),
           pLast->Name);
  
}

////////////////////////////////////////////////////////////////////////////////
const char *smgrMesgIccDpiIpOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_DPI_IP_ADD:
        return "Add";
    case IOM_DPI_IP_DELETE:
        return "Del";
    case IOM_DPI_IP_POLICY_FLUSH:
        return "Flush";        
    case IOM_DPI_IP_AUDIT_END:
        return "Audit";
    }
    return "";
}
const char *smgrMesgIccDpiPrefixOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_FILTER_CREATE:
        return "AddList";
    case IOM_FILTER_DELETE:
        return "DeleteList";
    case IOM_FILTER_ADD_RULES:
        return "AddRule";        
    case IOM_FILTER_DELETE_RULES:
        return "DeleteRule";
    case IOM_FILTER_AUDIT:
        return "Audit";
    }
    return "";
}
const char *smgrMesgIccSdpBindStatsOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SDP_STATS_READ_RELATIVE:
        return "ReadRlt";
    case IOM_SDP_STATS_READ_ABSOLUTE:
        return "ReadAbs";
    case IOM_SDP_STATS_RESET:
        return "Reset";        
    case IOM_SDP_STATS_READ_RESET:
        return "ReadReset";
    case IOM_SDP_STATS_READ_L2TPV3:
        return "ReadL2TPV3";
    case IOM_SDP_STATS_RESET_L2TPV3:
        return "ResetL2TPV3";
    }
    return "";
}
PUBLIC const char *smgrMesgIccSvcOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SVC_ADD:
        return "Add";
    case IOM_SVC_DELETE:
        return "Del";
    case IOM_SVC_AUDIT:
        return "Audit";        
    case IOM_SVC_ADD_VIRTUAL_PORT_STATE:
        return "VirtPortSt";
    case IOM_SVC_SYS_WIDE_UPDATE:
        return "SysWide";
    case IOM_SVC_ADD_TLS_FLOOD_UPDATE:
        return "TlsFlood";
    case IOM_SVC_TLS_FWDING_UPDATE:
        return "Tls";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccSdpOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SDP_ADD:
        return "Add";
    case IOM_SDP_DELETE:
        return "Delete";
    case IOM_SDP_MISCONFIGURED:
        return "Mis";
    case IOM_SDP_AUDIT:
        return "Audit";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccPolicyOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_POLICY_ADD:
        return "Add";
    case IOM_POLICY_DELETE:
        return "Delete";
    case IOM_POLICY_AUDIT:
        return "Audit";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccQosOverrideOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_QOS_OVERRIDE_ADD:
        return "Add";
    case IOM_QOS_OVERRIDE_DELETE:
        return "Delete";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccPolicyMacFilterOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_MAC_RULE_ADD:
        return "Add";
    case IOM_MAC_RULE_DELETE:
        return "Delete";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccPolicyIpFilterOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_IP_RULE_ADD:
        return "Add";
    case IOM_IP_RULE_DELETE:
        return "Delete";
    default:;
    }
    return "Unsupported";
}
PUBLIC const char *smgrMesgIccEmgOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_EMG_ADD:
        return "Add";
    case IOM_EMG_DELETE:
        return "Delete";
    case IOM_EMG_AUDIT:
        return "Audit";
    case IOM_EMG_READ:
        return "Read";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccSapSubOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SAP_ADD:
        return "SapAdd";
    case IOM_SAP_DELETE:
        return "SapDel";
    case IOM_SAP_AUDIT:
        return "SapAudit";
    case IOM_SAP_SWITCH:
        return "SapSwitch";
    case IOM_SAP_STATE:
        return "SapState";
    case IOM_SAP_MCLISTPRUNE_MVRP:
        return "SapMcLstPrMvrp";
    case IOM_SAP_CFM_PVLAN:
        return "SapCfmPrimVlan";
    case IOM_SAP_MAC_LPBK:
        return "SapLoopBack";
    case IOM_ESM_SUBSCRIBER_ADD:
        return "SubAdd";
    case IOM_ESM_SUBSCRIBER_DELETE:
        return "SubDel";
    case IOM_ESM_SUBSCRIBER_AUDIT:
        return "SubAudit";
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
        return "SchedPlcyOvrAdd";
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
        return "QosOvrAdd";
    case IOM_ESM_HOST_ADD:
        return "HostAdd";
    case IOM_ESM_SUB_PROFILE_ADD:
        return "SubProfAdd";
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
        return "ProfSchedPlcyOvrAdd";
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
        return "ProfQosPlcyOvrAdd";
    case IOM_ESM_SLA_PROFILE_ADD:
        return "SlaProfAdd";
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
        return "SlaProfQosPlcyOvrAdd";
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
        return "RedGrpAdd";
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
        return "RedIntDestGrpAdd";
    case IOM_ESM_CATMAP_POLICY_ADD:
        return "HostCatMapPlcyAdd";
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return "SchedPlcyOvrDel";
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
        return "QosOvrDel";
    case IOM_ESM_HOST_DELETE:
        return "HostDel";
    case IOM_ESM_SUB_PROFILE_DELETE:
        return "SubProfDel";
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return "ProfSchedPlcyOvrDel";
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return "ProfQosPlcyOvrDel";
    case IOM_ESM_SLA_PROFILE_DELETE:
        return "SlaProfDel";
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return "SlaProfQosPlcyOvrDel";
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
        return "RedGrpDel";
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
        return "RedIntDestGrpDel";
    case IOM_ESM_CATMAP_POLICY_DELETE:
        return "HostCatMapPlcyDel";
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
        return "QosOvrAudit";
    case IOM_ESM_HOST_AUDIT:
        return "HostAudit";
    case IOM_ESM_SUB_PROFILE_AUDIT:
        return "SubProfAudit";
    case IOM_ESM_SLA_PROFILE_AUDIT:
        return "SlaProfAudit";
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
        return "RedGrpAudit";
    case IOM_ESM_CATMAP_POLICY_AUDIT:
        return "HostCatMapPlcyAudit";
    case IOM_ESM_HOST_UNBIND_SAP:
        return "HostUnbindSap";
    case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ:
        return "HostCatCredQhtReq";
    case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:
        return "HostCatCredExpReq";
    case IOM_ESM_HOST_CAT_WRAPUP_REQ:
        return "HostCatWrapupReq";
    case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
        return "HostCatEvtAckReq";
    case IOM_ESM_HOST_CAT_AUDIT_REQ:
        return "HostCatAuditReq";
    case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
        return "HostCatDelDeactReq";
    case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
        return "HostCatRecReq";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccSdpBindOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SVC_BIND:
        return "Bind";
    case IOM_SVC_UNBIND:
        return "Unbind";
    case IOM_SVC_BIND_SWITCH:
        return "Switch";
    case IOM_SVC_BIND_AUDIT:
        return "Audit";
    case IOM_SVC_BIND_STATE:
        return "State";
    case IOM_SVC_BIND_MCLISTPRUNE:
        return "McLstPr";
    case IOM_SVC_BIND_MAC_LPBK:
        return "MacLpbk";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccTlsFdbOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_TLS_MAC_LEARN:
        return "Learn";
    case IOM_TLS_MAC_ADD:
        return "Add";
    case IOM_TLS_MAC_AGE:
        return "Age";
    case IOM_TLS_MAC_DELETE:
        return "Delete";
    case IOM_TLS_MAC_DELETE_ALL_FOR_DEST:
        return "DeleteDst";
    case IOM_TLS_MAC_DELETE_ALL_FOR_TLS:
        return "DeleteTls";
    case IOM_TLS_MAC_DELETE_ALL_FOR_MIM:
        return "DeleteMim";
    case IOM_TLS_MAC_MOVE_ALL_FOR_DEST:
        return "MoveDst";
    case IOM_TLS_MAC_QUERY:
        return "Query";
    case IOM_TLS_MAC_CALLBACK:
        return "MacCallback";
    case IOM_TLS_MAC_AUDIT:
        return "Audit";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccTlsFdbQueryOpToStr(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_TLS_MAC_QUERY:
        return "Query";
    default:;
    }
    return "Unsupported";
}

PUBLIC const char *smgrMesgIccMirrorSvcOpToStr(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_MIRROR_SRC_ADD:
        return "Add";

    case IOM_MIRROR_SRC_DELETE:
        return "Delete";
        
    case IOM_MIRROR_SRC_AUDIT:
        return "Audit";
    default:;
    }
    return "Unsupported";
}

const char *smgrMesgIccSubOpToStr(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_ESM_SUBSCRIBER_ADD:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
    case IOM_ESM_HOST_ADD:
    case IOM_ESM_SUB_PROFILE_ADD:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_ADD:
    case IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
    case IOM_ESM_CATMAP_POLICY_ADD:
        return "Add";

    case IOM_ESM_SUBSCRIBER_DELETE:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
    case IOM_ESM_HOST_DELETE:
    case IOM_ESM_SUB_PROFILE_DELETE:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SLA_PROFILE_DELETE:
    case IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
    case IOM_ESM_CATMAP_POLICY_DELETE:
        return "Delete";

    case IOM_ESM_SUBSCRIBER_AUDIT:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
    case IOM_ESM_HOST_AUDIT:
    case IOM_ESM_SUB_PROFILE_AUDIT:
    case IOM_ESM_SLA_PROFILE_AUDIT:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
    case IOM_ESM_CATMAP_POLICY_AUDIT:
        return "Audit";
                
    case IOM_ESM_HOST_UNBIND_SAP:
        return "Unbind";
            
    case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ:
    case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:
    case IOM_ESM_HOST_CAT_WRAPUP_REQ:
    case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
    case IOM_ESM_HOST_CAT_AUDIT_REQ:
    case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
    case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
        return "Cat Stuff";
    default:;
    }
    return "Unsupported";
}

const char *smgrMesgIccDpiTransitIpOpToStr(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_DPI_IP_ADD:
        return "Add";

    case IOM_DPI_IP_DELETE:
        return "Delete";

     case IOM_DPI_IP_AUDIT_END:
        return "Audit";

    case IOM_DPI_IP_POLICY_FLUSH:
        return "Flush";

    default:;
    }
    return "";
}


PUBLIC const char *smgrMesgIccSapQmdaQOvrOpToStr(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_QMDA_QOS_POLICY_OVERRIDE_ADD:
        return "Add";

    case IOM_QMDA_QOS_POLICY_OVERRIDE_DELETE:
        return "Delete";   
    default:;
    }
    return "Unsupported";
 }


PUBLIC const char *smgrMesgIccSapEgrEncapGroupOpToStr(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_ENCAP_GROUP_ADD:
        return "Add";

    case IOM_ENCAP_GROUP_MEMBERS_ADD:
        return "MembersAdd";

    case IOM_ENCAP_GROUP_DELETE:
        return "Delete";

    case IOM_ENCAP_GROUP_AUDIT:
        return "Audit";
    default:;
    }
    return "Unsupported";
 }


const char *smgrMesgIccSapSubQosOvrOpToStr(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
        return "Add";

    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
        return "Delete";
        
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
        return "Audit";
   
    default:;
    }
    return "";
}

////////////////////////////////////////////////////////////////////////////////
PRIVATE int smgrMesgIccSdpBindStatsOpMaxEntPerMsg(tUint32 OpCode)
{
    return MAX_SDP_STATS_ENTRIES_PER_MSG;
}

PRIVATE tInt32 smgrMesgIccSdpBindStatsMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_SDP_STATS_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccDpiIpOpMaxEntPerMsg(tUint32 OpCode)
{
    return MAX_DPI_IP_ENTRIES_PER_MSG;
}

PRIVATE tInt32 smgrMesgIccDpiIpMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_DPI_IP_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccDpiPrefixOpMaxEntPerMsg(tUint32 OpCode)
{
    return MAX_DPI_FILTER_RULE_ENTRIES_PER_MSG;
}

PRIVATE tInt32 smgrMesgIccDpiPrefixMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_DPI_FILTER_MSG(Num);
}

PUBLIC int smgrMesgIccSvcOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SVC_ADD:
        return SMMaxNumSvcAddEntriesPerMesg;
    case IOM_SVC_DELETE:
        return SMMaxNumSvcDelEntriesPerMesg;
    case IOM_SVC_AUDIT:
        return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_NA;
    case IOM_SVC_ADD_VIRTUAL_PORT_STATE:
        return SMMaxNumSvcVirtPortEntriesPerMesg;
    case IOM_SVC_SYS_WIDE_UPDATE:
        return 1;
    case IOM_SVC_ADD_TLS_FLOOD_UPDATE:
        return SMMaxNumSvcTlsFloodEntriesPerMesg;
    case IOM_SVC_TLS_FWDING_UPDATE:
        return SMMaxNumSvcTlsEntriesPerMesg;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PUBLIC int smgrMesgIccSvcOpEntrySize(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SVC_ADD:
        return SIZEOF_SVC_ADD_ENTRY;
    case IOM_SVC_DELETE:
        return SIZEOF_SVC_DEL_ENTRY;
    case IOM_SVC_ADD_VIRTUAL_PORT_STATE:
        return SIZEOF_SVC_PIP_ENTRY;
    case IOM_SVC_SYS_WIDE_UPDATE:
        return SIZEOF_SVC_SYSTEM_WIDE_ENTRY;
    case IOM_SVC_ADD_TLS_FLOOD_UPDATE:
        return SIZEOF_SVC_TLS_FLOOD_ENTRY;
    case IOM_SVC_TLS_FWDING_UPDATE:
        return SIZEOF_SVC_TLS_FWDING_ENTRY;
    default:;
    }
    return 0;
}


PRIVATE tInt32 smgrMesgIccSvcMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_SVC_REQUEST_MSG(OpCode, Num);
}

PUBLIC int smgrMesgIccSdpOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SDP_ADD:
        return SMMaxNumSdpEntriesPerMesg;
    case IOM_SDP_DELETE:
        return SMMaxNumSdpEntriesPerMesg;
    case IOM_SDP_MISCONFIGURED:
        return SMMaxNumSdpEntriesPerMesg;
    case IOM_SDP_AUDIT:
        return SMMaxNumSdpEntriesPerMesg;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PRIVATE tInt32 smgrMesgIccSdpMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_SDP_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccQosSchedPolicyOpMaxEntPerMsg(tUint32 OpCode)
{
    return MAX_QOS_SCHEDULERS_PER_SCHEDULER_POLICY_MSG;
}

PRIVATE tInt32 smgrMesgIccQosSchedPolicyMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QOS_SCHEDULER_POLICY_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccQosPolicyCtrlOpMaxEntPerMsg(tUint32 OpCode)
{
    return MAX_QOS_ARBITERS_PER_ARBITER_POLICY_MSG;
}

PRIVATE tInt32 smgrMesgIccQosPolicyControlMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QOS_ARBITER_POLICY_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccOneEntPerMsg(tUint32 OpCode)
{
    return 1;
}

PRIVATE tInt32 smgrMesgIccQosSapIngressPolicyMsgSize(tUint32 OpCode, tInt32 Num)
{
    return sizeof (tIomQosSapIngressBasePolicyRequest);
}

PRIVATE int smgrMesgIccQosSapEgressPolicyIpFilterOpMaxEntPerMsg(tUint32 OpCode)
{
    return SMMaxNumIpQosFilterRuleEntriesPerMesg;
}


PUBLIC int smgrMesgIccQosMssOpMaxEntPerMsg(tUint32 OpCode)
{
    return SMMaxNumQosMssEntriesPerMesg;
}

PRIVATE tInt32 smgrMesgIccQosMssMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QOS_MULTI_SERVICE_SITE_MSG(Num);
}

PUBLIC int smgrMesgIccVsOMaxEntPerMsg(tUint32 OpCode)
{
    return SMMaxNumVSOverrideEntriesPerMesg;
}

PRIVATE tInt32 smgrMesgIccVsOMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QOS_GROUP_OVERRIDE_REQUEST_MSG(Num);
}

PUBLIC int smgrMesgIccEmgMaxEntPerMsg(tUint32 OpCode)
{
    return SMMaxNumEmgEntriesPerMesg;
}

PRIVATE tInt32 smgrMesgEmgMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_EMG_CONFIG_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccPolicyMacFilterOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_MAC_RULE_ADD:
        return SMMaxNumMacQosFilterRuleEntriesPerMesg;
    case IOM_MAC_RULE_DELETE:
        return SMMaxNumMacQosFilterRuleEntriesPerMesg;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PRIVATE tInt32 smgrMesgIccQosSapIngressPolicyMacFilterMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QOS_INGRESS_SAP_MAC_FILTER_MSG(Num);
}

PRIVATE int smgrMesgIccPolicyIpFilterOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_IP_RULE_ADD:
        return SMMaxNumIpQosFilterRuleEntriesPerMesg;
    case IOM_IP_RULE_DELETE:
        return SMMaxNumIpQosFilterRuleEntriesPerMesg;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PRIVATE tInt32 smgrMesgIccPolicyIpFilterMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QOS_SAP_IP_FILTER_MSG(Num);
}

PRIVATE tInt32 smgrMesgIccQosSapEgressPolicyMsgSize(tUint32 OpCode, tInt32 Num)
{
    return sizeof (tIomQosSapEgressPolicyRequest);
}

PUBLIC int smgrMesgIccSapSubOpMaxEntPerMsg(tUint32 OpCode)
{
    const int cSingleElm = 1;

    switch (OpCode) {
    case IOM_SAP_ADD:
        return SMMaxNumSapAddEntriesPerMesg;
    case IOM_SAP_DELETE:
        return SMMaxNumSapDelEntriesPerMesg;
    case IOM_SAP_SWITCH:
        return SMMaxNumSapSwitchEntriesPerMesg;
    case IOM_SAP_STATE:
        return SMMaxNumSapStateEntriesPerMesg;
    case IOM_SAP_MCLISTPRUNE_MVRP:
        return SMMaxNumSapMcListPruneAndMvrpEntriesPerMesg;
    case IOM_SAP_CFM_PVLAN:
        return SMMaxNumSapCfmPrimVlanEntriesPerMesg;
    case IOM_SAP_MAC_LPBK:
        return SMMaxNumSapLoopBackEntriesPerMesg;

    case IOM_SAP_AUDIT:
    case IOM_ESM_SUBSCRIBER_AUDIT:
    case IOM_ESM_HOST_AUDIT:
    case IOM_ESM_SUB_PROFILE_AUDIT:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
    case IOM_ESM_SLA_PROFILE_AUDIT:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
    case IOM_ESM_CATMAP_POLICY_AUDIT:
        return cSingleElm;

    case IOM_ESM_SUBSCRIBER_ADD:
    case IOM_ESM_SUBSCRIBER_DELETE:
        return SMMaxNumSubscrEntriesPerMesg;
    case IOM_ESM_HOST_ADD:
    case IOM_ESM_HOST_DELETE:
    case IOM_ESM_HOST_UNBIND_SAP:
        return SMMaxNumSubscrHostEntriesPerMesg;
    case IOM_ESM_SUB_PROFILE_ADD:
    case IOM_ESM_SUB_PROFILE_DELETE:
        return cSingleElm;
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return SMMaxNumSubscrVSOverrideEntriesPerMesg;
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return SMMaxNumSubProfVSOverrideEntriesPerMesg;
    case IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return SMMaxNumSLAProfVSOverrideEntriesPerMesg;
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
        return MAX_SUB_QOS_OVERRIDE_ENTRIES_PER_MIXED_MSG;
    case IOM_ESM_SLA_PROFILE_ADD:
    case IOM_ESM_SLA_PROFILE_DELETE:
        return cSingleElm;
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return SMMaxNumSLAProfPolicerOverrideEntriesPerMesg;
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
        return SMMaxNumSubL3RedGroupEntriesPerMesg;
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
        return SMMaxNumSubL3RedInterDestGroupIdEntriesPerMesg;
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return SMMaxNumSubProfQueueOverrideEntriesPerMesg;
    case IOM_ESM_CATMAP_POLICY_ADD:
    case IOM_ESM_CATMAP_POLICY_DELETE:
        return cSingleElm;
    case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ:
    case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:
    case IOM_ESM_HOST_CAT_WRAPUP_REQ:
    case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
    case IOM_ESM_HOST_CAT_AUDIT_REQ:
    case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
        return MAX_SUBSCR_HOST_CATEGORY_ENTRIES_PER_MIXED_MSG;
    case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
        return cSingleElm;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PUBLIC tInt32 smgrMesgIccSapSubMsgSize(tUint32 OpCode, tInt32 Num)
{
    tUint32 MsgHdrLen = OFFSET(tIomSapSubMixedRequest, Entries[0]);

    switch (OpCode) {
    case IOM_SAP_ADD:
        return MsgHdrLen + (SIZEOF_SAP_ADD_MIXED_ENTRY * Num);
    case IOM_SAP_DELETE:
        return MsgHdrLen + (SIZEOF_SAP_DEL_MIXED_ENTRY * Num);
    case IOM_SAP_SWITCH:
        return MsgHdrLen + (SIZEOF_SAP_SWITCH_MIXED_ENTRY * Num);
    case IOM_SAP_STATE:
        return MsgHdrLen + (SIZEOF_SAP_STATE_MIXED_ENTRY * Num);
    case IOM_SAP_MCLISTPRUNE_MVRP:
        return MsgHdrLen + (SIZEOF_SAP_MCLISTPRUNE_MVRP_MIXED_ENTRY * Num);
    case IOM_SAP_CFM_PVLAN:
        return MsgHdrLen + (SIZEOF_SAP_CFM_PVLAN_MIXED_ENTRY * Num);
    case IOM_SAP_MAC_LPBK:
        return MsgHdrLen + (SIZEOF_SAP_MAC_LPBK_MIXED_ENTRY  * Num);

    case IOM_SAP_AUDIT:
    case IOM_ESM_SUBSCRIBER_AUDIT:
    case IOM_ESM_HOST_AUDIT:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
    case IOM_ESM_SUB_PROFILE_AUDIT:
    case IOM_ESM_SLA_PROFILE_AUDIT:
    case IOM_ESM_CATMAP_POLICY_AUDIT:
        return MsgHdrLen + SIZEOF_SAP_SUB_AUDIT_MIXED_ENTRY;

    case IOM_ESM_SUBSCRIBER_ADD:
    case IOM_ESM_SUBSCRIBER_DELETE:
        return MsgHdrLen + (SIZEOF_SUBSCR_MIXED_ENTRY * Num);
    case IOM_ESM_HOST_ADD:
    case IOM_ESM_HOST_DELETE:
    case IOM_ESM_HOST_UNBIND_SAP:
        return MsgHdrLen + (SIZEOF_SUBSCR_HOST_MIXED_ENTRY * Num);
    case IOM_ESM_SUB_PROFILE_ADD:
    case IOM_ESM_SUB_PROFILE_DELETE:
        return MsgHdrLen + SIZEOF_SUBSCR_PROFILE_MIXED_ENTRY;
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return MsgHdrLen + (SIZEOF_SUB_SCHEDULER_POLICY_OVERRIDE_MIXED_ENTRY * Num);
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
        return MsgHdrLen + (SIZEOF_SUB_QOS_OVERRIDE_MIXED_ENTRY * Num);
    case IOM_ESM_SLA_PROFILE_ADD:
    case IOM_ESM_SLA_PROFILE_DELETE:
        return MsgHdrLen + SIZEOF_SLA_PROFILE_MIXED_ENTRY;
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return MsgHdrLen + (SIZEOF_SLA_QOS_POLICY_OVERRIDE_MIXED_ENTRY * Num);
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
        return MsgHdrLen + (SIZEOF_SUB_L3_RED_GROUP_MIXED_ENTRY * Num);
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
        return MsgHdrLen + (SIZEOF_SUB_L3_RED_INTER_DEST_GROUP_MIXED_ENTRY * Num);
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return MsgHdrLen + (SIZEOF_SUB_QOS_POLICY_OVERRIDE_MIXED_ENTRY * Num);
    case IOM_ESM_CATMAP_POLICY_ADD:           // USS pre-allocates memory for buffering its message regardless of the OpCode.
    case IOM_ESM_CATMAP_POLICY_DELETE:        // These OpCodes need to return the same value
        return MsgHdrLen + SIZEOF_SUB_HOST_CATMAP_POLICY_MIXED_ENTRY;
    case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ: // USS pre-allocates memory for buffering its message regardless of the OpCode.
    case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:  // These OpCodes need to return the same value
    case IOM_ESM_HOST_CAT_WRAPUP_REQ:
    case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
    case IOM_ESM_HOST_CAT_AUDIT_REQ:
    case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
        return MsgHdrLen + (SIZEOF_SUBSCR_HOST_CATEGORY_MIXED_ENTRY * Num);
    case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
        return MsgHdrLen + SIZEOF_SUB_HOST_CAT_RECONCILE_EVENTS_MIXED_ENTRY;
    default:
        SVCMGR_ERROR(NOCLASS, "Unsupported OpCode %u", OpCode);
        break;
    }

    return 0;
}

// the size of all members of tIomSapSubMixedEntry must be multiples of 8
#define IOM_VALIDATE_MEMBER_ALIGNMENT(s, m, align) \
    STATIC_ASSERT((MEMBER_SIZE(s, m)%align == 0), "IOM Message Validation Error: Member " #m " within type " #s " is not " #align " byte aligned");

IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, Add, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, Del, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, Switch, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, State, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, McListPruneAndMvrp, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, CfmPvlan, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, MacLpbk, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SapAudit, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, Subscriber, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubscriberHost, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubProfile, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubSchedulerPolicyOverride, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubQosOverride, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SlaProfile, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SlaProfileQosPolicyOverride, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubL3RedGroup, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubL3RedInterDestGroup, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubProfileQosPolicyOverride, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubscriberHostCatMapPolicy, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubscriberHostCategory, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, SubscriberHostCatEventReconcile, 8);
IOM_VALIDATE_MEMBER_ALIGNMENT(tIomSapSubMixedEntry, Audit, 8);

PUBLIC tInt32 smgrMesgIccSapSubEntrySize(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SAP_ADD:
        return SIZEOF_SAP_ADD_MIXED_ENTRY;
    case IOM_SAP_DELETE:
        return SIZEOF_SAP_DEL_MIXED_ENTRY;
    case IOM_SAP_SWITCH:
        return SIZEOF_SAP_SWITCH_MIXED_ENTRY;
    case IOM_SAP_STATE:
        return SIZEOF_SAP_STATE_MIXED_ENTRY;
    case IOM_SAP_MCLISTPRUNE_MVRP:
        return SIZEOF_SAP_MCLISTPRUNE_MVRP_MIXED_ENTRY;
    case IOM_SAP_CFM_PVLAN:
        return SIZEOF_SAP_CFM_PVLAN_MIXED_ENTRY;

    case IOM_SAP_AUDIT:
    case IOM_ESM_SUBSCRIBER_AUDIT:
    case IOM_ESM_HOST_AUDIT:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT:
    case IOM_ESM_SUB_PROFILE_AUDIT:
    case IOM_ESM_SLA_PROFILE_AUDIT:
    case IOM_ESM_CATMAP_POLICY_AUDIT:
        return SIZEOF_SAP_SUB_AUDIT_MIXED_ENTRY;

    case IOM_ESM_SUBSCRIBER_ADD:
    case IOM_ESM_SUBSCRIBER_DELETE:
        return SIZEOF_SUBSCR_MIXED_ENTRY;
    case IOM_ESM_HOST_ADD:
    case IOM_ESM_HOST_DELETE:
    case IOM_ESM_HOST_UNBIND_SAP:
        return SIZEOF_SUBSCR_HOST_MIXED_ENTRY;
    case IOM_ESM_SUB_PROFILE_ADD:
    case IOM_ESM_SUB_PROFILE_DELETE:
        return SIZEOF_SUBSCR_PROFILE_MIXED_ENTRY;
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE:
        return SIZEOF_SUB_SCHEDULER_POLICY_OVERRIDE_MIXED_ENTRY;
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD:
    case IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_DELETE:
        return SIZEOF_SUB_QOS_OVERRIDE_MIXED_ENTRY;
    case IOM_ESM_SLA_PROFILE_ADD:
    case IOM_ESM_SLA_PROFILE_DELETE:
        return SIZEOF_SLA_PROFILE_MIXED_ENTRY;
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return SIZEOF_SLA_QOS_POLICY_OVERRIDE_MIXED_ENTRY;
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_GROUP_DELETE:
        return SIZEOF_SUB_L3_RED_GROUP_MIXED_ENTRY;
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD:
    case IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE:
        return SIZEOF_SUB_L3_RED_INTER_DEST_GROUP_MIXED_ENTRY;
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD:
    case IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE:
        return SIZEOF_SUB_QOS_POLICY_OVERRIDE_MIXED_ENTRY;
    case IOM_ESM_CATMAP_POLICY_ADD:
    case IOM_ESM_CATMAP_POLICY_DELETE:
        return SIZEOF_SUB_HOST_CATMAP_POLICY_MIXED_ENTRY;
    case IOM_ESM_HOST_CAT_CREDIT_AND_QHT_REQ:
    case IOM_ESM_HOST_CAT_CREDIT_EXPIRY_REQ:
    case IOM_ESM_HOST_CAT_WRAPUP_REQ:
    case IOM_ESM_HOST_CAT_EVENT_ACK_REQ:
    case IOM_ESM_HOST_CAT_AUDIT_REQ:
    case IOM_ESM_HOST_CAT_DELETE_DEACTIVATE_REQ:
        return SIZEOF_SUBSCR_HOST_CATEGORY_MIXED_ENTRY;
    case IOM_ESM_HOST_CAT_RECONCILE_EVENTS:
        return SIZEOF_SUB_HOST_CAT_RECONCILE_EVENTS_MIXED_ENTRY;

    case IOM_SAP_ISSU1:
    case IOM_SAP_ISSU2:
    default:
        SVCMGR_ERROR(NOCLASS, "Unsupported OpCode %u", OpCode);
        break;
    }

    return 0;
}

PUBLIC int smgrMesgIccSdpBindOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SVC_BIND:
        return SMMaxNumSdpBindEntriesPerMesg;
    case IOM_SVC_UNBIND:
        return SMMaxNumSdpBindEntriesPerMesg;
    case IOM_SVC_BIND_SWITCH:
        return SMMaxNumSdpBindSwitchEntriesPerMesg;
    case IOM_SVC_BIND_AUDIT:
        return 0;
    case IOM_SVC_BIND_STATE:
        return SMMaxNumSdpBindStateEntriesPerMesg;
    case IOM_SVC_BIND_MCLISTPRUNE:
        return SMMaxNumSdpBindMcListPruneEntriesPerMesg;
    case IOM_SVC_BIND_MAC_LPBK:
        return SMMaxNumSdpBindMacLoopBackEntriesPerMesg;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PUBLIC int smgrMesgIccSdpBindOpEntrySize(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_SVC_BIND:
    case IOM_SVC_UNBIND:
        return SIZEOF_SVC_BIND_ENTRY;
    case IOM_SVC_BIND_SWITCH:
        return SIZEOF_SVC_BIND_SWITCH_ENTRY;
    case IOM_SVC_BIND_STATE:
        return SIZEOF_SVC_BIND_STATE_ENTRY;
    case IOM_SVC_BIND_MCLISTPRUNE:
        return SIZEOF_SVC_BIND_MCLISTPRUNE_ENTRY;
    case IOM_SVC_BIND_MAC_LPBK:
        return SIZEOF_SVC_BIND_MAC_LPBK_ENTRY;
    default:;
    }
    return 0;
}

PUBLIC tInt32 smgrMesgIccSdpBindMsgSize(tUint32 OpCode, tInt32 Num)
{
    switch (OpCode) {
    case IOM_SVC_BIND:
    case IOM_SVC_UNBIND:
        return SIZE_SVC_BIND_REQUEST_MSG(Num);
    case IOM_SVC_BIND_SWITCH:
        return SIZE_SVC_BIND_SWITCH_REQUEST_MSG(Num);
    case IOM_SVC_BIND_STATE:
        return SIZE_SVC_BIND_STATE_MSG(Num);
    case IOM_SVC_BIND_AUDIT:
        return SIZE_SVC_BIND_AUDIT_REQUEST_MSG();
    case IOM_SVC_BIND_MCLISTPRUNE:
        return SIZE_SVC_BIND_MCLISTPRUNE_MSG(Num);
    case IOM_SVC_BIND_MAC_LPBK:
        return SIZE_SVC_BIND_MAC_LPBK_MSG(Num);
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PUBLIC int smgrMesgIccTlsFdbOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_TLS_MAC_LEARN:
        return SMMaxNumTlsMacLrnAgeEntriesPerMesg;
    case IOM_TLS_MAC_ADD:
        return SMMaxNumTlsMacAddEntriesPerMesg;
    case IOM_TLS_MAC_AGE:
        return SMMaxNumTlsMacLrnAgeEntriesPerMesg;
    case IOM_TLS_MAC_DELETE:
        return SMMaxNumTlsMacDelEntriesPerMesg;
    case IOM_TLS_MAC_DELETE_ALL_FOR_DEST:
        return SMMaxNumTlsMacDelDstEntriesPerMesg;
    case IOM_TLS_MAC_DELETE_ALL_FOR_TLS:
        return SMMaxNumTlsMacDelTlsEntriesPerMesg;
    case IOM_TLS_MAC_DELETE_ALL_FOR_MIM:
        return SMMaxNumTlsMacDelMimEntriesPerMesg;
    case IOM_TLS_MAC_MOVE_ALL_FOR_DEST:
        return SMMaxNumTlsMacMoveEntriesPerMesg;
    case IOM_TLS_MAC_QUERY:
        return SMMaxNumTlsMacQueryEntriesPerMesg;
    case IOM_TLS_MAC_CALLBACK:
        return SMMaxNumTlsMacCallbackEntriesPerMesg;
    case IOM_TLS_MAC_AUDIT:
        return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_NA;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PRIVATE tInt32 smgrMesgIccTlsFdbMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_TLS_MAC_REQUEST_MSG(OpCode, Num);
}

PUBLIC int smgrMesgIccTlsFdbOpEntrySize(tUint32 OpCode)
{
    switch (OpCode) {
    case IOM_TLS_MAC_LEARN:
        return SIZEOF_TLS_MAC_LRN_AGE_ENTRY;
    case IOM_TLS_MAC_ADD:
        return SIZEOF_TLS_MAC_ADD_ENTRY;
    case IOM_TLS_MAC_AGE:
        return SIZEOF_TLS_MAC_LRN_AGE_ENTRY;
    case IOM_TLS_MAC_DELETE:
        return SIZEOF_TLS_MAC_DEL_ENTRY;
    case IOM_TLS_MAC_DELETE_ALL_FOR_DEST:
        return SIZEOF_TLS_MAC_DEL_DST_ENTRY;
    case IOM_TLS_MAC_DELETE_ALL_FOR_TLS:
        return SIZEOF_TLS_MAC_DEL_TLS_ENTRY;
    case IOM_TLS_MAC_DELETE_ALL_FOR_MIM:
        return SIZEOF_TLS_MAC_DEL_MIM_ENTRY;
    case IOM_TLS_MAC_MOVE_ALL_FOR_DEST:
        return SIZEOF_TLS_MAC_MOVE_ENTRY;
    case IOM_TLS_MAC_QUERY:
        return SIZEOF_TLS_MAC_QUERY_ENTRY;
    case IOM_TLS_MAC_CALLBACK:
        return SIZEOF_TLS_MAC_CALLBACK_ENTRY;
    case IOM_TLS_MAC_AUDIT:
        return 0;
    default:;
    }
    return 0;
}

PRIVATE int smgrMesgIccTlsFdbQueryOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_TLS_MAC_QUERY:
        return SMMaxNumTlsMacQueryEntriesPerMesg;
    default:;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PRIVATE tInt32 smgrMesgIccMirrorSvcMsgSize(tUint32 OpCode, tInt32 Num)
{
    return sizeof(tIomMirrorSourceConfigRequest);
}

PRIVATE tInt32 smgrMesgIccMfibTlsMsgSize(tUint32 OpCode, tInt32 Num)
{
    return MFIB_TLS_MAX_REQ_SIZE;
}

PUBLIC int smgrMesgIccSapQOMaxEntPerMsg(tUint32 OpCode)
{
    return SMMaxNumQueueOverrideEntriesPerMesg;
}

PRIVATE tInt32 smgrMesgIccSapQOMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(Num);
}

PRIVATE int smgrMesgIccSapQmdaQOvrOpMaxEntPerMsg(tUint32 OpCode)
{
    return SMMaxNumQmdaQueueOverrideEntriesPerMesg;
}

PRIVATE tInt32 smgrMesgIccSapQmdaQOvrMsgSize(tUint32 OpCode, tInt32 Num)
{
    return SIZE_QMDA_SAP_QOS_POLICY_OVERRIDE_REQUEST_MSG(Num);
}

PUBLIC int smgrMesgIccSapEgrEncapGroupOpMaxEntPerMsg(tUint32 OpCode)
{
    switch (OpCode) {

    case IOM_ENCAP_GROUP_ADD:
        return SMMaxNumSapEgrEncapGroupEntriesPerMesg;

    case IOM_ENCAP_GROUP_MEMBERS_ADD:
        return SMMaxNumSapEgrEncapMemberEntriesPerMesg;

    case IOM_ENCAP_GROUP_DELETE:
        return SMMaxNumSapEgrEncapGroupEntriesPerMesg;

    case IOM_ENCAP_GROUP_AUDIT:
        return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_NA;
    default: ;
    }
    return SMGR_MSGR_OP_CODE_MAX_ENT_PER_MSG_UNKNOWN;
}

PRIVATE tInt32 smgrMesgIccSapEgrEncapGroupMsgSize(tUint32 OpCode, tInt32 Num)
{
    switch (OpCode) {
    case IOM_ENCAP_GROUP_ADD:
    case IOM_ENCAP_GROUP_DELETE:
    case IOM_ENCAP_GROUP_AUDIT:        
        return SIZE_ENCAP_GROUP_REQUEST_MSG(Num);

    case IOM_ENCAP_GROUP_MEMBERS_ADD:
        return SIZE_ENCAP_GROUP_MEMBERS_REQUEST_MSG(Num);
    default: ;
    }
    return 0;
}

#define SMGRMSGRENTRY_CARDONLINEMASK(name, num, sock, minOp, maxOp, max, OpStr, \
                                     OpMEpM, MsgSize, Pre, Update, Flush, Post, \
                                     Dump, AuditDebug)                  \
    SMGRMSGRENTRY_MASK(                                                 \
            /* Name        */ name,                                     \
            /* DownloadNum */ num,                                      \
            /* IccSocket   */ sock,                                     \
            /* MinIccOpCode*/ minOp,                                    \
            /* MaxIccOpCode*/ maxOp,                                    \
            /* MaxKeySize  */ max,                                      \
            /* OpCodeStrFn */ OpStr,                                    \
            /* OpCodeMaxPerMsgFn */ OpMEpM,                             \
            /* MsgSizeFn   */ MsgSize,                                  \
            /* PreBatchFn  */ Pre,                                      \
            /* UpdateFn    */ Update,                                   \
            /* FlushFn     */ Flush,                                    \
            /* PostBatchFn */ Post,                                     \
            /* DumpFn      */ Dump,                                     \
            /* AuditDebug  */ AuditDebug,                               \
            /* DownloadMask*/ SMGRMSGR_MASK_CARDONLINE ,                 \
            /* DownloadBitmap */ 0                                      \
        )

////////////////////////////////////////////////////////////////////////////////
// This download table determines the order in which object are downloaded
// when a new IOM comes online
//
PUBLIC struct SmgrMsgrEntry SmgrMsgr_DownloadTable[] = {

    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "Start",
        /* DownloadNum */ SmgrMsgrEntry_Start,
        /* IccSocket   */ 0,
        /* MinIccOpCode*/ 0,
        /* MaxIccOpCode*/ 0,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ NULL,
        /* OpCodeMaxPerMsgFn */ NULL,
        /* MsgSizeFn   */ NULL,
        /* PreBatchFn  */ NULL,
        /* UpdateFn    */ NULL, /* First entry must be NULL */
        /* FlushFn     */ NULL,
        /* PostBatchFn */ NULL,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ 0),
     SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "DpiIp",
        /* DownloadNum */ SmgrMsgrEntry_DpiIp,
        /* IccSocket   */ ICC_SOCKET_DPI_IP_TABLE,
        /* MinIccOpCode*/ IOM_DPI_IP_ADD,
        /* MaxIccOpCode*/ IOM_DPI_IP_AUDIT_END,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ smgrMesgIccDpiIpOpToStr,       
        /* OpCodeMaxPerMsgFn */ smgrMesgIccDpiIpOpMaxEntPerMsg,
        /* MsgSizeFn   */ NULL,        
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgDpiIpUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ 0),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "DpiPrefix",
        /* DownloadNum */ SmgrMsgrEntry_DpiPrefix,
        /* IccSocket   */ ICC_SOCKET_DPI_PREFIX_FILTERS,
        /* MinIccOpCode*/ IOM_FILTER_CREATE,
        /* MaxIccOpCode*/ IOM_FILTER_AUDIT,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ smgrMesgIccDpiPrefixOpToStr,       
        /* OpCodeMaxPerMsgFn */ smgrMesgIccDpiPrefixOpMaxEntPerMsg,
        /* MsgSizeFn   */ NULL,        
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgDpiPrefixUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ 0),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SdpBindStats",
        /* DownloadNum */ SmgrMsgrEntry_SdpBindStats,
        /* IccSocket   */ ICC_SOCKET_SDP_BINDING_STATS,
        /* MinIccOpCode*/ IOM_SDP_STATS_READ_RELATIVE,
        /* MaxIccOpCode*/ IOM_SDP_STATS_RESET_L2TPV3,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ smgrMesgIccSdpBindStatsOpToStr,       
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpBindStatsOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSdpBindStatsMsgSize,        
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSdpBindStatsUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ 0),    
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SysWide",
        /* DownloadNum */ SmgrMsgrEntry_SysWide,
        /* IccSocket   */ ICC_SOCKET_SVC_TABLE,
        /* MinIccOpCode*/ IOM_SVC_SYS_WIDE_UPDATE,
        /* MaxIccOpCode*/ IOM_SVC_SYS_WIDE_UPDATE,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ smgrMesgIccSvcOpToStr,       
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSvcOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSvcMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSvcSysWideUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ 0),
   SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "GtpApi",
        /* DownloadNum */ SmgrMsgrEntry_Gtp,
        /* IccSocket   */ ICC_SOCKET_SVC_SDP_TABLE,
        /* MinIccOpCode*/ IOM_SDP_ADD,
        /* MaxIccOpCode*/ IOM_SDP_DELETE,
        /* MaxKeySize  */ sizeof(struct tGtpApiPeerAddress),
        /* OpCodeStrFn */ smgrMesgIccSdpOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSvcMsgSize,
        /* PreBatchFn  */ gtpApiCardOnlinePreUpdate,
        /* UpdateFn    */ smgrMesgGtpUpdate,
        /* FlushFn     */ gtpApiCardOnLineFlushForSdp,
        /* PostBatchFn */ gtpApiCardOnlinePostUpdate,
        /* DumpFn      */ gtpApiCardOnLineDumpForSdp,
        /* AuditDebug  */ IOM_AUDIT_SDP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "L2tp",
        /* DownloadNum */ SmgrMsgrEntry_L2tp,
        /* IccSocket   */ ICC_SOCKET_SVC_SDP_TABLE,
        /* MinIccOpCode*/ IOM_SDP_ADD,
        /* MaxIccOpCode*/ IOM_SDP_DELETE,
        /* MaxKeySize  */ sizeof(struct tL2tpPeerAddress),
        /* OpCodeStrFn */ smgrMesgIccSdpOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSdpMsgSize,
        /* PreBatchFn  */ l2tpCardOnlinePreUpdate,
        /* UpdateFn    */ smgrMesgL2tpUpdate,
        /* FlushFn     */ l2tpCardOnLineFlushForSdp,
        /* PostBatchFn */ l2tpCardOnlinePostUpdate,
        /* DumpFn      */ l2tpCardOnLineDumpForSdp,
        /* AuditDebug  */ IOM_AUDIT_SDP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "Sdp",
        /* DownloadNum */ SmgrMsgrEntry_Sdp,
        /* IccSocket   */ ICC_SOCKET_SVC_SDP_TABLE,
        /* MinIccOpCode*/ IOM_SDP_ADD,
        /* MaxIccOpCode*/ IOM_SDP_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrMesgSdp),
        /* OpCodeStrFn */ smgrMesgIccSdpOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSdpMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSdpUpdate,
        /* FlushFn     */ smgrFlushSdpAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSdpDump,
        /* AuditDebug  */ IOM_AUDIT_SDP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosShedPolicy",
        /* DownloadNum */ SmgrMsgrEntry_QosSchedPol,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_SCHEDULER_TABLE,
        /* MinIccOpCode*/ IOM_POLICY_ADD,
        /* MaxIccOpCode*/ IOM_POLICY_AUDIT,  // IOM_EMG_READ - don't care about it
        /* MaxKeySize  */ sizeof(tSmgrMesgQosPolicyName),
        /* OpCodeStrFn */ smgrMesgIccPolicyOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccQosSchedPolicyOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccQosSchedPolicyMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosSchedPolUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosSchedPolDump,
        /* AuditDebug  */ IOM_AUDIT_QOSSP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosPolicerContrl",
        /* DownloadNum */ SmgrMsgrEntry_QosPolicerCtrlPol,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_ARBITER_TABLE,
        /* MinIccOpCode*/ IOM_POLICY_ADD,
        /* MaxIccOpCode*/ IOM_POLICY_AUDIT,  
        /* MaxKeySize  */ sizeof(tSmgrMesgQosPolicyName),
        /* OpCodeStrFn */ smgrMesgIccPolicyOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccQosPolicyCtrlOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccQosPolicyControlMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosPolicerCtrlPolUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosPolicerCtrlPolDump,
        /* AuditDebug  */ IOM_AUDIT_QOSAP),    
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosSapIngressPolicy",
        /* DownloadNum */ SmgrMsgrEntry_QosSapIngPol,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_INGRESS_SAP_BASE_TABLE,
        /* MinIccOpCode*/ IOM_POLICY_ADD,
        /* MaxIccOpCode*/ IOM_POLICY_AUDIT,  
        /* MaxKeySize  */ sizeof(tSmgrMesgQosSapPolicy),
        /* OpCodeStrFn */ smgrMesgIccPolicyOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccQosSapIngressPolicyMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosSapIngPolUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosSapIngPolDump,
        /* AuditDebug  */ IOM_AUDIT_QOSSIP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosSapIngressPolicyMacFilter",
        /* DownloadNum */ SmgrMsgrEntry_QosSapIngPolMacFilter,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_INGRESS_SAP_MAC_FILTER_TABLE,
        /* MinIccOpCode*/ IOM_MAC_RULE_ADD,
        /* MaxIccOpCode*/ IOM_MAC_RULE_DELETE,  
        /* MaxKeySize  */ sizeof(tSmgrMesgQosSapIngPolicyFilter),
        /* OpCodeStrFn */ smgrMesgIccPolicyMacFilterOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccPolicyMacFilterOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccQosSapIngressPolicyMacFilterMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosSapIngPolMacFilterUpdate,
        /* FlushFn     */ smgrFlushSapIngQosPolMacRuleAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosSapIngPolMacFilterDump,
        /* AuditDebug  */ IOM_AUDIT_QOSSIP),        
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosSapIngressPolicyIpFilter",
        /* DownloadNum */ SmgrMsgrEntry_QosSapIngPolIpFilter,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_INGRESS_SAP_IP_FILTER_TABLE,
        /* MinIccOpCode*/ IOM_IP_RULE_ADD,
        /* MaxIccOpCode*/ IOM_IP_RULE_DELETE,  
        /* MaxKeySize  */ sizeof(tSmgrMesgQosSapIngPolicyFilter),
        /* OpCodeStrFn */ smgrMesgIccPolicyIpFilterOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccPolicyIpFilterOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccPolicyIpFilterMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosSapIngPolIpFilterUpdate,
        /* FlushFn     */ smgrFlushSapIngQosPolIpRuleAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosSapIngPolIpFilterDump,
        /* AuditDebug  */ IOM_AUDIT_QOSSIP),   
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosSapEgressPolicy",
        /* DownloadNum */ SmgrMsgrEntry_QosSapEgrPol,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_EGRESS_SAP_TABLE,
        /* MinIccOpCode*/ IOM_POLICY_ADD,
        /* MaxIccOpCode*/ IOM_POLICY_AUDIT,  
        /* MaxKeySize  */ sizeof(tSmgrMesgQosSapPolicy),
        /* OpCodeStrFn */ smgrMesgIccPolicyOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccQosSapEgressPolicyMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosSapEgrPolUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosSapEgrPolDump,
        /* AuditDebug  */ IOM_AUDIT_QOSSEP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosSapEgressPolicyIpFilter",
        /* DownloadNum */ SmgrMsgrEntry_QosSapEgrPolIpFilter,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_EGRESS_SAP_IP_FILTER_TABLE,
        /* MinIccOpCode*/ IOM_IP_RULE_ADD,
        /* MaxIccOpCode*/ IOM_IP_RULE_DELETE,  
        /* MaxKeySize  */ sizeof(tSmgrMesgQosSapEgrPolicyFilter),
        /* OpCodeStrFn */ smgrMesgIccPolicyIpFilterOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccPolicyIpFilterOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccPolicyIpFilterMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgQosSapEgrPolIpFilterUpdate,
        /* FlushFn     */ smgrFlushSapEgrQosPolIpRuleAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgQosSapEgrPolIpFilterDump,
        /* AuditDebug  */ IOM_AUDIT_QOSSEP),    
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosMss",
        /* DownloadNum */ SmgrMsgrEntry_QosMss,
        /* IccSocket   */ ICC_SOCKET_QOS_MULTI_SERVICE_SITE_TABLE,
        /* MinIccOpCode*/ IOM_POLICY_ADD,
        /* MaxIccOpCode*/ IOM_POLICY_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrMesgCustMssKey),
        /* OpCodeStrFn */ smgrMesgIccPolicyOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccQosMssOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccQosMssMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgCustMssUpdate,
        /* FlushFn     */ smgrFlushMultSvcSiteAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgCustMssDump,
        /* AuditDebug  */ IOM_AUDIT_ILMMIRROR),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "QosMssVsO",
        /* DownloadNum */ SmgrMsgrEntry_QosMssVsO,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrMesgCustMssVsOvKey),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccVsOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccVsOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgCustMssVsOvUpdate,
        /* FlushFn     */ smgrFlushVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgCustMssVsOvDump,
        /* AuditDebug  */ IOM_AUDIT_QOSMSSITE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "Emg",
        /* DownloadNum */ SmgrMsgrEntry_Emg,
        /* IccSocket   */ ICC_SOCKET_TLS_EMG_TABLE,
        /* MinIccOpCode*/ IOM_EMG_ADD,
        /* MaxIccOpCode*/ IOM_EMG_AUDIT,  // IOM_EMG_READ - do we care about the read?
        /* MaxKeySize  */ sizeof(tSmgrMesgEmg),
        /* OpCodeStrFn */ smgrMesgIccEmgOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccEmgMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgEmgMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgEmgUpdate,
        /* FlushFn     */ smgrFlushEmgAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgEmgDump,
        /* AuditDebug  */ IOM_AUDIT_EMG),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "Svc",
        /* DownloadNum */ SmgrMsgrEntry_Svc,
        /* IccSocket   */ ICC_SOCKET_SVC_TABLE,
        /* MinIccOpCode*/ IOM_SVC_ADD,
        /* MaxIccOpCode*/ IOM_SVC_ADD_TLS_FLOOD_UPDATE,
        /* MaxKeySize  */ sizeof(tSmgrMesgSvc),
        /* OpCodeStrFn */ smgrMesgIccSvcOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSvcOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSvcMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSvcUpdate,
        /* FlushFn     */ smgrFlushSvcAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSvcDump,
        /* AuditDebug  */ IOM_AUDIT_SVC),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SvcTls",
        /* DownloadNum */ SmgrMsgrEntry_SvcTls,
        /* IccSocket   */ ICC_SOCKET_SVC_TABLE,
        /* MinIccOpCode*/ IOM_SVC_TLS_FWDING_UPDATE,
        /* MaxIccOpCode*/ IOM_SVC_TLS_FWDING_UPDATE,
        /* MaxKeySize  */ sizeof(tSmgrMesgSvc),
        /* OpCodeStrFn */ smgrMesgIccSvcOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSvcOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSvcMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSvcTlsUpdate,
        /* FlushFn     */ smgrFlushSvcAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSvcDump,
        /* AuditDebug  */ IOM_AUDIT_SVC),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "Sap",
        /* DownloadNum */ SmgrMsgrEntry_Sap,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_SAP_ADD,
        /* MaxIccOpCode*/ IOM_SAP_MCLISTPRUNE_MVRP,
        /* MaxKeySize  */ sizeof(tSmgrMesgSap),
        /* OpCodeStrFn */ smgrMesgIccSapSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSapUpdate,
        /* FlushFn     */ smgrFlushSapAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSapDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapCfmPrimVlan",
        /* DownloadNum */ SmgrMsgrEntry_SapCfmPrimVlan,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_SAP_CFM_PVLAN,
        /* MaxIccOpCode*/ IOM_SAP_CFM_PVLAN,
        /* MaxKeySize  */ sizeof(tSmgrMesgSapCfmPrimVlan),
        /* OpCodeStrFn */ smgrMesgIccSapSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSapCfmPrimVlanUpdate,
        /* FlushFn     */ smgrFlushSapCfmPrimVlanMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSapCfmPrimVlanDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapLoopBack",
        /* DownloadNum */ SmgrMsgrEntry_SapLoopBack,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_SAP_MAC_LPBK,
        /* MaxIccOpCode*/ IOM_SAP_MAC_LPBK,
        /* MaxKeySize  */ sizeof(tSmgrMesgSapLoopBack),
        /* OpCodeStrFn */ smgrMesgIccSapSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSapLoopBackUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSapLoopBackDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
   SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "GtpApiBind",
        /* DownloadNum */ SmgrMsgrEntry_GtpBind,
        /* IccSocket   */ ICC_SOCKET_SVC_BIND,
        /* MinIccOpCode*/ IOM_SVC_BIND,
        /* MaxIccOpCode*/ IOM_SVC_UNBIND,
        /* MaxKeySize  */ sizeof(tGtpApiSmgrGtpSdpBindKey),
        /* OpCodeStrFn */ smgrMesgIccSdpBindOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpBindOpMaxEntPerMsg,
        /* MsgSizeFn   */ NULL,
        /* PreBatchFn  */ gtpApiCardOnlinePreUpdate,
        /* UpdateFn    */ smgrMesgGtpBindUpdate,
        /* FlushFn     */ gtpApiCardOnLineFlushForSdpBind,
        /* PostBatchFn */ gtpApiCardOnlinePostUpdate,
        /* DumpFn      */ gtpApiCardOnLineDumpForSdpBind,
        /* AuditDebug  */ IOM_AUDIT_SDPBIND),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "L2tpBind",
        /* DownloadNum */ SmgrMsgrEntry_L2tpBind,
        /* IccSocket   */ ICC_SOCKET_SVC_BIND,
        /* MinIccOpCode*/ IOM_SVC_BIND,
        /* MaxIccOpCode*/ IOM_SVC_UNBIND,
        /* MaxKeySize  */ sizeof(tL2tpSmgrL2tpSdpBindKey),
        /* OpCodeStrFn */ smgrMesgIccSdpBindOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpBindOpMaxEntPerMsg,
        /* MsgSizeFn   */ NULL,
        /* PreBatchFn  */ l2tpCardOnlinePreUpdate,
        /* UpdateFn    */ smgrMesgL2tpBindUpdate,
        /* FlushFn     */ l2tpCardOnLineFlushForSdpBind,
        /* PostBatchFn */ l2tpCardOnlinePostUpdate,
        /* DumpFn      */ l2tpCardOnLineDumpForSdpBind,
        /* AuditDebug  */ IOM_AUDIT_SDPBIND),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SdpBind",
        /* DownloadNum */ SmgrMsgrEntry_SdpBind,
        /* IccSocket   */ ICC_SOCKET_SVC_BIND,
        /* MinIccOpCode*/ IOM_SVC_BIND,
        /* MaxIccOpCode*/ IOM_SVC_BIND_MCLISTPRUNE,
        /* MaxKeySize  */ sizeof(tSmgrMesgSdpBind),
        /* OpCodeStrFn */ smgrMesgIccSdpBindOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpBindOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSdpBindMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSdpBindUpdate,
        /* FlushFn     */ smgrFlushSdpBindMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSdpBindDump,
        /* AuditDebug  */ IOM_AUDIT_SDPBIND),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "sdpBindLoopBack",
        /* DownloadNum */ SmgrMsgrEntry_SdpBindLoopBack,
        /* IccSocket   */ ICC_SOCKET_SVC_BIND,
        /* MinIccOpCode*/ IOM_SVC_BIND_MAC_LPBK,
        /* MaxIccOpCode*/ IOM_SVC_BIND_MAC_LPBK,
        /* MaxKeySize  */ sizeof(tSmgrMesgSdpBindLoopBack),
        /* OpCodeStrFn */ smgrMesgIccSdpBindOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSdpBindOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSdpBindMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgSdpBindLoopBackUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgSdpBindLoopBackDump,
        /* AuditDebug  */ IOM_AUDIT_SDPBIND),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "TlsFdb",
        /* DownloadNum */ SmgrMsgrEntry_TlsFdb,
        /* IccSocket   */ ICC_SOCKET_TLS_MAC_TABLE,
        /* MinIccOpCode*/ IOM_TLS_MAC_ADD,
        /* MaxIccOpCode*/ IOM_TLS_MAC_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_TlsFdb),
        /* OpCodeStrFn */ smgrMesgIccTlsFdbOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccTlsFdbOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccTlsFdbMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccTlsFdbUpdate,
        /* FlushFn     */ smgrFlushTlsMacAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccTlsFdbDump,
        /* AuditDebug  */ IOM_AUDIT_TLSMAC),        
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "TlsFdbQuery",
        /* DownloadNum */ SmgrMsgrEntry_TlsFdbQuery,
        /* IccSocket   */ ICC_SOCKET_TLS_MAC_QUERY,
        /* MinIccOpCode*/ IOM_TLS_MAC_QUERY,
        /* MaxIccOpCode*/ IOM_TLS_MAC_QUERY,
        /* MaxKeySize  */ sizeof(tSmgrIcc_TlsFdb),
        /* OpCodeStrFn */ smgrMesgIccTlsFdbQueryOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccTlsFdbQueryOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccTlsFdbMsgSize,
        /* PreBatchFn  */ NULL,
        /* UpdateFn    */ smgrMesgIccTlsFdbQueryUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ NULL,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ IOM_AUDIT_TLSMAC ),
    SMGRMSGRENTRY_MASK(
        /* Name        */ "MirrorSvcRemote",
        /* DownloadNum */ SmgrMsgrEntry_MirrorSvcRemote,
        /* IccSocket   */ ICC_SOCKET_MIRROR_SOURCE_TABLE,
        /* MinIccOpCode*/ IOM_MIRROR_SRC_ADD,
        /* MaxIccOpCode*/ IOM_MIRROR_SRC_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_MirrorSvcRemote),
        /* OpCodeStrFn */ smgrMesgIccMirrorSvcOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccMirrorSvcMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccMirrorSvcRemoteUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccMirrorSvcRemoteDump,
        /* AuditDebug  */ IOM_AUDIT_ILMMIRROR,
        /* DownloadMask*/ SMGRMSGR_MASK_CARDONLINE|SMGRMSGR_MASK_ISAAA,
        /* DownloadBitmap*/ 0),
    SMGRMSGRENTRY_MASK(
        /* Name        */ "MirrorSvcLocal",
        /* DownloadNum */ SmgrMsgrEntry_MirrorSvcLocal,
        /* IccSocket   */ ICC_SOCKET_MIRROR_SOURCE_TABLE,
        /* MinIccOpCode*/ IOM_MIRROR_SRC_ADD,
        /* MaxIccOpCode*/ IOM_MIRROR_SRC_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_MirrorSvcLocal),
        /* OpCodeStrFn */ smgrMesgIccMirrorSvcOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccMirrorSvcMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccMirrorSvcLocalUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccMirrorSvcLocalDump,
        /* AuditDebug  */ IOM_AUDIT_ILMMIRROR,
        /* DownloadMask*/ SMGRMSGR_MASK_CARDONLINE|SMGRMSGR_MASK_ISAAA,
        /* Downloadbitmap*/ 0),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "MfibTls",
        /* DownloadNum */ SmgrMsgrEntry_MfibTls,
        /* IccSocket   */ ICC_SOCKET_TLS_IGMP_SNOOPING,
        /* MinIccOpCode*/ 0,
        /* MaxIccOpCode*/ 0,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ NULL,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccMfibTlsMsgSize,
        /* PreBatchFn  */ NULL,
        /* UpdateFn    */ smgrMesgIccMfibTlsUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ NULL,
        /* DumpFn      */ NULL,
        /* AuditDebug  */ IOM_AUDIT_TLSIGMP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "UssCatMap",
        /* DownloadNum */ SmgrMsgrEntry_UssCatMap,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_CATMAP_POLICY_ADD,
        /* MaxIccOpCode*/ IOM_ESM_CATMAP_POLICY_AUDIT,
        /* MaxKeySize  */ 0,
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ ussApiLock,
        /* UpdateFn    */ smgrMesgIccUssCatMapUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ ussApiUnlock,
        /* DumpFn      */ smgrMesgIccUssCatMapDump,
        /* AuditDebug  */ IOM_AUDIT_CATMAP_POLICY),         
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubProfile",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubProfile,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUB_PROFILE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUB_PROFILE_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubProfile),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSubProfUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSubProfDump,
        /* AuditDebug  */ IOM_AUDIT_SUB_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubProfileSchedOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubProfileSchedOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubProfSchedOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSubProfSchedOvrUpdate,
        /* FlushFn     */ smgrFlushSubProfVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSubProfSchedOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SUB_PROFILE),    
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubProfilePlcrCtrlOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubProfilePlcrCtrlOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUB_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubProfPlcrCtrlOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSubProfPlcrCtrlOvrUpdate,
        /* FlushFn     */ smgrFlushSubProfPlcrCtrlOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSubProfPlcrCtrlOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SUB_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubProfileHsmda2EgrQOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubProfileHsmda2EgrQOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUB_PROFILE_QOS_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubProfQOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSubProfHsmda2EgrQOvrUpdate,
        /* FlushFn     */ smgrFlushSubProfHsmda2EgrQueueOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSubProfQOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SUB_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSLAProfile",
        /* DownloadNum */ SmgrMsgrEntry_SbmSLAProfile,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SLA_PROFILE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SLA_PROFILE_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSLAProfile),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccOneEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSLAProfUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSLAProfDump,
        /* AuditDebug  */ IOM_AUDIT_SLA_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSLAProfileIngQOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSLAProfileIngQOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSLAProfQOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSLAProfIngQOvrUpdate,
        /* FlushFn     */ smgrFlushSLAProfQueueOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSLAProfQOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SLA_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSLAProfileEgrQOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSLAProfileEgrQOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSLAProfQOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSLAProfEgrQOvrUpdate,
        /* FlushFn     */ smgrFlushSLAProfQueueOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSLAProfQOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SLA_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSLAProfileIngPlcrOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSLAProfileIngPlcrOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSLAProfPlcrOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSLAProfIngPlcrOvrUpdate,
        /* FlushFn     */ smgrFlushSLAProfPolicerOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSLAProfPlcrOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SLA_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSLAProfileEgrPlcrOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSLAProfileEgrPlcrOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SLA_PROFILE_QOS_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSLAProfPlcrOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSLAProfEgrPlcrOvrUpdate,
        /* FlushFn     */ smgrFlushSLAProfPolicerOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSLAProfPlcrOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SLA_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSLAProfileSchedOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSLAProfileSchedOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SLA_PROFILE_SCHEDULER_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSLAProfSchedOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSLAProfSchedOvrUpdate,
        /* FlushFn     */ smgrFlushSLAProfVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSLAProfSchedOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SLA_PROFILE),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmActSub",
        /* DownloadNum */ SmgrMsgrEntry_SbmActSub,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUBSCRIBER_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUBSCRIBER_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmActSub),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmActSubUpdate,
        /* FlushFn     */ smgrFlushSubscriberAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmActSubDump,
        /* AuditDebug  */ IOM_AUDIT_SUBSCRIBER),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubSchedOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubSchedOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUBSCRIBER_SCHEDULER_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubSchedOvr),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSubSchedOvrUpdate,
        /* FlushFn     */ smgrFlushSubVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSubSchedOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SUBSCRIBER),    
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmIesIfGroupIf",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubIesIfGroupIf,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_L3_SUBSCRIBER_RED_GROUP_ADD,
        /* MaxIccOpCode*/ IOM_ESM_L3_SUBSCRIBER_RED_GROUP_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmIesIfGroupIf),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmIesIfGroupIfUpdate,
        /* FlushFn     */ smgrFlushSubIesIfGroupIfMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmIesIfGroupIfDump,
        /* AuditDebug  */ IOM_AUDIT_SUB_L3_GRP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmIesIfGroupIfRingNode",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubIesIfGroupIfRingNode,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_ADD,
        /* MaxIccOpCode*/ IOM_ESM_L3_SUBSCRIBER_RED_INTER_DEST_GROUP_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmIesIfGroupIfRingNode),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmIesIfGroupIfRingNodeUpdate,
        /* FlushFn     */ smgrFlushMcRingRingnodeAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmIesIfGroupIfRingNodeDump,
        /* AuditDebug  */ IOM_AUDIT_SUB_L3_GRP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubHost",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubHost,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_HOST_ADD,
        /* MaxIccOpCode*/ IOM_ESM_HOST_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubHost),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmSubHostUpdate,
        /* FlushFn     */ smgrFlushSbmSubHostAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmSubHostDump,
        /* AuditDebug  */ IOM_AUDIT_SUBSCRIBER_HOST),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmpppoeLnsSubHost",
        /* DownloadNum */ SmgrMsgrEntry_SbmPppoeLnsSubHost,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_HOST_ADD,
        /* MaxIccOpCode*/ IOM_ESM_HOST_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmPppoeLnsSub),
        /* OpCodeStrFn */ smgrMesgIccSubOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSbmPppoeLnsSubUpdate,
        /* FlushFn     */ smgrFlushSbmSubHostAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSbmPppoeLnsSubDump,
        /* AuditDebug  */ IOM_AUDIT_SUBSCRIBER_HOST),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapIngSchedPlcyOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapIngSchedPlcyOvr,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapSchedPlcyOvr),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccVsOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccVsOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapIngSchedPlcyOvrUpdate,
        /* FlushFn     */ smgrFlushVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapIngSchedPlcyOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrSchedPlcyOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrSchedPlcyOvr,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapSchedPlcyOvr),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccVsOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccVsOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrSchedPlcyOvrUpdate,
        /* FlushFn     */ smgrFlushVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrSchedPlcyOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapIngPlcrCtrlOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapIngPlcrCtrlOvr,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvrKey),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccVsOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccVsOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapIngPlcrCtrlOvrUpdate,
        /* FlushFn     */ smgrFlushVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapIngPlcrCtrlOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrPlcrCtrlOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrPlcrCtrlOvr,
        /* IccSocket   */ ICC_SOCKET_QOS_POLICY_SCHEDULER_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvrKey),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccVsOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccVsOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrPlcrCtrlOvrUpdate,
        /* FlushFn     */ smgrFlushVSOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrPlcrCtrlOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),    
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapIngQOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapIngQOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_QOS_POLICY_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvr),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapQOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapQOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapIngQOvrUpdate,
        /* FlushFn     */ smgrFlushSapQosOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapIngQOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrQOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrQOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_QOS_POLICY_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvr),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapQOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapQOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrQOvrUpdate,
        /* FlushFn     */ smgrFlushSapQosOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrQOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapIngPlcrOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapIngPlcrOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_QOS_POLICY_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvr),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapQOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapQOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapIngPlcrOvrUpdate,
        /* FlushFn     */ smgrFlushSapQosOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */smgrMesgIccSapIngPlcrOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),        
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrPlcrOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrPlcrOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_QOS_POLICY_OVERRIDE,
        /* MinIccOpCode*/ IOM_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QOS_OVERRIDE_LAST,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvr),
        /* OpCodeStrFn */ smgrMesgIccQosOverrideOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapQOMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapQOMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrPlcrOvrUpdate,
        /* FlushFn     */ smgrFlushSapQosOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrPlcrOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrQmdaQOvr",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrQmdaQOvr,
        /* IccSocket   */ ICC_SOCKET_QMDA,
        /* MinIccOpCode*/ IOM_QMDA_QOS_POLICY_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_QMDA_QOS_POLICY_OVERRIDE_DELETE,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapQosOvr),
        /* OpCodeStrFn */ smgrMesgIccSapQmdaQOvrOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapQmdaQOvrOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapQmdaQOvrMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrQmdaQOvrUpdate,
        /* FlushFn     */ smgrFlushQmdaQueueOverrideAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrQmdaQOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SbmSubQosOvr",
        /* DownloadNum */ SmgrMsgrEntry_SbmSubQosOvr,
        /* IccSocket   */ ICC_SOCKET_SAP_SUB,
        /* MinIccOpCode*/ IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_ADD,
        /* MaxIccOpCode*/ IOM_ESM_SUBSCRIBER_QOS_OVERRIDE_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SbmSubHost),
        /* OpCodeStrFn */ smgrMesgIccSapSubQosOvrOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapSubOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapSubMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapSubQosOvrUpdate,
        /* FlushFn     */ NULL,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapSubQosOvrDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrEncapGroup",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrEncapGroup,
        /* IccSocket   */ ICC_SOCKET_ENCAP_GROUP_TABLE,
        /* MinIccOpCode*/ IOM_ENCAP_GROUP_ADD,
        /* MaxIccOpCode*/ IOM_ENCAP_GROUP_AUDIT,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapEgrEncapGroup),
        /* OpCodeStrFn */ smgrMesgIccSapEgrEncapGroupOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapEgrEncapGroupOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapEgrEncapGroupMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrEncapGroupUpdate,
        /* FlushFn     */ smgrFlushSapEgrEncapGroupAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrEncapGroupDump,
        /* AuditDebug  */ IOM_AUDIT_SAP),
    SMGRMSGRENTRY_CARDONLINEMASK(
        /* Name        */ "SapEgrEncapMember",
        /* DownloadNum */ SmgrMsgrEntry_SapEgrEncapMember,
        /* IccSocket   */ ICC_SOCKET_ENCAP_GROUP_TABLE,
        /* MinIccOpCode*/ IOM_ENCAP_GROUP_MEMBERS_ADD,
        /* MaxIccOpCode*/ IOM_ENCAP_GROUP_MEMBERS_ADD,
        /* MaxKeySize  */ sizeof(tSmgrIcc_SapEgrEncapMember),
        /* OpCodeStrFn */ smgrMesgIccSapEgrEncapGroupOpToStr,
        /* OpCodeMaxPerMsgFn */ smgrMesgIccSapEgrEncapGroupOpMaxEntPerMsg,
        /* MsgSizeFn   */ smgrMesgIccSapEgrEncapGroupMsgSize,
        /* PreBatchFn  */ smgrMesgPre,
        /* UpdateFn    */ smgrMesgIccSapEgrEncapMemberUpdate,
        /* FlushFn     */ smgrFlushSapEgrEncapMemberAddMesg,
        /* PostBatchFn */ smgrMesgPost,
        /* DumpFn      */ smgrMesgIccSapEgrEncapMemberDump,
        /* AuditDebug  */ IOM_AUDIT_SAP)
};


tUint32 SmgrMsgr_DownloadTableNumEntries = NELEMENTS(SmgrMsgr_DownloadTable);


